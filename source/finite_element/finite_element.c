/*******************************************************************************
FILE : finite_element.c

LAST MODIFIED : 9 November 2000

DESCRIPTION :
Functions for manipulating finite element structures.
???DB.  Can FE_node_field_info become a module type ?  (create_FE_node would be
	given the element field lists)
???DB.  Get rid of the find_FE_ and replace with FIRST_OBJECT_IN_/FIND_BY_IDEN ?
???DB.  enum FE_basis_type ?
???DB.  calculate_FE_node_field ?
???DB.  change FE_nodes so that request a particular value for a particular
	field (see merge_FE_node)
???DB.  Should the list_ routines be in their own module ?
==============================================================================*/
#define NOT_FINITE_ELEMENT_USE_SAFE_LIST
#define NOT_FINITE_ELEMENT_EXCEPT_FOR_FE_node
	/*???DB.  Temporary.  Need because there are problems with indexed lists.
		What are the problems ? */

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "command/command_window.h"
	/*???DB.  required for set_FE_element_group .  Should it be here ? */
#include "finite_element/finite_element.h"
#include "general/compare.h"
#include "general/debug.h"
#include "general/managed_group_private.h"
#include "general/heapsort.h"
#if defined (FINITE_ELEMENT_USE_SAFE_LIST)
#include "general/list_private.h"
#if defined (FINITE_ELEMENT_EXCEPT_FOR_FE_node)
#include "general/indexed_list_private.h"
#endif /* defined (FINITE_ELEMENT_EXCEPT_FOR_FE_node) */
#else /* defined (FINITE_ELEMENT_USE_SAFE_LIST) */
#include "general/list_private.h"
#include "general/indexed_list_private.h"
#endif /* defined (FINITE_ELEMENT_USE_SAFE_LIST) */
#include "general/manager_private.h"
#include "general/multi_range.h"
#include "general/mystring.h"
#include "general/object.h"
#include "general/value.h"
#include "mirage/tracking_editor_data.h"
#include "user_interface/message.h"
#include "user_interface/user_interface.h"

/*
Global variables
----------------
*/
struct LIST(FE_element_field_info) *all_FE_element_field_info=
	(struct LIST(FE_element_field_info) *)NULL;
#if defined (OLD_CODE)
struct LIST(FE_element) *all_FE_element=(struct LIST(FE_element) *)NULL;
#endif /* defined (OLD_CODE) */
struct LIST(FE_element_shape) *all_FE_element_shape=
	(struct LIST(FE_element_shape) *)NULL;
#if defined (OLD_CODE)
struct LIST(FE_field) *all_FE_field=(struct LIST(FE_field) *)NULL;
#endif /* defined (OLD_CODE) */


/*
Module Constants
----------------
*/

/* need following to handle 64-bit alignment problems of 64-bit quantities in
   64-bit version */
#if defined (O64)
#define VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE 8
#define ADJUST_VALUE_STORAGE_SIZE( new_values_storage_size ) \
/* round size up to nearest 64-bit boundary */ \
if (new_values_storage_size % 8) \
{ \
	new_values_storage_size += (8 - (new_values_storage_size % 8)); \
}
#else /* defined (O64) */
#define VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE sizeof(int)
#define ADJUST_VALUE_STORAGE_SIZE( new_values_storage_size )
/* do nothing */
#endif /* defined (O64) */

/*
Module types
------------
*/
struct FE_node_field_component
/*******************************************************************************
LAST MODIFIED : 19 January 1998

DESCRIPTION :
Specifies how to find the value and derivatives for a field component at a node.
This only appears as part of a FE_node_field.
==============================================================================*/
{
	/* the offset for the global value within the list of all global values and
		derivatives at the node */
	int value;
	/* the number of global derivatives.  NB The global derivatives are assumed to
		follow directly after the global value in the list of all global values and
		derivatives at the node */
	int number_of_derivatives;
	/* the number of versions at the node.  Different fields may use different
		versions eg if the node is on the axis in prolate spheroidal coordinates
		(mu=0 or mu=pi).  NB The different versions are assumed to follow directly
		after each other (only need one starting <value>) and to have the same
		<number_of derivatives> */
	int number_of_versions;
	/* the types the nodal values */
	enum FE_nodal_value_type *nodal_value_types;
}; /* struct FE_node_field_component */

struct FE_node_field
/*******************************************************************************
LAST MODIFIED : 6 December 1993

DESCRIPTION :
How to access the the global values and derivatives for a field at a node.
???DB.  More information needed ?  FE_node_basis ?
==============================================================================*/
{
	/* the field which this accesses values and derivatives for */
	struct FE_field *field;
	/* an array with <number_of_components> node field components */
	struct FE_node_field_component *components;
	/* the number of structures that point to this node field.  The node field
		cannot be destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_node_field */

DECLARE_LIST_TYPES(FE_node_field);

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
FULL_DECLARE_INDEXED_LIST_TYPE(FE_node_field);
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_LIST_TYPE(FE_node_field);
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

struct FE_node_field_info
/*******************************************************************************
LAST MODIFIED : 9 February 1999

DESCRIPTION :
The fields defined for a node and how to access the values and derivatives.
==============================================================================*/
{
	/* the total number of values and derivatives */
	int number_of_values; 

	/* the size of the data in node->values->storage */
	int values_storage_size;

  /* list of the node fields */
  struct LIST(FE_node_field) *node_field_list;

	/* the number of structures that point to this node field information.  The
		node field information cannot be destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_node_field_info */

DECLARE_LIST_TYPES(FE_node_field_info);

FULL_DECLARE_LIST_TYPE(FE_node_field_info);

struct FE_node
/*******************************************************************************
LAST MODIFIED : 13 September 1999

DESCRIPTION :
==============================================================================*/
{
	/* the unique number that identifies the node in CMISS */
	int cm_node_identifier;
	/* the fields defined at the node */
	struct FE_node_field_info *fields;
	/* the global values and derivatives for the fields defined at the node */
	Value_storage *values_storage;

	/* the number of structures that point to this node.  The node cannot be
		destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_node */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
FULL_DECLARE_INDEXED_LIST_TYPE(FE_node);
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
#if defined (FINITE_ELEMENT_EXCEPT_FOR_FE_node)
FULL_DECLARE_INDEXED_LIST_TYPE(FE_node);
#else /* FINITE_ELEMENT_EXCEPT_FOR_FE_node */
FULL_DECLARE_LIST_TYPE(FE_node);
#endif /* FINITE_ELEMENT_EXCEPT_FOR_FE_node */
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

FULL_DECLARE_MANAGER_TYPE(FE_node);

FULL_DECLARE_MANAGED_GROUP_TYPES(FE_node);
/* indexed_list and manager automatically set up for MANAGED_GROUPs */
#if defined (OLD_CODE)
FULL_DECLARE_GROUP_TYPE(FE_node);
#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
FULL_DECLARE_INDEXED_LIST_TYPE(GROUP(FE_node));
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_LIST_TYPE(GROUP(FE_node));
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_MANAGER_TYPE(GROUP(FE_node));
#endif /* defined (OLD_CODE) */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
FULL_DECLARE_INDEXED_LIST_TYPE(FE_basis);
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_LIST_TYPE(FE_basis);
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_MANAGER_TYPE(FE_basis);

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
FULL_DECLARE_INDEXED_LIST_TYPE(FE_element_field);
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_LIST_TYPE(FE_element_field);
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

FULL_DECLARE_LIST_TYPE(FE_element_field_info);

FULL_DECLARE_LIST_TYPE(FE_element_shape);

FULL_DECLARE_LIST_TYPE(FE_element_parent);

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
FULL_DECLARE_INDEXED_LIST_TYPE(FE_element);
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_LIST_TYPE(FE_element);
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_MANAGER_TYPE(FE_element);

FULL_DECLARE_MANAGED_GROUP_TYPES(FE_element);
/* indexed_list and manager automatically set up for MANAGED_GROUPs */

struct FE_element_type_node_sequence_identifier
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
See struct FE_element_type_node_sequence.
==============================================================================*/
{
	enum CM_element_type cm_type;
	/* node_numbers must be ordered from lowest to highest to work! */
	int *node_numbers,number_of_nodes;
}; /* struct FE_element_type_node_sequence_identifier */

struct FE_element_type_node_sequence
/*******************************************************************************
LAST MODIFIED : 30 April 1999

DESCRIPTION :
Structure for storing an element with its identifier being its cm_type and the
number and list - in ascending order - of the nodes referred to by the default
coordinate field of the element. Indexed lists, indexed using function
compare_FE_element_type_node_sequence_identifier ensure that recalling a line or
face with the same nodes is extremely rapid. add_FE_element_and_faces_to_manager
uses them to find faces and lines for elements without them, if they exist.

???RC Can only match faces correctly for coordinate fields with standard node
to element maps and no versions. A grid-based coordinate field would fail
utterly since it has no nodes. A possible future solution for all cases is to
match the geometry exactly either by using the FE_element_field_values
(coefficients of the monomial basis functions), although there is a problem with
xi-directions not matching up, or actual centre positions of the face being a
trivial rejection, narrowing down to a single face or list of faces to compare
against.
==============================================================================*/
{
	struct FE_element_type_node_sequence_identifier *identifier;
	struct FE_element *element;
	int access_count;
}; /* struct FE_element_line_face_node_sequence */

DECLARE_LIST_TYPES(FE_element_type_node_sequence);
FULL_DECLARE_INDEXED_LIST_TYPE(FE_element_type_node_sequence);

struct FE_field
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Stores the information for calculating the value of a field at a point.  The
position of the point should be specified by giving the element that contains
the point and the Xi coordinates of the point within the element.
==============================================================================*/
{
	/* the name of the field */
	char *name;
	/* CMISS field type and number */
	struct CM_field_information cm;
/*???DB.  CMISS number ? */
	enum FE_field_type fe_field_type;
	/* following two for INDEXED_FE_FIELD only */
	struct FE_field *indexer_field;
	int number_of_indexed_values; 
	/* the number of components (allows vector valued fields) */
	int number_of_components;
	/* the names of the different vector components */
	char **component_names;
	/* the coordinate system for the vector */
	struct Coordinate_system coordinate_system;
	/* the number of global values/derivatives that are stored with the field */
	int number_of_values;
 /* the type of the values returned by the field */
  enum Value_type value_type;
  /* array of global values/derivatives that are stored with the field.  The
    actual values can be extracted using the <value_type> */
  Value_storage *values_storage;
    /*???DB.  Have something like enum FE_nodal_value_type ? */
    /*???DB.  Needs to be clarified for constant fields */
  /* time series information.  If <number_of_times> is zero then constant in
    time */
  enum Value_type time_value_type;
  int number_of_times;
  Value_storage *times;
	/* the number of structures that point to this field.  The field cannot be
		destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_field */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
FULL_DECLARE_INDEXED_LIST_TYPE(FE_field);
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
FULL_DECLARE_LIST_TYPE(FE_field);
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

FULL_DECLARE_MANAGER_TYPE(FE_field);

struct FE_node_field_iterator_and_data
{
	FE_node_field_iterator_function *iterator;
	struct FE_node *node;
	void *user_data;
}; /* struct FE_node_field_iterator_and_data */

struct FE_node_field_priority_iterator_and_data
{
	FE_node_field_iterator_function *iterator;
	struct FE_node *node;
	void *user_data;
	int priority_on;
	struct LIST(FE_field) *priority_field_list;
}; /* struct FE_node_field_iterator_and_data */

struct FE_element_field_iterator_and_data
{
	FE_element_field_iterator_function *iterator;
	struct FE_element *element;
	void *user_data;
}; /* struct FE_element_field_iterator_and_data */

struct FE_element_field_priority_iterator_and_data
{
	FE_element_field_iterator_function *iterator;
	struct FE_element *element;
	void *user_data;
	int priority_on;
	struct LIST(FE_field) *priority_field_list;
}; /* struct FE_element_field_iterator_and_data */

/*
Module variables
----------------
*/
static struct LIST(FE_node_field_info) *all_FE_node_field_info=
	(struct LIST(FE_node_field_info) *)NULL;

/* blending matricies for the monomial basis */
static FE_value linear_lagrange_blending_matrix[]=
{
	1,-1,
	0, 1
};

static FE_value quadratic_lagrange_blending_matrix[]=
{
	1,-3, 2,
	0, 4,-4,
	0,-1, 2
};

static FE_value cubic_lagrange_blending_matrix[]=
{
	1,-5.5,  9  , -4.5,
	0, 9  ,-22.5, 13.5,
	0,-4.5, 18  ,-13.5,
	0, 1  , -4.5,  4.5
};

static FE_value cubic_hermite_blending_matrix[]=
{
	1,0,-3, 2,
	0,1,-2, 1,
	0,0, 3,-2,
	0,0,-1, 1
};

static FE_value lagrange_hermite_blending_matrix[]=
{
	1,-2, 1,
	0, 2,-1,
	0,-1, 1
};

static FE_value hermite_lagrange_blending_matrix[]=
{
	1,0,-1,
	0,1,-1,
	0,0, 1
};

/*???DB.  Start by blending to full monomial.  Think about reduced later */
static FE_value linear_simplex_2d_blending_matrix[]=
{
	1,-1,-1, 0,
	0, 1, 0, 0,
	0, 0, 1, 0
};

static FE_value quadratic_simplex_2d_blending_matrix[]=
{
	1,-3, 2,-3, 4, 0, 2, 0, 0,
	0, 4,-4, 0,-4, 0, 0, 0, 0,
	0,-1, 2, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 4,-4, 0,-4, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0, 0,
	0, 0, 0,-1, 0, 0, 2, 0, 0
};

static FE_value linear_simplex_3d_blending_matrix[]=
{
	1,-1,-1, 0,-1, 0, 0, 0,
	0, 1, 0, 0, 0, 0, 0, 0,
	0, 0, 1, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 0, 0
};

#if defined (NEW_NEW_CODE)
/*???DB.  For reduced monomial */
static FE_value linear_simplex_2d_blending_matrix[]=
{
	1,-1,-1,
	0, 1, 0,
	0, 0, 1
};

static FE_value quadratic_simplex_2d_blending_matrix[]=
{
	1,-3, 2,-3,-4, 2,
	0, 4,-4, 0,-4, 0,
	0,-1, 2, 0, 0, 0,
	0, 0, 0, 4,-4,-4,
	0, 0, 0, 0, 4, 0,
	0, 0, 0, 2, 0,-2
};

static FE_value linear_simplex_3d_blending_matrix[]=
{
	1,-1,-1,-1,
	0, 1, 0, 0,
	0, 0, 1, 0,
	0, 0, 0, 1
};
#endif /* defined (NEW_NEW_CODE) */

struct Add_FE_element_and_faces_to_manager_data
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
User data for function add_FE_element_and_faces_to_manager - created by
CREATE(Add_FE_element_and_faces_to_manager_data).
==============================================================================*/
{
	/* this flag should initially be set; if add_FE_element_and_faces_to_manager
		 needs to find an existing face for the first time (ie. this flag is set),
		 it does the lengthy job of taking all existing faces and lines and making
		 an element_type_node_sequence item in the list for them so it can be found
		 easily again. Any new faces automatically have an entry put in the list,
		 hence this flag is then immediately cleared. */
	int first_time_called;
	/* keep next free identifiers so don't have expensive search to get them
		 each time we call add_FE_element_and_faces_to_manager */
	struct CM_element_information next_free_face_identifier,
		next_free_line_identifier;
	struct LIST(FE_element_type_node_sequence) *element_type_node_sequence_list;
	struct MANAGER(FE_element) *element_manager;
}; /* struct Add_FE_element_and_faces_to_manager_data */

struct FE_element_parent_has_field_data
/*******************************************************************************
LAST MODIFIED : 16 August 1999

DESCRIPTION :
Used by FE_element_parent_has_field.
==============================================================================*/
{
	struct FE_field *field;
	struct GROUP(FE_element) *element_group;
}; /* struct FE_element_parent_has_field_data */

/*
Module functions
----------------
*/
PROTOTYPE_LIST_FUNCTIONS(FE_node_field);
PROTOTYPE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_node_field,field, \
	struct FE_field *);
PROTOTYPE_LIST_FUNCTIONS(FE_node_field_info);

static int get_Value_storage_size(enum Value_type value_type)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Given the value type, returns the size in bytes of the memory required to store 
the following:
For non-array type, the actual data.
For array types, an integer storing the number of array values, and a pointer to
the array values.
==============================================================================*/
{		
	int size;

	ENTER(get_Value_storage_size);
	switch(value_type)
	{
		case DOUBLE_VALUE:
		{
			size = sizeof(double);
		} break;
		case ELEMENT_XI_VALUE:
		{
			/* need this to handle 64-bit alignment problems of 64-bit quantities in
				 64-bit version */
#if defined (O64)
			size = (sizeof(struct FE_element *) + sizeof(FE_value) * 
				MAXIMUM_ELEMENT_XI_DIMENSIONS) -
				((sizeof(struct FE_element *) + sizeof(FE_value) * 
				MAXIMUM_ELEMENT_XI_DIMENSIONS)%8) + 8;
#else /* defined (O64) */
			size = sizeof(struct FE_element *) + sizeof(FE_value) * 
				MAXIMUM_ELEMENT_XI_DIMENSIONS;
#endif /* defined (O64) */
		} break;
		case FE_VALUE_VALUE:
		{
			size = sizeof(FE_value);
		} break;
		case FLT_VALUE:
		{
			size = sizeof(float);
		} break;
		case SHORT_VALUE:
		{
			size = sizeof(short);
		} break;
		case INT_VALUE:
		{
			size = sizeof(int);
		} break;	
		case UNSIGNED_VALUE:
		{
			size = sizeof(unsigned);
		} break;
		case DOUBLE_ARRAY_VALUE:
		{
			/* VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE space for number of array values */
			/* (*double) to store pointer to data*/
			size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(double *);
		} break; 
		case FE_VALUE_ARRAY_VALUE:				
		{
			size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(FE_value *);
		} break;
		case FLT_ARRAY_VALUE:
		{
			size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(float *);
		} break;	
		case SHORT_ARRAY_VALUE:
		{
			size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(short *);
		} break;
		case INT_ARRAY_VALUE:
		{
			size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(int *);
		} break;
		case UNSIGNED_ARRAY_VALUE:
		{
			size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(unsigned *);
		} break;
		case STRING_VALUE:
		{
			size = sizeof(char *);
		} break;
		default:
		{
			display_message(ERROR_MESSAGE,
				"get_Value_storage_size.  Unknown value_type");
			size =0;
		} break;
	}
	LEAVE;

	return(size);	
} /* get_Value_storage_size */

static int free_value_storage_array(Value_storage *values_storage,
	enum Value_type value_type,int number_of_values)
/*******************************************************************************
LAST MODIFIED: 30 September 1999

DESCRIPTION:
DEACCESSes objects and DEALLOCATEs dynamic storage in use by <values_storage>,
which is assumed to have <number_of_values> of the given <value_type>.
Note that the values_storage array itself is not DEALLOCATED - up to the
calling function to do this.
Only certain value types, eg. arrays, strings, element_xi require this.
==============================================================================*/
{
	Value_storage *the_values_storage;
	int i,return_code,size;

	ENTER(free_value_storage_array);
	if (values_storage&&(size=get_Value_storage_size(value_type))&&
		(0<number_of_values))
	{
		return_code=1;
		the_values_storage = values_storage;
		switch (value_type)
		{
			case DOUBLE_ARRAY_VALUE:
			{
				double **array_address;

				for (i=0;i<number_of_values;i++)
				{
					array_address = (double **)(the_values_storage+sizeof(int));
					DEALLOCATE(*array_address);
					the_values_storage += size;
				}
			} break;
			case ELEMENT_XI_VALUE:
			{
				struct FE_element **element_address;

				for (i=0;i<number_of_values;i++)
				{
					element_address = (struct FE_element **)the_values_storage;
					if (*element_address)
					{
						DEACCESS(FE_element)(element_address);
					}
					the_values_storage += size;
				}
			} break;
			case FE_VALUE_ARRAY_VALUE:
			{
				FE_value **array_address;

				for (i=0;i<number_of_values;i++)
				{
					array_address = (FE_value **)(the_values_storage+sizeof(int));
					DEALLOCATE(*array_address);
					the_values_storage += size;
				}
			} break;
			case FLT_ARRAY_VALUE:
			{
				float **array_address;

				for (i=0;i<number_of_values;i++)
				{
					array_address = (float **)(the_values_storage+sizeof(int));
					DEALLOCATE(*array_address);
					the_values_storage += size;
				}
			} break;
			case INT_ARRAY_VALUE:
			{
				int **array_address;

				for (i=0;i<number_of_values;i++)
				{
					array_address = (int **)(the_values_storage+sizeof(int));
					DEALLOCATE(*array_address);
					the_values_storage += size;
				}
			} break;
			case UNSIGNED_ARRAY_VALUE:
			{
				unsigned **array_address;

				for (i=0;i<number_of_values;i++)
				{
					array_address = (unsigned **)(the_values_storage+sizeof(int));
					DEALLOCATE(*array_address);
					the_values_storage += size;
				}
			} break;
			case STRING_VALUE:
			{
				char **array_address;

				for (i=0;i<number_of_values;i++)
				{
					array_address = (char **)(the_values_storage);
					DEALLOCATE(*array_address);
					the_values_storage += size;
				}
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"free_value_storage_array. Invalid arguments");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* free_value_storage_array */

static int allocate_and_copy_values_storage_array(Value_storage *source, 
	enum Value_type value_type, Value_storage *dest)
/************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION
Allocate an array of type value_type, of the length stored in source.
Copy the data from the array referenced by the pointer in source to the
alocated array. Copy the number of array values and the pointer to the 
allocated array into dest.

Therefore must must free dest in calling function, and dest must be 
an unallocated pointer when this function is called.

NOTE:
For array types, the contents of values_storage is:
 | int (number of array values) | pointer to array (eg double *) | 
  x number_of_values 
Assumes that sizeof(int) = 1 DWORD, so that the pointers are a DWORD aligned
in memory. If pointers weren't DWORD aligned get bus errors on SGIs.
=======================================================================*/
{
	int number_of_array_values,array_size,return_code;
 
	
	ENTER(allocate_and_copy_values_storage_array);	
	if(source)
	{	
		return_code = 1;
		switch(value_type)
		{				
			case DOUBLE_ARRAY_VALUE:			
			{
				double *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if(number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (double **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(double))*(number_of_array_values);
					/* allocate the dest array */
					if(ALLOCATE(dest_array,double,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (double **)(dest+sizeof(int));
						*array_address = dest_array;					
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}
				}
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (double **)(dest+sizeof(int));
					*array_address = (double *)NULL;		
				}
			}break; 
			case FE_VALUE_ARRAY_VALUE:				
			{
				FE_value *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if(number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (FE_value **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(FE_value))*(number_of_array_values);
					/* allocate the dest array */
					if(ALLOCATE(dest_array,FE_value,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (FE_value **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (FE_value **)(dest+sizeof(int));
					*array_address = (FE_value *)NULL;		
				}
			}break;
			case FLT_ARRAY_VALUE:		
			{
				float *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if(number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (float **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(float))*(number_of_array_values);
					/* allocate the dest array */
					if(ALLOCATE(dest_array,float,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (float **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}		
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (float **)(dest+sizeof(int));
					*array_address = (float *)NULL;		
				}	
			}break;
			case SHORT_ARRAY_VALUE:		
			{
				short *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if(number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (short **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(short))*(number_of_array_values);
					/* allocate the dest array */
					if(ALLOCATE(dest_array,short,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (short **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}		
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (short **)(dest+sizeof(int));
					*array_address = (short *)NULL;		
				}	
			}break;	
			case INT_ARRAY_VALUE:			
			{
				int *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if(number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (int **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(int))*(number_of_array_values);
					/* allocate the dest array */
					if(ALLOCATE(dest_array,int,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (int **)(dest+sizeof(int));
						*array_address = dest_array;									
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}							
				}		
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (int **)(dest+sizeof(int));
					*array_address = (int *)NULL;		
				}	
			}break;
			case UNSIGNED_ARRAY_VALUE:
			{
				unsigned *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if(number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (unsigned **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(unsigned))*(number_of_array_values);
					/* allocate the dest array */
					if(ALLOCATE(dest_array,unsigned,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (unsigned **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (unsigned **)(dest+sizeof(int));
					*array_address = (unsigned *)NULL;		
				}		
			}break;
			case STRING_VALUE:
			{
				char *dest_array,*source_array,**array_address;			
				/* get address of array from source */				
				array_address = (char **)(source);
				if(*array_address)/* if we have a source array*/
				{
					source_array = *array_address;
					array_size = strlen(source_array)+1; /* +1 for null termination */
					/* allocate the dest array */
					if(ALLOCATE(dest_array,char,array_size))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);				
						/* copy the address of the new array into the dest values_storage*/		
						array_address = (char **)(dest);
						*array_address = dest_array;
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}					
				}
				else	/* copy NULL into the dest values_storage*/	
				{
					array_address = (char **)(dest);
					*array_address = (char *)NULL;
				}
			}break;		
			default:
			{	
				display_message(ERROR_MESSAGE,
					"allocate_and_copy_values_storage_array. Invalis type");
				return_code = 0;
			}break;
		} /*switch(the_value_type) */
	}
	else
	{
		display_message(ERROR_MESSAGE,"allocate_and_copy_values_storage_array."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
} /* allocate_and_copy_values_storage_array */

static int copy_value_storage_array(Value_storage *destination,
	enum Value_type value_type,int number_of_values,Value_storage *source)
/*******************************************************************************
LAST MODIFIED : 15 September 1999

DESCRIPTION :
Copies the <number_of_values> of <value_type> stored in <source> into
<destination>. Arrays, strings and other dynamic values are allocated afresh
for <destination>. <destination> is assumed to be blank and large enough to
contain such values.
==============================================================================*/
{
	int i,return_code;

	ENTER(copy_value_storage_array);
	if (destination&&(0<number_of_values)&&source)
	{
		return_code=1;
		switch (value_type)
		{			
			case DOUBLE_VALUE:
			{
				double *src,*dest;

				src = (double *)source;
				dest = (double *)destination;
				for (i=0;i<number_of_values;i++)
				{
					*dest = *src;
					dest++;
					src++;
				}
			} break;
			case ELEMENT_XI_VALUE:
			{
				int i,j;
				Value_storage *src,*dest;

				src = source;
				dest = destination;
				for (i=0;i<number_of_values;i++)
				{
					/* copy accessed element pointer */
					if (*((struct FE_element **)src))
					{
						(*(struct FE_element **)dest)
					      = ACCESS(FE_element)(*((struct FE_element **)src));
					}
					else
					{
						(*(struct FE_element **)dest) = (struct FE_element *)NULL;
					}
					dest += sizeof(struct FE_element *);
					src += sizeof(struct FE_element *);
					/* copy the xi location */
					for (j=0;j<MAXIMUM_ELEMENT_XI_DIMENSIONS;j++)
					{
						*((FE_value *)dest) = *((FE_value *)src);
						dest += sizeof(FE_value);
						src += sizeof(FE_value);
					}
				}
			} break;
			case FE_VALUE_VALUE:
			{
				FE_value *src,*dest;

				src = (FE_value *)source;
				dest = (FE_value *)destination;
				for (i=0;i<number_of_values;i++)
				{
					*dest = *src;
					dest++;
					src++;
				}
			} break;
			case FLT_VALUE:
			{
				float *src,*dest;

				src = (float *)source;
				dest = (float *)destination;
				for (i=0;i<number_of_values;i++)
				{
					*dest = *src;
					dest++;
					src++;
				}
			} break;	
			case SHORT_VALUE:
			{
				display_message(ERROR_MESSAGE,"copy_value_storage_array.  "
					"SHORT_VALUE: Haven't written code yet. Beware pointer alignment problems!");
				return_code = 0;
			} break;
			case INT_VALUE:
			{
				int *src,*dest;

				src = (int *)source;
				dest = (int *)destination;
				for (i=0;i<number_of_values;i++)
				{
					*dest = *src;
					dest++;
					src++;
				}
			} break;	
			case UNSIGNED_VALUE:
			{
				unsigned *src,*dest;

				src = (unsigned *)source;
				dest = (unsigned *)destination;
				for (i=0;i<number_of_values;i++)
				{
					*dest = *src;
					dest++;
					src++;
				}
			} break;	
			case DOUBLE_ARRAY_VALUE:
			case FE_VALUE_ARRAY_VALUE:
			case FLT_ARRAY_VALUE:	
			case SHORT_ARRAY_VALUE:
			case INT_ARRAY_VALUE:
			case UNSIGNED_ARRAY_VALUE:
			case STRING_VALUE:
			{
				int value_size;
				Value_storage *src,*dest;

				dest = destination;
				src = source;
				value_size=get_Value_storage_size(value_type);
				for (i=0;(i<number_of_values)&&return_code;i++)
				{
					if (!allocate_and_copy_values_storage_array(src,value_type,dest))
					{
						display_message(ERROR_MESSAGE,
							"copy_value_storage_array.  Failed to copy array");
						if (0<i)
						{
							/* free any arrays allocated to date */
							free_value_storage_array(destination,value_type,i);
						}
						return_code = 0;
					}
					dest += value_size;
					src += value_size;
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"copy_value_storage_array.  Unknown value_type");
				return_code = 0;
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_value_storage_array.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* copy_value_storage_array */

static Value_storage *make_value_storage_array(enum Value_type value_type,
	int number_of_values)
/*******************************************************************************
LAST MODIFIED : 26 October 1999

DESCRIPTION :
Allocates and clears value_storage space large enough to contain
<number_of_values> of the given <value_type>.
For non-array types, the contents of field->values_storage is:
   | data type (eg FE_value) | x number_of_values
For array types, the contents of field->values_storage is:
   ( | int (number of array values) | pointer to array (eg double *) |
   x number_of_values )
Sets data in this memory to 0, pointers to NULL.
==============================================================================*/
{
	int i,j,size,values_storage_size;
	Value_storage *new_value,*return_values_storage,*values_storage;

	ENTER(make_value_storage_array);
	return_values_storage=(Value_storage *)NULL;
	if ((size=get_Value_storage_size(value_type))&&(0<number_of_values))
	{
		values_storage_size=size*number_of_values;
		ADJUST_VALUE_STORAGE_SIZE(values_storage_size);
		if (ALLOCATE(return_values_storage,Value_storage,values_storage_size))	
		{
			values_storage=return_values_storage;
			for (i=0;(i<number_of_values)&&return_values_storage;i++)
			{
				switch (value_type) 
				{
					/* set values to zero*/
					case DOUBLE_VALUE: 
					{						
						*((double *)values_storage) = 0.0;
					}	break;
					case ELEMENT_XI_VALUE:
					{
						new_value = values_storage;
						*((struct FE_element **)new_value) = (struct FE_element *)NULL;
						new_value += sizeof(struct FE_element *);
						for (j=0;j<MAXIMUM_ELEMENT_XI_DIMENSIONS;j++)
						{
							*((FE_value *)new_value) = 0;
							new_value += sizeof(FE_value);
						}
					}	break;
					case FE_VALUE_VALUE:
					{
						*((FE_value *)values_storage) = 0.0;
					}	break;
					case FLT_VALUE: 
					{
						*((float *)values_storage) = 0.0;
					} break;
					case SHORT_VALUE: 
					{							
						display_message(ERROR_MESSAGE," make_value_storage_array." 
							"SHORT_VALUE. Code not written yet. Beware alignment problems ");
						DEALLOCATE(return_values_storage);
					} break;
					case INT_VALUE: 
					{						
						*((int *)values_storage) = 0;
					}	break;	
					case UNSIGNED_VALUE: 
					{							
						*((unsigned *)values_storage) = 0;
					}	break;
					/* set number of array values to 0, array pointers to NULL */
					case DOUBLE_ARRAY_VALUE:
					{ 						
						double **array_address;
						/* copy the number of array values (0!) to values_storage */
						*((int *)values_storage) = 0;
						/* copy the pointer to the array values (currently NULL), to
							 values_storage*/
						array_address = (double **)(values_storage+sizeof(int));
						*array_address = (double *)NULL;
					} break;
					case FE_VALUE_ARRAY_VALUE:				
					{
						FE_value **array_address;
						*((int *)values_storage) = 0;
						array_address = (FE_value **)(values_storage+sizeof(int));
						*array_address = (FE_value *)NULL;
					} break;
					case FLT_ARRAY_VALUE:			
					{
						float **array_address;
						*((int *)values_storage) = 0;
						array_address = (float **)(values_storage+sizeof(int));
						*array_address = (float *)NULL;
					} break;	
					case SHORT_ARRAY_VALUE:			
					{
						short **array_address;
						*((int *)values_storage) = 0;
						array_address = (short **)(values_storage+sizeof(int));
						*array_address = (short *)NULL;
					} break;			
					case INT_ARRAY_VALUE:								
					{
						int **array_address;
						*((int *)values_storage) = 0;
						array_address = (int **)(values_storage+sizeof(int));
						*array_address = (int *)NULL;
					} break;	
					case UNSIGNED_ARRAY_VALUE:			
					{
						unsigned **array_address;
						*((int *)values_storage) = 0;
						array_address = (unsigned **)(values_storage+sizeof(int));
						*array_address = (unsigned *)NULL;
					} break;	
					case STRING_VALUE:
					{
						char **str_address;
						str_address = (char **)(values_storage);
						*str_address = (char *)NULL;	
					} break;
					default:
					{
						display_message(ERROR_MESSAGE,
							"make_value_storage_array.  Unknown value_type");
						DEALLOCATE(return_values_storage);
					} break;
				}
				values_storage += size;	
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"make_value_storage_array.  Not enough memory");
		}	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"make_value_storage_array.  Invalid argument(s)");
	}
	LEAVE;

	return (return_values_storage);
} /* make_value_storage_array */

#if defined (DEBUG)
int show_FE_nodal_FE_values(struct FE_node *node)
/************************************************************************
LAST MODIFIED : 19 April 1999

DESCRIPTION
A debug function to print a node's value storage (to stdout)
=======================================================================*/
{
	int return_code,limit,i;
	FE_value *values;
	ENTER(show_FE_nodal_FE_values);
	if(node)
	{
		if(node->values_storage)
		{
			limit = get_FE_node_number_of_values(node);
			return_code = 1;
			values = (FE_value*)(node->values_storage);
			for(i=0;i<limit;i++)
			{
				printf("Nodal value[%d], = %f \n",i,*values);
				values++;	
			}
		}
		else
		{
			printf("Node->values_storage = NULL \n");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"show_FE_nodal_values."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
} /* show_FE_nodal_field_FE_values */


static int show_node_field(struct FE_node_field *node_field,void *count)
/************************************************************************
LAST MODIFIED : 19 April 1999

DESCRIPTION
A debug function to print a node fields (to stdout)
=======================================================================*/
{
	int return_code,i;
	struct FE_node_field_component *component;

	int *the_count;

	ENTER(show_node_field);		
	the_count = (int *)count;
	printf("count = %d\n",*the_count);
	if(node_field)
	{	
		printf("node_field = %x \n",node_field);
		if(node_field->field)
		{	
			printf("   node_field->field = %x \n",node_field->field);
			printf("   name = %s \n",node_field->field->name);
			printf("   number of values = %d \n",node_field->field->number_of_values);
			printf("   number of components = %d \n",node_field->field->number_of_components);		
			for(i=0;i<node_field->field->number_of_components;i++)
			{	
				printf("      component %d: \n",i);
				component = &(node_field->components[i]);
				printf("      number of versions = %d \n",component->number_of_versions);
				printf("      number of derivatives = %d \n",component->number_of_derivatives);
			}
		}
		else
		{
			printf("node_field->field = NULL \n");
		}
		return_code =1;	
	}
	else
	{
		printf("node_field = NULL \n");
		return_code = 1;
	}
	(*the_count)++;	
	printf("\n");
	LEAVE;
	return(return_code);
}

int show_FE_nodal_node_fields(struct FE_node *node)
/************************************************************************
LAST MODIFIED : 19 April 1999

DESCRIPTION
A debug function to print all a node's node fields (to stdout)
=======================================================================*/
{
	int return_code,count;
	FE_value *values;
	ENTER(show_FE_nodal_node_fields);
	if(node)
	{
		if(node->fields)
		{
			count =0;
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)
				(show_node_field,(void *)(&count),node->fields->node_field_list);
		}
		else
		{
			printf("Node->fields = NULL \n");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"show_FE_nodal_values."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
} /* show_FE_nodal_node_fields */
#endif /* defined (DEBUG) */

static int FE_node_field_get_number_of_values(struct FE_node_field *node_field)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
Returns the number of values sum of (1+number_of_derivatives)*number_of_versions
for all components.
==============================================================================*/
{
	int i,number_of_values;
	struct FE_node_field_component *component;
	
	ENTER(FE_node_field_get_number_of_values);
	number_of_values=0;
	if (node_field)
	{
		component = node_field->components;
		for (i=node_field->field->number_of_components;0<i;i--)
		{
			number_of_values +=
				(1+component->number_of_derivatives) * component->number_of_versions;
			component++;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_get_number_of_values.  Invalid argument");
	}
	LEAVE;

	return (number_of_values);
} /* FE_node_field_get_number_of_values */

static int FE_node_field_add_values_storage_size(
	struct FE_node_field *node_field,void *values_storage_size_void)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
If <node_field> represents a GENERAL_FE_FIELD then its required values_storage
in the node, adjusted for word alignment, is added on to <*values_storage_size>.
==============================================================================*/
{
	int return_code,this_values_storage_size,*values_storage_size;
	struct FE_field *field;

	ENTER(FE_node_field_add_values_storage_size);
	if (node_field&&(field=node_field->field)&&
		(values_storage_size = (int *)values_storage_size_void))
	{
		if (GENERAL_FE_FIELD==field->fe_field_type)
		{
			this_values_storage_size =
				FE_node_field_get_number_of_values(node_field) *
				get_Value_storage_size(field->value_type);
			ADJUST_VALUE_STORAGE_SIZE(this_values_storage_size);
			(*values_storage_size) += this_values_storage_size;
		}
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_add_values_storage_size.  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_add_values_storage_size */

static int FE_node_field_copy_value_storage(struct FE_node_field *node_field,
	struct FE_node *node,Value_storage *values_storage)
/*******************************************************************************
LAST MODIFIED : 13 September 2000

DESCRIPTION :
Copy the FE_node_field's values_storage stored at the FE_node to values_storage.
Assumes values_storage has already been allocated.
==============================================================================*/
{
 	enum Value_type value_type;
	int number_of_values,offset,return_code;
	struct FE_field *field;
	struct FE_node_field_component *component;
	Value_storage *destination,*source;

	ENTER(FE_node_field_copy_value_storage);
	if (node_field&&(field=node_field->field)&&node&&values_storage)
	{
		/* only GENERAL_FE_FIELD has values stored with node */
		if (GENERAL_FE_FIELD == field->fe_field_type)
		{
			value_type = field->value_type;
			number_of_values = FE_node_field_get_number_of_values(node_field);
			/* start at first component->value */
			component = node_field->components;
			offset = component->value;
			destination = values_storage + offset;
			source = node->values_storage + offset;
			return_code=copy_value_storage_array(destination,value_type,
				number_of_values,source);
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_copy_value_storage.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* FE_node_field_copy_value_storage */

struct FE_node_value_data
{
	struct FE_node *source_node;
	Value_storage *dest_values_storage;
	struct LIST(FE_node_field) *exclusion_field_list;
}; /* FE_node_value_data */

static int iterative_FE_node_field_copy_values_storage(
	struct FE_node_field *node_field,	void *node_value_data_void)
/*******************************************************************************
LAST MODIFIED: 4 March 1999

Wrapper for FE_node_field_copy_value_storage(), so can call it 
iteratively for all the FE_node_fields in  
FE_node_field_info->node_field_list. 

Accumulates information in node_value_data.
Assumes space for the FE_node_field's values_storage has been allocated in
node_value_data.values_storage.
==============================================================================*/
{	
	int return_code;
	struct FE_node_value_data *node_value_data;

	ENTER(iterative_FE_node_field_copy_values_storage);
	if (node_field&&(node_value_data=
		(struct FE_node_value_data *)node_value_data_void))
	{
		return_code =1;
		if (node_value_data->dest_values_storage)
		{
			if ((!node_value_data->exclusion_field_list)||
				!FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(node_field->field,
					node_value_data->exclusion_field_list))
			{
				/* get the values_storage for this node field*/	
				FE_node_field_copy_value_storage(node_field,
					node_value_data->source_node,node_value_data->dest_values_storage);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"iterative_FE_node_field_copy_values_storage.  "
				"Missing destination values_storage");
			return_code = 0;
		}
	
	}
	else
	{
		display_message(ERROR_MESSAGE,"iterative_FE_node_field_copy_values_storage"
			".Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
} /* iterative_FE_node_field_copy_values_storage */

static int copy_FE_node_value_storage(struct FE_node *node, 
	Value_storage **values_storage, struct LIST(FE_node_field) *exclusion_field_list)
/******************************************************************************
LAST MODIFIED: 4 March 1999

DESCRIPTION:
Copies the node->values_storage to values_storage. Also allocates and copies
any arrays in node->values_storage. Assumes that values_storage has been allocated!

Note that values_storage contains no information about the value_type(s) or the
number of values of the data in it. You must refer to the FE_node/FE_field to 
get this.

The the calling function is responsible for deallocating values_storage,
and any arrays in values_storage.

The optional <exclusion_field_list> excludes any fields that are referenced by
FE_node_fields in its list so that values that are about to be overwritten 
are not allocated and copied.
==============================================================================*/
{
	int return_code;
	struct FE_node_value_data data;

	ENTER(copy_FE_node_value_storage);
	if(node)
	{
		return_code = 1;
		data.source_node = node;
		data.dest_values_storage = *values_storage; 
		data.exclusion_field_list = exclusion_field_list;
		/* data will be set and arrays allocated within */
		/* iterative_FE_node_field_copy_values_storage */
		if((node->fields)&&(values_storage))
		{					
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)
				(iterative_FE_node_field_copy_values_storage,
					(void *)(&data),node->fields->node_field_list);
		}
		else
		{
			display_message(ERROR_MESSAGE,"copy_FE_node_value_storage." 
				" node->fields not set");
			return_code = 0;
		}

	}
	else
	{
		display_message(ERROR_MESSAGE,"copy_FE_node_value_storage." 
			" Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* copy_FE_node_value_storage */

static int get_FE_node_field_list_values_storage_size(
	struct LIST(FE_node_field) *node_field_list)
/*******************************************************************************
LAST MODIFIED : 13 September 2000

DESCRIPTION :
Returns the size, in bytes, of the data in the nodal values storage owned
by the all the node_fields in node_field_list.
==============================================================================*/
{
	int values_storage_size;
	
	ENTER(get_FE_node_field_list_values_storage_size);
	values_storage_size=0;
	if (node_field_list)
	{
		FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			FE_node_field_add_values_storage_size,
			(void *)&values_storage_size,node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_list_values_storage_size.  Invalid argument");
	}
	LEAVE;

	return (values_storage_size);
} /* get_FE_node_field_list_values_storage_size */

static int allocate_and_copy_FE_node_value_storage(struct FE_node *node, 
	Value_storage **values_storage)
/******************************************************************************
LAST MODIFIED: 13 September 2000

DESCRIPTION:
Allocates values_storage to the same size as node->values_storage.
Copies the node->values_storage to values_storage. Also allocates and copies
any arrays in node->values_storage.

Note that values_storage contains no information about the value_type(s) or the
number of values of the data in it. You must refer to the FE_node/FE_field to 
get this.

The the calling function is responsible for deallocating values_storage,
and any arrays in values_storage.
==============================================================================*/
{
	int return_code,size;
	Value_storage *dest_values_storage;

	ENTER(allocate_and_copy_FE_node_value_storage);
	if(node)
	{
		return_code = 1;
	
		if (node->fields)
		{
			size = get_FE_node_field_list_values_storage_size(
				node->fields->node_field_list);
			if (size)
			{
				if (ALLOCATE(dest_values_storage,Value_storage,size))
				{
					copy_FE_node_value_storage(node,&dest_values_storage,
						(struct LIST(FE_node_field) *)NULL);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"allocate_and_copy_FE_node_value_storage.  Not enough memory");
					dest_values_storage = (Value_storage *)NULL;
					return_code = 0;
				}
			}
			else /* no fields, nothing to copy */
			{
				dest_values_storage = (Value_storage *)NULL;	
			}	
		}	
		else /* no fields, nothing to copy */
		{
		 dest_values_storage = (Value_storage *)NULL;	
		}	
		*values_storage = dest_values_storage;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"allocate_and_copy_FE_node_value_storage.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* allocate_and_copy_FE_node_value_storage */

static int FE_node_field_free_values_storage_arrays(
	struct FE_node_field *node_field,void *node_void)
/*******************************************************************************
LAST MODIFIED: 20 October 1999

DESCRIPTION:
Frees accesses and dynamically allocated memory for the FE_node_field at node.
Only certain value types, eg. arrays, strings, element_xi require this.
==============================================================================*/
{
	enum Value_type value_type;
	int i,number_of_components,number_of_values,return_code;
	struct FE_node_field_component *component;
	struct FE_node *node;
	Value_storage *values_storage;

	ENTER(FE_node_field_free_values_storage_arrays);
	if (node_field&&node_field->field&&(node=(struct FE_node *)node_void))
	{
		return_code = 1;
		/* only general fields have node_field_components and can have
			 values_storage at the node */
		if (GENERAL_FE_FIELD==node_field->field->fe_field_type)
		{
			value_type = node_field->field->value_type;
			number_of_components = node_field->field->number_of_components;
			component = node_field->components;
			for (i=0;i<number_of_components;i++)
			{
				values_storage = node->values_storage + component->value;	
				number_of_values=
					(1+component->number_of_derivatives)*component->number_of_versions;
				free_value_storage_array(values_storage,value_type,number_of_values);
				component++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_free_values_storage_arrays. Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* FE_node_field_free_values_storage_arrays */

static int FE_node_field_is_type_CM_coordinate(struct FE_node_field 
	*node_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 10 February 1999

DESCRIPTION:
returns true if <node_field> has a field of type CM_coordinate
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_is_type_CM_coordinate);
	if(node_field&&!dummy)
	{
		return_code = (node_field->field->cm.type == CM_COORDINATE_FIELD); 	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_is_type_CM_coordinate. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
}/* FE_node_field_is_type_CM_coordinate */

static int FE_node_field_has_time(struct FE_node_field *node_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 16 June 1999

DESCRIPTION:
returns true if <node_field> has time information defined
==============================================================================*/
{
	int return_code;
	ENTER(FE_node_field_has_time);

	if(node_field&&!dummy)
	{
		return_code = (node_field->field->number_of_times > 0); 	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_has_time. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
}/* FE_node_field_has_time */

static int assign_FE_node_field_component(
	struct FE_node_field_component *component,
	int value,int number_of_derivatives,int number_of_versions,
	enum FE_nodal_value_type *nodal_value_types)
/*******************************************************************************
LAST MODIFIED : 19 January 1998

DESCRIPTION :
Assigns the fields for the component
???DB.  Do nodal_value_types better ?
==============================================================================*/
{
	int i,return_code;

	ENTER(assign_FE_node_field_component);

	return_code = 1;
	if (component&&/*nodal_value_types&&*/(0<=number_of_derivatives))
	{
		if (!(component->nodal_value_types))
		{
			i=number_of_derivatives+1;
			if (ALLOCATE(component->nodal_value_types,enum FE_nodal_value_type,i))
			{
				if (nodal_value_types)
				{
					while (i>0)
					{
						i--;
						(component->nodal_value_types)[i]=nodal_value_types[i];
					}
				}
				else
				{
					while (i>1)
					{
						i--;
						(component->nodal_value_types)[i]=FE_NODAL_UNKNOWN;
					}
					(component->nodal_value_types)[0]=FE_NODAL_VALUE;
				}
				component->value=value;
				component->number_of_derivatives=number_of_derivatives;
				component->number_of_versions=number_of_versions;
			}
			else
			{
				display_message(ERROR_MESSAGE,
"assign_FE_node_field_component.  Could not allocate memory for nodal value types");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"assign_FE_node_field_component.  Component already assigned");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"assign_FE_node_field_component.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* assign_FE_node_field_component */

static int compare_FE_field(struct FE_field *field_1,struct FE_field *field_2)
/*******************************************************************************
LAST MODIFIED : 18 May 1998

DESCRIPTION :
Returns -1 if field_1 < field_2, 0 if field_1 = field_2 and 1 if
field_1 > field_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_FE_field);
	/*???DB.  Alphabetical ordering */
	return_code=strcmp(field_1->name,field_2->name);
#if defined (OLD_CODE)
	if (field_1<field_2)
	{
		return_code= -1;
	}
	else
	{
		if (field_1>field_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
#endif /* defined (OLD_CODE) */
	LEAVE;

	return (return_code);
} /* compare_FE_field */

static struct FE_node_field *CREATE(FE_node_field)(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 19 January 1998

DESCRIPTION :
Allocates memory and assigns fields for a node field.  The components are
allocated and set to "zero".
???DB.  Not allocating any nodal value names.
==============================================================================*/
{
	int number_of_components;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;

	ENTER(CREATE(FE_node_field));
	if (field)
	{
		number_of_components=field->number_of_components;
		if (ALLOCATE(node_field,struct FE_node_field,1)&&
			ALLOCATE(component,struct FE_node_field_component,number_of_components))
		{
			node_field->field=ACCESS(FE_field)(field);
			node_field->components=component;
			while (number_of_components>0)
			{
				component->value=0;
				component->number_of_derivatives=0;
				component->number_of_versions=0;
				component->nodal_value_types=(enum FE_nodal_value_type *)NULL;
				component++;
				number_of_components--;
			}
			node_field->access_count=0;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_node_field).  Could not allocate memory for node field");
			DEALLOCATE(node_field);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_node_field).  Invalid argument(s)");
		node_field=(struct FE_node_field *)NULL;
	}
	LEAVE;

	return (node_field);
} /* CREATE(FE_node_field) */

static int DESTROY(FE_node_field)(struct FE_node_field **node_field_address)
/*******************************************************************************
LAST MODIFIED : 19 January 1998

DESCRIPTION :
Frees the memory for the node field and sets <*node_field_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;

	ENTER(DESTROY(FE_node_field));
	if ((node_field_address)&&(node_field= *node_field_address))
	{
		if (0==node_field->access_count)
		{
			component=node_field->components;
			for (i=node_field->field->number_of_components;i>0;i--)
			{
				DEALLOCATE(component->nodal_value_types);
				component++;
			}
			/* free the components */
			DEALLOCATE(node_field->components);
			(void)DEACCESS(FE_field)(&(node_field->field));
			DEALLOCATE(*node_field_address);
		}
		else
		{
			*node_field_address=(struct FE_node_field *)NULL;
		}
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node_field) */

DECLARE_OBJECT_FUNCTIONS(FE_node_field)

static struct FE_node_field *copy_create_FE_node_field_with_offset(
	struct FE_node_field *source_node_field,int value_offset)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
Creates an FE_node_field that is identical to <source_node_field> except that
the <value_offset> is added to the value member of the components (which is
an offset into the values_storage array at the node). For non-GENERAL_FE_FIELD
types, the value is not changed.
==============================================================================*/
{
	int i,number_of_components;
	struct FE_field *field;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component,*source_component;

	ENTER(copy_create_FE_node_field_with_offset);
	if (source_node_field&&(field=source_node_field->field))
	{
		if (node_field=CREATE(FE_node_field)(field))
		{
			if (GENERAL_FE_FIELD != field->fe_field_type)
			{
				/* though component->value is currently irrelevant for these fields,
					 keep it unchanged for future use */
				value_offset=0;
			}
			number_of_components=get_FE_field_number_of_components(field);
			component=node_field->components;
			source_component=source_node_field->components;
			for (i=number_of_components;(0<i)&&node_field;i--)
			{
				if (!assign_FE_node_field_component(component,
					source_component->value+value_offset,
					source_component->number_of_derivatives,
					source_component->number_of_versions,
					source_component->nodal_value_types))
				{
					display_message(ERROR_MESSAGE,
						"copy_create_FE_node_field_with_offset.  "
						"Could not assign node field component");
					DESTROY(FE_node_field)(&node_field);
				}
				component++;
				source_component++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"copy_create_FE_node_field_with_offset.  Could not create node field");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_create_FE_node_field_with_offset.  Invalid argument(s)");
		node_field=(struct FE_node_field *)NULL;
	}
	LEAVE;

	return (node_field);
} /* copy_create_FE_node_field_with_offset */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_node_field,field,struct FE_field *, \
	compare_FE_field)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(FE_node_field)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_node_field,field, \
	struct FE_field *,compare_FE_field)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_LIST_FUNCTIONS(FE_node_field)
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_node_field,field, \
	struct FE_field *,compare_FE_field)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

PROTOTYPE_CREATE_LIST_FUNCTION(FE_node_field_info);

PROTOTYPE_FIRST_OBJECT_IN_LIST_THAT_FUNCTION(FE_node_field_info);

static int FE_node_fields_match(struct FE_node_field *node_field_1,
	struct FE_node_field *node_field_2)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
Returns true if <node_field_1> and <node_field_2> are the same in every way.
==============================================================================*/
{
	int i,return_code;
	struct FE_node_field_component *component_1,*component_2;

	ENTER(FE_node_fields_match);
	if (node_field_1 && node_field_2)
	{
		if (node_field_1->field == node_field_2->field)
		{
			return_code=1;
			component_1=node_field_1->components;
			component_2=node_field_2->components;
			for (i=node_field_1->field->number_of_components;(return_code)&&(0<i);i--)
			{
				if ((component_1->value == component_2->value) &&
					(component_1->number_of_derivatives == 
						component_2->number_of_derivatives) &&
					(component_1->number_of_versions ==
						component_2->number_of_versions))
				{
					/*???RC Should compare nodal value types ie. derivatives here */
					component_1++;
					component_2++;
				}
				else
				{
					return_code=0;
				}
			}
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_fields_match.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_fields_match */

static int FE_node_field_not_in_list(struct FE_node_field *node_field,
	void *node_field_list)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
Checks if the <node_field> is not in the <node_field_list>.
==============================================================================*/
{
	int return_code;
	struct FE_node_field *node_field_2;
	struct LIST(FE_node_field) *list;

	ENTER(FE_node_field_not_in_list);
	if (node_field&&(node_field->field)&&
		(list=(struct LIST(FE_node_field) *)node_field_list))
	{
		if ((node_field_2 = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			node_field->field,list)) &&
			FE_node_fields_match(node_field,node_field_2))
		{
			return_code=0;
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_not_in_list.  Invalid argument(s)");
		return_code=1;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_not_in_list */

static int match_FE_node_field_list(struct FE_node_field_info *field_info,
	void *node_field_list)
/*******************************************************************************
LAST MODIFIED : 9 February 1999

DESCRIPTION :
Checks if the <field_info> matches the <node_field_lists>.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_info *field_list;

	ENTER(match_FE_node_field_list);
	/* check arguments */
	if (field_info&&(field_list=(struct FE_node_field_info *)node_field_list))
	{
		if ((NUMBER_IN_LIST(FE_node_field)(field_list->node_field_list)==
			NUMBER_IN_LIST(FE_node_field)(field_info->node_field_list)))
		{
			if (FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
				FE_node_field_not_in_list,(void *)(field_info->node_field_list),
						field_list->node_field_list))
			{
				return_code=0;
			}
			else
			{
				return_code=1;
			}

		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"match_FE_node_field_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* match_FE_node_field_list */

static int add_FE_node_field_if_not_duplicate(struct FE_node_field *node_field,
	void *list)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
If the <node_field> is not in the <list> it is added to the list.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node_field) *node_field_list;

	ENTER(add_FE_node_field_if_not_duplicate);
	/* check arguments */
	if (node_field&&(node_field->field)&&
		(node_field_list=(struct LIST(FE_node_field) *)list))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			node_field->field,node_field_list))
		{
			return_code=0;
		}
		else
		{
			if (ADD_OBJECT_TO_LIST(FE_node_field)(node_field,node_field_list))
			{
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"add_FE_node_field_if_not_duplicate.  Could not add field %s to list",
					node_field->field->name);
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_node_field_if_not_duplicate.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_node_field_if_not_duplicate */

static struct FE_node_field_info *find_FE_node_field_info_in_list(
	struct LIST(FE_node_field) *node_field_list,
	struct LIST(FE_node_field_info) *list)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
Searchs the <list> for the node field_information with the specified node
fields.
==============================================================================*/
{
	struct FE_node_field_info *field_info,the_node_field_list;

	ENTER(find_FE_node_field_info_in_list);
	if (list&&node_field_list)
	{
		the_node_field_list.node_field_list=node_field_list;
		field_info=FIRST_OBJECT_IN_LIST_THAT(FE_node_field_info)(
			match_FE_node_field_list,(void *)(&the_node_field_list),list);
	}
	else
	{
		field_info=(struct FE_node_field_info *)NULL;
	}
	LEAVE;

	return (field_info);
} /* find_FE_node_field_info_in_list */

static struct FE_node_field_info *CREATE(FE_node_field_info)(
	int number_of_values,	struct LIST(FE_node_field) *node_field_list)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
Searchs the list of all node field information (<all_FE_node_field_info>) for
one with the specified <number_of_values> and containing the specified node
fields.  If one is found it is returned, otherwise a new node field information
is created with duplicated node field lists, added to
<all_FE_node_field_info> and returned.
==============================================================================*/
{
	struct FE_node_field_info *field_info;
	struct LIST(FE_node_field) *duplicate_node_field_list;

	ENTER(CREATE(FE_node_field_info));
	/* check the arguments */
	if (0<=number_of_values)
	{
		/* check for duplicates in the node field lists */
		if ((duplicate_node_field_list=CREATE_LIST(FE_node_field)())&&
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)(add_FE_node_field_if_not_duplicate,
			(void *)duplicate_node_field_list,node_field_list))
		{
			if (!all_FE_node_field_info)
			{
				all_FE_node_field_info=CREATE_LIST(FE_node_field_info)();
			}
			if (field_info=find_FE_node_field_info_in_list(
				node_field_list,all_FE_node_field_info))
			{
				/* field information already exists */
				DESTROY_LIST(FE_node_field)(&duplicate_node_field_list);
				if (number_of_values!=field_info->number_of_values)
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_node_field_info).  Incorrect number of values %d;"
						" should be %d",number_of_values,field_info->number_of_values);
					field_info=(struct FE_node_field_info *)NULL;
				}
			}
			else
			{
				/* create a new field information structure */
				if (ALLOCATE(field_info,struct FE_node_field_info,1))
				{
					field_info->node_field_list=duplicate_node_field_list;
					field_info->number_of_values=number_of_values;
					field_info->access_count=0;	 					
					field_info->values_storage_size=
						get_FE_node_field_list_values_storage_size(
							field_info->node_field_list);					
					if (!ADD_OBJECT_TO_LIST(FE_node_field_info)(field_info,
						all_FE_node_field_info))
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_node_field_info).  Could not add to all list");
						DESTROY_LIST(FE_node_field)(&duplicate_node_field_list);
						DEALLOCATE(field_info);
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_node_field_info).  Insufficient memory");
					DESTROY_LIST(FE_node_field)(&duplicate_node_field_list);
				}
			}
		}
		else
		{
			DESTROY_LIST(FE_node_field)(&duplicate_node_field_list);
			field_info=(struct FE_node_field_info *)NULL;
		}	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_node_field_info).  No node fields");
		field_info=(struct FE_node_field_info *)NULL;
	}
	LEAVE;

	return (field_info);
} /* CREATE(FE_node_field_info) */

static int DESTROY(FE_node_field_info)(
	struct FE_node_field_info **field_info_address)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
Removes the information from the list <all_FE_node_field_info>, frees the memory
for the information and sets <*field_info_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_info *field_info;

	ENTER(DESTROY(FE_node_field_info));
	/* check the arguments */
	if ((field_info_address)&&(field_info= *field_info_address))
	{
		/* <=1 is used (instead of <=0) because every node field information
			structure is in <all_FE_node_field_information> */
		if (0==field_info->access_count)
		{
			DESTROY_LIST(FE_node_field)(&(field_info->node_field_list));
			DEALLOCATE(*field_info_address);
			return_code=1;
		}
		else
		{
			if (1==field_info->access_count)
			{
				return_code=REMOVE_OBJECT_FROM_LIST(FE_node_field_info)(field_info,
					all_FE_node_field_info);
				if (0 == NUMBER_IN_LIST(FE_node_field_info)(all_FE_node_field_info))
				{
					DESTROY(LIST(FE_node_field_info))(&all_FE_node_field_info);
					all_FE_node_field_info = (struct LIST(FE_node_field_info) *)NULL;
				}
			}
			else
			{
				return_code=1;
			}
			*field_info_address=(struct FE_node_field_info *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node_field_info) */

DECLARE_ACCESS_OBJECT_FUNCTION(FE_node_field_info)
PROTOTYPE_DEACCESS_OBJECT_FUNCTION(FE_node_field_info)
{ 
	int return_code; 
	struct FE_node_field_info *object; 

	ENTER(DEACCESS(FE_node_field_info)); 
	if (object_address&&(object= *object_address)) 
	{ 
		(object->access_count)--;
		/* <=1 is used (instead of <=0) because every element field information
			structure is in <all_FE_node_field_info> */
		if (object->access_count<=1) 
		{ 			
				return_code=DESTROY(FE_node_field_info)(object_address); 
		} 
		else 
		{ 
			*object_address=(struct FE_node_field_info *)NULL; 
			return_code=1; 
		} 
	} 
	else 
	{ 
		return_code=0; 
	} 
	LEAVE; 

	return (return_code); 
} /* DEACCESS(FE_node_field_info) */

PROTOTYPE_REACCESS_OBJECT_FUNCTION(FE_node_field_info) 
{ 
	int return_code; 
	struct FE_node_field_info *current_object; 

	ENTER(REACCESS(FE_node_field_info)); 
	if (object_address) 
	{ 
		return_code=1; 
		if (new_object) 
		{ 
			/* access the new object */ 
			(new_object->access_count)++; 
		} 
		if (current_object= *object_address) 
		{ 
			/* deaccess the current object */ 
			(current_object->access_count)--; 
			/* <=1 is used (instead of <=0) because every element field information
			structure is in <all_FE_node_field_info> */
			if (current_object->access_count<=1) 
			{ 
				DESTROY(FE_node_field_info)(object_address); 
			} 
		} 
		/* point to the new object */ 
		*object_address=new_object; 
	} 
	else 
	{ 
		display_message(ERROR_MESSAGE, 
			"REACCESS( FE_node_field_info ).  Invalid argument"); 
		return_code=0; 
	} 
	LEAVE; 

	return (return_code); 
} /* REACCESS(FE_node_field_info) */

static struct FE_node_field *find_FE_node_field_in_info(struct FE_field *field,
	struct FE_node_field_info *node_field_information)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
Searches through the <node_field_information> for the node field for the
specified <field>.
==============================================================================*/
{
	struct FE_node_field *node_field;

	ENTER(find_FE_node_field_in_info);

	node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node_field_information->node_field_list);

	if (!node_field)
	{
		display_message(WARNING_MESSAGE,
			"find_FE_node_field_in_info.  Could not find field");
	}
	LEAVE;

	return (node_field);
} /* find_FE_node_field_in_all_fields */

DECLARE_LIST_FUNCTIONS(FE_node_field_info)

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_node,cm_node_identifier,int,compare_int)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

#if defined (FINITE_ELEMENT_EXCEPT_FOR_FE_node)
DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_node,cm_node_identifier,int,compare_int)
#endif /* FINITE_ELEMENT_EXCEPT_FOR_FE_node */

DECLARE_MANAGED_GROUP_MODULE_FUNCTIONS(FE_node)
/* indexed list and manager module functions included with MANAGED_GROUP */

static int compare_FE_basis_type(int *basis_type_1,int *basis_type_2)
/*******************************************************************************
LAST MODIFIED : 2 November 1995

DESCRIPTION :
Returns -1 if basis_type_1 < basis_type_2, 0 if basis_type_1 = basis_type_2 and
1 if basis_type_1 > basis_type_2.
==============================================================================*/
{
	int return_code,*type_1,*type_2;
	int i;

	ENTER(compare_FE_basis_type);
	if (type_1=basis_type_1)
	{
		if (type_2=basis_type_2)
		{
			if ((i= *type_1)== *type_2)
			{
				if (i>0)
				{
					i *= i+1;
					i /= 2;
					do
					{
						type_1++;
						type_2++;
						i--;
					} while ((i>0)&&(*type_1== *type_2));
					if (*type_1< *type_2)
					{
						return_code= -1;
					}
					else
					{
						if (*type_1> *type_2)
						{
							return_code=1;
						}
						else
						{
							return_code=0;
						}
					}
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				if (*type_1< *type_2)
				{
					return_code= -1;
				}
				else
				{
					return_code=1;
				}
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		if (basis_type_2)
		{
			return_code= -1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* compare_FE_basis_type */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_basis,type,int *,compare_FE_basis_type)

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_element_field,field, \
	struct FE_field *,compare_FE_field)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

 static int compare_CM_element_information(
	struct CM_element_information *cmiss_1,
	struct CM_element_information *cmiss_2)
/*******************************************************************************
LAST MODIFIED : 17 April 1999

DESCRIPTION :
Returns -1 if cmiss_1 < cmiss_2, 0 if cmiss_1 = cmiss_2 and 1 if cmiss_1 >
cmiss_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_CM_element_information);
	if (cmiss_1&&cmiss_2)
	{		
		if(cmiss_1->type==cmiss_2->type )
		{		
			if(cmiss_1->number==cmiss_2->number)
				return_code=0;
			else if(cmiss_1->number < cmiss_2->number)
				return_code=-1;
			else					 
				return_code =1;		
		}
		else
		{
			if(cmiss_1->type<cmiss_2->type )
				return_code=-1;
			else					 
				return_code =1;		
		}
		
	}
	else
	{
		return_code=1;
	}
	LEAVE;

	return (return_code);
} /* compare_CM_element_information */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_element,identifier, \
	struct CM_element_information *, compare_CM_element_information)

DECLARE_MANAGED_GROUP_MODULE_FUNCTIONS(FE_element)
#if defined (OLD_CODE)
/* indexed list and manager module functions included with MANAGED_GROUP */
DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(GROUP(FE_element),name,char *,strcmp)
#endif /* defined (OLD_CODE) */

static int compare_FE_element_type_node_sequence_identifier(
	struct FE_element_type_node_sequence_identifier *identifier1,
	struct FE_element_type_node_sequence_identifier *identifier2)
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
Compare functions for listing struct FE_element_type_node_sequence in order:
- cm_type changing slowest;
- number_of_nodes changing next slowest;
- node numbers in numerical order (nodes must be in ascending order).
Returns values like strcmp:
-1 = identifier 1 < identifier 2
 0 = identifier 1 = identifier 2
 1 = identifier 1 > identifier 2
==============================================================================*/
{
	int i,number_of_nodes,return_code;

	ENTER(compare_FE_element_type_node_sequence_identifier);
	if (identifier1&&identifier2)
	{
		/* 1. compare cm_type */
		if (identifier1->cm_type < identifier2->cm_type)
		{
			return_code=-1;
		}
		else if (identifier1->cm_type > identifier2->cm_type)
		{
			return_code=1;
		}
		else
		{
			/* 2. compare number_of_nodes */
			number_of_nodes=identifier1->number_of_nodes;
			if (number_of_nodes < identifier2->number_of_nodes)
			{
				return_code=-1;
			}
			else if (number_of_nodes > identifier2->number_of_nodes)
			{
				return_code=1;
			}
			else
			{
				/* 3. compare node_numbers - assumed in ascending order */
				return_code=0;
				/*???RC.  Assumes the identifiers have nodes - as required by
					CREATE(FE_element_type_node_sequence */
				for (i=0;(!return_code)&&(i<number_of_nodes);i++)
				{
					if (identifier1->node_numbers[i]<identifier2->node_numbers[i])
					{
						return_code=-1;
					}
					else if (identifier1->node_numbers[i]>identifier2->node_numbers[i])
					{
						return_code=1;
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"compare_FE_element_type_node_sequence_identifier.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* compare_FE_element_type_node_sequence_identifier */

static int DESTROY(FE_element_type_node_sequence)(
	struct FE_element_type_node_sequence **element_type_node_sequence_address)
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
Cleans up memory used by the FE_element_type_node_sequence.
???RC Have DESTROY before CREATE and OBJECT_FUNCTIONS (RE/DEACCESS) since these
can call this.
==============================================================================*/
{
	int return_code;
	struct FE_element_type_node_sequence *element_type_node_sequence;

	ENTER(DESTROY(FE_element_type_node_sequence));
	if (element_type_node_sequence_address&&
		(element_type_node_sequence= *element_type_node_sequence_address))
	{
		if (0==element_type_node_sequence->access_count)
		{
			/* must deaccess element */
			DEACCESS(FE_element)(&(element_type_node_sequence->element));
			if (element_type_node_sequence->identifier)
			{
				DEALLOCATE(element_type_node_sequence->identifier->node_numbers);
				DEALLOCATE(element_type_node_sequence->identifier);
			}
			DEALLOCATE(*element_type_node_sequence_address);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_element_type_node_sequence).  Non-zero access count of %d",
				element_type_node_sequence->access_count);
			*element_type_node_sequence_address=
				(struct FE_element_type_node_sequence *)NULL;
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(FE_element_type_node_sequence).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_type_node_sequence) */

DECLARE_OBJECT_FUNCTIONS(FE_element_type_node_sequence)
DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_element_type_node_sequence, \
	identifier, struct FE_element_type_node_sequence_identifier *, \
	compare_FE_element_type_node_sequence_identifier)

static
struct FE_element_type_node_sequence *CREATE(FE_element_type_node_sequence)(
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
Structure for storing an element with its identifier being its cm_type and the
number and list - in ascending order - of the nodes referred to by the default
coordinate field of the element. Indexed lists, indexed using function
compare_FE_element_type_node_sequence_identifier ensure that recalling a line or
face with the same nodes is extremely rapid. add_FE_element_and_faces_to_manager
uses them to find faces and lines for elements without them, if they exist.
==============================================================================*/
{
	int i,j,k,node_number,*node_numbers,number_of_nodes,placed;
	struct FE_element_type_node_sequence *element_type_node_sequence;
	struct FE_node *node;
	struct LIST(FE_node) *nodes_in_element;

	ENTER(CREATE(FE_element_type_node_sequence));
	if (element)
	{
		/* get list of nodes used by default coordinate field in element */
		nodes_in_element=CREATE(LIST(FE_node))();
		if (calculate_FE_element_field_nodes(element,(struct FE_field *)NULL,
			nodes_in_element)&&
			(0<(number_of_nodes=NUMBER_IN_LIST(FE_node)(nodes_in_element))))
		{
			if (ALLOCATE(element_type_node_sequence,
				struct FE_element_type_node_sequence,1)&&
				ALLOCATE(element_type_node_sequence->identifier,
					struct FE_element_type_node_sequence_identifier,1)&&
				ALLOCATE(node_numbers,int,number_of_nodes))
			{
				element_type_node_sequence->identifier->cm_type=element->cm.type;
				element_type_node_sequence->identifier->number_of_nodes=number_of_nodes;
				element_type_node_sequence->identifier->node_numbers=node_numbers;
				element_type_node_sequence->element=ACCESS(FE_element)(element);
				element_type_node_sequence->access_count=0;
				/* put the nodes in the identifier in ascending order */
				for (i=0;element_type_node_sequence&&(i<number_of_nodes);i++)
				{
					if ((node=FIRST_OBJECT_IN_LIST_THAT(FE_node)(
						(LIST_CONDITIONAL_FUNCTION(FE_node) *)NULL,(void *)NULL,
						nodes_in_element))&&
						REMOVE_OBJECT_FROM_LIST(FE_node)(node,nodes_in_element))
					{
						node_number=node->cm_node_identifier;
						placed=0;
						for (j=0;(!placed)&&(j<i);j++)
						{
							if (node_number<node_numbers[j])
							{
								/* make space for the new number */
								for (k=i;j<k;k--)
								{
									node_numbers[k]=node_numbers[k-1];
								}
								node_numbers[j]=node_number;
								placed=1;
							}
						}
						if (!placed)
						{
							node_numbers[i]=node_number;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_element_type_node_sequence).  "
							"Node missing or not removable");
						DESTROY(FE_element_type_node_sequence)(&element_type_node_sequence);
					}
				}
#if defined (DEBUG)
				/*???debug*/
				printf("Element %d: type %d nodes =",element->cm.number,
					element_type_node_sequence->identifier->cm_type);
				for (i=0;i<number_of_nodes;i++)
				{
					printf(" %d",node_numbers[i]);
				}
				printf("\n");
#endif /* defined (DEBUG) */
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_element_type_node_sequence).  Not enough memory");
				if (element_type_node_sequence)
				{
					if (element_type_node_sequence->identifier)
					{
						DEALLOCATE(element_type_node_sequence->identifier);
					}
					DEALLOCATE(element_type_node_sequence);
				}
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"CREATE(FE_element_type_node_sequence).  "
				"Could not get nodes in element");
			element_type_node_sequence=(struct FE_element_type_node_sequence *)NULL;
		}
		DESTROY(LIST(FE_node))(&nodes_in_element);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_type_node_sequence).  Invalid argument(s)");
		element_type_node_sequence=(struct FE_element_type_node_sequence *)NULL;
	}
	LEAVE;

	return (element_type_node_sequence);
} /* CREATE(FE_element_type_node_sequence) */

DECLARE_INDEXED_LIST_FUNCTIONS(FE_element_type_node_sequence)
DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION( \
	FE_element_type_node_sequence,identifier, \
	struct FE_element_type_node_sequence_identifier *, \
	compare_FE_element_type_node_sequence_identifier)

static int FE_element_type_node_sequence_is_collapsed(
	struct FE_element_type_node_sequence *element_type_node_sequence)
/*******************************************************************************
LAST MODIFIED : 30 April 1999

DESCRIPTION :
Returns true if the <element_type_node_sequence> represents an element that
has collapsed, ie, is a face with <= 2 unique nodes, or a line with 1 unique
node.
???RC Note that repeated nodes in the face/line are not put in the node_numbers
array twice, facilitating the simple logic in this function. If they were, then
this function would have to be modified extensively.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_type_node_sequence_is_collapsed);
	if (element_type_node_sequence&&element_type_node_sequence->identifier)
	{
		return_code=((CM_FACE == element_type_node_sequence->identifier->cm_type)&&
			(2 >= element_type_node_sequence->identifier->number_of_nodes))||
			((CM_LINE == element_type_node_sequence->identifier->cm_type)&&
				(1 == element_type_node_sequence->identifier->number_of_nodes));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_type_node_sequence_is_collapsed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_type_node_sequence_is_collapsed */

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_field,name,char *,strcmp)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

DECLARE_LOCAL_MANAGER_FUNCTIONS(FE_field)

static FE_value *tensor_product(int row_dimension_1,int column_dimension_1,
	FE_value *matrix_1,int row_dimension_2,int column_dimension_2,
	FE_value *matrix_2)
/*******************************************************************************
LAST MODIFIED : 17 June 1994

DESCRIPTION :
This function returns the tensor product (memory allocated within the function)
of <matrix_1> and <matrix_2>.  All matricies are assumed to be stored row-wise.
==============================================================================*/
{
	FE_value *product,*row_start_1,*row_start_2,*value,*value_1,*value_2;
	int i,j,k,l;

	ENTER(tensor_product);
	if ((row_dimension_1>0)&&(column_dimension_1>0)&&matrix_1&&
		(row_dimension_2>0)&&(column_dimension_2>0)&&matrix_2)
	{
		if (ALLOCATE(product,FE_value,
			row_dimension_1*column_dimension_1*row_dimension_2*column_dimension_2))
		{
			value=product;
			row_start_1=matrix_1;
			for (i=row_dimension_1;i>0;i--)
			{
				row_start_2=matrix_2;
				for (j=row_dimension_2;j>0;j--)
				{
					value_1=row_start_1;
					for (k=column_dimension_1;k>0;k--)
					{
						value_2=row_start_2;
						for (l=column_dimension_2;l>0;l--)
						{
							*value=(*value_2)*(*value_1);
							value++;
							value_2++;
						}
						value_1++;
					}
					row_start_2=value_2;
				}
				row_start_1=value_1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"tensor_product.  Could not allocate memory for product");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE, "tensor_product.  Invalid argument(s)");
		product=(FE_value *)NULL;
	}
	LEAVE;

	return (product);
} /* tensor_product */

static int sort_basis_function_numbers(void *number_1_address,
	void *number_2_address)
/*******************************************************************************
LAST MODIFIED : 20 June 1993

DESCRIPTION :
==============================================================================*/
{
	int number_1,number_2,return_code;

	ENTER(sort_basis_function_numbers);
	number_1= *((int *)number_1_address);
	number_2= *((int *)number_2_address);
	if (number_1<number_2)
	{
		return_code= -1;
	}
	else
	{
		if (number_1>number_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* sort_basis_function_numbers */

static int monomial_basis_functions(void *type_arguments,
	FE_value *xi_coordinates,FE_value *function_values)
/*******************************************************************************
LAST MODIFIED : 29 January 1994

DESCRIPTION :
Calculates the monomial basis function values.  Expects the memory to already be
allocated for the <function_values>.  The first entry of the <type_arguments> is
the number of xi coordinates and the other entries are the orders of the
monomials for each xi coordinate.
NB.  xi_1 is varying slowest (xi_n fastest)
==============================================================================*/
{
	FE_value *temp_value,*value,xi,*xi_coordinate,xi_power;
	int *argument,i,j,k,order,number_of_values,number_of_xi_coordinates,
		return_code;

	ENTER(monomial_basis_functions);
	if ((argument=(int *)type_arguments)&&(xi_coordinate=xi_coordinates)&&
		function_values)
	{
/*???debug */
/*printf("monomial_basis_functions ");
for (i=0;i<=argument[0];i++)
{
	printf(" %d",argument[i]);
}
printf("\n");*/
		number_of_xi_coordinates= *argument;
		value=function_values;
		*value=1;
		number_of_values=1;
		for (i=number_of_xi_coordinates;i>0;i--)
		{
			xi= *xi_coordinate;
			xi_coordinate++;
			xi_power=xi;
			argument++;
			order= *argument;
			for (j=order;j>0;j--)
			{
				temp_value=function_values;
				for (k=number_of_values;k>0;k--)
				{
					value++;
					*value=(*temp_value)*xi_power;
					temp_value++;
				}
				xi_power *= xi;
			}
			number_of_values *= (order+1);
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"monomial_basis_functions.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* monomial_basis_functions */

static int polygon_basis_functions(void *type_arguments,
	FE_value *xi_coordinates,FE_value *function_values)
/*******************************************************************************
LAST MODIFIED : 7 January 1998

DESCRIPTION :
For a polygon
a) xi1 is circumferential and xi2 is radial.
b) the nodal basis functions are
	phi0 = 1 - xi2,  centre node
				/ xi2 * (1 - n*xi1), 0<=n*xi1<1
	phi1 = | xi2 * (n*xi1 - (n-1)), n-1<n*xi1<n
				\ 0, otherwise
				/ xi2 * (i - n*xi1), i-1<=n*xi1<i
	phii = | xi2 * (n*xi1 - (i-2)), i-2<n*xi1<i-1 ,  1<i<=n
				\ 0, otherwise
	where n is the number of polygon verticies/sides.
c) the standard basis functions are
				/ 1, xi1=1
	s001 = | 1, 0<=n*xi1<1
				\ 0, otherwise
	s00i = / 1, i-1<=n*xi1<i ,  2<=i<=n
				\ 0, otherwise
	s10i = / n*xi1-i+1, i-1<=n*xi1<i ,  1<=i<=n
				\ 0, otherwise
	s01i = xi2 * s00i ,  1<=i<=n
	s11i = xi2 * s10i ,  1<=i<=n
???DB.  Should this be
				/ 0.5, xi1=0 or xi1=1 or n*xi1=1
	s001 = | 1, 0<n*xi1<1
				\ 0, otherwise
				/ 0.5, n*xi1=i-1 or n*xi1=i
	s00i = | 1, i-1<n*xi1<i           ,  2<=i<=n
				\ 0, otherwise
				/ 0.5, n*xi1=i
	s10i = | n*xi1-i+1, i-1<n*xi1<i ,  1<=i<=n
				\ 0, otherwise
	s01i = xi2 * s00i ,  1<=i<=n
	s11i = xi2 * s10i ,  1<=i<=n
	to get derivatives right (better) at vertices ?
d) the blending matrix is
	1 1 1 . . . 1 0 0 0 . . . 0 -1 -1 -1 . . . -1  0  0  0 . . .  0
	0 0 0 . . . 0 0 0 0 . . . 0  1  0  0 . . .  0 -1  0  0 . . .  1
	0 0 0 . . . 0 0 0 0 . . . 0  0  1  0 . . .  0  1 -1  0 . . .  0
	0 0 0 . . . 0 0 0 0 . . . 0  0  0  1 . . .  0  0  1 -1 . . .  0
	.             .              .              .              .
	.             .              .              .              .
	.             .              .              .              .
	0 0 0 . . . 0 0 0 0 . . . 0  0  0  0 . . .  1  0  0  0 . 0 1 -1
==============================================================================*/
{
	FE_value basis_function10,basis_function11,save_value,*temp_value,*value,xi,
		xi2,*xi_coordinate,xi_power;
	int *argument,i,j,k,order,number_of_polygon_verticies,number_of_values,
		number_of_xi_coordinates,offset00,offset01,offset10,offset11,polygon_offset,
		polygon_vertex,return_code;

	ENTER(polygon_basis_functions);
	if ((argument=(int *)type_arguments)&&(xi_coordinate=xi_coordinates)&&
		function_values)
	{
		number_of_xi_coordinates= *argument;
		value=function_values;
		*value=1;
		number_of_values=1;
		for (i=number_of_xi_coordinates;i>0;i--)
		{
			xi= *xi_coordinate;
			argument++;
			order= *argument;
			if (order<0)
			{
				/* polygon */
				if ((polygon_offset= -order)<number_of_xi_coordinates)
				{
					/* first polygon coordinate */
					/* may be called with xi outside the element (eg. during streamline
						tracking).  Wrap the circumferential (first) coordinate */
					xi -= floor(xi);
					number_of_polygon_verticies=
						-argument[polygon_offset]-number_of_xi_coordinates;
					xi2=xi_coordinate[polygon_offset];
					basis_function10=xi*(FE_value)number_of_polygon_verticies;
					polygon_vertex=(int)(basis_function10);
					basis_function10 -= (FE_value)polygon_vertex;
					if (number_of_polygon_verticies==polygon_vertex)
					{
						polygon_vertex=0;
					}
					basis_function11=xi2*basis_function10;
					temp_value=function_values;
					offset00=polygon_vertex*number_of_values;
					offset11=number_of_polygon_verticies*number_of_values;
					offset10=offset00+offset11;
					offset01=offset10+offset11;
					offset11=offset01+offset11;
					for (j=number_of_values;j>0;j--)
					{
						save_value= *temp_value;
						temp_value[offset00]=save_value;
						temp_value[offset10]=basis_function10*save_value;
						temp_value[offset01]=xi2*save_value;
						temp_value[offset11]=basis_function11*save_value;
						temp_value++;
					}
					temp_value=function_values;
					offset10=number_of_polygon_verticies*number_of_values;
					offset01=2*offset10;
					offset11=3*offset10;
					for (j=offset00;j>0;j--)
					{
						*temp_value=0;
						temp_value[offset10]=0;
						temp_value[offset01]=0;
						temp_value[offset11]=0;
						temp_value++;
					}
					temp_value += number_of_values;
					for (j=(number_of_polygon_verticies-polygon_vertex-1)*
						number_of_values;j>0;j--)
					{
						*temp_value=0;
						temp_value[offset10]=0;
						temp_value[offset01]=0;
						temp_value[offset11]=0;
						temp_value++;
					}
					number_of_values *= 4*number_of_polygon_verticies;
					value=function_values+(number_of_values-1);
				}
			}
			else
			{
				/* not polygon */
				xi_power=xi;
				for (j=order;j>0;j--)
				{
					temp_value=function_values;
					for (k=number_of_values;k>0;k--)
					{
						value++;
						*value=(*temp_value)*xi_power;
						temp_value++;
					}
					xi_power *= xi;
				}
				number_of_values *= (order+1);
			}
			xi_coordinate++;
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"polygon_basis_functions.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* polygon_basis_functions */

struct FE_element_field_lists_merge_data
/*******************************************************************************
LAST MODIFIED : 5 October 1998

DESCRIPTION :
The data needed to merge an element_field into the list.  This structure is
local to this module.
==============================================================================*/
{
	struct LIST(FE_element_field) *list;
	Value_storage **values_storage_address;
	int *values_storage_size_address;

	/* new field information */
	Value_storage *new_values_storage;
	int new_number_of_nodes,new_number_of_scale_factors,
		new_number_of_scale_factor_sets,*new_numbers_in_scale_factor_sets;
	struct FE_node **new_nodes;
	void **new_scale_factor_set_identifiers;

	/* merged field information */
	int number_of_nodes,number_of_scale_factors,number_of_scale_factor_sets,
		*numbers_in_scale_factor_sets;
	struct FE_node **nodes;
	void **scale_factor_set_identifiers;
}; /* struct FE_element_field_lists_merge_data */

static int merge_FE_element_field_into_list(
	struct FE_element_field *new_element_field,void *merge_data)
/*******************************************************************************
LAST MODIFIED : 18 November 1999

DESCRIPTION :
Merges the <element_field> into the <list>.
==============================================================================*/
{
	int i,j,k,l,m,*new_number_in_scale_factor_set,*new_number_in_xi,
		*new_scale_factor_index,*new_value_index,new_values_storage_size,node_index,
		*number_in_scale_factor_set,*number_in_xi,number_of_values,return_code,
		*scale_factor_index,start_new_scale_factor_set,start_scale_factor_set,
		*value_index;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component,**new_component;
	struct FE_element_field_lists_merge_data *merge;
	struct FE_node *new_node,**node;
	struct General_node_to_element_map **new_general_node_map,**general_node_map;
	struct Linear_combination_of_global_values **element_value,
		**new_element_value;
	struct Standard_node_to_element_map **new_standard_node_map,
		**standard_node_map;
	void **new_scale_factor_set_identifier,**scale_factor_set_identifier;
	Value_storage *new_values_storage,*values_storage;

	ENTER(merge_FE_element_field_into_list);
	if (new_element_field&&(new_element_field->field)&&
		(merge=(struct FE_element_field_lists_merge_data *)merge_data))
	{
		return_code=1;
		/* check if the new element field is in the existing list */
		if (element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			new_element_field->field,merge->list))
		{
			/* only GENERAL_FE_FIELD has components to check for merge */
			if (GENERAL_FE_FIELD==new_element_field->field->fe_field_type)
			{
				/* check the new element field for consistency */
				if ((component=element_field->components)&&
					(new_component=new_element_field->components))
				{
					/* check each component */
					i=new_element_field->field->number_of_components;
					while (return_code&&(i>0))
					{
						if ((*component)&&(*new_component)&&
							((*component)->type==(*new_component)->type)&&
							((*component)->basis==(*new_component)->basis)&&
							((*component)->modify==(*new_component)->modify))
						{
							switch ((*component)->type)
							{
								case STANDARD_NODE_TO_ELEMENT_MAP:
								{
									if (((j=(*component)->map.standard_node_based.
										number_of_nodes)==(*new_component)->map.
										standard_node_based.number_of_nodes)&&
										(standard_node_map=(*component)->map.
											standard_node_based.node_to_element_maps)&&
										(new_standard_node_map=(*new_component)->map.
											standard_node_based.node_to_element_maps))
									{
										/* check each standard node to element map */
										while (return_code&&(j>0))
										{
											if ((*standard_node_map)&&(*new_standard_node_map)&&
												((merge->nodes)[(*standard_node_map)->node_index]==
													(merge->new_nodes)[(*standard_node_map)->node_index])&&
												((k=(*standard_node_map)->number_of_nodal_values)==
													(*new_standard_node_map)->number_of_nodal_values)&&
												(value_index=(*standard_node_map)->
													nodal_value_indices)&&(new_value_index=
														(*new_standard_node_map)->nodal_value_indices)&&
												(scale_factor_index=(*standard_node_map)->
													scale_factor_indices)&&(new_scale_factor_index=
														(*new_standard_node_map)->scale_factor_indices))
											{
												/* determine the merged scale factor set */
												start_scale_factor_set=0;
												l=merge->number_of_scale_factor_sets;
												number_in_scale_factor_set=
													merge->numbers_in_scale_factor_sets;
												scale_factor_set_identifier=
													merge->scale_factor_set_identifiers;
												while ((l>0)&&(*scale_factor_index>=
													start_scale_factor_set+
													(*number_in_scale_factor_set)))
												{
													start_scale_factor_set +=
														*number_in_scale_factor_set;
													scale_factor_set_identifier++;
													number_in_scale_factor_set++;
													l--;
												}
												/* determine the new scale factor set */
												start_new_scale_factor_set=0;
												l=merge->new_number_of_scale_factor_sets;
												new_number_in_scale_factor_set=
													merge->new_numbers_in_scale_factor_sets;
												new_scale_factor_set_identifier=
													merge->new_scale_factor_set_identifiers;
												while ((l>0)&&(*new_scale_factor_index>=
													start_new_scale_factor_set+
													(*new_number_in_scale_factor_set)))
												{
													start_new_scale_factor_set +=
														*new_number_in_scale_factor_set;
													new_scale_factor_set_identifier++;
													new_number_in_scale_factor_set++;
													l--;
												}
												if ((*scale_factor_set_identifier==
													*new_scale_factor_set_identifier)&&
													(*number_in_scale_factor_set==
														*new_number_in_scale_factor_set))
												{
													while (return_code&&(k>0)&&
														(*value_index== *new_value_index)&&
														((*scale_factor_index)-start_scale_factor_set==
															(*new_scale_factor_index)-
															start_new_scale_factor_set))
													{
														value_index++;
														new_value_index++;
														scale_factor_index++;
														new_scale_factor_index++;
														k--;
													}
													if (k<=0)
													{
														standard_node_map++;
														new_standard_node_map++;
														j--;
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"merge_FE_element_field_into_list.  Invalid standard node to element map");
														return_code=0;
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  Inconsistent scale factor sets");
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"merge_FE_element_field_into_list.  Inconsistent global to element map");
												return_code=0;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  Invalid global to element map");
										return_code=0;
									}
								} break;
								case GENERAL_NODE_TO_ELEMENT_MAP:
								{
									if (((j=(*component)->map.general_node_based.
										number_of_nodes)==(*new_component)->map.
										general_node_based.number_of_nodes)&&(general_node_map=
											(*component)->map.general_node_based.
											node_to_element_maps)&&(new_general_node_map=
												(*new_component)->map.general_node_based.
												node_to_element_maps))
									{
										/* check each general node to element map */
										while (return_code&&(j>0))
										{
											if ((*general_node_map)&&(*new_general_node_map)&&
												((merge->nodes)[(*general_node_map)->node_index]==
													(merge->new_nodes)[(*general_node_map)->node_index])&&
												((k=(*general_node_map)->number_of_nodal_values)==
													(*new_general_node_map)->number_of_nodal_values)&&
												(element_value=(*general_node_map)->element_values)&&
												(new_element_value=(*new_general_node_map)->
													element_values))
											{
												while (return_code&&(k>0))
												{
													if ((*element_value)&&(*new_element_value)&&
														((l=(*element_value)->number_of_global_values)==
															(*new_element_value)->number_of_global_values)&&
														(value_index=(*element_value)->
															global_value_indices)&&(new_value_index=
																(*new_element_value)->global_value_indices)&&
														(scale_factor_index=(*element_value)->
															coefficient_indices)&&(new_scale_factor_index=
																(*new_element_value)->coefficient_indices))
													{
														/* determine the element scale factor set */
														start_scale_factor_set=0;
														m=merge->number_of_scale_factor_sets;
														number_in_scale_factor_set=
															merge->numbers_in_scale_factor_sets;
														scale_factor_set_identifier=
															merge->scale_factor_set_identifiers;
														while ((m>0)&&(*scale_factor_index>=
															start_scale_factor_set+
															(*number_in_scale_factor_set)))
														{
															start_scale_factor_set +=
																*number_in_scale_factor_set;
															scale_factor_set_identifier++;
															number_in_scale_factor_set++;
															m--;
														}
														/* determine the new scale factor set */
														start_new_scale_factor_set=0;
														m=merge->new_number_of_scale_factor_sets;
														new_number_in_scale_factor_set=
															merge->new_numbers_in_scale_factor_sets;
														new_scale_factor_set_identifier=
															merge->new_scale_factor_set_identifiers;
														while ((m>0)&&(*new_scale_factor_index>=
															start_new_scale_factor_set+
															(*new_number_in_scale_factor_set)))
														{
															start_new_scale_factor_set +=
																*new_number_in_scale_factor_set;
															new_scale_factor_set_identifier++;
															new_number_in_scale_factor_set++;
															m--;
														}
														if ((*scale_factor_set_identifier==
															*new_scale_factor_set_identifier)&&
															(*number_in_scale_factor_set==
																*new_number_in_scale_factor_set))
														{
															while (return_code&&(l>0)&&
																(*value_index== *new_value_index)&&
																((*scale_factor_index)-
																	start_scale_factor_set==
																	(*new_scale_factor_index)-
																	start_new_scale_factor_set))
															{
																value_index++;
																new_value_index++;
																scale_factor_index++;
																new_scale_factor_index++;
																l--;
															}
															if (l<=0)
															{
																element_value++;
																new_element_value++;
																k--;
															}
															else
															{
																display_message(ERROR_MESSAGE,
																	"merge_FE_element_field_into_list.  Invalid general node to element map");
																return_code=0;
															}
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"merge_FE_element_field_into_list.  Inconsistent scale factor sets");
															return_code=0;
														}
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"merge_FE_element_field_into_list.  Inconsistent global to element map");
														return_code=0;
													}
												}
												standard_node_map++;
												new_standard_node_map++;
												j--;
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"merge_FE_element_field_into_list.  Inconsistent global to element map");
												return_code=0;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  Invalid global to element map");
										return_code=0;
									}
								} break;
								case FIELD_TO_ELEMENT_MAP:
								{
									if (((j=(*component)->map.field_based.
										number_of_element_values)==(*new_component)->map.
										field_based.number_of_element_values)&&(element_value=
											(*component)->map.field_based.element_values)&&
										(new_element_value=(*new_component)->map.field_based.
											element_values))
									{
										/* check each field to element map */
										while (return_code&&(j>0))
										{
											if ((*element_value)&&(*new_element_value)&&
												((k=(*element_value)->number_of_global_values)==
													(*new_element_value)->number_of_global_values)&&
												(value_index=(*element_value)->
													global_value_indices)&&(new_value_index=
														(*new_element_value)->global_value_indices)&&
												(scale_factor_index=(*element_value)->
													coefficient_indices)&&(new_scale_factor_index=
														(*new_element_value)->coefficient_indices))
											{
												while (return_code&&(k>0)&&
													(*value_index== *new_value_index)&&
													(*scale_factor_index== *new_scale_factor_index))
												{
													value_index++;
													new_value_index++;
													scale_factor_index++;
													new_scale_factor_index++;
													k--;
												}
												if (k<=0)
												{
													element_value++;
													new_element_value++;
													j--;
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  Invalid field to element map");
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"merge_FE_element_field_into_list.  Inconsistent global to element map");
												return_code=0;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  Invalid global to element map");
										return_code=0;
									}
								} break;
								case ELEMENT_GRID_MAP:
								{
									number_in_xi=
										((*component)->map).element_grid_based.number_in_xi;
									new_number_in_xi=
										((*new_component)->map).element_grid_based.number_in_xi;
									j=((*component)->basis->type)[0];
									number_of_values=1;
									while ((j>0)&&(*number_in_xi== *new_number_in_xi))
									{
										number_of_values *= (*number_in_xi)+1;
										j--;
										number_in_xi++;
										new_number_in_xi++;
									}
									if (j<=0)
									{
										/* copy the values_storage for the grid values, first freeing
											 any dynamic allocations and accesses in existing storage */
										values_storage = (*(merge->values_storage_address))+
											(((*component)->map).element_grid_based.value_index);
										new_values_storage=(merge->new_values_storage)+
											(((*new_component)->map).element_grid_based.value_index);
										free_value_storage_array(values_storage,
											new_element_field->field->value_type,number_of_values);
										copy_value_storage_array(values_storage,
											new_element_field->field->value_type,number_of_values,
											new_values_storage);
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  Inconsistent grids");
										return_code=0;
									}
								} break;
								default:
								{
									display_message(ERROR_MESSAGE,
										"merge_FE_element_field_into_list.  Invalid global to element map type");
									return_code=0;
								} break;
							}
							component++;
							new_component++;
							i--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_element_field_into_list.  Inconsistent element field components");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"merge_FE_element_field_into_list.  Invalid element field");
					return_code=0;
				}
			}
		}
		else
		{
			/* add the new element field */
			if (element_field=CREATE(FE_element_field)(new_element_field->field))
			{
				/* only GENERAL_FE_FIELD has components to copy for merge */
				if (GENERAL_FE_FIELD==new_element_field->field->fe_field_type)
				{
					new_component=new_element_field->components;
					i=new_element_field->field->number_of_components;
					component=element_field->components;
					while (return_code&&(i>0))
					{
						if ((*new_component)&&((*new_component)->basis))
						{
							switch ((*new_component)->type)
							{
								case STANDARD_NODE_TO_ELEMENT_MAP:
								{
									if ((new_standard_node_map=(*new_component)->map.
										standard_node_based.node_to_element_maps)&&
										((j=(*new_component)->map.standard_node_based.
											number_of_nodes)>0)&&
										(*component=CREATE(FE_element_field_component)(
											STANDARD_NODE_TO_ELEMENT_MAP,j,(*new_component)->basis,
											(*new_component)->modify)))
									{
										standard_node_map=(*component)->map.standard_node_based.
											node_to_element_maps;
										while (return_code&&(j>0))
										{
											if ((*new_standard_node_map)&&
												((k=(*new_standard_node_map)->
													number_of_nodal_values)>0)&&(new_value_index=
														(*new_standard_node_map)->nodal_value_indices)&&
												(new_scale_factor_index=(*new_standard_node_map)->
													scale_factor_indices))
											{
												/* determine the node index */
												node=merge->nodes;
												new_node=(merge->new_nodes)[(*new_standard_node_map)->
													node_index];
												/*???RC since using this function in
													define_FE_field_at_element, have to handle case of
													NULL nodes just by using existing node_index */
												if (new_node)
												{
													node_index=0;
													while ((node_index<merge->number_of_nodes)&&
														(*node!=new_node))
													{
														node_index++;
														node++;
													}
												}
												else
												{
													node_index=(*new_standard_node_map)->node_index;
												}
												/* determine the new scale factor set */
												start_new_scale_factor_set=0;
												l=merge->new_number_of_scale_factor_sets;
												new_number_in_scale_factor_set=
													merge->new_numbers_in_scale_factor_sets;
												new_scale_factor_set_identifier=
													merge->new_scale_factor_set_identifiers;
												while ((l>0)&&(*new_scale_factor_index>=
													start_new_scale_factor_set+
													(*new_number_in_scale_factor_set)))
												{
													start_new_scale_factor_set +=
														*new_number_in_scale_factor_set;
													new_scale_factor_set_identifier++;
													new_number_in_scale_factor_set++;
													l--;
												}
												/* determine the element scale factor set */
												start_scale_factor_set=0;
												l=merge->number_of_scale_factor_sets;
												number_in_scale_factor_set=
													merge->numbers_in_scale_factor_sets;
												scale_factor_set_identifier=
													merge->scale_factor_set_identifiers;
												while ((l>0)&&(*scale_factor_set_identifier!=
													*new_scale_factor_set_identifier))
												{
													start_scale_factor_set +=
														*number_in_scale_factor_set;
													scale_factor_set_identifier++;
													number_in_scale_factor_set++;
													l--;
												}
												if ((*node==new_node)&&
													((!number_in_scale_factor_set)||(
														(*scale_factor_set_identifier==
															*new_scale_factor_set_identifier)&&
														(*number_in_scale_factor_set==
															*new_number_in_scale_factor_set)))&&
													(*standard_node_map=
														CREATE(Standard_node_to_element_map)(node_index,k)))
												{
													value_index=(*standard_node_map)->
														nodal_value_indices;
													scale_factor_index=
														(*standard_node_map)->scale_factor_indices;
													l=start_scale_factor_set-
														start_new_scale_factor_set;
													while (k>0)
													{
														*value_index= *new_value_index;
														*scale_factor_index=(*new_scale_factor_index)+l;
														value_index++;
														new_value_index++;
														scale_factor_index++;
														new_scale_factor_index++;
														k--;
													}
													standard_node_map++;
													new_standard_node_map++;
													j--;
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  "
														"Invalid node or scale factor information");
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"merge_FE_element_field_into_list.  "
													"Invalid standard node to element map");
												return_code=0;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  "
											"Could not create element field component");
										return_code=0;
									}
								} break;
								case GENERAL_NODE_TO_ELEMENT_MAP:
								{
									if ((new_general_node_map=(*new_component)->map.
										general_node_based.node_to_element_maps)&&
										((j=(*new_component)->map.general_node_based.
											number_of_nodes)>0)&&
										(*component=CREATE(FE_element_field_component)(
											GENERAL_NODE_TO_ELEMENT_MAP,j,(*new_component)->basis,
											(*new_component)->modify)))
									{
										general_node_map=(*component)->map.general_node_based.
											node_to_element_maps;
										while (return_code&&(j>0))
										{
											if ((*new_general_node_map)&&
												((k=(*new_general_node_map)->
													number_of_nodal_values)>0)&&(new_element_value=
														(*new_general_node_map)->element_values))
											{
												/* determine the node index */
												node=merge->nodes;
												new_node=(merge->new_nodes)[(*new_general_node_map)->
													node_index];
												node_index=0;
												while ((node_index<merge->number_of_nodes)&&
													(*node!=new_node))
												{
													node_index++;
													node++;
												}
												if ((*node==new_node)&&(*general_node_map=CREATE(
													General_node_to_element_map)(node_index,k)))
												{
													element_value=(*general_node_map)->element_values;
													while (return_code&&(k>0))
													{
														if ((*new_element_value)&&
															((l=(*new_element_value)->
																number_of_global_values)>0)&&(new_value_index=
																	(*new_element_value)->global_value_indices)&&
															(new_scale_factor_index=(*new_element_value)->
																coefficient_indices)&&(*element_value=CREATE(
																	Linear_combination_of_global_values)(l)))
														{
															value_index=(*element_value)->
																global_value_indices;
															scale_factor_index=
																(*element_value)->coefficient_indices;
															/* determine the new scale factor set */
															start_new_scale_factor_set=0;
															m=merge->new_number_of_scale_factor_sets;
															new_number_in_scale_factor_set=
																merge->new_numbers_in_scale_factor_sets;
															new_scale_factor_set_identifier=
																merge->new_scale_factor_set_identifiers;
															while ((m>0)&&(*new_scale_factor_index>=
																start_new_scale_factor_set+
																(*new_number_in_scale_factor_set)))
															{
																start_new_scale_factor_set +=
																	*new_number_in_scale_factor_set;
																new_scale_factor_set_identifier++;
																new_number_in_scale_factor_set++;
																m--;
															}
															/* determine the element scale factor set */
															start_scale_factor_set=0;
															m=merge->number_of_scale_factor_sets;
															number_in_scale_factor_set=
																merge->numbers_in_scale_factor_sets;
															scale_factor_set_identifier=
																merge->scale_factor_set_identifiers;
															while ((m>0)&&(*scale_factor_set_identifier!=
																*new_scale_factor_set_identifier))
															{
																start_scale_factor_set +=
																	*number_in_scale_factor_set;
																scale_factor_set_identifier++;
																number_in_scale_factor_set++;
																m--;
															}
															if ((*scale_factor_set_identifier==
																*new_scale_factor_set_identifier)&&
																(*number_in_scale_factor_set==
																	*new_number_in_scale_factor_set))
															{
																m=start_scale_factor_set-
																	start_new_scale_factor_set;
																while (l>0)
																{
																	*value_index= *new_value_index;
																	*scale_factor_index=
																		(*new_scale_factor_index)+m;
																	value_index++;
																	new_value_index++;
																	scale_factor_index++;
																	new_scale_factor_index++;
																	l--;
																}
																element_value++;
																new_element_value++;
																k--;
															}
															else
															{
																display_message(ERROR_MESSAGE,
																	"merge_FE_element_field_into_list.  "
																	"Invalid scale factor set");
																return_code=0;
															}
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"merge_FE_element_field_into_list.  "
																"Could not create linear combination");
															return_code=0;
														}
													}
													if (return_code)
													{
														general_node_map++;
														new_general_node_map++;
														j--;
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  "
														"Could not create general node to element map");
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"merge_FE_element_field_into_list.  "
													"Invalid general node to element map");
												return_code=0;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  "
											"Could not create element field component");
										return_code=0;
									}
								} break;
								case FIELD_TO_ELEMENT_MAP:
								{
									if ((new_element_value=(*new_component)->map.field_based.
										element_values)&&((j=(*new_component)->map.field_based.
											number_of_element_values)>0)&&(*component=CREATE(
												FE_element_field_component)(FIELD_TO_ELEMENT_MAP,j,
													(*new_component)->basis,(*new_component)->modify)))
									{
										element_value=(*general_node_map)->element_values;
										while (return_code&&(j>0))
										{
											if ((*new_element_value)&&((k=(*new_element_value)->
												number_of_global_values)>0)&&(new_value_index=
													(*new_element_value)->global_value_indices)&&
												(new_scale_factor_index=(*new_element_value)->
													coefficient_indices)&&(*element_value=
														CREATE(Linear_combination_of_global_values)(k)))
											{
												value_index=(*element_value)->global_value_indices;
												scale_factor_index=(*element_value)->
													coefficient_indices;
												/* determine the new scale factor set */
												start_new_scale_factor_set=0;
												l=merge->new_number_of_scale_factor_sets;
												new_number_in_scale_factor_set=
													merge->new_numbers_in_scale_factor_sets;
												new_scale_factor_set_identifier=
													merge->new_scale_factor_set_identifiers;
												while ((l>0)&&(*new_scale_factor_index>=
													start_new_scale_factor_set+
													(*new_number_in_scale_factor_set)))
												{
													start_new_scale_factor_set +=
														*new_number_in_scale_factor_set;
													new_scale_factor_set_identifier++;
													new_number_in_scale_factor_set++;
													l--;
												}
												/* determine the element scale factor set */
												start_scale_factor_set=0;
												l=merge->number_of_scale_factor_sets;
												number_in_scale_factor_set=
													merge->numbers_in_scale_factor_sets;
												scale_factor_set_identifier=
													merge->scale_factor_set_identifiers;
												while ((m>0)&&(*scale_factor_set_identifier!=
													*new_scale_factor_set_identifier))
												{
													start_scale_factor_set +=
														*number_in_scale_factor_set;
													scale_factor_set_identifier++;
													number_in_scale_factor_set++;
													l--;
												}
												if ((*scale_factor_set_identifier==
													*new_scale_factor_set_identifier)&&
													(*number_in_scale_factor_set==
														*new_number_in_scale_factor_set))
												{
													l=start_scale_factor_set-
														start_new_scale_factor_set;
													while (k>0)
													{
														*value_index= *new_value_index;
														*scale_factor_index=
															(*new_scale_factor_index)+m;
														value_index++;
														new_value_index++;
														scale_factor_index++;
														new_scale_factor_index++;
														k--;
													}
													element_value++;
													new_element_value++;
													j--;
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  "
														"Invalid scale factor set");
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"merge_FE_element_field_into_list.  "
													"Could not create field to element map");
												return_code=0;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  "
											"Could not create element field component");
										return_code=0;
									}
								} break;
								case ELEMENT_GRID_MAP:
								{
									int size;

									if (*component=CREATE(FE_element_field_component)(
										ELEMENT_GRID_MAP,1,(*new_component)->basis,
										(*new_component)->modify))
									{
										number_in_xi=
											((*component)->map).element_grid_based.number_in_xi;
										new_number_in_xi=
											((*new_component)->map).element_grid_based.number_in_xi;
										number_of_values=1;
										for (j=((*component)->basis->type)[0];j>0;j--)
										{
											*number_in_xi= *new_number_in_xi;
											number_of_values *= (*number_in_xi)+1;
											number_in_xi++;
											new_number_in_xi++;
										}
										size=get_Value_storage_size(
											new_element_field->field->value_type);
										new_values_storage_size=size*number_of_values;
										ADJUST_VALUE_STORAGE_SIZE(new_values_storage_size);
										if (REALLOCATE(values_storage,
											*(merge->values_storage_address),Value_storage,
											(*(merge->values_storage_size_address))+
											new_values_storage_size))
										{
											((*component)->map).element_grid_based.value_index=
												*(merge->values_storage_size_address);
											*(merge->values_storage_address)=values_storage;
											values_storage += *(merge->values_storage_size_address);
											*(merge->values_storage_size_address) +=
												new_values_storage_size;
											new_values_storage=(merge->new_values_storage)+
												(((*new_component)->map).element_grid_based.value_index);
											/* copy new_values_storage into values_storage */
											copy_value_storage_array(values_storage,
												new_element_field->field->value_type,number_of_values,
												new_values_storage);
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"merge_FE_element_field_into_list.  "
												"Could not reallocate merged values_storage");
											return_code=0;
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  "
											"Could not create element field component");
										return_code=0;
									}
								} break;
								default:
								{
									display_message(ERROR_MESSAGE,
										"merge_FE_element_field_into_list.  "
										"Invalid global to element map type");
									return_code=0;
								} break;
							}
							component++;
							new_component++;
							i--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_element_field_into_list.  "
								"Invalid element field component");
							return_code=0;
						}
					}
				}
				if (!return_code||!ADD_OBJECT_TO_LIST(FE_element_field)(element_field,
					merge->list))
				{
					display_message(ERROR_MESSAGE,"merge_FE_element_field_into_list.  "
						"Could not add element field to list");
					return_code=0;
					DESTROY(FE_element_field)(&element_field);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"merge_FE_element_field_into_list.  Could not create element field");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_element_field_into_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_element_field_into_list */

static int merge_FE_element_field_lists(
	struct LIST(FE_element_field) *new_list,Value_storage *new_values_storage,
	int new_number_of_nodes,struct FE_node **new_nodes,
	int new_number_of_scale_factor_sets,void **new_scale_factor_set_identifiers,
	int *new_numbers_in_scale_factor_sets,int new_number_of_scale_factors,
	struct LIST(FE_element_field) *list,int number_of_nodes,
	struct FE_node **nodes,int number_of_scale_factor_sets,
	void **scale_factor_set_identifiers,int *numbers_in_scale_factor_sets,
	int number_of_scale_factors,int *values_storage_size_address,
	Value_storage **values_storage_address,
	struct LIST(FE_element_field) **merged_list_address)
/*******************************************************************************
LAST MODIFIED : 30 September 1999

DESCRIPTION :
Merges the <new_list> with the existing <list> to create a new list
(*merged_list_address).
???RC Changed to allow no scale factor sets.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_lists_merge_data merge;

	ENTER(merge_FE_element_field_lists);
	if ((((0==new_number_of_nodes)&&!new_nodes)||
		((0<new_number_of_nodes)&&new_nodes))&&
		(((0==new_number_of_scale_factor_sets)&&!new_scale_factor_set_identifiers&&
			!new_numbers_in_scale_factor_sets&&(0==new_number_of_scale_factors))||
			((0<new_number_of_scale_factor_sets)&&new_scale_factor_set_identifiers&&
				new_numbers_in_scale_factor_sets&&(0<new_number_of_scale_factors)))&&
		(((0==number_of_nodes)&&!nodes)||((0<number_of_nodes)&&nodes))&&
		(((0==number_of_scale_factor_sets)&&!scale_factor_set_identifiers&&
			!numbers_in_scale_factor_sets&&(0==number_of_scale_factors))||
			((0<number_of_scale_factor_sets)&&scale_factor_set_identifiers&&
				numbers_in_scale_factor_sets&&(0<number_of_scale_factors)))&&
		values_storage_size_address&&values_storage_address&&list&&new_list&&
		merged_list_address)
	{
		merge.new_values_storage=new_values_storage;
		merge.new_number_of_nodes=new_number_of_nodes;
		merge.new_nodes=new_nodes;
		merge.new_number_of_scale_factor_sets=new_number_of_scale_factor_sets;
		merge.new_scale_factor_set_identifiers=new_scale_factor_set_identifiers;
		merge.new_numbers_in_scale_factor_sets=new_numbers_in_scale_factor_sets;
		merge.new_number_of_scale_factors=new_number_of_scale_factors;
		merge.number_of_nodes=number_of_nodes;
		merge.nodes=nodes;
		merge.number_of_scale_factor_sets=number_of_scale_factor_sets;
		merge.scale_factor_set_identifiers=scale_factor_set_identifiers;
		merge.numbers_in_scale_factor_sets=numbers_in_scale_factor_sets;
		merge.number_of_scale_factors=number_of_scale_factors;
		merge.values_storage_size_address=values_storage_size_address;
		merge.values_storage_address=values_storage_address;
		/* duplicate the existing list */
		if ((merge.list=CREATE_LIST(FE_element_field)())&&
			(COPY_LIST(FE_element_field)(merge.list,list)))
		{
			/* merge the new element field list */
			if (return_code=FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				merge_FE_element_field_into_list,(void *)(&merge),new_list))
			{
				*merged_list_address=merge.list;
			}
			else
			{
				DESTROY_LIST(FE_element_field)(&(merge.list));
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"merge_FE_element_field_lists.  Could not duplicate existing list");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_element_field_lists.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_element_field_lists */

static int check_FE_element_field_dimension(
	struct FE_element_field *element_field,void *dimension_address)
/*******************************************************************************
LAST MODIFIED : 2 October 1995

DESCRIPTION :
Checks that the <element_field> has the specified dimension.
==============================================================================*/
{
	int dimension,i,return_code;
	struct FE_element_field_component **component;

	ENTER(check_FE_element_field_dimension);
	/* check the arguments */
	if (element_field&&(element_field->field)&&
		(component=element_field->components)&&dimension_address)
	{
		dimension= *(int *)dimension_address;
		return_code=1;
		i=element_field->field->number_of_components;
		while (return_code&&(i>0))
		{
			if ((*component)&&((*component)->basis)&&
				(dimension== *((*component)->basis->type)))
			{
				i--;
				component++;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"check_FE_element_field_dimension.  Inconsistent element field");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"check_FE_element_field_dimension.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* check_FE_element_field_dimension */

static int count_nodal_values(struct FE_node_field *node_field,
	void *number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 12 April 1996

DESCRIPTION :
Increases the <number_of_nodal_values> by the number of values for <node_field>.
==============================================================================*/
{
	int i,*number_of_values,return_code;
	struct FE_node_field_component *component;

	ENTER(count_nodal_values);
	/* check arguments */
	if (node_field&&(node_field->field)&&(component=node_field->components)&&
		(number_of_values=(int *)number_of_nodal_values))
	{
		i=node_field->field->number_of_components;
		while (i>0)
		{
			*number_of_values += (component->number_of_versions)*
				((component->number_of_derivatives)+1);
			component++;
			i--;
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"count_nodal_values.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* count_nodal_values */

static int count_nodal_size(struct FE_node_field *node_field,
	void *number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 26 October 1999

DESCRIPTION :
Increases the <number_of_nodal_values> by the number of values for <node_field>
times the size of <node_field->field->value_type> .
==============================================================================*/
{
	int i,*number_of_values,return_code,size,this_values_storage_size;
	struct FE_node_field_component *component;

	ENTER(count_nodal_values);
	/* check arguments */
	if (node_field&&(node_field->field)&&(component=node_field->components)&&
		(number_of_values=(int *)number_of_nodal_values))
	{
		size=get_Value_storage_size(node_field->field->value_type);
		this_values_storage_size=0;
		for (i=node_field->field->number_of_components;0<i;i--)
		{
			this_values_storage_size += ((component->number_of_versions)*
				((component->number_of_derivatives)+1))*size;
			component++;
		}
		ADJUST_VALUE_STORAGE_SIZE(this_values_storage_size);
		*number_of_values += this_values_storage_size;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"count_nodal_size.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* count_nodal_size */

struct Merge_FE_node_field_into_list_data
{
	char changed_node;
	int values_size; 
	int number_of_values;
	struct LIST(FE_node_field) *list;
}; /* struct Merge_FE_node_field_into_list_data */

static int merge_FE_node_field_into_list(struct FE_node_field *node_field,
	void *merge_FE_node_field_into_list_data)
/*******************************************************************************
LAST MODIFIED : 26 October 1999

DESCRIPTION :
Merges the <node_field> into the list.
==============================================================================*/
{
	int i,j,new_values_storage_size,return_code,size,this_number_of_values;
	struct FE_field *field;
	struct FE_node_field *existing_node_field,*new_node_field;
	struct FE_node_field_component *component,*existing_component,*new_component;
	struct Merge_FE_node_field_into_list_data *merge_data;

	ENTER(merge_FE_node_field_into_list);
	if (node_field&&(field=node_field->field)&&
		(merge_data=(struct Merge_FE_node_field_into_list_data *)
		merge_FE_node_field_into_list_data))
	{
		/* check if the node field is in the list */
		if (existing_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,
			field)(field,merge_data->list))
		{
			/* the node field is already in the list */
			/* check that the components agree */
				/*???DB.  Check names ? */
			if ((component=node_field->components)&&
				(existing_component=existing_node_field->components))
			{
				i=field->number_of_components;
				return_code=1;
				while (return_code&&(i>0))
				{
					if ((component->number_of_derivatives==
						existing_component->number_of_derivatives)&&
						(component->number_of_versions==
						existing_component->number_of_versions))
					{
						component++;
						existing_component++;
						i--;
					}
					else
					{
						return_code=0;
					}
				}
			}
			else
			{
				return_code=0;
			}
		}
		else
		{
			/* the node field is not already in the list */
			/* create a new node field with modified offsets */
			if ((component=node_field->components)&&
				(new_node_field=CREATE(FE_node_field)(field)))
			{
				size=get_Value_storage_size(field->value_type);
				new_component=new_node_field->components;
				i=field->number_of_components;
				return_code=1;
				new_values_storage_size=0;
				while (return_code&&(i>0))
				{
					new_component->value=merge_data->values_size+new_values_storage_size;
					new_component->number_of_derivatives=component->number_of_derivatives;
					new_component->number_of_versions=component->number_of_versions;
					this_number_of_values=((component->number_of_versions)*
						((component->number_of_derivatives)+1));
					new_values_storage_size += this_number_of_values*size;
					merge_data->number_of_values += this_number_of_values;
					if (component->nodal_value_types)
					{
						/* assign nodal value names */
						if (ALLOCATE(new_component->nodal_value_types,
							enum FE_nodal_value_type,new_component->number_of_derivatives+1))
						{
							for (j=new_component->number_of_derivatives;j>=0;j--)
							{
								(new_component->nodal_value_types)[j]=
									(component->nodal_value_types)[j];
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_node_field_into_list.  "
								"Could not allocate memory for nodal value types");
						}
					}
					component++;
					new_component++;
					i--;
				}
				if (return_code)
				{
					ADJUST_VALUE_STORAGE_SIZE(new_values_storage_size);
					merge_data->values_size += new_values_storage_size;
					/* add the new node field to the list */
					if (ADD_OBJECT_TO_LIST(FE_node_field)(new_node_field,
						merge_data->list))
					{
						merge_data->changed_node=1;
					}
					else
					{
						return_code=0;
						DESTROY(FE_node_field)(&new_node_field);
					}
				}
				else
				{
					DESTROY(FE_node_field)(&new_node_field);
				}
			}
			else
			{
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_node_field_into_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_node_field_into_list */

struct Place_nodal_values_data
{
	Value_storage *destination_values,*source_values;
	struct LIST(FE_node_field) *list;
}; /* struct Place_nodal_values_data */

static int place_nodal_values(struct FE_node_field *node_field,
	void *place_nodal_values_data)
/*******************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION :
Transfers the nodal values associated with the <node_field> from the source to
the destination.
NOTE: For array types, doesn't copy the array, just the number of array values and
the pointer to the array.
==============================================================================*/
{
	Value_storage *new_value,*value;
	int i,j,k,return_code,size;
	struct FE_field *field;
	struct FE_node_field *new_node_field;
	struct Place_nodal_values_data *place_data;
	struct FE_node_field_component *component,*new_component;

	ENTER(place_nodal_values);
	/* check arguments */
	if (node_field&&(field=node_field->field)&&
		(place_data=(struct Place_nodal_values_data *)place_nodal_values_data))
	{
		if (new_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,place_data->list))
		{
			if ((component=node_field->components)&&
				(new_component=new_node_field->components))
			{
				i=field->number_of_components;
				size = get_Value_storage_size(field->value_type);
				while (i>0)
				{
					value=(place_data->source_values)+(component->value);
					new_value=(place_data->destination_values)+(new_component->value);

					for (j=(component->number_of_versions)*
						(1+component->number_of_derivatives);j>0;j--)
					{
						switch(field->value_type)
						{
							case DOUBLE_VALUE:
							{
								printf("new_value = %p   value = %p   (%g)\n",new_value,value,*((double *)value));
								*((double *)new_value) = *((double *)value);
							} break;
							case ELEMENT_XI_VALUE:
							{
								Value_storage *value_source, *value_destination;
								
								value_source = value;
								value_destination = new_value;
								*((struct FE_element **)(value_destination)) = 
									*((struct FE_element **)(value_source));
								value_source += sizeof(struct FE_element *);
								value_destination += sizeof(struct FE_element *);
								for(k = 0 ; k < MAXIMUM_ELEMENT_XI_DIMENSIONS ; k++)
								{
									*((FE_value *)value_destination) = *((FE_value *)value_source);
									value_source += sizeof(FE_value);
									value_destination += sizeof(FE_value);
								}
							} break;
							case FE_VALUE_VALUE:
							{
								*((FE_value *)new_value) = *((FE_value *)value);
							} break;
							case FLT_VALUE:
							{
								*((float *)new_value) = *((float *)value);
							} break;	
							case SHORT_VALUE:
							{
								display_message(ERROR_MESSAGE,"place_nodal_values. SHORT_VALUE."
									" Haven't written code yet. Beware pointer alignment problems");
								return_code =0;
							} break;
							case INT_VALUE:
							{
								*((int *)new_value) = *((int *)value);
							} break;	
							case UNSIGNED_VALUE:
							{
								*((unsigned *)new_value) = *((unsigned *)value);
							} break;
							case DOUBLE_ARRAY_VALUE:						
							{
								*((int *)new_value) = *((int *)value); /* number of array values */
								/* pointer to array */
								*((double **)(new_value+sizeof(int))) = *((double **)(value+sizeof(int)));
							} break; 
							case FE_VALUE_ARRAY_VALUE:
							{
								*((int *)new_value) = *((int *)value); 							
								*((FE_value **)(new_value+sizeof(int))) = 
									*((FE_value **)(value+sizeof(int)));
							} break;
							case FLT_ARRAY_VALUE:
							{
								*((int *)new_value) = *((int *)value); 							
								*((float **)(new_value+sizeof(int))) = *((float **)(value+sizeof(int)));
							} break;	
							case SHORT_ARRAY_VALUE:
							{
								*((int *)new_value) = *((int *)value); 							
								*((short **)(new_value+sizeof(int))) = *((short **)(value+sizeof(int)));
							} break;	
							case INT_ARRAY_VALUE:			
							{
								*((int *)new_value) = *((int *)value); 							
								*((int **)(new_value+sizeof(int))) = *((int **)(value+sizeof(int)));
							} break;
							case UNSIGNED_ARRAY_VALUE:			
							{
								*((int *)new_value) = *((int *)value); 							
								*((unsigned **)(new_value+sizeof(int))) = 
									*((unsigned **)(value+sizeof(int)));
							} break;
							case STRING_VALUE:
							{														
								*((char **)(new_value)) = *((char **)(value));
							} break;								
						}					
						value+=size;
						new_value+=size;
					}
					component++;
					new_component++;
					i--;
				}
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"place_nodal_values.  Missing components");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"place_nodal_values.  Field not in list");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"place_nodal_values.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* place_nodal_values */

static int FE_element_parent_element_matches_recursive(
	struct FE_element_parent *element_parent,void *match_element_void)
/*******************************************************************************
LAST MODIFIED : 29 June 1999

DESCRIPTION :
Returns true if the element referred to by <element_parent> or one of the
elements referred to by its parents matches the <match_element>. Called by
FE_element_get_top_level_element_conversion to check that a suggested
top_level_element is in fact valid.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_parent_element_matches_recursive);
	if (element_parent&&element_parent->parent&&match_element_void)
	{
		if ((element_parent->parent==(struct FE_element *)match_element_void)||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				match_element_void,element_parent->parent->parent_list))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_element_matches_recursive.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_element_matches_recursive */

struct Field_defined_for_parent_data
{
	FE_value *coordinate_transformation;
	struct FE_element *field_element,*top_level_element;
	struct FE_element_field *element_field;
	struct FE_field *field;
}; /* struct Field_defined_for_parent_data */

static int field_defined_for_parent(struct FE_element_parent *parent,
	void *field_defined_for_parent_data)
/*******************************************************************************
LAST MODIFIED : 1 July 1999

DESCRIPTION :
Checks if the field is defined for the element referred to be the <parent>.
Now tries to inherit from a given <top_level_element>, if specified.
==============================================================================*/
{
	int return_code;
	struct Field_defined_for_parent_data *field_data;

	ENTER(field_defined_for_parent);
	if (parent&&(field_data=(struct Field_defined_for_parent_data *)
		field_defined_for_parent_data))
	{
		if ((!(field_data->top_level_element))||
			((parent->parent == field_data->top_level_element)||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				(void *)field_data->top_level_element,parent->parent->parent_list)))
		{
			if (return_code=inherit_FE_element_field(parent->parent,field_data->field,
				&(field_data->element_field),&(field_data->field_element),
				&(field_data->coordinate_transformation),field_data->top_level_element))
			{
				if (field_data->element_field)
				{
					return_code=1;
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				return_code=0;
			}
		}
		else
		{
			/* not inheriting from the given top_level_element */
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"field_defined_for_parent.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* field_defined_for_parent */

static int FE_element_field_not_in_list(struct FE_element_field *element_field,
	void *element_field_list)
/*******************************************************************************
LAST MODIFIED : 5 October 1998

DESCRIPTION :
Checks if the <element_field> is not in the <element_field_list>.
==============================================================================*/
{
	int i,j,k,l,*number_in_xi_1,*number_in_xi_2,number_of_xi_coordinates,
		return_code,*scale_factor_index_1,*scale_factor_index_2,*value_index_1,
		*value_index_2;
	struct FE_element_field *element_field_2;
	struct LIST(FE_element_field) *list;
	struct FE_element_field_component **component_1,**component_2;
	struct General_node_to_element_map **general_node_map_1,**general_node_map_2;
	struct Linear_combination_of_global_values **element_value_1,
		**element_value_2;
	struct Standard_node_to_element_map **standard_node_map_1,
		**standard_node_map_2;

	ENTER(FE_element_field_not_in_list);
	/* check arguments */
	if (element_field&&(element_field->field)&&
		(list=(struct LIST(FE_element_field) *)element_field_list))
	{
		if ((element_field_2=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,
			field)(element_field->field,list))&&
			(component_1=element_field->components)&&
			(component_2=element_field_2->components))
		{
			return_code=0;
			i=element_field->field->number_of_components;
			while (!return_code&&(i>0))
			{
				if ((*component_1)&&(*component_2)&&
					((*component_1)->type==(*component_2)->type)&&
					((*component_1)->basis==(*component_2)->basis)&&
					((*component_1)->modify==(*component_2)->modify))
				{
					number_of_xi_coordinates=((*component_1)->basis->type)[0];
					switch ((*component_1)->type)
					{
						case STANDARD_NODE_TO_ELEMENT_MAP:
						{
							if (((j=(*component_1)->map.standard_node_based.
								number_of_nodes)==(*component_2)->map.standard_node_based.
								number_of_nodes)&&(standard_node_map_1=(*component_1)->map.
								standard_node_based.node_to_element_maps)&&
								(standard_node_map_2=(*component_2)->map.standard_node_based.
								node_to_element_maps))
							{
								while (!return_code&&(j>0))
								{
									if ((*standard_node_map_1)&&(*standard_node_map_2)&&
										((*standard_node_map_1)->node_index==
										(*standard_node_map_2)->node_index)&&
										((k=(*standard_node_map_1)->number_of_nodal_values)==
										(*standard_node_map_2)->number_of_nodal_values)&&
										(value_index_1=(*standard_node_map_1)->
										nodal_value_indices)&&(value_index_2=
										(*standard_node_map_2)->nodal_value_indices)&&
										(scale_factor_index_1=(*standard_node_map_1)->
										scale_factor_indices)&&(scale_factor_index_2=
										(*standard_node_map_2)->scale_factor_indices))
									{
										while (!return_code&&(k>0))
										{
											if ((*value_index_1== *value_index_2)&&
												(*scale_factor_index_1== *scale_factor_index_2))
											{
												value_index_1++;
												value_index_2++;
												scale_factor_index_1++;
												scale_factor_index_2++;
												k--;
											}
											else
											{
												return_code=1;
											}
										}
										standard_node_map_1++;
										standard_node_map_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						case GENERAL_NODE_TO_ELEMENT_MAP:
						{
							if (((j=(*component_1)->map.general_node_based.
								number_of_nodes)==(*component_2)->map.general_node_based.
								number_of_nodes)&&(general_node_map_1=(*component_1)->map.
								general_node_based.node_to_element_maps)&&
								(general_node_map_2=(*component_2)->map.general_node_based.
								node_to_element_maps))
							{
								while (!return_code&&(j>0))
								{
									if ((*general_node_map_1)&&(*general_node_map_2)&&
										((*general_node_map_1)->node_index==
										(*general_node_map_2)->node_index)&&
										((k=(*general_node_map_1)->number_of_nodal_values)==
										(*general_node_map_2)->number_of_nodal_values)&&
										(element_value_1=(*general_node_map_1)->element_values)&&
										(element_value_2=(*general_node_map_2)->element_values))
									{
										while (!return_code&&(k>0))
										{
											if ((*element_value_1)&&(*element_value_2)&&
												((l=(*element_value_1)->number_of_global_values)==
												(*element_value_2)->number_of_global_values)&&
												(value_index_1=(*element_value_1)->
												global_value_indices)&&(value_index_2=
												(*element_value_2)->global_value_indices)&&
												(scale_factor_index_1=(*element_value_1)->
												coefficient_indices)&&(scale_factor_index_2=
												(*element_value_2)->coefficient_indices))
											{
												while (!return_code&&(l>0))
												{
													if ((*value_index_1== *value_index_2)&&
														(*scale_factor_index_1== *scale_factor_index_2))
													{
														value_index_1++;
														value_index_2++;
														scale_factor_index_1++;
														scale_factor_index_2++;
														l--;
													}
													else
													{
														return_code=1;
													}
												}
												element_value_1++;
												element_value_2++;
												k--;
											}
											else
											{
												return_code=1;
											}
										}
										general_node_map_1++;
										general_node_map_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						case FIELD_TO_ELEMENT_MAP:
						{
							if (((j=(*component_1)->map.field_based.
								number_of_element_values)==(*component_2)->map.field_based.
								number_of_element_values)&&(element_value_1=(*component_1)->
								map.field_based.element_values)&&(element_value_2=
								(*component_2)->map.field_based.element_values))
							{
								while (!return_code&&(j>0))
								{
									if ((*element_value_1)&&(*element_value_2)&&
										((k=(*element_value_1)->number_of_global_values)==
										(*element_value_2)->number_of_global_values)&&
										(value_index_1=(*element_value_1)->
										global_value_indices)&&(value_index_2=
										(*element_value_2)->global_value_indices)&&
										(scale_factor_index_1=(*element_value_1)->
										coefficient_indices)&&(scale_factor_index_2=
										(*element_value_2)->coefficient_indices))
									{
										while (!return_code&&(k>0))
										{
											if ((*value_index_1== *value_index_2)&&
												(*scale_factor_index_1== *scale_factor_index_2))
											{
												value_index_1++;
												value_index_2++;
												scale_factor_index_1++;
												scale_factor_index_2++;
												k--;
											}
											else
											{
												return_code=1;
											}
										}
										element_value_1++;
										element_value_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						case ELEMENT_GRID_MAP:
						{
							if (((*component_1)->map.element_grid_based.value_index==
								(*component_2)->map.element_grid_based.value_index)&&
								(number_in_xi_1=
								(*component_1)->map.element_grid_based.number_in_xi)&&
								(number_in_xi_2=
								(*component_2)->map.element_grid_based.number_in_xi))
							{
								j=number_of_xi_coordinates;
								while (!return_code&&(j>0))
								{
									if (*number_in_xi_1== *number_in_xi_2)
									{
										number_in_xi_1++;
										number_in_xi_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						default:
						{
							display_message(ERROR_MESSAGE,
								"FE_element_field_not_in_list.  Invalid map type");
							return_code=1;
						} break;
					}
					component_1++;
					component_2++;
					i--;
				}
				else
				{
					return_code=1;
				}
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_not_in_list.  Invalid argument(s)");
		return_code=1;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_not_in_list */

static int add_FE_element_field_if_not_duplicate(
	struct FE_element_field *element_field,void *list)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
If the <element_field> is not in the <list> it is added to the list.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element_field) *element_field_list;

	ENTER(add_FE_element_field_if_not_duplicate);
	/* check arguments */
	if (element_field&&(element_field->field)&&
		(element_field_list=(struct LIST(FE_element_field) *)list))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			element_field->field,element_field_list))
		{
			return_code=0;
		}
		else
		{
			if (ADD_OBJECT_TO_LIST(FE_element_field)(element_field,
				element_field_list))
			{
				return_code=1;
			}
			else
			{
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_field_if_not_duplicate.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_field_if_not_duplicate */

static int match_FE_element_field_lists(
	struct FE_element_field_info *field_info,void *element_field_lists)
/*******************************************************************************
LAST MODIFIED : 23 September 1995

DESCRIPTION :
Checks if the <field_info> matchs the <element_field_lists>.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_info *field_lists;

	ENTER(match_FE_element_field_lists);
	/* check arguments */
	if (field_info&&
		(field_lists=(struct FE_element_field_info *)element_field_lists))
	{
		if ((NUMBER_IN_LIST(FE_element_field)(field_lists->element_field_list)==
			NUMBER_IN_LIST(FE_element_field)(field_info->element_field_list)))
		{			
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
				FE_element_field_not_in_list,
				(void *)(field_info->element_field_list),
				field_lists->element_field_list))
			{
				return_code=0;
			}
			else
			{
				return_code=1;
			}
		
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"match_FE_element_field_lists.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* match_FE_element_field_lists */

#if !defined (WINDOWS_DEV_FLAG)
static int list_FE_element_field(struct FE_element_field *element_field,
	void *dummy_user_data)
/*******************************************************************************
LAST MODIFIED : 7 April 1999

DESCRIPTION :
Outputs the information contained by the element field.
==============================================================================*/
{
	char line[81], *component_name;
	int *basis_type,i,j,k,line_length,*nodal_value_index,*number_in_xi,
		number_of_characters,number_of_components,number_of_nodal_values,
		number_of_xi_coordinates,return_code,*scale_factor_index;
	struct FE_element_field_component **element_field_component;
	struct FE_field *field;
	struct Standard_node_to_element_map **node_to_element_map;

	ENTER(list_FE_element_field);
	if (element_field&&!dummy_user_data)
	{
		if (field=element_field->field)
		{
			return_code=1;
			display_message(INFORMATION_MESSAGE,"  ");
			display_message(INFORMATION_MESSAGE,field->name);
			switch (field->cm.type)
			{
				case CM_COORDINATE_FIELD:
				{
					display_message(INFORMATION_MESSAGE,", coordinate");
				} break;
				case CM_ANATOMICAL_FIELD:
				{
					display_message(INFORMATION_MESSAGE,", anatomical");
				} break;
				case CM_FIELD:
				{
					display_message(INFORMATION_MESSAGE,", field");
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"list_FE_element_field.  Invalid field type");
					return_code=0;
				} break;
			}
			switch (field->coordinate_system.type)
			{
				case RECTANGULAR_CARTESIAN:
				{
					display_message(INFORMATION_MESSAGE,", rectangular cartesian");
				} break;
				case CYLINDRICAL_POLAR:
				{
					display_message(INFORMATION_MESSAGE,", cylindrical polar");
				} break;
				case SPHERICAL_POLAR:
				{
					display_message(INFORMATION_MESSAGE,", spherical polar");
				} break;
				case PROLATE_SPHEROIDAL:
				{
					display_message(INFORMATION_MESSAGE,", prolate spheroidal");
				} break;	
				case NOT_APPLICABLE:
				{
					display_message(INFORMATION_MESSAGE,", no coordinate system");
				} break;
				case OBLATE_SPHEROIDAL:
				{
					display_message(INFORMATION_MESSAGE,", oblate spheroidal");
				} break;
				case FIBRE:
				{
					display_message(INFORMATION_MESSAGE,", fibre");
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"list_FE_element_field.  Invalid field coordinate system");
					return_code=0;
				} break;
			}
			number_of_components=field->number_of_components;
			sprintf(line," #Components=%d\n",number_of_components);
			display_message(INFORMATION_MESSAGE,line);
			element_field_component=element_field->components;
			i=0;
			while (return_code&&(i<number_of_components))
			{
				display_message(INFORMATION_MESSAGE,"    ");
				if (component_name = get_FE_field_component_name(field, i))
				{
					display_message(INFORMATION_MESSAGE,component_name);
					DEALLOCATE(component_name);
				}
				if (*element_field_component)
				{
					display_message(INFORMATION_MESSAGE,".  ");
					if (((*element_field_component)->basis)&&
						(basis_type=(*element_field_component)->basis->type))
					{
						/*???DB.  Only correct for tensor products */
						number_of_xi_coordinates= *basis_type;
						basis_type++;
						j=number_of_xi_coordinates;
						while (j>0)
						{
							switch (*basis_type)
							{
								case LINEAR_LAGRANGE:
								{
									display_message(INFORMATION_MESSAGE,"linear Lagrange");
								} break;
								case QUADRATIC_LAGRANGE:
								{
									display_message(INFORMATION_MESSAGE,"quadratic Lagrange");
								} break;
								case CUBIC_LAGRANGE:
								{
									display_message(INFORMATION_MESSAGE,"cubic Lagrange");
								} break;
								case CUBIC_HERMITE:
								{
									display_message(INFORMATION_MESSAGE,"cubic Hermite");
								} break;
								case LAGRANGE_HERMITE:
								{
									display_message(INFORMATION_MESSAGE,"Lagrange Hermite");
								} break;
								case HERMITE_LAGRANGE:
								{
									display_message(INFORMATION_MESSAGE,"Hermite Lagrange");
								} break;
							}
							if (j>1)
							{
								display_message(INFORMATION_MESSAGE,"*");
							}
							basis_type += j;
							j--;
						}
					}
					if ((*element_field_component)->modify)
					{
						display_message(INFORMATION_MESSAGE,", modify");
					}
					else
					{
						display_message(INFORMATION_MESSAGE,", no modify");
					}
					switch ((*element_field_component)->type)
					{
						case STANDARD_NODE_TO_ELEMENT_MAP:
						{
							display_message(INFORMATION_MESSAGE,", standard node based\n");
							if (node_to_element_map=(*element_field_component)->map.
								standard_node_based.node_to_element_maps)
							{
								j=(*element_field_component)->map.standard_node_based.
									number_of_nodes;
								while (j>0)
								{
									if (*node_to_element_map)
									{
										number_of_nodal_values=(*node_to_element_map)->
											number_of_nodal_values;
										sprintf(line,"      %d.  #Values=%d\n",
											(*node_to_element_map)->node_index,
											number_of_nodal_values);
										display_message(INFORMATION_MESSAGE,line);
										if (nodal_value_index=(*node_to_element_map)->
											nodal_value_indices)
										{
											sprintf(line,"        Value indices:%n",&line_length);
											for (k=number_of_nodal_values;k>0;k--)
											{
												sprintf(line+line_length," %d%n",*nodal_value_index,
													&number_of_characters);
												line_length += number_of_characters;
												nodal_value_index++;
											}
											sprintf(line+line_length,"\n");
											display_message(INFORMATION_MESSAGE,line);
										}
										if (scale_factor_index=(*node_to_element_map)->
											scale_factor_indices)
										{
											sprintf(line,"        Scale factor indices:%n",
												&line_length);
											for (k=number_of_nodal_values;k>0;k--)
											{
												sprintf(line+line_length," %d%n",*scale_factor_index,
													&number_of_characters);
												line_length += number_of_characters;
												scale_factor_index++;
											}
											sprintf(line+line_length,"\n");
											display_message(INFORMATION_MESSAGE,line);
										}
									}
									j--;
									node_to_element_map++;
								}
							}
						} break;
						case GENERAL_NODE_TO_ELEMENT_MAP:
						{
							display_message(INFORMATION_MESSAGE,", general node based\n");
						} break;
						case FIELD_TO_ELEMENT_MAP:
						{
							display_message(INFORMATION_MESSAGE,", field to element\n");
						} break;
						case ELEMENT_GRID_MAP:
						{
							display_message(INFORMATION_MESSAGE,", grid based\n");
							number_in_xi=
								(*element_field_component)->map.element_grid_based.number_in_xi;
							number_of_xi_coordinates=
								((*element_field_component)->basis->type)[0];
							sprintf(line,"      %n",&line_length);
							for (j=0;j<number_of_xi_coordinates;j++)
							{
								if (j>0)
								{
									sprintf(line+line_length,", ");
									line_length += 2;
								}
								printf(line+line_length,"#xi%d=%d%n",j+1,number_in_xi[j],
									&number_of_characters);
								line_length += number_of_characters;
							}
							sprintf(line+line_length,"\n");
							display_message(INFORMATION_MESSAGE,line);
						} break;
						default:
						{
							display_message(INFORMATION_MESSAGE,"\n");
						} break;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"list_FE_element_field.  Missing element field component");
					return_code=0;
				}
				element_field_component++;
				i++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"list_FE_element_field.  Missing field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_element_field.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element_field */
#endif /* !defined (WINDOWS_DEV_FLAG) */

#if !defined (WINDOWS_DEV_FLAG)
static int list_FE_node_field (struct FE_node_field *node_field,void *node_void)
/*******************************************************************************
LAST MODIFIED : 31 July 2000

DESCRIPTION :
Outputs the information contained by the node field.
==============================================================================*/
{
	char *component_name;
	enum FE_nodal_value_type *type;
	Value_storage *values_storage, *value;
	int i,j,k,number_of_components,number_of_versions,return_code,xi_dimension,xi_index;
	struct FE_field *field;
	struct FE_node *node;
	struct FE_node_field_component *node_field_component;

	ENTER(list_FE_node_field);
	if (node_field&&(node=(struct FE_node *)node_void))
	{
		if ((field=node_field->field)&&
			(node_field_component=node_field->components))
		{	 
			return_code=1;
			display_message(INFORMATION_MESSAGE,"  %s",field->name);
			switch (field->cm.type)
			{
				case CM_COORDINATE_FIELD:
				{
					display_message(INFORMATION_MESSAGE,", coordinate");
				} break;
				case CM_ANATOMICAL_FIELD:
				{
					display_message(INFORMATION_MESSAGE,", anatomical");
				} break;
				case CM_FIELD:
				{
					display_message(INFORMATION_MESSAGE,", field");
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"list_FE_node_field.  Invalid field type");
					return_code=0;
				} break;
			}
			switch (field->coordinate_system.type)
			{
				case RECTANGULAR_CARTESIAN:
				{
					display_message(INFORMATION_MESSAGE,", rectangular cartesian");
				} break;
				case CYLINDRICAL_POLAR:
				{
					display_message(INFORMATION_MESSAGE,", cylindrical polar");
				} break;
				case SPHERICAL_POLAR:
				{
					display_message(INFORMATION_MESSAGE,", spherical polar");
				} break;
				case PROLATE_SPHEROIDAL:
				{
					display_message(INFORMATION_MESSAGE,", prolate spheroidal");
				} break;
				case OBLATE_SPHEROIDAL:
				{
					display_message(INFORMATION_MESSAGE,", oblate spheroidal");
				} break;
				case FIBRE:
				{
					display_message(INFORMATION_MESSAGE,", fibre");
				} break;
				case NOT_APPLICABLE:
				{
					display_message(INFORMATION_MESSAGE,", no coordinate system");
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"list_FE_node_field.  Invalid field coordinate system");
					return_code=0;
				} break;
			}
			number_of_components=field->number_of_components;
			display_message(INFORMATION_MESSAGE,", #Components=%d\n",
				number_of_components);
			i=0;
			while (return_code&&(i<number_of_components))
			{
				if (component_name = get_FE_field_component_name(field, i))
				{
					display_message(INFORMATION_MESSAGE,"    %s", component_name);
					DEALLOCATE(component_name);
				}
				number_of_versions=node_field_component->number_of_versions;
				if (1<number_of_versions)
				{
					display_message(INFORMATION_MESSAGE,", #Versions=%d",
						number_of_versions);
				}
				else
				{
					display_message(INFORMATION_MESSAGE,".  ");
				}			
				/* display field based information*/
				if(field->number_of_values)
				{	
					int count;

					display_message(INFORMATION_MESSAGE,"field based values: ");							
					switch(field->value_type)
					{
						case FE_VALUE_VALUE:
						{
							display_message(INFORMATION_MESSAGE,"\n");
							display_message(INFORMATION_MESSAGE,"    "); 
							/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
							for (count=0;count<field->number_of_values;count++)
							{	
								display_message(INFORMATION_MESSAGE,"%g",
									/*	display_message(INFORMATION_MESSAGE," %"FE_VALUE_STRING,*/
									*((FE_value*)(field->values_storage + count*sizeof(FE_value)) ));
								if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
									(0==((count+1) % DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
								{
									display_message(INFORMATION_MESSAGE,"\n");
								}											
							}	
							display_message(INFORMATION_MESSAGE,"\n");
						} break;
						default:
						{
							display_message(INFORMATION_MESSAGE,"list_FE_node_field: "
								"Can't display that field value_type yet. Write the code!");
						} break;
					}	/* switch() */							
				}
				/* display node based information*/
				if ((values_storage=node->values_storage)&&(type=node_field_component->
					nodal_value_types))
				{					
					values_storage += node_field_component->value;
					j=0;
					while (return_code&&(j<number_of_versions))
					{
						j++;
						if (1<number_of_versions)
						{
							display_message(INFORMATION_MESSAGE,"\n      Version %d.  ",j);
							type=node_field_component->nodal_value_types;
						}
						k=1+(node_field_component->number_of_derivatives);
						while (return_code&&(k>0))
						{
							display_message(INFORMATION_MESSAGE,"%s=",
								get_FE_nodal_value_type_string(*type));
#if defined (NEW_CODE) /* not sure how we're going to display these yet */
							/* display field time information*/
							if(field->number_of_times)
							{
								int count;

								display_message(INFORMATION_MESSAGE,"times: ");							
								switch(field->time_value_type)
								{
									case FE_VALUE_VALUE:
									{
										display_message(INFORMATION_MESSAGE,"\n");
										/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
										for(count=0;count<field->number_of_times;count++)
										{
											display_message(INFORMATION_MESSAGE," %"FE_VALUE_STRING,
												*((FE_value*)(field->times + count*sizeof(FE_value)) ));
											if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
												(0==((count+1) % DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
											{
												display_message(INFORMATION_MESSAGE,"\n");
											}											
										}																							
									} break;
									default:
									{
										display_message(INFORMATION_MESSAGE,"list_FE_node_field: "
											"Can't display that time_value_type yet. Write the code!");
									} break;
								}	/* switch() */							
							}
#endif /* defined (NEW_CODE) */				
							/* display node based field information*/
							if(field->number_of_times)
							{
								/* for the moment don't display the (generally massive) time based*/
								/* field information */
								display_message(INFORMATION_MESSAGE," TIME BASED FIELD ");
							}
							else
							{							
								switch(field->value_type)
								{
									case FE_VALUE_VALUE:
									{
										display_message(INFORMATION_MESSAGE,"%g",
											*((FE_value*)values_storage));
									} break;
									case ELEMENT_XI_VALUE:
									{
										xi_dimension = (*((struct FE_element**)
											values_storage))->shape->dimension;
										display_message(INFORMATION_MESSAGE,"element %d xi",
											(*((struct FE_element**)values_storage))->cm.number);
										value = values_storage + sizeof (struct FE_element *);
										for (xi_index = 0 ; xi_index < xi_dimension ; xi_index++)
										{
											display_message(INFORMATION_MESSAGE," %g",
												*((FE_value *)value));
											value += sizeof (FE_value);
										}
									} break;	
									case INT_VALUE:
									{
										display_message(INFORMATION_MESSAGE,"%d",
											*((int *)values_storage));
									} break;	
									case STRING_VALUE:
									{
										char *name;

										if (get_FE_nodal_string_value(node,field,
											/*component_number*/0,/*version*/0,FE_NODAL_VALUE,&name))
										{
											display_message(INFORMATION_MESSAGE,name);
											DEALLOCATE(name);
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"list_FE_node_field.  Could not get string value");
											return_code=0;
										}
									} break;
									case DOUBLE_ARRAY_VALUE:
									{
										struct FE_field_component component;
										double *array;
										int number_of_values,count;
									
										component.field =field;
										component.number = 0;
										number_of_values=get_FE_nodal_array_number_of_elements(node,
											&component,0,FE_NODAL_VALUE);
										if(number_of_values>0)
										{									
											if(ALLOCATE(array,double,number_of_values))
											{
												get_FE_nodal_double_array_value(node,&component,0,
													FE_NODAL_VALUE,array,number_of_values);
												display_message(INFORMATION_MESSAGE,"\n");
												/* output in columns if DOUBLE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
												for (count=0;count<number_of_values;count++)
												{
													display_message(INFORMATION_MESSAGE," %"
														DOUBLE_VALUE_STRING,array[count]);
													if ((0<DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)&&
														(0==((count+1) % DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
													{
														display_message(INFORMATION_MESSAGE,"\n");
													}											
												}										
											}
											else
											{
												display_message(ERROR_MESSAGE,"list_FE_node_field."
													" Out of memory");
												return_code =0;
											}	
											DEALLOCATE(array);							
										}	
										else
										{
											/* this is NOT an error */
											display_message(INFORMATION_MESSAGE,"array length 0");
										}
										
									} break;	
									case FE_VALUE_ARRAY_VALUE:
									{
										struct FE_field_component component;
										FE_value *array;
										int number_of_values,count;
									
										component.field =field;
										component.number = 0;	
										number_of_values=get_FE_nodal_array_number_of_elements(node,&component,
											0,FE_NODAL_VALUE);
										if(number_of_values>0)
										{																			
											if(ALLOCATE(array,FE_value,number_of_values))
											{
												get_FE_nodal_FE_value_array(node,&component,0,
													FE_NODAL_VALUE,array,number_of_values);	
												display_message(INFORMATION_MESSAGE,"\n");
												/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
												for (count=0;count<number_of_values;count++)
												{
													display_message(INFORMATION_MESSAGE," %"
														FE_VALUE_STRING,array[count]);
													if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
														(0==((count+1) % FE_VALUE_MAX_OUTPUT_COLUMNS)))
													{
														display_message(INFORMATION_MESSAGE,"\n");
													}											
												}									
											}
											else
											{
												display_message(ERROR_MESSAGE,"list_FE_node_field."
													" Out of memory");
												return_code =0;
											}
											DEALLOCATE(array);								
										}
										else
										{
											/* this is NOT an error */
											display_message(INFORMATION_MESSAGE,"array length 0");
										}										
									} break;	
									case SHORT_ARRAY_VALUE:
									{
										struct FE_field_component component;
										short *array;
										int number_of_values,count;									

										component.field =field;
										component.number = 0;
										number_of_values=get_FE_nodal_array_number_of_elements(node,&component,
											0,FE_NODAL_VALUE);
										if(number_of_values>0)
										{								
											if(ALLOCATE(array,short,number_of_values))
											{
												get_FE_nodal_short_array(node,&component,0,
													FE_NODAL_VALUE,array,number_of_values);
												display_message(INFORMATION_MESSAGE,"\n");
												/* output in columns if SHORT_VALUE_MAX_OUTPUT_COLUMNS > 0 */
												for (count=0;count<number_of_values;count++)
												{
													display_message(INFORMATION_MESSAGE," %4d",array[count]);
													if ((0<SHORT_VALUE_MAX_OUTPUT_COLUMNS)&&
														(0==((count+1) % SHORT_VALUE_MAX_OUTPUT_COLUMNS)))
													{
														display_message(INFORMATION_MESSAGE,"\n");
													}											
												}										
											}
											else
											{
												display_message(ERROR_MESSAGE,"list_FE_node_field."
													" Out of memory");
												return_code =0;
											}
											DEALLOCATE(array);									
										}																		
										else
										{
											/* this is NOT an error */
											display_message(INFORMATION_MESSAGE,"array length 0");
										}
									} break;									
									default:
									{
										display_message(INFORMATION_MESSAGE,"list_FE_node_field: "
											"Can't display that Value_type yet. Write the code!");
									} break;
								}/* switch*/
							} /* if(field->number_of_times) */
							values_storage += get_Value_storage_size(field->value_type); 
							type++;
							k--;
							if (k>0)
							{
								display_message(INFORMATION_MESSAGE,", ");
							}
						}
					}
					display_message(INFORMATION_MESSAGE,"\n");
				}
				else
				{
					/*Missing nodal values only an error if no field based values either */
					if(!(field->number_of_values))
					{
						display_message(ERROR_MESSAGE,
							"list_FE_node_field.  Missing nodal values");
						return_code=0;
					}
				}
				node_field_component++;
				i++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"list_FE_node_field.  Missing field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_node_field.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_node_field */
#endif /* !defined (WINDOWS_DEV_FLAG) */

struct Match_FE_element_shape_data
{
	int dimension;
	int *type;
}; /* struct Match_FE_element_shape_data */

static int match_FE_element_shape(struct FE_element_shape *shape,
	void *match_FE_element_shape_data)
/*******************************************************************************
LAST MODIFIED : 24 July 1995

DESCRIPTION :
Checks if the <match_FE_element_shape_data> matchs the <shape>.
==============================================================================*/
{
	int *find_type,i,return_code,*shape_type;
	struct Match_FE_element_shape_data *match_data;

	ENTER(match_FE_element_shape);
	/* check arguments */
	if (shape&&(match_data=
		(struct Match_FE_element_shape_data *)match_FE_element_shape_data)&&
		(find_type=match_data->type)&&(shape_type=shape->type))
	{
		if (match_data->dimension==shape->dimension)
		{
			i=(match_data->dimension)*((match_data->dimension)+1)/2;
			while ((i>0)&&(*find_type== *shape_type))
			{
				find_type++;
				shape_type++;
				i--;
			}
			if (i>0)
			{
				return_code=0;
			}
			else
			{
				return_code=1;
			}
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"match_FE_element_shape.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* match_FE_element_shape */

static int compare_FE_element_parent_parent(struct FE_element *parent_1,
	struct FE_element *parent_2)
/*******************************************************************************
LAST MODIFIED : 30 July 1995

DESCRIPTION :
Returns -1 if parent_1 < parent_2, 0 if parent_1 = parent_2 and 1 if
parent_1 > parent_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_FE_element_parent_parent);
	if (parent_1<parent_2)
	{
		return_code= -1;
	}
	else
	{
		if (parent_1>parent_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* compare_FE_element_parent_parent */

static int compare_FE_element_parent_face_number(int face_number_1,
	int face_number_2)
/*******************************************************************************
LAST MODIFIED : 30 July 1995

DESCRIPTION :
Returns -1 if face_number_1 < face_number_2, 0 if face_number_1 = face_number_2
and 1 if face_number_1 > face_number_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_FE_element_parent_face_number);
	if (face_number_1<face_number_2)
	{
		return_code= -1;
	}
	else
	{
		if (face_number_1>face_number_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* compare_FE_element_parent_face_number */

#if !defined (WINDOWS_DEV_FLAG)
static int list_FE_element_parent(struct FE_element_parent *element_parent,
	void *void_line)
/*******************************************************************************
LAST MODIFIED : 15 February 1999

DESCRIPTION :
Outputs the information contained at the element.
==============================================================================*/
{
	char *line;
	int return_code;
	struct FE_element *parent;

	ENTER(list_FE_element_parent);
	if (element_parent&&(parent=element_parent->parent)&&(line=(char *)void_line))
	{
		sprintf(line+strlen(line)," (%d)",
			parent->cm.number);
		if (70<=strlen(line))
		{
			display_message(INFORMATION_MESSAGE,line);
			display_message(INFORMATION_MESSAGE,"\n");
			*line='\0';
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"list_FE_element_parent.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element_parent */
#endif /* !defined (WINDOWS_DEV_FLAG) */

static int set_FE_node_group_list_sub(struct GROUP(FE_node) *node_group,
	void *user_data)
/*******************************************************************************
LAST MODIFIED : 17 February 1996

DESCRIPTION :
Writes the group name to the output pane.
???DB.  Should this be here ?
==============================================================================*/
{
	int *counter,return_code;

	ENTER(set_FE_node_group_list_sub);
	if (node_group)
	{
		if (counter=(int *)user_data)
		{
			display_message(INFORMATION_MESSAGE,node_group->name);
			(*counter)--;
			if (*counter)
			{
				display_message(INFORMATION_MESSAGE,",");
			}
			return_code=1;
		}
		else
		{
			display_message(WARNING_MESSAGE,
				"set_FE_node_group_list_sub.  Invalid counter");
			return_code=0;
		}
	}
	else
	{
		display_message(WARNING_MESSAGE,
			"set_FE_node_group_list_sub.  Invalid node group");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_group_list_sub */

DECLARE_LOCAL_MANAGER_FUNCTIONS(FE_basis)

DECLARE_LOCAL_MANAGER_FUNCTIONS(FE_node)

#if defined (OLD_CODE)
/* indexed list and manager module functions included with MANAGED_GROUP */
DECLARE_LOCAL_MANAGER_FUNCTIONS(GROUP(FE_node))
#endif /* defined (OLD_CODE) */

DECLARE_LOCAL_MANAGER_FUNCTIONS(FE_element)

#if defined (OLD_CODE)
/* indexed list and manager module functions included with MANAGED_GROUP */
DECLARE_LOCAL_MANAGER_FUNCTIONS(GROUP(FE_element))
#endif /* defined (OLD_CODE) */

static int global_to_element_map_values(struct FE_element *element,
	struct FE_element_field *element_field,int component_number,
	int *number_of_values,FE_value **values)
/*******************************************************************************
LAST MODIFIED : 18 November 1999

DESCRIPTION :
The standard function for calculating the <element> <values> for the given
<component_number> of <element_field>. Calculates the <number_of_values> and
the <values> for the component.  The storage for the <values> is allocated by
the function.
???RC Changed to use relative offsets into nodal values array in standard and
general node to element maps. Absolute offset for start of field component is
obtained from the node_field_component for the field at the node.
==============================================================================*/
{
	FE_value *blended_element_value,*blended_element_values,*blending_matrix,
		*element_value,*element_values,*global_values,*scale_factors,temp_value,fe_value;
	int *coefficient_index,*global_value_index,i,j,k,l,
		number_of_blended_element_values,number_of_element_nodes,
		number_of_element_values,number_of_global_values,number_of_map_values,
		number_of_scale_factors,return_code,*scale_factor_index,scale_index,
		value_index;
	struct FE_basis *basis;
	struct FE_element_field_component *component;
	struct FE_field *field;
	struct FE_node *node,**nodes;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct FE_node_field_info *node_field_info;
	struct General_node_to_element_map *general_node_map,
		**general_node_map_address;
	struct Linear_combination_of_global_values *linear_combination,
		**linear_combination_address;
	struct Standard_node_to_element_map *standard_node_map,
		**standard_node_map_address;

	ENTER(global_to_element_map_values);
/*???debug */
/*printf("enter global_to_element_map_values\n");*/
	/* check the arguments */
	if (element&&element_field&&(field=element_field->field)&&number_of_values&&
		values&&(0<=component_number)&&
		(component_number<field->number_of_components)&&
		(component=element_field->components[component_number]))
	{
		/* retrieve the element values */
		switch (component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
			/* global values are associated with nodes */
			{
				/* check information */
				/*???RC 18 Nov 1999 allowed having no scale factors */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->number_of_nodes)>0)&&
					((0==(number_of_scale_factors=
						element->information->number_of_scale_factors))||
						((0<number_of_scale_factors)&&
							(scale_factors=element->information->scale_factors))))
				{
					/* calculate the number of element values by summing the numbers of
						values retrieved from each node */
					number_of_element_values=0;
					standard_node_map_address=
						component->map.standard_node_based.node_to_element_maps;
					j=component->map.standard_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((standard_node_map= *standard_node_map_address)&&
							((number_of_map_values=
							standard_node_map->number_of_nodal_values)>0)&&
							(0<=standard_node_map->node_index)&&
							(standard_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[standard_node_map->node_index])&&(node->values_storage)&&
							(node->fields)&&(standard_node_map->nodal_value_indices)&&
							(standard_node_map->scale_factor_indices))
						{
							number_of_element_values += number_of_map_values;
							standard_node_map_address++;
							j--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
				"global_to_element_map_values.  Invalid standard node to element map");
							return_code=0;
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&
							(ALLOCATE(element_values,FE_value,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							standard_node_map_address=
								component->map.standard_node_based.node_to_element_maps;
							j=component->map.standard_node_based.number_of_nodes;
							/* Need node_field_component to get absolute offset into nodal
								 values array. Also store node_field_info so we don't have to
								 get node_field_component each time if it is not changing */
							node_field_info=(struct FE_node_field_info *)NULL;
							node_field_component=(struct FE_node_field_component *)NULL;
							while (return_code&&(j>0))
							{
								/* retrieve the scaled nodal values */
								standard_node_map= *standard_node_map_address;
								node=nodes[standard_node_map->node_index];
#if defined (OLD_CODE)
								global_values=node->values;
#endif /* defined (OLD_CODE) */
								number_of_global_values=node->fields->number_of_values;
								global_value_index=standard_node_map->nodal_value_indices;
								scale_factor_index=standard_node_map->scale_factor_indices;
								/* get node_field_component for absolute offsets into nodes */
								if (node_field_info != node->fields)
								{
									if (node->fields&&(node_field=FIND_BY_IDENTIFIER_IN_LIST(
										FE_node_field,field)(field,node->fields->node_field_list))&&
										node_field->components)
									{
										node_field_component=
											node_field->components + component_number;
									}
									else
									{
										/* field not defined at this node */
										node_field_component=(struct FE_node_field_component *)NULL;
									}
									node_field_info=node->fields;
								}
								if (node_field_component)
								{
									/* add absolute value offset from node_field_component and
										 cast address into FE_value type */
									global_values=
										(FE_value *)(node->values_storage+node_field_component->value);
									k=standard_node_map->number_of_nodal_values;
									while (k>0)
									{
										/* if there is not a nodal value use 0 */
										if ((0<=(value_index= *global_value_index))&&
											(value_index<number_of_global_values))
										{
											/* if there is not a scale factor use 1 as the scale
												 factor */
											if ((0<=(scale_index= *scale_factor_index))&&
												(scale_index<number_of_scale_factors))
											{
												*element_value=global_values[value_index]*
													scale_factors[scale_index];
											}
											else
											{
												*element_value=global_values[value_index];
											}
										}
										else
										{
											*element_value=0;
										}
										element_value++;
										global_value_index++;
										scale_factor_index++;
										k--;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"global_to_element_map_values.  Cannot evaluate field %s "
										"in element %d because it is not defined at node %d",
										field->name,element->cm.number,node->cm_node_identifier);
									return_code=0;
								}
								standard_node_map_address++;
								j--;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
				"global_to_element_map_values.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Missing element information");
					return_code=0;
				}
			} break;
			case GENERAL_NODE_TO_ELEMENT_MAP:
			/* global values are associated with nodes */
			{
				/* check information */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->number_of_nodes)>0)&&
					(scale_factors=element->information->scale_factors)&&
					((number_of_scale_factors=element->information->
					number_of_scale_factors)>0))
				{
					/* calculate the number of element values by summing the numbers of
						values retrieved from each node */
					number_of_element_values=0;
					general_node_map_address=
						component->map.general_node_based.node_to_element_maps;
					j=component->map.general_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((general_node_map= *general_node_map_address)&&
							((number_of_map_values=
							general_node_map->number_of_nodal_values)>0)&&
							(0<=general_node_map->node_index)&&
							(general_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[general_node_map->node_index])&&(node->values_storage)&&
							(node->fields)&&(general_node_map->element_values))
						{
							number_of_element_values += number_of_map_values;
							general_node_map_address++;
							j--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
					"global_to_element_map_values.  Invalid general node to element map");
							return_code=0;
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&
							(ALLOCATE(element_values,FE_value,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							general_node_map_address=
								component->map.general_node_based.node_to_element_maps;
							j=component->map.general_node_based.number_of_nodes;
							/* Need node_field_component to get absolute offset into nodal
								 values array. Also store node_field_info so we don't have to
								 get node_field_component each time if it is not changing */
							node_field_info=(struct FE_node_field_info *)NULL;
							node_field_component=(struct FE_node_field_component *)NULL;
							while (return_code&&(j>0))
							{
								/* retrieve the scaled nodal values */
								general_node_map= *general_node_map_address;
								node=nodes[general_node_map->node_index];
#if defined (OLD_CODE)
								global_values=node->values;
#endif /* defined (OLD_CODE) */
								number_of_global_values=node->fields->number_of_values;
								linear_combination_address=general_node_map->element_values;
								/* get node_field_component for absolute offsets into nodes */
								if (node_field_info != node->fields)
								{
									if (node->fields&&(node_field=FIND_BY_IDENTIFIER_IN_LIST(
										FE_node_field,field)(field,node->fields->node_field_list))&&
										node_field->components)
									{
										node_field_component=
											node_field->components + component_number;
									}
									node_field_info=node->fields;
								}
								if (node_field_component)
								{
									/* add absolute value offset from node_field_component and
										 cast address into FE_value type */
									global_values=
										(FE_value *)(node->values_storage+node_field_component->value);
									k=general_node_map->number_of_nodal_values;
									while (return_code&&(k>0))
									{
										*element_value=0;
										if ((linear_combination= *linear_combination_address)&&
											((l=linear_combination->number_of_global_values)>0)&&
											(global_value_index=
												linear_combination->global_value_indices)&&
											(coefficient_index=
												linear_combination->coefficient_indices))
										{
											while (return_code&&(l>0))
											{
												/* if there is not a global value use 0 */
												if ((0<=(value_index= *global_value_index))&&
													(value_index<number_of_global_values))
												{
													/* if there is not a coefficient use 1 as the
														 coefficient */
													if ((0<=(scale_index= *coefficient_index))&&
														(scale_index<number_of_scale_factors))
													{
														/* ???RC Change to relative. */
														*element_value += global_values[value_index]*
															scale_factors[scale_index];
													}
													else
													{
														/* ???RC Change to relative. */
														*element_value += global_values[value_index];
													}
												}
												global_value_index++;
												coefficient_index++;
												l--;
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
								   "global_to_element_map_values.  Missing linear combination");
											DEALLOCATE(element_values);
											return_code=0;
										}
										element_value++;
										k--;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
								 "global_to_element_map_values.  Invalid node field component");
									return_code=0;
								}
								general_node_map_address++;
								j--;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
				"global_to_element_map_values.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Missing element information");
					return_code=0;
				}
			} break;
			case FIELD_TO_ELEMENT_MAP:
			/* global values are associated with the field */
			{
				/* check information */
				if ((element->information)&&
					(scale_factors=element->information->scale_factors)&&
					((number_of_scale_factors=element->information->
					number_of_scale_factors)>0)&&					 						
					(field->value_type==FE_VALUE_VALUE)&&
					((number_of_global_values=field->number_of_values)>0))
				{
					/* allocate storage for storing the element values */
					if ((linear_combination_address=component->map.field_based.
						element_values)&&((number_of_element_values=
						component->map.field_based.number_of_element_values)>0)&&
						(ALLOCATE(element_values,FE_value,number_of_element_values)))
					{
						element_value=element_values;
						/* calculate each element value as a linear combination of global
							values */
						j=number_of_element_values;
						return_code=1;
						while (return_code&&(j>0))
						{
							*element_value=0;
							if ((linear_combination= *linear_combination_address)&&
								((k=linear_combination->number_of_global_values)>0)&&
								(global_value_index=linear_combination->global_value_indices)&&
								(coefficient_index=linear_combination->coefficient_indices))
							{
								while (return_code&&(k>0))
								{
									/* if there is not a global value use 0 */
									if ((0<=(value_index= *global_value_index))&&
										(value_index<number_of_global_values))
									{
										get_FE_field_FE_value_value(field,value_index,&fe_value);
										/* if there is not a coefficient use 1 as the coefficient */
										if ((0<=(scale_index= *coefficient_index))&&
											(scale_index<number_of_scale_factors))
										{
											
											*element_value += fe_value*scale_factors[scale_index];
										}
										else
										{
											*element_value +=	fe_value;
										}
									}
									global_value_index++;
									coefficient_index++;
									k--;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"global_to_element_map_values.  Missing linear combination");
								DEALLOCATE(element_values);
								return_code=0;
							}
							element_value++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
				"global_to_element_map_values.  Could not allocate memory for values");
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Missing element/field information");
					return_code=0;
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"global_to_element_map_values.  Invalid map type");
				return_code=0;
			} break;
		}
		if (return_code)
		{
			/* if necessary, modify the calculated element values */
			if (component->modify)
			{
/*???debug */
/*printf("Element %d %d %d\n",element->cmiss.element_number,
	element->cmiss.face_number,element->cmiss.line_number);
printf("unmodified values :");
for (i=0;i<number_of_element_values;i++)
{
	printf(" %g",element_values[i]);
}
printf("\n");*/
				return_code=(component->modify)(component,element,field,
					number_of_element_values,element_values);
/*???debug */
/*printf("modified values :");
for (i=0;i<number_of_element_values;i++)
{
	printf(" %g",element_values[i]);
}
printf("\n");*/
			}
			if (return_code)
			{
				/* check that there is a valid basis */
				if ((basis=component->basis)&&
					(number_of_element_values==basis->number_of_basis_functions)&&
					(basis->standard_basis)&&((number_of_blended_element_values=
					basis->number_of_standard_basis_functions)>0))
				{
					/* if there is a blending matrix then the element values are the
						product of the element values and the blending matrix */
					if (blending_matrix=basis->blending_matrix)
					{
						/* allocate storage for the blended element values */
						if (ALLOCATE(blended_element_values,FE_value,
							number_of_blended_element_values))
						{
/*???debug */
/*{
	FE_value *value;
	int i;

	printf("unblended values :");
	value=element_values;
	i=number_of_element_values;
	while (i>0)
	{
		printf(" %.10g",*value);
		value++;
		i--;
	}
	printf("\n");
}*/
							/* calculate the blended element values */
							blended_element_value=blended_element_values;
							for (i=number_of_blended_element_values;i>0;i--)
							{
								*blended_element_value=0;
								blended_element_value++;
							}
							element_value=element_values;
							for (j=number_of_element_values;j>0;j--)
							{
								temp_value= *element_value;
								blended_element_value=blended_element_values;
								for (i=number_of_blended_element_values;i>0;i--)
								{
									*blended_element_value += (*blending_matrix)*temp_value;
									blended_element_value++;
									blending_matrix++;
								}
								element_value++;
							}
/*???debug */
/*{
	FE_value *value;
	int i;

	printf("blended values :");
	value=blended_element_values;
	i=number_of_blended_element_values;
	while (i>0)
	{
		printf(" %.10g",*value);
		value++;
		i--;
	}
	printf("\n");
}*/
							*values=blended_element_values;
							*number_of_values=number_of_blended_element_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
"global_to_element_map_values.  Could not allocate memory for blended values");
							return_code=0;
						}
						DEALLOCATE(element_values);
					}
					else
					{
						*values=element_values;
						*number_of_values=number_of_element_values;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Invalid basis");
					DEALLOCATE(element_values);
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"global_to_element_map_values.  Error modifying element values");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"global_to_element_map_values.  Invalid argument(s)");
		return_code=0;
	}
/*???debug */
/*printf("leave global_to_element_map_values\n");*/
	LEAVE;

	return (return_code);
} /* global_to_element_map_values */

static int global_to_element_map_nodes(
	struct FE_element_field_component *component,struct FE_element *element,
	struct FE_field *field,int *number_of_values,
	struct FE_node ***element_values_address)
/*******************************************************************************
LAST MODIFIED : 9 February 1998

DESCRIPTION :
The standard function for calculating the nodes used for a <component>.
Calculates the <number_of_values> and the node used to calculate each element
value for a <component>.  The storage for the nodes array
(<*element_values_address>) is allocated by the function.
==============================================================================*/
{
	int j,k,number_of_element_nodes,number_of_element_values,number_of_map_values,
	 return_code;
	struct FE_node **element_value,**element_values,*node,**nodes;
	struct General_node_to_element_map *general_node_map,
		**general_node_map_address;
	struct Standard_node_to_element_map *standard_node_map,
		**standard_node_map_address;

	ENTER(global_to_element_map_nodes);
/*???debug */
/*printf("enter global_to_element_map_nodes\n");*/
	/* check the arguments */
	if (component&&element&&field&&number_of_values&&element_values_address)
	{
		/* retrieve the element values */
		switch (component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
			{
				/* check information */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->number_of_nodes)>0))
				{
					/* calculate the number of element values by summing the numbers
						of values retrieved from each node */
					number_of_element_values=0;
					standard_node_map_address=
						component->map.standard_node_based.node_to_element_maps;
					j=component->map.standard_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((standard_node_map= *standard_node_map_address)&&
							((number_of_map_values=
							standard_node_map->number_of_nodal_values)>0)&&
							(0<=standard_node_map->node_index)&&
							(standard_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[standard_node_map->node_index])&&(node->values_storage)&&
							(node->fields)&&(standard_node_map->nodal_value_indices)&&
							(standard_node_map->scale_factor_indices))
						{
							number_of_element_values += number_of_map_values;
							standard_node_map_address++;
							j--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Invalid standard node to element map");
							return_code=0;
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&(ALLOCATE(element_values,
							struct FE_node *,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							standard_node_map_address=
								component->map.standard_node_based.node_to_element_maps;
							for (j=component->map.standard_node_based.number_of_nodes;j>0;
								j--)
							{
								/* retrieve the scaled nodal values */
								standard_node_map= *standard_node_map_address;
								node=nodes[standard_node_map->node_index];
								for (k=standard_node_map->number_of_nodal_values;k>0;k--)
								{
									*element_value=node;
									element_value++;
								}
								standard_node_map_address++;
							}
							*element_values_address=element_values;
							*number_of_values=number_of_element_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_nodes.  Missing element information");
					return_code=0;
				}
			} break;
			case GENERAL_NODE_TO_ELEMENT_MAP:
			/* global values are associated with nodes */
			{
				/* check information */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->
					 number_of_nodes)>0))
				{
					/* calculate the number of element values by summing the numbers
						of values retrieved from each node */
					number_of_element_values=0;
					general_node_map_address=
						component->map.general_node_based.node_to_element_maps;
					j=component->map.general_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((general_node_map= *general_node_map_address)&&
							((number_of_map_values=
							general_node_map->number_of_nodal_values)>0)&&
							(0<=general_node_map->node_index)&&
							(general_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[general_node_map->node_index])&&(node->values_storage)&&
							(node->fields)&&(general_node_map->element_values))
						{
							number_of_element_values += number_of_map_values;
							general_node_map_address++;
							j--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Invalid general node to element map");
							return_code=0;
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&(ALLOCATE(element_values,
							struct FE_node *,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							general_node_map_address=
								component->map.general_node_based.node_to_element_maps;
							for (j=component->map.general_node_based.number_of_nodes;j>0;
								j--)
							{
								/* retrieve the scaled nodal values */
								general_node_map= *general_node_map_address;
								node=nodes[general_node_map->node_index];
								for (k=general_node_map->number_of_nodal_values;k>0;k--)
								{
									*element_value=node;
									element_value++;
								}
								general_node_map_address++;
							}
							*element_values_address=element_values;
							*number_of_values=number_of_element_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_nodes.  Missing element information");
					return_code=0;
				}
			} break;
			case FIELD_TO_ELEMENT_MAP:
			/* global values are associated with the field */
			{
				/*???DB.  What to do ? */
				return_code=0;
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Invalid map type");
				return_code=0;
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"global_to_element_map_nodes.  Invalid argument(s)");
		return_code=0;
	}
/*???debug */
/*printf("leave global_to_element_map_nodes\n");*/
	LEAVE;

	return (return_code);
} /* global_to_element_map_nodes */

static int calculate_standard_basis_transformation(struct FE_basis *basis,
	FE_value *coordinate_transformation,int inherited_dimension,
	int **inherited_arguments_address,int *number_of_inherited_values_address,
	FE_value **blending_matrix_address,int **field_to_element_address,
	int **reorder_coordinates_address)
/*******************************************************************************
LAST MODIFIED : 28 July 1998

DESCRIPTION :
==============================================================================*/
{
	FE_value *blending_matrix,*expanded_coordinate_transformation,*transformation,
		*value;
	int basis_dimension,*field_to_element,i,*inherited_standard_basis_argument,
		*inherited_standard_basis_arguments,j,k,l,number_of_inherited_values,
		number_of_polygon_verticies,offset,order,p,polygon_offset,
		*reorder_coordinate,return_code,row_size,*standard_basis_argument,
		*standard_basis_arguments;
	Standard_basis_function *standard_basis_function;

	ENTER(calculate_standard_basis_transformation);
#if defined (DEBUG)
	/*???debug */
	printf("enter calculate_standard_basis_transformation\n");
#endif /* defined (DEBUG) */
	return_code=0;
	/* check arguments */
	if (basis&&(inherited_dimension>0)&&inherited_arguments_address&&
		blending_matrix_address&&field_to_element_address&&
		reorder_coordinates_address)
	{
		standard_basis_arguments=(int *)(basis->arguments);
		standard_basis_function=basis->standard_basis;
		basis_dimension=(basis->type)[0];
		if (monomial_basis_functions==standard_basis_function)
		{
			/* calculate the blending matrix from the monomial basis for the full
				<basis> to the inherited monomial basis */
			ALLOCATE(inherited_standard_basis_arguments,int,inherited_dimension+1);
			ALLOCATE(expanded_coordinate_transformation,FE_value,
				(basis_dimension+1)*(inherited_dimension+1));
			if (inherited_standard_basis_arguments&&
				expanded_coordinate_transformation)
			{
				inherited_standard_basis_argument=
					inherited_standard_basis_arguments;
				*inherited_standard_basis_argument=inherited_dimension;
				for (i=inherited_dimension;i>0;i--)
				{
					inherited_standard_basis_argument++;
					*inherited_standard_basis_argument=0;
				}
				standard_basis_argument=standard_basis_arguments;
				expanded_coordinate_transformation[0]=1;
				transformation=expanded_coordinate_transformation;
				for (j=inherited_dimension;j>0;j--)
				{
					transformation++;
					*transformation=0;
				}
				if (value=coordinate_transformation)
				{
					for (i=basis_dimension;i>0;i--)
					{
						standard_basis_argument++;
						if ((order= *standard_basis_argument)<0)
						{
							/* simplex */
							j=0;
							k=0;
							do
							{
								k += standard_basis_argument[j];
								j++;
							}
							while ((standard_basis_argument[j]<0)&&
								(-basis_dimension<standard_basis_argument[j]));
							order=(-standard_basis_argument[j])/basis_dimension;
							k += (-standard_basis_argument[j])%basis_dimension;
							if (0==k)
							{
								/* first dimension */
								k=0;
								j=0;
								while (standard_basis_argument[j]<0)
								{
									inherited_standard_basis_argument=
										inherited_standard_basis_arguments;
									for (l=0;l<=inherited_dimension;l++)
									{
										transformation++;
										*transformation=value[k*(inherited_dimension+1)+l];
										if (l>0)
										{
											inherited_standard_basis_argument++;
#if defined (OLD_CODE)
											if ((0!= *transformation)&&
												(order> *inherited_standard_basis_argument))
											{
												*inherited_standard_basis_argument=order;
											}
#endif /* defined (OLD_CODE) */
											if (0!= *transformation)
											{
												*inherited_standard_basis_argument += order;
											}
										}
									}
									k -= standard_basis_argument[j];
									j++;
								}
							}
							else
							{
								/* not first */
								value += inherited_dimension;
							}
						}
						else
						{
							inherited_standard_basis_argument=
								inherited_standard_basis_arguments;
							for (j=inherited_dimension;j>=0;j--)
							{
								transformation++;
								*transformation= *value;
								value++;
								if (j>0)
								{
									inherited_standard_basis_argument++;
									if ((0!= *value)&&(order> *inherited_standard_basis_argument))
									{
										*inherited_standard_basis_argument=order;
									}
								}
							}
						}
					}
				}
				else
				{
/*???debug */
/*printf("no coordinate_transformation\n");*/
					for (i=basis_dimension*(inherited_dimension+1);i>0;i--)
					{
						transformation++;
						*transformation=0;
					}
					transformation=expanded_coordinate_transformation+
						(inherited_dimension+1);
					inherited_standard_basis_argument=
						inherited_standard_basis_arguments;
					i=1;
					while (i<=basis_dimension)
					{
/*???debug */
/*printf("i=%d\n",i);*/
						standard_basis_argument++;
						inherited_standard_basis_argument++;
						if ((order= *standard_basis_argument)<0)
						{
							/* simplex */
							j=0;
							do
							{
								j++;
							}
							while ((standard_basis_argument[j]<0)&&
								(-basis_dimension<standard_basis_argument[j]));
							order=(-standard_basis_argument[j])/basis_dimension;
/*???debug */
/*printf("order=%d\n",order);*/
							transformation[i]=1;
							transformation += inherited_dimension+1;
							*inherited_standard_basis_argument=order;
							j=i;
							do
							{
								j -= *standard_basis_argument;
								transformation[j]=1;
								transformation += inherited_dimension+1;
								standard_basis_argument++;
								i++;
								inherited_standard_basis_argument++;
								*inherited_standard_basis_argument=order;
							}
							while ((*standard_basis_argument<0)&&
								(-basis_dimension< *standard_basis_argument));
							i++;
						}
						else
						{
							transformation[i]=1;
							i++;
							transformation += inherited_dimension+1;
							*inherited_standard_basis_argument=order;
						}
					}
				}
/*???debug */
/*printf("expanded_coordinate_transformation: %p\n",
expanded_coordinate_transformation);
if (value=expanded_coordinate_transformation)
{
for (i=basis_dimension+1;i>0;i--)
{
for (j=inherited_dimension+1;j>0;j--)
{
printf(" %g",*value);
value++;
}
printf("\n");
}
}*/
				row_size=basis->number_of_standard_basis_functions;
				number_of_inherited_values=1;
				inherited_standard_basis_argument=
					inherited_standard_basis_arguments;
/*???debug */
/*printf("inherited_standard_basis_arguments : %d",
	*inherited_standard_basis_argument);*/
				for (j=inherited_dimension;j>0;j--)
				{
					inherited_standard_basis_argument++;
					number_of_inherited_values *= (*inherited_standard_basis_argument)+1;
/*???debug */
/*printf(" %d",*inherited_standard_basis_argument);*/
				}
/*???debug */
/*printf("\n");*/
/*???debug */
/*printf("size %d %d\n",row_size,number_of_inherited_values);*/
				if (ALLOCATE(blending_matrix,FE_value,
					row_size*number_of_inherited_values))
				{
					value=blending_matrix;
					*value=1;
					for (i=row_size*number_of_inherited_values-1;i>0;i--)
					{
						value++;
						*value=0;
					}
					standard_basis_argument=standard_basis_arguments;
					row_size=1;
					transformation=expanded_coordinate_transformation+
						(inherited_dimension+1);
					for (i=basis_dimension;i>0;i--)
					{
						standard_basis_argument++;
						if ((order= *standard_basis_argument)<0)
						{
							/* simplex */
							j=0;
							while ((standard_basis_argument[j]<0)&&
								(-basis_dimension<standard_basis_argument[j]))
							{
								j++;
							}
							order=(-standard_basis_argument[j])/
								basis_dimension;
							/*???DB.  If didn't store blending matrix for full monomials with
								the basis, would have to do somethingdifferent here */
						}
/*???debug */
/*printf("%d order %d\n",i,order);*/
						for (j=0;j<order;j++)
						{
							offset=0;
							for (k=0;k<=inherited_dimension;k++)
							{
								if (0!= *transformation)
								{
									/* loop over blending matrix rows */
									value=blending_matrix+(j*row_size*number_of_inherited_values);
									for (l=0;l<row_size;l++)
									{
										for (p=number_of_inherited_values-offset;p>0;p--)
										{
											if (0!= *value)
											{
/*???debug */
/*printf("non-zero %d %d %d %d\n",value-blending_matrix,transformation-
expanded_coordinate_transformation,row_size,offset);*/
												value[row_size*number_of_inherited_values+offset] +=
													(*value)*(*transformation);
											}
											value++;
										}
										value += offset;
									}
								}
								if (k>0)
								{
									offset *=
										(1+inherited_standard_basis_arguments[k]);
								}
								else
								{
									offset=1;
								}
								transformation++;
							}
							transformation -= inherited_dimension+1;
						}
						transformation += inherited_dimension+1;
						row_size *= (order+1);
					}
					*inherited_arguments_address=inherited_standard_basis_arguments;
					*blending_matrix_address=blending_matrix;
					*number_of_inherited_values_address=number_of_inherited_values;
					return_code=1;
/*???debug */
/*printf("blending_matrix:\n");
value=blending_matrix;
for (i=row_size;i>0;i--)
{
	for (j=number_of_inherited_values;j>0;j--)
	{
		printf(" %g",*value);
		value++;
	}
	printf("\n");
}*/
				}
				else
				{
					display_message(ERROR_MESSAGE,
"calculate_standard_basis_transformation.  Insufficient memory for blending_matrix");
					DEALLOCATE(inherited_standard_basis_arguments);
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_standard_basis_transformation.  Insufficient memory 1");
				DEALLOCATE(inherited_standard_basis_arguments);
				return_code=0;
			}
			DEALLOCATE(expanded_coordinate_transformation);
		}
		else
		{
			if (polygon_basis_functions==standard_basis_function)
			{
				if (coordinate_transformation)
				{
					field_to_element= *field_to_element_address;
					if (!field_to_element)
					{
						/* determine the correspondence between the xi coordinates
							for the element field and the xi coordinates for the
							element */
						/*???DB.  At present only able to do transformations that
							are one to one in the xi coordinates.  This is
							equivalent to one non-zero in each column of A and at
							most one non-zero in each row of A */
						/*???DB.  Can this be incorporated into the blending
							matrix idea for the monomial basis */
/*???debug */
/*{
FE_value *value;
int i,j;

printf("polygon coordinate transformation %d %d\n",inherited_dimension,
basis_dimension);
value=coordinate_transformation;
for (i=basis_dimension;i>0;i--)
{
printf("%g  ",*value);
value++;
for (j=inherited_dimension;j>0;j--)
{
printf(" %g",*value);
value++;
}
printf("\n");
}
}*/
						ALLOCATE(field_to_element,int,basis_dimension);
						ALLOCATE(reorder_coordinate,int,inherited_dimension);
						if (field_to_element&&reorder_coordinate)
						{
							*field_to_element_address=field_to_element;
							*reorder_coordinates_address=reorder_coordinate;
							return_code=1;
							i=0;
							/* for keeping track of whether or not the coordinates
								need reordering */
							k=0;
							transformation=coordinate_transformation;
							while (return_code&&(i<basis_dimension))
							{
								field_to_element[i]=0;
								/* skip translate b */
								transformation++;
								/* examine matrix A */
								j=0;
								while (return_code&&(j<inherited_dimension))
								{
									if (0!= *transformation)
									{
										if (0==field_to_element[i])
										{
											field_to_element[i]=j+1;
											*reorder_coordinate=j;
											reorder_coordinate++;
											if (j==k)
											{
												k++;
											}
											else
											{
												k= -1;
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
"calculate_standard_basis_transformation.  Coordinate transformation not 1 to 1");
											return_code=0;
										}
									}
									transformation++;
									j++;
								}
								i++;
							}
/*???debug */
/*printf("field to element :");
for (i=0;i<basis_dimension;i++)
{
printf(" %d",field_to_element[i]);
}
printf("\n");
printf("k=%d\n",k);*/
							if (return_code)
							{
								if (-1!=k)
								{
									/* coordinate reordering is not needed */
									DEALLOCATE(*reorder_coordinates_address);
								}
							}
							else
							{
								DEALLOCATE(*field_to_element_address);
								DEALLOCATE(*reorder_coordinates_address);
								display_message(ERROR_MESSAGE,
"calculate_standard_basis_transformation.  Invalid coordinate transformation");
								return_code=0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
							"calculate_standard_basis_transformation.  Insufficient memory");
							DEALLOCATE(*field_to_element_address);
							DEALLOCATE(*reorder_coordinates_address);
							return_code=0;
						}
					}
					if (return_code)
					{
						field_to_element= *field_to_element_address;
						/* calculate the arguments for the standard basis
							function */
						if (ALLOCATE(inherited_standard_basis_arguments,int,
							inherited_dimension+1))
						{
							*inherited_arguments_address=inherited_standard_basis_arguments;
							number_of_inherited_values=1;
							if (reorder_coordinate= *reorder_coordinates_address)
							{
								inherited_standard_basis_argument=
									inherited_standard_basis_arguments;
								*inherited_standard_basis_argument=inherited_dimension;
								inherited_standard_basis_argument++;
								standard_basis_argument=standard_basis_arguments;
/*???debug */
/*printf("field to element :");*/
								for (i=0;i<basis_dimension;i++)
								{
									standard_basis_argument++;
									order= *standard_basis_argument;
/*???debug */
/*printf(" %d",field_to_element[i]);*/
									if (order<0)
									{
										/* polygon */
										polygon_offset= -order;
										if (polygon_offset<basis_dimension)
										{
											/* first polygon coordinate */
											number_of_polygon_verticies=
												-standard_basis_argument[polygon_offset]-
												basis_dimension;
											if (field_to_element[i])
											{
												if (field_to_element[i+polygon_offset])
												{
													/*???DB.  Assume that reordering does NOT
														reorder polygon_coordinates */
													inherited_standard_basis_argument
														[*reorder_coordinate]=field_to_element[i]-
														field_to_element[i+polygon_offset];
													number_of_inherited_values *=
														4*number_of_polygon_verticies;
												}
												else
												{
													inherited_standard_basis_argument
														[*reorder_coordinate]=1;
													number_of_inherited_values *= 2;
												}
												reorder_coordinate++;
											}
										}
										else
										{
											/* second polygon coordinate */
											if (field_to_element[i])
											{
												inherited_standard_basis_argument
													[*reorder_coordinate]=
													*standard_basis_argument+
													basis_dimension-inherited_dimension;
												reorder_coordinate++;
											}
										}
									}
									else
									{
										/* not polygon */
										if (field_to_element[i])
										{
											inherited_standard_basis_argument
												[*reorder_coordinate]=
												*standard_basis_argument;
											reorder_coordinate++;
											number_of_inherited_values *= order+1;
										}
									}
								}
/*???debug */
/*printf("\n");*/
							}
							else
							{
								inherited_standard_basis_argument=
									inherited_standard_basis_arguments;
								*inherited_standard_basis_argument=inherited_dimension;
								standard_basis_argument=standard_basis_arguments;
								for (i=0;i<basis_dimension;i++)
								{
									standard_basis_argument++;
									order= *standard_basis_argument;
/*???debug */
/*printf("%d %d %d %d\n",i,order,field_to_element[i],basis_dimension);*/
									if (order<0)
									{
										/* polygon */
										polygon_offset= -order;
										if (polygon_offset<basis_dimension)
										{
											/* first polygon coordinate */
											number_of_polygon_verticies=
												-standard_basis_argument[polygon_offset]-
												basis_dimension;
											if (field_to_element[i])
											{
												if (field_to_element[i+polygon_offset])
												{
													inherited_standard_basis_argument++;
													*inherited_standard_basis_argument=
														field_to_element[i]-
														field_to_element[i+polygon_offset];
													number_of_inherited_values *=
														4*number_of_polygon_verticies;
												}
												else
												{
													inherited_standard_basis_argument++;
													*inherited_standard_basis_argument=1;
													number_of_inherited_values *= 2;
												}
											}
										}
										else
										{
											/* second polygon coordinate */
											if (field_to_element[i])
											{
												inherited_standard_basis_argument++;
												*inherited_standard_basis_argument=
													(*standard_basis_argument)+
													basis_dimension-inherited_dimension;
											}
										}
									}
									else
									{
										/* not polygon */
										if (field_to_element[i])
										{
											inherited_standard_basis_argument++;
											*inherited_standard_basis_argument=
												*standard_basis_argument;
											number_of_inherited_values *= order+1;
										}
									}
								}
							}
							*number_of_inherited_values_address=number_of_inherited_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
							"calculate_standard_basis_transformation.  Insufficient memory");
							return_code=0;
						}
					}
				}
				else
				{
					return_code=1;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_standard_basis_transformation.  Invalid basis");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(WARNING_MESSAGE,
			"calculate_standard_basis_transformation.  Invalid argument(s)");
		return_code=0;
	}
#if defined (DEBUG)
	/*???debug */
	printf("leave calculate_standard_basis_transformation %d\n",return_code);
#endif /* defined (DEBUG) */
	LEAVE;

	return (return_code);
} /* calculate_standard_basis_transformation */

#if defined (OLD_CODE)
static int merge_FE_node_into_list(struct FE_node *node,void *list_void)
/*******************************************************************************
LAST MODIFIED : 9 February 1998

DESCRIPTION :
Adds the <node> to the list if its not already in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *list;

	ENTER(merge_FE_node_into_list);
	return_code=0;
	/* check arguments */
	if (node&&(list=(struct LIST(FE_node) *)list_void))
	{
		if (IS_OBJECT_IN_LIST(FE_node)(node,list))
		{
			return_code=1;
		}
		else
		{
			return_code=ADD_OBJECT_TO_LIST(FE_node)(node,list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_node_into_list.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* merge_FE_node_into_list */
#endif /* defined (OLD_CODE) */

static int FE_element_parent_contains_node(
	struct FE_element_parent *element_parent,void *node_void)
/*******************************************************************************
LAST MODIFIED : 10 February 1998

DESCRIPTION :
Calls FE_element_contains_node for the element in the FE_element_parent.
==============================================================================*/
{
	int return_code;
	struct FE_node *node;

	ENTER(FE_element_parent_contains_node);
	if (element_parent&&(node=(struct FE_node *)node_void))
	{
		return_code=FE_element_or_parent_contains_node(element_parent->parent,node);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_contains_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_contains_node */

struct Check_element_grid_map_values_storage_data
{
	int check_sum,values_storage_size;
}; /* struct Check_element_grid_map_values_storage_data */

static int check_element_grid_map_values_storage(
	struct FE_element_field *element_field,
	void *check_element_grid_map_values_storage_data_void)
/*******************************************************************************
LAST MODIFIED : 18 October 1999

DESCRIPTION :
If the <element_field> is grid based, check that the index range is within the
values_storage array and add the values_storage size it requires to the
check_sum.
==============================================================================*/
{
	int i,j,*number_in_xi,number_of_values,return_code,size,value_index,
		values_storage_size;
	struct Check_element_grid_map_values_storage_data *check_grid_data;
	struct FE_element_field_component **component;

	ENTER(check_element_grid_map_values_storage);
	return_code=0;
	if (element_field&&element_field->field&&(check_grid_data=
		(struct Check_element_grid_map_values_storage_data *)
		check_element_grid_map_values_storage_data_void))
	{
		return_code=1;
		/* only GENERAL_FE_FIELD has components and can be grid-based */
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			size=get_Value_storage_size(element_field->field->value_type);
			component=element_field->components;
			for (i=element_field->field->number_of_components;(0<i)&&return_code;i--)
			{
				if (ELEMENT_GRID_MAP==(*component)->type)
				{
					number_in_xi=((*component)->map).element_grid_based.number_in_xi;
					number_of_values=1;
					for (j=((*component)->basis->type)[0];j>0;j--)
					{
						number_of_values *= (*number_in_xi)+1;
						number_in_xi++;
					}
					value_index=((*component)->map).element_grid_based.value_index;
					values_storage_size = number_of_values*size;
					if ((value_index<check_grid_data->values_storage_size)&&
						(value_index+values_storage_size <=
							check_grid_data->values_storage_size))
					{
						check_grid_data->check_sum += values_storage_size;
					}
					else
					{
						return_code=0;
					}
				}
				component++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"check_element_grid_map_values_storage.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* check_element_grid_map_values_storage */

static int for_FE_field_at_node_iterator(struct FE_node_field *node_field,
	void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
FE_node_field iterator for for_each_FE_field_at_node.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_node_iterator);
	if (node_field&&(iterator_and_data=
		(struct FE_node_field_iterator_and_data *)iterator_and_data_void)&&
		iterator_and_data->iterator)
	{
		return_code=(iterator_and_data->iterator)(iterator_and_data->node,
			node_field->field,iterator_and_data->user_data);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_node_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_node_iterator */

static int FE_node_field_add_indexer_field_to_list(
	struct FE_node_field *node_field,void *field_list_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
If the field in the <node_field> is of type INDEXED_FE_FIELD, function ensures
its indexer_field is put in the <field_list>.
Used by for_each_FE_field_at_node_indexer_first to put indexer_fields into a
priority list for iterating through first.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;
	struct LIST(FE_field) *field_list;

	ENTER(FE_node_field_add_indexer_field_to_list);
	if (node_field&&(field=node_field->field)&&
		(field_list=(struct LIST(FE_field) *)field_list_void))
	{
		return_code=1;
		if (INDEXED_FE_FIELD==field->fe_field_type)
		{
			if (!IS_OBJECT_IN_LIST(FE_field)(field->indexer_field,field_list))
			{
				return_code=
					ADD_OBJECT_TO_LIST(FE_field)(field->indexer_field,field_list);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_add_indexer_field_to_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_add_indexer_field_to_list */

static int for_FE_field_at_node_priority_iterator(
	struct FE_node_field *node_field,void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
FE_node_field iterator for for_each_FE_field_at_node. Only calls the iterator
function if the priority_on flag matches the field status in priority_list.
==============================================================================*/
{
	int priority_field,return_code;
	struct FE_node_field_priority_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_node_iterator);
	if (node_field&&(iterator_and_data=
		(struct FE_node_field_priority_iterator_and_data *)iterator_and_data_void)&&
		iterator_and_data->iterator)
	{
		priority_field=IS_OBJECT_IN_LIST(FE_field)(node_field->field,
			iterator_and_data->priority_field_list);
		if ((iterator_and_data->priority_on&&priority_field)||
			((!iterator_and_data->priority_on)&&(!priority_field)))
		{
			return_code=(iterator_and_data->iterator)(iterator_and_data->node,
				node_field->field,iterator_and_data->user_data);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_node_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_node_iterator */

static int find_FE_nodal_values_storage_dest(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,enum Value_type value_type,
	Value_storage **values_storage)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION :
Returns a pointer to the nodal values_storage for the given node, component,
version, type, value_type.
Returns 0 with no error in cases where the version or type is not stored, hence
can use this function to determing if either are defined.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type;
	int i,length,return_code,size;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	Value_storage *the_values_storage = (Value_storage *)NULL;

	ENTER(find_FE_nodal_values_storage_dest);
	return_code=0;
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if (node_field=find_FE_node_field_in_info(component->field,node->fields))
		{
			if (node_field_component=node_field->components)
			{
				if (node_field->field->value_type == value_type)
				{					
					node_field_component += component->number;
					if (version < node_field_component->number_of_versions)
					{
						if (nodal_value_type=node_field_component->nodal_value_types)
						{
							length=1+(node_field_component->number_of_derivatives);
							i=0;
							while ((i<length) && (type != nodal_value_type[i]))
							{
								i++;
							}
							if (i<length)
							{
								size = get_Value_storage_size(value_type);
								the_values_storage = node->values_storage +
									(node_field_component->value) + ((version*length+i)*size);
								*values_storage = the_values_storage;
								return_code=1;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"find_FE_nodal_values_storage_dest.  "
								"Missing nodal_value_type array");
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"find_FE_nodal_values_storage_dest.  value_type mismatch");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"find_FE_nodal_values_storage_dest.  Invalid node/field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"find_FE_nodal_values_storage_dest.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* find_FE_nodal_values_storage_dest */

static int FE_node_field_has_embedded_element(struct FE_node_field *node_field,
	void *data_void)
/*******************************************************************************
LAST MODIFIED : 28 April 1999

DESCRIPTION :
Returns true if <node> conatins a field which depends on <element_void>.
==============================================================================*/
{
	FE_value xi[MAXIMUM_ELEMENT_XI_DIMENSIONS];
	int i, j, return_code;
	struct FE_element *element;
	struct FE_node_field_has_embedded_element_data *data;

	ENTER(FE_node_field_has_embedded_element);

	return_code = 0;
	if (node_field&&(data=(struct FE_node_field_has_embedded_element_data *)data_void))
	{
		if (ELEMENT_XI_VALUE==get_FE_field_value_type(node_field->field))
		{
			for (i = 0 ; (!return_code) && (i < get_FE_field_number_of_components(node_field->field)) ; i++)
			{
				for (j = 0 ; (!return_code) && (j < get_FE_node_field_component_number_of_versions(
					data->node, node_field->field, i)) ; j++)
				{
					if (get_FE_nodal_element_xi_value(data->node,
						node_field->field, i, j, FE_NODAL_VALUE,
						&element, xi))
					{
						if (element)
						{
							if (element == data->changed_element)
							{
								return_code = 1;
							}
							else
							{
								if (data->changed_node)
								{
									return_code = FE_element_or_parent_contains_node(element,
										(void *)data->changed_node);
								}
							}
						}
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_field_has_embedded_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_has_embedded_element */

static int FE_element_parent_is_in_group(
	struct FE_element_parent *element_parent,void *element_group_void)
/*******************************************************************************
LAST MODIFIED : 14 April 1999

DESCRIPTION :
Returns true if the parent element referred to by the <element_parent> is in the
<element_group>.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_element) *element_group;

	ENTER(FE_element_parent_is_in_group);
	if (element_parent&&element_parent->parent&&
		(element_group=(struct GROUP(FE_element) *)element_group_void))
	{
		if (FIND_BY_IDENTIFIER_IN_GROUP(FE_element,identifier)(
			element_parent->parent->identifier,element_group))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_is_in_group.  Invalid argument(s)");
		return_code=0;
	}

	return (return_code);
} /* FE_element_parent_is_in_group */

static int FE_element_parent_remove_face(
	struct FE_element_parent *element_parent,void *face_element_void)
/*******************************************************************************
LAST MODIFIED : 14 April 1999

DESCRIPTION :
Takes the <face_element> out of the faces array of the parent element referred
to by the <element_parent>.
==============================================================================*/
{
	int return_code;
	struct FE_element **parent_faces,*face_element;

	ENTER(FE_element_parent_remove_face);
	if (element_parent&&(face_element=(struct FE_element *)face_element_void))
	{
		if (element_parent->parent&&(parent_faces=element_parent->parent->faces)&&
			(parent_faces[element_parent->face_number] == face_element))
		{
			DEACCESS(FE_element)(&(parent_faces[element_parent->face_number]));
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_parent_remove_face.  Invalid element_parent or faces");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_remove_face.  Invalid argument(s)");
		return_code=0;
	}

	return (return_code);
} /* FE_element_parent_remove_face */

static char *get_automatic_component_name(char **component_names,
	int component_no)
/*******************************************************************************
LAST MODIFIED : 28 January 1999

DESCRIPTION :
Used internally by some FE_field functions. Returns an allocated string
containing the component name for <component_no> (starting at 0 for the first).
If <component_names> or component_names[component_no] are NULL a name consisting
of the value component_no+1 is created and returned.
If <component_names> is not NULL, the function assumes that component_no is
less than the number of names in this array.
It is up to the calling function to deallocate the returned string.
==============================================================================*/
{
	char *component_name,*source_name,temp_string[20];

	ENTER(get_automatic_component_name);
	if (0<=component_no)
	{
		if (component_names&&component_names[component_no])
		{
			source_name=component_names[component_no];
		}
		else
		{
			sprintf(temp_string,"%i",component_no+1);
			source_name=temp_string;
		}
		component_name = duplicate_string(source_name);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_automatic_component_name.  Invalid component_no");
		component_name=(char *)NULL;
	}
	LEAVE;

	return (component_name);
} /* get_automatic_component_name */

static int FE_element_parent_has_field(struct FE_element_parent *element_parent,
	void *element_has_field_data_void)
{
	int return_code;
	struct FE_element_parent_has_field_data *element_has_field_data;

	ENTER(FE_element_parent_has_field);
	return_code=0;
	if (element_parent&&(element_has_field_data=
		(struct FE_element_parent_has_field_data *)element_has_field_data_void))
	{
		return_code=FE_element_or_parent_has_field(element_parent->parent,
			element_has_field_data->field,element_has_field_data->element_group);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_field.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_has_field */

static int FE_element_face_line_to_element_type_node_sequence_list(
	struct FE_element *element,void *element_type_node_sequence_list_void)
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
Iterator function; if <element> is type CM_LINE or CM_FACE, creates a struct
FE_element_type_node_sequence for it and adds it to the given list. Note that
function fails if two faces have the same shape and share the same nodes.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element_type_node_sequence) *element_type_node_sequence_list;
	struct FE_element_type_node_sequence *element_type_node_sequence;

	ENTER(FE_element_face_line_to_element_type_node_sequence_list);
	if (element&&(element_type_node_sequence_list=
		(struct LIST(FE_element_type_node_sequence) *)
		element_type_node_sequence_list_void))
	{
		return_code=1;
		if ((element->cm.type==CM_LINE)||(element->cm.type==CM_FACE))
		{
			if (element_type_node_sequence=
				CREATE(FE_element_type_node_sequence)(element))
			{
				if (!ADD_OBJECT_TO_LIST(FE_element_type_node_sequence)(
					element_type_node_sequence,element_type_node_sequence_list))
				{
					display_message(ERROR_MESSAGE,
						"FE_element_face_line_to_element_type_node_sequence_list.  "
						"Could not add FE_element_type_node_sequence to list");
					DESTROY(FE_element_type_node_sequence)(&element_type_node_sequence);
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_face_line_to_element_type_node_sequence_list.  "
					"Could not create FE_element_type_node_sequence");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_face_line_to_element_type_node_sequence_list.  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_face_line_to_element_type_node_sequence_list */

/*
Global functions
----------------
*/

struct FE_node *CREATE(FE_node)(int cm_node_identifier,
	struct FE_node *template_node)
/*******************************************************************************
LAST MODIFIED : 15 October 1999

DESCRIPTION :
Creates and returns a node with the specified <cm_node_identifier>. The node
is given the same fields and values_storage as <template_node>, or no fields if
no template is specified.
???DB.  Why is there a >=0 restriction on the <cm_node_identifier> ?
==============================================================================*/
{
	struct FE_node *node;
	struct FE_node_field_info *field_info;
	struct LIST(FE_node_field) *empty_node_field_list;
	Value_storage *values_storage;

	ENTER(CREATE(FE_node));
	node=(struct FE_node *)NULL;
	if ((0<=cm_node_identifier)&&((!template_node)||
		((template_node->fields)&&(0<=template_node->fields->number_of_values))))
	{
		field_info=(struct FE_node_field_info *)NULL;
		values_storage = (Value_storage *)NULL;
		if (template_node)
		{
			/* copy contents of template_node */
			field_info=ACCESS(FE_node_field_info)(template_node->fields);
			if (template_node->values_storage)
			{
				if (!allocate_and_copy_FE_node_value_storage(template_node,
					&values_storage))
				{
					display_message(ERROR_MESSAGE,"CREATE(FE_node).  "
						"Could not copy values storage... memory may be lost!");
					if (values_storage)
					{
						DEALLOCATE(values_storage);
					}
					DEACCESS(FE_node_field_info)(&field_info);
				}
			}
		}
		else
		{
			/* no template; create empty node field information */
			empty_node_field_list=CREATE_LIST(FE_node_field)();
			if (field_info=
				CREATE(FE_node_field_info)(0,empty_node_field_list))
			{
				ACCESS(FE_node_field_info)(field_info);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_node).  Could not create empty node field info");
			}
			DESTROY_LIST(FE_node_field)(&empty_node_field_list);
		}
		if (field_info)
		{
			/* allocate memory for the node */
			if (ALLOCATE(node,struct FE_node,1))
			{
				node->cm_node_identifier=cm_node_identifier;
				/* field_info is already ACCESSed, above */
				node->fields=field_info;
				node->values_storage=values_storage;
				node->access_count=0;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_node).  Could not allocate memory for node");
				DEACCESS(FE_node_field_info)(&field_info);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"CREATE(FE_node).  Invalid argument(s)");
	}
	LEAVE;

	return (node);
} /* CREATE(FE_node) */

#if defined (OLD_CODE)
struct FE_node *CREATE(FE_node)(int cm_node_identifier)
/*******************************************************************************
LAST MODIFIED : 27 October 1998

DESCRIPTION :
Creates a node.  The node is returned.
???DB.  Why is there a restriction on the <cm_node_identifier> ?
==============================================================================*/
{
	struct FE_node *node;
	struct FE_node_field_info *empty_node_field_info;
	struct LIST(FE_node_field) *empty_anatomical_node_field_list,
		*empty_coordinate_node_field_list,*empty_temp_node_field_list;

	ENTER(CREATE(FE_node));
	/* check the arguments */
	if (cm_node_identifier>=0)
	{
		empty_coordinate_node_field_list=CREATE_LIST(FE_node_field)();
		empty_anatomical_node_field_list=CREATE_LIST(FE_node_field)();
		empty_temp_node_field_list=CREATE_LIST(FE_node_field)();
		if (empty_node_field_info=CREATE(FE_node_field_info)(0,
			empty_coordinate_node_field_list,empty_anatomical_node_field_list,
			empty_temp_node_field_list))
		{
			/* allocate memory for the node */
			if (ALLOCATE(node,struct FE_node,1))
			{
				node->cm_node_identifier=cm_node_identifier;
				node->access_count=0;
				node->fields=ACCESS(FE_node_field_info)(empty_node_field_info);
				node->values=(FE_value *)NULL;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_node).  Could not allocate memory for node");
				DEALLOCATE(node);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_node).  Could not create field info");
			node=(struct FE_node *)NULL;
		}
		DESTROY_LIST(FE_node_field)(&empty_coordinate_node_field_list);
		DESTROY_LIST(FE_node_field)(&empty_anatomical_node_field_list);
		DESTROY_LIST(FE_node_field)(&empty_temp_node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,"CREATE(FE_node).  Invalid argument(s)");
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /* CREATE(FE_node) */
#endif /* defined (OLD_CODE) */

int DESTROY(FE_node)(struct FE_node **node_address)
/*******************************************************************************
LAST MODIFIED : 18 August 1999

DESCRIPTION :
Frees the memory for the node, sets <*node_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_node *node;

	ENTER(DESTROY(FE_node));
	if ((node_address)&&(node= *node_address))
	{
		if (0==node->access_count)
		{
			/* free the node values_storage */
			if(node->fields)
			{
				FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
					FE_node_field_free_values_storage_arrays,
					(void *)node,node->fields->node_field_list);		
				DEACCESS(FE_node_field_info)(&(node->fields));
			}
			DEALLOCATE(node->values_storage);

			/* free the memory associated with the node */
			DEALLOCATE(*node_address);
		}
		else
		{
			*node_address=(struct FE_node *)NULL;
		}
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node) */

DECLARE_OBJECT_FUNCTIONS(FE_node)

PROTOTYPE_COPY_OBJECT_FUNCTION(FE_node)
/*******************************************************************************
LAST MODIFIED : 17 March 1999

DESCRIPTION :
Creates an EXACT copy of the node.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_info *node_field_info;

	ENTER(COPY(FE_node));
	return_code=0;
	/* check the arguments */
	if (source&&destination)
	{
		DEACCESS(FE_node_field_info)(&(destination->fields));
		/* free the node values_storage */
		if(destination->fields)
		{			
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				FE_node_field_free_values_storage_arrays,
				(void *)destination,destination->fields->node_field_list);		
		}
		DEALLOCATE(destination->values_storage);

		/* copy the new */
		node_field_info=source->fields;
		if( allocate_and_copy_FE_node_value_storage(source,&(destination->values_storage)))
		{			
			destination->fields=ACCESS(FE_node_field_info)(node_field_info);
			destination->cm_node_identifier=source->cm_node_identifier;
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"COPY(FE_node).  Could not do copy_FE_node_value_storage for node");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"COPY(FE_node).  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* COPY(FE_node) */

PROTOTYPE_GET_OBJECT_NAME_FUNCTION(FE_node)
/*****************************************************************************
LAST MODIFIED : 5 November 1997

DESCRIPTION :
Returns the FE_node->cm_node_identifier identifier as a string.
Up to the calling routine to deallocate the returned char string!
============================================================================*/
{
	char temp_string[20];
	int return_code;

	ENTER(GET_NAME(FE_node));
	if (object&&name_ptr)
	{
		sprintf(temp_string,"%i",object->cm_node_identifier);
		if (ALLOCATE(*name_ptr,char,strlen(temp_string)+1))
		{
			strcpy(*name_ptr,temp_string);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"GET_NAME(FE_node).  Could not allocate space for name");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"GET_NAME(FE_node).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* GET_NAME(FE_node) */

struct FE_node_field_add_to_list_with_exclusion_data
{
	int value_exclusion_length,value_exclusion_start;
	struct FE_node_field *excluded_node_field;
	struct LIST(FE_node_field) *node_field_list;
};

static int FE_node_field_add_to_list_with_exclusion(
	struct FE_node_field *node_field,void *exclusion_data_void)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
If <node_field> is before the excluded_node_field, it is added to the list.
If <node_field> is the excluded_node_field, it is ignored.
If <node_field> is after the excluded_node_field, a copy of it is made with
a new value reduced by the <value_exclusion_length>.
==============================================================================*/
{
	int return_code;
	struct FE_node_field *offset_node_field;
	struct FE_node_field_add_to_list_with_exclusion_data *exclusion_data;

	ENTER(FE_node_field_add_to_list_with_exclusion);
	if (node_field && (exclusion_data=
		(struct FE_node_field_add_to_list_with_exclusion_data *)
		exclusion_data_void))
	{
		return_code=1;
		if (node_field != exclusion_data->excluded_node_field)
		{
			if ((GENERAL_FE_FIELD == node_field->field->fe_field_type) &&
				(node_field->components->value > exclusion_data->value_exclusion_start))
			{
				/* create copy of node_field with component->value reduced
					 by value_exclusion_length */
				if (offset_node_field=copy_create_FE_node_field_with_offset(
					node_field,-exclusion_data->value_exclusion_length))
				{
					if (!ADD_OBJECT_TO_LIST(FE_node_field)(offset_node_field,
						exclusion_data->node_field_list))
					{
						DESTROY(FE_node_field)(&offset_node_field);
						return_code=0;
					}
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				return_code=ADD_OBJECT_TO_LIST(FE_node_field)(node_field,
					exclusion_data->node_field_list);
			}
			if (!return_code)
			{
				display_message(ERROR_MESSAGE,
					"FE_node_field_add_to_list_with_exclusion.  Failed");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_add_to_list_with_exclusion.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_add_to_list_with_exclusion */

int undefine_FE_field_at_node(struct FE_node *node,struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Removes definition of <field> at <node>. If field is of type GENERAL_FE_FIELD
then removes values storage for it and shifts values storage for all subsequent
fields down.
Note: Must ensure that the node field is not in-use by any elements before it
is undefined!
==============================================================================*/
{
	int bytes_to_copy,field_number_of_values,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_add_to_list_with_exclusion_data exclusion_data;
	struct FE_node_field_info *existing_node_field_info,*new_node_field_info;
	Value_storage *values_storage;

	ENTER(undefine_FE_field_at_node);
	if (node&&field&&(existing_node_field_info=node->fields))
	{
		/* check if the field is already defined at the node */
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			existing_node_field_info->node_field_list))
		{
			if (1<NUMBER_IN_LIST(FE_node_field)(
				existing_node_field_info->node_field_list))
			{
			field_number_of_values=FE_node_field_get_number_of_values(node_field);
			if (GENERAL_FE_FIELD==field->fe_field_type)
			{
				exclusion_data.value_exclusion_start = node_field->components->value;
				exclusion_data.value_exclusion_length = field_number_of_values *
					get_Value_storage_size(node_field->field->value_type);
				/* adjust size for proper word alignment in memory */
				ADJUST_VALUE_STORAGE_SIZE(exclusion_data.value_exclusion_length);
			}
			else
			{
				exclusion_data.value_exclusion_start=
					existing_node_field_info->values_storage_size;
				exclusion_data.value_exclusion_length=0;
			}
			exclusion_data.excluded_node_field=node_field;
			exclusion_data.node_field_list=CREATE(LIST(FE_node_field))();
			if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				FE_node_field_add_to_list_with_exclusion,(void *)&exclusion_data,
				existing_node_field_info->node_field_list))
			{
				if (new_node_field_info=CREATE(FE_node_field_info)(
					existing_node_field_info->number_of_values - field_number_of_values,
					exclusion_data.node_field_list))
				{
					if (0<exclusion_data.value_exclusion_length)
					{
						/* copy values_storage after the removed field */
						bytes_to_copy = existing_node_field_info->values_storage_size -
							(exclusion_data.value_exclusion_start +
								exclusion_data.value_exclusion_length);
						if (0<bytes_to_copy)
						{
							/* use memmove instead of memcpy as memory blocks overlap */
							memmove(node->values_storage+exclusion_data.value_exclusion_start,
								node->values_storage+exclusion_data.value_exclusion_start+
								exclusion_data.value_exclusion_length,bytes_to_copy);
						}
						/* free the currently used space */
						if (REALLOCATE(values_storage,node->values_storage,Value_storage,
							new_node_field_info->values_storage_size))
						{
							node->values_storage=values_storage;
						}
					}
					REACCESS(FE_node_field_info)(&(node->fields),new_node_field_info);
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"undefine_FE_field_at_node.  Could not create node field info");
					DESTROY(LIST(FE_node_field))(&exclusion_data.node_field_list);
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"undefine_FE_field_at_node.  Could not copy node field list");
				DESTROY(LIST(FE_node_field))(&exclusion_data.node_field_list);
				return_code=0;
			}
			}
			else
			{
				/* if all fields are removed from a node then the user will have
					 no way of visually selecting the node. Hence, prevent removal of
					 last field */
				display_message(ERROR_MESSAGE,
					"undefine_FE_field_at_node.  Cannot undefine last field at node");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"undefine_FE_field_at_node.  Field %s is not defined at node %d",
				field->name,node->cm_node_identifier);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"undefine_FE_field_at_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* undefine_FE_field_at_node */
struct Node_list_field_data
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Iterator/conditional function data containing a node list and FE_field.
==============================================================================*/
{
	struct LIST(FE_node) *node_list;
	struct FE_field *field;
};

static int ensure_FE_element_nodes_are_not_in_list_if_field_defined(
	struct FE_element *element,void *node_list_field_data_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT)
and <field> is defined over it, ensures none of its nodes are in <node_list>.
==============================================================================*/
{
	int i,return_code;
	struct Node_list_field_data *node_list_field_data;
	struct FE_node **node;

	ENTER(ensure_FE_element_nodes_are_not_in_list_if_field_defined);
	if (element&&(node_list_field_data=
		(struct Node_list_field_data *)node_list_field_data_void))
	{
		return_code=1;
		/* only nodes in parentless elements need be added */
		if (CM_ELEMENT==element->cm.type)
		{
			if (element->information)
			{
				if (FE_field_is_defined_in_element(node_list_field_data->field,element))
				{
					/* note that element may have no node-based fields */
					if (node=element->information->nodes)
					{
						for (i=element->information->number_of_nodes;(0<i)&&return_code;i--)
						{
							if ((*node)&&IS_OBJECT_IN_LIST(FE_node)(*node,
								node_list_field_data->node_list))
							{
								if (!REMOVE_OBJECT_FROM_LIST(FE_node)(*node,
									node_list_field_data->node_list))
								{
									display_message(ERROR_MESSAGE,
										"ensure_FE_element_nodes_are_not_in_list_if_field_defined."
										"  Could not remove node from list");
									return_code=0;
								}
							}
							node++;
						}
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"ensure_FE_element_nodes_are_not_in_list_if_field_defined.  "
					"Missing node scale field information");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_nodes_are_not_in_list_if_field_defined.  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_nodes_are_not_in_list_if_field_defined */

struct Ensure_FE_node_field_is_undefined_data
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
User data for ensure_FE_node_field_is_undefined function.
==============================================================================*/
{
	struct FE_field *field;
	struct MANAGER(FE_node) *node_manager;
};

static int ensure_FE_node_field_is_undefined(struct FE_node *node,
	void *undefine_data_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
If FE_field <field> is defined at <node>, it is undefined.
Note: must first ensure node field is not used by element field!
==============================================================================*/
{
	int return_code;
	struct Ensure_FE_node_field_is_undefined_data *undefine_data;
	struct FE_node *temp_node;

	ENTER(ensure_FE_node_field_is_undefined);
	if (node&&(undefine_data=
		(struct Ensure_FE_node_field_is_undefined_data *)undefine_data_void))
	{
		if (FE_field_is_defined_at_node(undefine_data->field,node))
		{
			if (temp_node=CREATE(FE_node)(0,node))
			{
				return_code=undefine_FE_field_at_node(temp_node,undefine_data->field)&&
					MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(node,
						temp_node,undefine_data->node_manager);
				DESTROY(FE_node)(&temp_node);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"ensure_FE_node_field_is_undefined.  Could not create node copy");
				return_code=0;
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_field_is_undefined.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_field_is_undefined */

int undefine_field_at_listed_nodes(struct LIST(FE_node) *node_list,
	struct FE_field *field,struct MANAGER(FE_node) *node_manager,
	struct MANAGER(FE_element) *element_manager)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Makes sure <field> is not defined at any nodes in <node_list>, unless that field
at the node is in use by an element.
==============================================================================*/
{
	int number_to_undefine,number_with_field_defined,return_code;
	struct Node_list_field_data node_list_field_data;
	struct Ensure_FE_node_field_is_undefined_data undefine_data;

	ENTER(undefine_field_at_listed_nodes);
	if (node_list&&field&&node_manager&&element_manager)
	{
		node_list_field_data.field=field;
		node_list_field_data.node_list=CREATE(LIST(FE_node))();
		if (COPY_LIST(FE_node)(node_list_field_data.node_list,node_list))
		{
			REMOVE_OBJECTS_FROM_LIST_THAT(FE_node)(
				FE_node_field_is_not_defined,(void *)field,
				node_list_field_data.node_list);
			number_with_field_defined=
				NUMBER_IN_LIST(FE_node)(node_list_field_data.node_list);
			if (FOR_EACH_OBJECT_IN_MANAGER(FE_element)(
				ensure_FE_element_nodes_are_not_in_list_if_field_defined,
				(void *)&node_list_field_data,element_manager))
			{
				number_to_undefine=
					NUMBER_IN_LIST(FE_node)(node_list_field_data.node_list);
				if (number_to_undefine < number_with_field_defined)
				{
					display_message(WARNING_MESSAGE,"Field could not be undefined in %d "
						"node(s) because in-use by elements",
						number_with_field_defined-number_to_undefine);
				}
				undefine_data.field=field;
				undefine_data.node_manager=node_manager;
				MANAGER_BEGIN_CACHE(FE_node)(node_manager);
				return_code=FOR_EACH_OBJECT_IN_LIST(FE_node)(
					ensure_FE_node_field_is_undefined,(void *)&undefine_data,
					node_list_field_data.node_list);
				if (!return_code)
				{
					display_message(ERROR_MESSAGE,"undefine_field_at_listed_nodes.  "
						"Error undefining field at nodes");
				}
				MANAGER_END_CACHE(FE_node)(node_manager);
			}
			else
			{
				display_message(ERROR_MESSAGE,"undefine_field_at_listed_nodes.  "
					"Error excluding nodes in elements with field defined");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"undefine_field_at_listed_nodes.  Could not copy node list");
			return_code=0;
		}
		DESTROY(LIST(FE_node))(&node_list_field_data.node_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"undefine_field_at_listed_nodes.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* undefine_field_at_listed_nodes */

int define_FE_field_at_node(struct FE_node *node,struct FE_field *field,
	int *components_number_of_derivatives,int *components_number_of_versions,
	enum FE_nodal_value_type **components_nodal_value_types)
/*******************************************************************************
LAST MODIFIED : 26 October 1999

DESCRIPTION :
Defines a field at a node (does not assign values)
==============================================================================*/
{
	enum FE_nodal_value_type **component_nodal_value_types;
	enum Value_type value_type;
	int *component_number_of_derivatives,*component_number_of_versions,i,j,
		new_values_storage_size,number_of_values,return_code,size,
		number_of_values_in_component;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	struct FE_node_field_info *existing_node_field_info,*new_node_field_info;
	struct LIST(FE_node_field) *node_field_list;
	Value_storage *new_value;

	ENTER(define_FE_field_at_node);
	return_code=0;
	if (node&&field&&(existing_node_field_info=node->fields)&&
		(component_number_of_derivatives=components_number_of_derivatives)&&
		(component_number_of_versions=components_number_of_versions)&&
		(component_nodal_value_types=components_nodal_value_types))
	{
		value_type = field->value_type;
		size = get_Value_storage_size(value_type);
		return_code=1;
		/* check if the field is already defined at the node */
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			existing_node_field_info->node_field_list))
		{
			display_message(ERROR_MESSAGE,
				"define_FE_field_at_node.  Field %s already defined at node %d",
				field->name,node->cm_node_identifier);
			return_code=0;
		}
		/* no longer perform following check since it prevents us from reading in
			 indexed fields when the indexer is not in the same header */
#if defined (OLD_CODE)
		/* if indexed field, check that the indexer field is defined at the node */
		if (INDEXED_FE_FIELD==field->fe_field_type)
		{
			if (!FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field->indexer_field,
				existing_node_field_info->node_field_list))
			{
				display_message(ERROR_MESSAGE,"define_FE_field_at_node.  "
					"Indexer field %s for field %s not defined at node %d",
					field->indexer_field->name,field->name,node->cm_node_identifier);
				return_code=0;
			}
		}
#endif /* defined (OLD_CODE) */
		if (return_code)
		{
			/* create the node field */
			if (node_field=CREATE(FE_node_field)(field))
			{
				number_of_values=existing_node_field_info->number_of_values;
				if (GENERAL_FE_FIELD==field->fe_field_type)
				{
					i=field->number_of_components;
					component=node_field->components;
					new_values_storage_size=0;
					while (return_code&&(i>0))
					{
						return_code=assign_FE_node_field_component(component,
							existing_node_field_info->values_storage_size+
							new_values_storage_size,*component_number_of_derivatives,
							*component_number_of_versions,*component_nodal_value_types);
						/*???DB.  Inline assign_FE_node_field_component and get rid of
							it ? */
						number_of_values_in_component = (*component_number_of_versions) *
							(1+(*component_number_of_derivatives));
						/*???RC values_storage realloc change */
						number_of_values += number_of_values_in_component;
						new_values_storage_size += number_of_values_in_component*size;
						component_number_of_derivatives++;
						component_number_of_versions++;
						component_nodal_value_types++;
						component++;
						i--;
					}
				}
				if (return_code)
				{
					/* duplicate the existing node field information */					
					node_field_list=(struct LIST(FE_node_field) *)NULL;
					if ((node_field_list=CREATE_LIST(FE_node_field)())&&
						COPY_LIST(FE_node_field)(node_field_list,
						existing_node_field_info->node_field_list))
					{
						/* add the new node field */
						if (!ADD_OBJECT_TO_LIST(FE_node_field)(node_field,
							node_field_list))
						{
							return_code=0;
						}
						if (return_code)
						{
							/* create the new node information */
							if (new_node_field_info=CREATE(FE_node_field_info)(
								number_of_values,node_field_list))
							{
								if (GENERAL_FE_FIELD==field->fe_field_type)
								{
									ADJUST_VALUE_STORAGE_SIZE(new_values_storage_size);
									if (REALLOCATE(new_value,node->values_storage,Value_storage,
										existing_node_field_info->values_storage_size+
										new_values_storage_size))
									{
										node->values_storage=new_value;
										/* initialize new values */
										new_value += existing_node_field_info->values_storage_size;
										for (i=number_of_values-
											(existing_node_field_info->number_of_values);i>0;i--)
										{
											switch(value_type)
											{
												case ELEMENT_XI_VALUE:
												{											
													*((struct FE_element **)new_value) = (struct FE_element *)NULL;
													new_value+=sizeof(struct FE_element *);
													for (j = 0 ; j < MAXIMUM_ELEMENT_XI_DIMENSIONS ; j++)
													{
														*((FE_value *)new_value) = FE_VALUE_INITIALIZER;
														new_value+=sizeof(FE_value);
													}
												}break;
												case FE_VALUE_VALUE:
												{																					
													*((FE_value *)new_value) = FE_VALUE_INITIALIZER;
													new_value+=size;
												}break;
												case UNSIGNED_VALUE:
												{																					
													*((unsigned *)new_value) = 0;
													new_value+=size;
												}break;	
												case INT_VALUE:
												{																			
													*((int *)new_value) = 0;
													new_value+=size;
												}break;
												case DOUBLE_VALUE:
												{																							
													*((double *)new_value) = 0;
													new_value+=size;
												}break;	
												case FLT_VALUE:
												{																						
													*((float *)new_value) = 0;
													new_value+=size;
												}break;
												case SHORT_VALUE:
												{
													display_message(ERROR_MESSAGE,"define_FE_field_at_node."
														"SHORT_VALUE.Code not written yet. Beware alignmemt problems ");
													return_code =0;
												}break;
												case DOUBLE_ARRAY_VALUE:
												{	
													double *array = (double *)NULL;
													double **array_address;
													int zero = 0;										
													/* copy the number of array values to values_storage*/
													*((int *)new_value) = zero;
													/* copy the pointer to the array values to values_storage*/
													array_address = (double **)(new_value+sizeof(int));
													*array_address = array;																							
													new_value+=size;
												}break;																			
												case FE_VALUE_ARRAY_VALUE:
												{	
													FE_value *array = (FE_value *)NULL;
													FE_value **array_address;
													int zero = 0;
													*((int *)new_value) = zero;													
													array_address = (FE_value **)(new_value+sizeof(int));
													*array_address = array;	
													new_value+=size;
												}break;
												case FLT_ARRAY_VALUE:
												{	
													float *array = (float *)NULL;	
													float **array_address;
													int zero = 0;																							
													*((int *)new_value) = zero;												
													array_address = (float **)(new_value+sizeof(int));
													*array_address = array;	
													new_value+=size;
												}break;		
												case SHORT_ARRAY_VALUE:
												{	
													short *array = (short *)NULL;	
													short **array_address;
													int zero = 0;																							
													*((int *)new_value) = zero;												
													array_address = (short **)(new_value+sizeof(int));
													*array_address = array;	
													new_value+=size;
												}break;									
												case  INT_ARRAY_VALUE:
												{	
													int *array = (int *)NULL;	
													int **array_address;
													int zero = 0;																										
													*((int *)new_value) = zero;												
													array_address = (int **)(new_value+sizeof(int));
													*array_address = array;	
													new_value+=size;
												}break;															
												case  UNSIGNED_ARRAY_VALUE:
												{	
													unsigned *array = (unsigned *)NULL;	
													unsigned **array_address;
													int zero = 0;																						
													*((int *)new_value) = zero;												
													array_address = (unsigned **)(new_value+sizeof(int));
													*array_address = array;	
													new_value+=size;
												}break;
												case STRING_VALUE:
												{	
													char **string_address;

													string_address = (char **)(new_value);
													*string_address = (char *)NULL;	
													new_value += size;
												}break;	
												case  UNKNOWN_VALUE:
												{
													display_message(ERROR_MESSAGE,"define_FE_field_at_node." 
														" UNKNOWN_VALUE");
													return_code =0;
												}break;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,"define_FE_field_at_node.  "
											"Could not reallocate nodal values");
										DESTROY(FE_node_field_info)(&new_node_field_info);
										return_code=0;
									}
								}
								REACCESS(FE_node_field_info)(&(node->fields),
									new_node_field_info);
							}
							else
							{
								display_message(ERROR_MESSAGE,
						"define_FE_field_at_node.  Could not create new field information");
								/* don't need to destroy node_field because it will be
									destroyed when the corresponding list is destroyed */
								return_code=0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"define_FE_field_at_node.  Could not add node field to list");
							DESTROY(FE_node_field)(&node_field);
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"define_FE_field_at_node.  Error duplicating node field lists");
						DESTROY(FE_node_field)(&node_field);
						return_code=0;
					}
					DESTROY_LIST(FE_node_field)(&node_field_list);
				}
				else
				{
					DESTROY(FE_node_field)(&node_field);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"define_FE_field_at_node.  Could not create node_field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"define_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* define_FE_field_at_node */ 

int for_FE_field_at_node(struct FE_field *field,
	FE_node_field_iterator_function *iterator,void *user_data,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
If an <iterator> is supplied and the <field> is defined at the <node> then the
result of the <iterator> is returned.  Otherwise, if an <iterator> is not
supplied and the <field> is defined at the <node> then a non-zero is returned.
Otherwise, zero is returned.
???DB.  Multiple behaviour dangerous ?
==============================================================================*/
{
	int return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_iterator_and_data iterator_and_data;

	ENTER(for_FE_field_at_node);
	return_code=0;
	/* check arguments */
	if (field&&node&&(node->fields))
	{
		node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node->fields->node_field_list);
	
		if (node_field)
		{
			if (iterator)
			{
				iterator_and_data.iterator=iterator;
				iterator_and_data.user_data=user_data;
				iterator_and_data.node=node;
				return_code=for_FE_field_at_node_iterator(node_field,
					&iterator_and_data);
			}
			else
			{
				return_code=1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"for_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_node */

int for_each_FE_field_at_node(FE_node_field_iterator_function *iterator,
	void *user_data,struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
Calls the <iterator> for each field defined at the <node> until the <iterator>
returns 0 or it runs out of fields.  Returns the result of the last <iterator>
called.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_node);
	return_code=0;
	/* check arguments */
	if (iterator&&node&&(node->fields))
	{
		iterator_and_data.iterator=iterator;
		iterator_and_data.user_data=user_data;
		iterator_and_data.node=node;	
		return_code=FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			for_FE_field_at_node_iterator,&iterator_and_data,
			node->fields->node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_node */

int for_each_FE_field_at_node_indexer_first(
	FE_node_field_iterator_function *iterator,void *user_data,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Calls the <iterator> for each field defined at the <node> until the <iterator>
returns 0 or it runs out of fields.  Returns the result of the last <iterator>
called. This version insists that any field used as an indexer_field for another
field in the list is output first.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_priority_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_node);
	return_code=0;
	/* check arguments */
	if (iterator&&node&&(node->fields))
	{
		if (iterator_and_data.priority_field_list=CREATE(LIST(FE_field))())
		{
			/* make priority list of indexer fields for fields defined at node */
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				FE_node_field_add_indexer_field_to_list,
				(void *)(iterator_and_data.priority_field_list),
				node->fields->node_field_list);
			iterator_and_data.iterator=iterator;
			iterator_and_data.user_data=user_data;
			iterator_and_data.node=node;
			/* call iterator function for fields in priority list */
			iterator_and_data.priority_on=1;
			return_code=FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				for_FE_field_at_node_priority_iterator,&iterator_and_data,
				node->fields->node_field_list);
			/* call iterator function for fields not in priority list */
			iterator_and_data.priority_on=0;
			return_code=FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				for_FE_field_at_node_priority_iterator,&iterator_and_data,
				node->fields->node_field_list);
			DESTROY(LIST(FE_field))(&(iterator_and_data.priority_field_list));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_node */

static int FE_node_field_has_FE_field_values(
	struct FE_node_field *node_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 19 October 1999

DESCRIPTION:
Returns true if <node_field> has a field with values_storage.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_has_FE_field_values);
	USE_PARAMETER(dummy);
	if (node_field&&node_field->field)
	{
		return_code=(0<node_field->field->number_of_values);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_has_FE_field_values.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* FE_node_field_has_FE_field_values */

int FE_node_has_FE_field_values(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 24 September 1999

DESCRIPTION :
Returns true if any single field defined at <node> has values stored with
the field.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_has_FE_field_values);
	if (node&&node->fields)
	{
		return_code=((struct FE_node_field *)NULL != 
			FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
				FE_node_field_has_FE_field_values,(void *)NULL,
				node->fields->node_field_list));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_has_FE_field_values.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_has_FE_field_values */

int equivalent_FE_field_at_nodes(struct FE_field *field,struct FE_node *node_1,
	struct FE_node *node_2)
/*******************************************************************************
LAST MODIFIED : 10 October 2000

DESCRIPTION :
Returns non-zero if the <field> is defined in the same way at the two nodes.
Note this will also return true if <field> is not defined at both nodes.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type_1,*nodal_value_type_2;
	int i,j,return_code;
	struct FE_node_field *node_field_1,*node_field_2;
	struct FE_node_field_component *component_1,*component_2;

	ENTER(equivalent_FE_field_at_nodes);
	return_code=0;
	/* check arguments */
	if (field&&node_1&&(node_1->fields)&&node_2&&(node_2->fields))
	{
		node_field_1=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node_1->fields->node_field_list);
		
		node_field_2=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node_2->fields->node_field_list);
	
		if (node_field_1&&node_field_2)
		{
			if (node_1->fields==node_2->fields)
			{
				return_code=1;
			}
			else
			{
				component_1=node_field_1->components;
				component_2=node_field_2->components;
				i=field->number_of_components;
				return_code=1;
				while (return_code&&(i>0))
				{
					if ((component_1->number_of_derivatives==
						component_2->number_of_derivatives)&&
						(component_1->number_of_versions==
						component_2->number_of_versions)&&
						(nodal_value_type_1=component_1->nodal_value_types)&&
						(nodal_value_type_2=component_2->nodal_value_types))
					{
						j=1+component_1->number_of_derivatives;
						while (return_code&&(j>0))
						{
							if (*nodal_value_type_1!= *nodal_value_type_2)
							{
								return_code=0;
							}
							nodal_value_type_1++;
							nodal_value_type_2++;
							j--;
						}
					}
					else
					{
						return_code=0;
					}
					component_1++;
					component_2++;
					i--;
				}
			}
		}
		else if ((!node_field_1) && (!node_field_2))
		{
			/* fields identically NOT defined */
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"equivalent_FE_field_at_nodes.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* equivalent_FE_field_at_nodes */

int equivalent_FE_fields_at_nodes(struct FE_node *node_1,
	struct FE_node *node_2)
/*******************************************************************************
LAST MODIFIED : 23 May 2000

DESCRIPTION :
Returns true if all fields are defined in the same way at the two nodes.
==============================================================================*/
{
	int return_code;

	ENTER(equivalent_FE_fields_at_nodes);
	return_code=0;
	if (node_1&&(node_1->fields)&&node_2&&(node_2->fields)&&
		(node_1->fields==node_2->fields))
	{
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* equivalent_FE_fields_at_nodes */

struct FE_node *node_string_to_FE_node(char *name,
	struct MANAGER(FE_node) *node_manager)
/*******************************************************************************
LAST MODIFIED : 9 September 1999

DESCRIPTION :
Returns the node in the <node_manager> with the number written in the <name>.
==============================================================================*/
{
	struct FE_node *node;

	ENTER(node_string_to_FE_node);
	if (name&&node_manager)
	{
		node=FIND_BY_IDENTIFIER_IN_MANAGER(FE_node,cm_node_identifier)(
			atoi(name),node_manager);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"node_string_to_FE_node.  Invalid argument(s)");
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /* node_string_to_FE_node */

int FE_nodal_value_version_exists(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type)
/*******************************************************************************
LAST MODIFIED : 23 June 1999

DESCRIPTION :
Returns 1 if the field, component number, version and type are stored at the
node.
???DB.  May need speeding up
==============================================================================*/
{
	int return_code;
	Value_storage *values_storage = NULL;

	ENTER(FE_nodal_value_version_exists);
	return_code=0;
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if (find_FE_nodal_values_storage_dest(node,component,version,type,
			get_FE_field_value_type(component->field),&values_storage))
		{
			return_code=1;
		}
		else
		{	
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_nodal_value_version_exists.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_nodal_value_version_exists */

int get_FE_nodal_value_as_string(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,char **string)
/*******************************************************************************
LAST MODIFIED : 17 October 1999

DESCRIPTION :
Returns as a string the value for the (<version>, <type>) for the <field>
<component_number> at the <node>.
It is up to the calling function to DEALLOCATE the returned string.
==============================================================================*/
{
	char temp_string[40];
	int return_code;

	ENTER(get_FE_nodal_value_as_string);
	return_code=0;
	(*string)=(char *)NULL;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		switch (field->value_type)
		{
			case ELEMENT_XI_VALUE:
			{
				FE_value xi[MAXIMUM_ELEMENT_XI_DIMENSIONS];
				int error,i;
				struct FE_element *element;

				if (get_FE_nodal_element_xi_value(node,field,
					component_number,version,type,&element,xi)&&element->shape)
				{
					error=0;
					switch (element->cm.type)
					{
						case CM_ELEMENT:
						{
							append_string(string,"E",&error);
						} break;
						case CM_FACE:
						{
							append_string(string,"F",&error);
						} break;
						case CM_LINE:
						{
							append_string(string,"L",&error);
						} break;
						default:
						{
							error=1;
						} break;
					}
					sprintf(temp_string," %d",element->cm.number);
					append_string(string,temp_string,&error);
					for (i=0;i<element->shape->dimension;i++)
					{
						sprintf(temp_string," %g",xi[i]);
						append_string(string,temp_string,&error);
					}
					return_code = !error;
				}
			} break;
			case FE_VALUE_VALUE:
			{
				FE_value value;
				struct FE_field_component component;

				component.field=field;
				component.number=component_number;
				if (get_FE_nodal_FE_value_value(node,&component,version,type,&value))
				{
					sprintf(temp_string,"%g",value);
					return_code=append_string(string,temp_string,&return_code);
				}
			} break;
			case INT_VALUE:
			{
				int value;
				struct FE_field_component component;

				component.field=field;
				component.number=component_number;
				if (get_FE_nodal_int_value(node,&component,version,type,&value))
				{
					sprintf(temp_string,"%d",value);
					return_code=append_string(string,temp_string,&return_code);
				}
			} break;
			case STRING_VALUE:
			{
				return_code=get_FE_nodal_string_value(node,field,component_number,
					version,type,string);
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_value_as_string.  Unknown value type %s",
					Value_type_string(field->value_type));
			} break;
		}
		if (!return_code)
		{
			display_message(ERROR_MESSAGE,"get_FE_nodal_value_as_string.  Failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_value_as_string.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_value_as_string */

int get_FE_nodal_double_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,double *value)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Gets a particular double value (<version>, <type>) for the field <component> at
the <node>.
???DB.  May need speeding up
==============================================================================*/
{
	int return_code;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_double_value);
	return_code=0;
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		value)
	{
		if (find_FE_nodal_values_storage_dest(node,component,version,type,
			DOUBLE_VALUE,&values_storage))
		{
			*value = *((double *)values_storage);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_double_value.  find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_double_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_double_value */

int set_FE_nodal_double_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,double value)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets a particular double value (<version>, <type>) for the field <component> at
the <node>.
==============================================================================*/
{
	int return_code; 
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_double_value);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,component,version,type,
			DOUBLE_VALUE,&values_storage))
		{
			/* copy in the double */		
			*((double *)values_storage) = value;
			return_code=1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_double_value.  find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_double_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_double_value */

int get_FE_nodal_FE_value_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,FE_value *value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Gets a particular FE_value value (<version>, <type>) for the field <component>
at the <node>.
???DB.  May need speeding up
==============================================================================*/
{
	int return_code;
	struct FE_field *field;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_FE_value_value);
	return_code=0;
	if (node&&component&&(field=component->field)&&(0<=component->number)&&
		(component->number < field->number_of_components)&&(0<=version)&&value)
	{
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				*value = *((FE_value *)(field->values_storage)+component->number);
				return_code=1;
			} break;
			case GENERAL_FE_FIELD:
			{
				if (find_FE_nodal_values_storage_dest(node,component,version,type,
					FE_VALUE_VALUE,&values_storage))
				{
					*value = *((FE_value *)values_storage);
					return_code=1;
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_FE_value_value.  "
						"find_FE_nodal_values_storage_dest failed");
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index;
				struct FE_field_component index_component;

				index_component.field=field->indexer_field;
				index_component.number=0;
				if (get_FE_nodal_int_value(node,&index_component,/*version*/0,
					FE_NODAL_VALUE,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						*value = *((FE_value *)(field->values_storage)+
							field->number_of_indexed_values*component->number+index-1);
						return_code=1;	
					}
					else
					{	
						display_message(ERROR_MESSAGE,"get_FE_nodal_FE_value_value.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_FE_value_value.  "
						"Field %s, indexed by %s not defined at node %",
						field->name,field->indexer_field->name,node->cm_node_identifier);
					return_code=0;	
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_FE_value_value.  Unknown FE_field_type");
			} break;
		}
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_FE_value_value */

int set_FE_nodal_FE_value_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,FE_value value)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets a particular FE_value value (<version>, <type>) for the field <component>
at the <node>.
==============================================================================*/
{
	int return_code; 
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_FE_value_value);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,component,version,type,
			FE_VALUE_VALUE,&values_storage))
		{
			/* copy in the FE_value */		
			*((FE_value *)values_storage) = value;
			return_code=1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,"set_FE_nodal_FE_value_value.  "
				"find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_FE_value_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_FE_value_value */

int get_FE_nodal_float_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,float *value)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Gets a particular float value (<version>, <type>) for the field <component> at
the <node>.
???DB.  May need speeding up
==============================================================================*/
{
	int return_code;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_float_value);
	return_code=0;
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		value)
	{
		if (find_FE_nodal_values_storage_dest(node,component,version,type,
			FLT_VALUE,&values_storage))
		{
			*value = *((float *)values_storage);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_float_value.  find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_float_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_float_value */

int set_FE_nodal_float_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,float value)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets a particular float value (<version>, <type>) for the field <component> at
the <node>.
==============================================================================*/
{
	int return_code; 
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_float_value);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,component,version,type,
			FLT_VALUE,&values_storage))
		{
			/* copy in the float */		
			*((float *)values_storage) = value;
			return_code=1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_float_value.  find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_float_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_float_value */

int get_FE_nodal_int_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int *value)
/*******************************************************************************
LAST MODIFIED : 3 September 1999

DESCRIPTION :
Gets a particular int value (<version>, <type>) for the field <component> at
the <node>.
???DB.  May need speeding up
==============================================================================*/
{
	int return_code;
	struct FE_field *field;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_int_value);
	return_code=0;
	if (node&&component&&(field=component->field)&&(0<=component->number)&&
		(component->number<field->number_of_components)&&(0<=version)&&value)
	{
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				*value = *((int *)(field->values_storage)+component->number);
				return_code=1;
			} break;
			case GENERAL_FE_FIELD:
			{
				if (find_FE_nodal_values_storage_dest(node,component,version,type,
					INT_VALUE,&values_storage))
				{
					*value = *((int *)values_storage);
					return_code =1;
				}
				else
				{
					display_message(ERROR_MESSAGE,"get_FE_nodal_int_value.  "
						"find_FE_nodal_values_storage_dest failed");
					return_code=0;	
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index;
				struct FE_field_component index_component;

				index_component.field=field->indexer_field;
				index_component.number=0;
				if (get_FE_nodal_int_value(node,&index_component,/*version*/0,
					FE_NODAL_VALUE,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						*value = *((int *)(field->values_storage)+
							field->number_of_indexed_values*component->number+index-1);
						return_code=1;	
					}
					else
					{	
						display_message(ERROR_MESSAGE,"get_FE_nodal_int_value.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_int_value.  "
						"Field %s, indexed by %s not defined at node %",
						field->name,field->indexer_field->name,node->cm_node_identifier);
					return_code=0;	
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_int_value.  Unknown FE_field_type");
			} break;
		}
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_int_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_int_value */

int set_FE_nodal_int_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int value)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets a particular int value (<version>, <type>) for the field <component> at
the <node>.
==============================================================================*/
{
	int return_code; 
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_int_value);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,component,version,type,
			INT_VALUE,&values_storage))
		{
			/* copy in the int */		
			*((int *)values_storage) = value;
			return_code=1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_int_value.  find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_int_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_int_value */

int get_FE_nodal_element_xi_value(struct FE_node *node,
	struct FE_field *field, int component_number, int version,
	enum FE_nodal_value_type type, struct FE_element **element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 3 September 1999

DESCRIPTION :
Gets a particular element_xi_value (<version>, <type>) for the field <component> at the
<node>.
???DB.  May need speeding up
==============================================================================*/
{
	int i,return_code;
	struct FE_field_component component;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_element_xi_value);
	return_code=0;
	/* check arguments */
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		element&&xi&&(field->value_type==ELEMENT_XI_VALUE))
	{
		values_storage=(Value_storage *)NULL;
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				values_storage=field->values_storage +
					get_Value_storage_size(ELEMENT_XI_VALUE)*component_number;
				return_code=1;
			} break;
			case GENERAL_FE_FIELD:
			{
				/* Put into a component for the meantime */
				component.field = field;
				component.number = component_number;
				if (find_FE_nodal_values_storage_dest(node,&component,version,type,
					ELEMENT_XI_VALUE,&values_storage))
				{
					return_code=1;
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_element_xi_value.  "
						"find_FE_nodal_values_storage_dest failed");
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index;
				struct FE_field_component index_component;

				index_component.field=field->indexer_field;
				index_component.number=0;
				if (get_FE_nodal_int_value(node,&index_component,/*version*/0,
					FE_NODAL_VALUE,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						values_storage=field->values_storage+
							get_Value_storage_size(ELEMENT_XI_VALUE)*
							(field->number_of_indexed_values*component_number+index-1);
						return_code=1;	
					}
					else
					{	
						display_message(ERROR_MESSAGE,"get_FE_nodal_element_xi_value.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_element_xi_value.  "
						"Field %s, indexed by %s not defined at node %",
						field->name,field->indexer_field->name,node->cm_node_identifier);
					return_code=0;	
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_element_xi_value.  Unknown FE_field_type");
			} break;
		}
		if (return_code&&values_storage)
		{
			*element = *((struct FE_element **)values_storage);
			values_storage += sizeof(struct FE_element *);
			for(i = 0 ; i < MAXIMUM_ELEMENT_XI_DIMENSIONS ; i++)
			{
				xi[i] = *((FE_value *)values_storage);
				values_storage += sizeof(FE_value);
			}
		}
		else
		{
			if (return_code)
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_element_xi_value.  No values storage");
				return_code=0;
			}
		}
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_element_xi_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_element_xi_value */

int set_FE_nodal_element_xi_value(struct FE_node *node,
	struct FE_field *field, int component_number, int version,
	enum FE_nodal_value_type type,struct FE_element *element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 14 September 1999

DESCRIPTION :
Sets a particular element_xi_value (<version>, <type>) for the field
<component> at the <node>.
==============================================================================*/
{
	int i, number_of_xi_dimensions, return_code; 
	struct FE_field_component component;
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_element_xi_value);
	return_code=0;
	/* check arguments */
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		element&&element->shape&&xi&&(field->value_type==ELEMENT_XI_VALUE))
	{
		/* Put into a component for the meantime */
		component.field = field;
		component.number = component_number;
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,&component,version,type,
			ELEMENT_XI_VALUE,&values_storage))
		{
			number_of_xi_dimensions = element->shape->dimension;
			/* copy in the element_xi_value */		
			REACCESS(FE_element)((struct FE_element **)values_storage, element);
			values_storage += sizeof(struct FE_element *);
			for (i = 0 ; i < MAXIMUM_ELEMENT_XI_DIMENSIONS ; i++)
			{
				if (i<number_of_xi_dimensions)
				{
					*((FE_value *)values_storage) = xi[i];
				}
				else
				{
					/* set spare xi values to 0 */
					*((FE_value *)values_storage) = 0.0;
				}
				values_storage += sizeof(FE_value);
			}
			return_code=1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
					"set_FE_nodal_element_xi_value. find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_element_xi_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_element_xi_value */

int FE_node_is_in_Multi_range(struct FE_node *node,void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Conditional function returning true if <node> identifier is in the
<multi_range>.
==============================================================================*/
{
	int return_code;
	struct Multi_range *multi_range;

	ENTER(FE_node_is_in_Multi_range);
	if (node&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		return_code=
			Multi_range_is_value_in_range(multi_range,node->cm_node_identifier);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_in_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_in_Multi_range */

int FE_node_is_not_in_Multi_range(struct FE_node *node,void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Conditional function returning true if <node> identifier is NOT in the
<multi_range>.
==============================================================================*/
{
	int return_code;
	struct Multi_range *multi_range;

	ENTER(FE_node_is_not_in_Multi_range);
	if (node&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		return_code=
			!Multi_range_is_value_in_range(multi_range,node->cm_node_identifier);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_not_in_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_not_in_Multi_range */

int add_FE_node_number_to_Multi_range(struct FE_node *node,
	void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 20 February 2000

DESCRIPTION :
Iterator function for adding the number of <node> to <multi_range>.
==============================================================================*/
{
	int node_number,return_code;
	struct Multi_range *multi_range;

	ENTER(add_FE_node_number_to_Multi_range);
	if (node&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		node_number=get_FE_node_cm_node_identifier(node);
		return_code=Multi_range_add_range(multi_range,node_number,node_number);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_node_number_to_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_node_number_to_Multi_range */

int FE_node_is_in_group(struct FE_node *node,void *node_group_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <node> is in <node_group>.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_node) *node_group;

	ENTER(FE_node_is_in_group);
	if (node&&(node_group=(struct GROUP(FE_node) *)node_group_void))
	{
		if (IS_OBJECT_IN_GROUP(FE_node)(node,node_group))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_is_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_in_group */

int ensure_FE_node_is_in_group(struct FE_node *node,void *node_group_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for adding <node> to <node_group> if not currently in it.
Note: If function is to be called several times on a group then surround by
MANAGED_GROUP_BEGIN_CACHE/END_CACHE calls for efficient manager messages.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_node) *node_group;

	ENTER(ensure_FE_node_is_in_group);
	if (node&&(node_group=(struct GROUP(FE_node) *)node_group_void))
	{
		if (!IS_OBJECT_IN_GROUP(FE_node)(node,node_group))
		{
			return_code=ADD_OBJECT_TO_GROUP(FE_node)(node,node_group);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_in_group */

int ensure_FE_node_is_not_in_group(struct FE_node *node,void *node_group_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for removing <node> from <node_group> if currently in it.
Note: If function is to be called several times on a group then surround by
MANAGED_GROUP_BEGIN_CACHE/END_CACHE calls for efficient manager messages.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_node) *node_group;

	ENTER(ensure_FE_node_is_not_in_group);
	if (node&&(node_group=(struct GROUP(FE_node) *)node_group_void))
	{
		if (IS_OBJECT_IN_GROUP(FE_node)(node,node_group))
		{
			return_code=REMOVE_OBJECT_FROM_GROUP(FE_node)(node,node_group);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_not_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_not_in_group */

int ensure_FE_node_is_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Iterator function for adding <node> to <node_list> if not currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_FE_node_is_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		if (!IS_OBJECT_IN_LIST(FE_node)(node,node_list))
		{
			return_code=ADD_OBJECT_TO_LIST(FE_node)(node,node_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_in_list */

int ensure_FE_node_is_in_list_conditional(struct FE_node *node,
	void *list_conditional_data_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for adding <node> to a list - if not already in it - if a
conditional function with user_data is true.
The node_list, conditional function and user_data are passed in a
struct FE_node_list_conditional_data * in the second argument.
Warning: Must not be iterating over the list being added to!
==============================================================================*/
{
	int return_code;
	struct FE_node_list_conditional_data *list_conditional_data;

	ENTER(ensure_FE_node_is_in_list_conditional);
	if (node&&(list_conditional_data=
		(struct FE_node_list_conditional_data *)list_conditional_data_void)&&
		list_conditional_data->node_list&&list_conditional_data->function)
	{
		if ((list_conditional_data->function)(node,
			list_conditional_data->user_data))
		{
			if (!IS_OBJECT_IN_LIST(FE_node)(node,list_conditional_data->node_list))
			{
				return_code=
					ADD_OBJECT_TO_LIST(FE_node)(node,list_conditional_data->node_list);
			}
			else
			{
				return_code=1;
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_in_list_conditional.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_in_list_conditional */

int ensure_FE_node_is_not_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for removing <node> from <node_list> if currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_FE_node_is_not_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		if (IS_OBJECT_IN_LIST(FE_node)(node,node_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_node)(node,node_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_not_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_not_in_list */

int toggle_FE_node_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
If <node> is in <node_list> it is taken out, otherwise it is added.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(toggle_FE_node_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		if (IS_OBJECT_IN_LIST(FE_node)(node,node_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_node)(node,node_list);
		}
		else
		{
			return_code=ADD_OBJECT_TO_LIST(FE_node)(node,node_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"toggle_FE_node_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* toggle_FE_node_in_list */

int FE_node_can_be_destroyed(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 16 April 1999

DESCRIPTION :
Returns true if the <node> is only accessed once (assumed to be by the manager).
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_can_be_destroyed);
	if (node)
	{
		return_code=(1==node->access_count);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_can_be_destroyed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_can_be_destroyed */

int FE_node_has_embedded_element_or_node(struct FE_node *node,void *data_void)
/*******************************************************************************
LAST MODIFIED : 28 April 1999

DESCRIPTION :
Returns true if <node> conatins a field which depends on the changed_element
of changed_node in the <data_void>.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_has_embedded_element_data *data;

	ENTER(FE_node_has_embedded_element);
	if (node&&(data=(struct FE_node_field_has_embedded_element_data *)data_void))
	{
		data->node = node;
		if (FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
			FE_node_field_has_embedded_element, data_void,
			node->fields->node_field_list))
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_has_embedded_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_has_embedded_element */

int FE_node_has_FE_field_and_string_data(struct FE_node *node,void *data_void)
/*******************************************************************************
LAST MODIFIED : 26 September 2000

DESCRIPTION :
Returns true(1) if the <data_void>->fe_field is define at the <node> AND
the nodal string at <node>,<data_void>->fe_field is equal to <data_void>->string.
Otherwise returns false (0)
==============================================================================*/
{
	int return_code;	
	struct FE_field_and_string_data *field_and_string_data;
	struct FE_field *fe_field;
	char *required_string,*field_string;

	ENTER(FE_node_has_FE_field_and_string_data);
	field_and_string_data=(struct FE_field_and_string_data *)NULL;
	fe_field=(struct FE_field *)NULL;
	required_string=(char *)NULL;
	field_string=(char *)NULL;	
	return_code=0;
	if (node&&(field_and_string_data=(struct FE_field_and_string_data *)data_void))
	{
		fe_field=field_and_string_data->fe_field;
		required_string=field_and_string_data->string;
		if (FE_field_is_defined_at_node(fe_field,node))
		{
			if(get_FE_nodal_string_value(node,fe_field,0,0,FE_NODAL_VALUE,&field_string))
			{
				if(!strcmp(required_string,field_string))
				{
					return_code=1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_has_FE_field_and_string_data.  Invalid argument(s)");	
	}
	LEAVE;

	return (return_code);
} /*FE_node_has_FE_field_and_string_data */

int FE_node_is_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <node> is in <node_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(FE_node_is_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code = IS_OBJECT_IN_LIST(FE_node)(node,node_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_in_list */

int FE_node_is_not_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <node> is not in <node_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(FE_node_is_not_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code = !IS_OBJECT_IN_LIST(FE_node)(node,node_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_not_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_not_in_list */

char *get_FE_nodal_value_type_string(enum FE_nodal_value_type nodal_value_type)
/*******************************************************************************
LAST MODIFIED : 23 June 1999

DESCRIPTION :
Returns a pointer to a static string token for the given <nodal_value_type>.
The calling function must not deallocate the returned string.
==============================================================================*/
{
	char *nodal_value_type_string;

	ENTER(get_FE_nodal_value_type_string);
	switch (nodal_value_type)
	{
		case FE_NODAL_VALUE:
		{
			nodal_value_type_string="value";
		} break;
		case FE_NODAL_D_DS1:
		{
			nodal_value_type_string="d/ds1";
		} break;
		case FE_NODAL_D_DS2:
		{
			nodal_value_type_string="d/ds2";
		} break;
		case FE_NODAL_D_DS3:
		{
			nodal_value_type_string="d/ds3";
		} break;
		case FE_NODAL_D2_DS1DS2:
		{
			nodal_value_type_string="d2/ds1ds2";
		} break;
		case FE_NODAL_D2_DS1DS3:
		{
			nodal_value_type_string="d2/ds1ds3";
		} break;
		case FE_NODAL_D2_DS2DS3:
		{
			nodal_value_type_string="d2/ds2ds3";
		} break;
		case FE_NODAL_D3_DS1DS2DS3:
		{
			nodal_value_type_string="d3/ds1ds2ds3";
		} break;
		case FE_NODAL_UNKNOWN:
		{
			nodal_value_type_string="unknown";
		} break;
		default:
		{
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_value_type_string.  Invalid nodal_value_type");
			nodal_value_type_string="ERROR - unknown";
		} break;
	}
	LEAVE;

	return (nodal_value_type_string);
} /* get_FE_nodal_value_type_string */

#if defined (OLD_CODE) 
/* superceded by  get_FE_nodal_value_type,get_FE_nodal_array_number_of_elements */
int get_FE_nodal_array_attributes(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,enum Value_type *value_type,
	int *number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Get the value_type and the number of array values for the array in the nodal 
values_storage for the given node, component, version,type.

Give an error if field->values_storage isn't storing array types.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type;
	int i,length,return_code,size;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	Value_storage *values_storage;

	ENTER(get_FE_nodal_array_attributes);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if (node_field=find_FE_node_field_in_info(component->field,node->fields))
		{
			if ((node_field_component=node_field->components)&&
				(nodal_value_type=node_field_component->nodal_value_types))
			{
				/* get the value type*/
				*value_type	= node_field->field->value_type;
				switch(node_field->field->value_type)
				{
					case DOUBLE_ARRAY_VALUE:
					case FE_VALUE_ARRAY_VALUE:
					case FLT_ARRAY_VALUE:	
					case SHORT_ARRAY_VALUE:
					case INT_ARRAY_VALUE:
					case UNSIGNED_ARRAY_VALUE:	
					case STRING_VALUE:				
					{								
						node_field_component += component->number;
						if (version<node_field_component->number_of_versions)
						{
							length=1+(node_field_component->number_of_derivatives);
							i=0;
							while ((i<length)&&(type!=nodal_value_type[i]))
							{
								i++;
							}
							if (i<length)
							{
								size = get_Value_storage_size(*value_type);
								/* get the offset into nodal values_storage*/
								values_storage = node->values_storage+(node_field_component->value)+
									((version*length+i)*size);
								if(node_field->field->value_type!=STRING_VALUE)
								{
								/*copy in the number_of_array_values  */							
								*number_of_array_values = *((int *)(values_storage));
								}
								else
								{	
									char *the_string,**str_address;								
									str_address = (char **)(values_storage);
									the_string = *str_address;
									*number_of_array_values = strlen(the_string)+1;/* +1 for NULL term.*/
								}
								return_code=1;
							}
						}
					}break;				
					default:
					{					
						display_message(ERROR_MESSAGE,
							"get_FE_nodal_array_attributes. Not an array type");
					}break;
				}


			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_array_attributes. Invalid node/field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_array_attributes."
			" Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /*get_FE_nodal_array_attributes */
#endif /* OLD_CODE*/

enum Value_type get_FE_nodal_value_type(struct FE_node *node,
	struct FE_field_component *component,int version)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
Get's a node's field's value type
==============================================================================*/
{
	enum Value_type value_type;
	struct FE_node_field *node_field;

	ENTER(get_FE_nodal_value_type);
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if (node_field=find_FE_node_field_in_info(component->field,node->fields))
		{		
			/* get the value type*/
			value_type	= node_field->field->value_type;		
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_value_type."
			" Invalid argument(s)");
		value_type	=UNKNOWN_VALUE;
	}
	LEAVE;

	return (value_type);
} /*get_FE_nodal_value_type */

int get_FE_nodal_array_number_of_elements(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
Returns the number of elements  for the array in the nodal 
values_storage for the given node, component, version,type.

Returns -1 upon error.

Give an error if field->values_storage isn't storing array types.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type;
	int i,length,size,number_of_array_elements;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	Value_storage *values_storage;

	ENTER(get_FE_nodal_array_number_of_elements);
	number_of_array_elements=-1;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if (node_field=find_FE_node_field_in_info(component->field,node->fields))
		{
			if ((node_field_component=node_field->components)&&
				(nodal_value_type=node_field_component->nodal_value_types))
			{			
				switch(node_field->field->value_type)
				{
					case DOUBLE_ARRAY_VALUE:
					case FE_VALUE_ARRAY_VALUE:
					case FLT_ARRAY_VALUE:	
					case SHORT_ARRAY_VALUE:
					case INT_ARRAY_VALUE:
					case UNSIGNED_ARRAY_VALUE:	
					case STRING_VALUE:				
					{								
						node_field_component += component->number;
						if (version<node_field_component->number_of_versions)
						{
							length=1+(node_field_component->number_of_derivatives);
							i=0;
							while ((i<length)&&(type!=nodal_value_type[i]))
							{
								i++;
							}
							if (i<length)
							{/* get the value type*/			
								size = get_Value_storage_size(node_field->field->value_type);
								/* get the offset into nodal values_storage*/
								values_storage = node->values_storage+(node_field_component->value)+
									((version*length+i)*size);
								if(node_field->field->value_type!=STRING_VALUE)
								{
								/*copy in the number_of_array_values  */							
								number_of_array_elements = *((int *)(values_storage));
								}
								else
								{	
									char *the_string,**str_address;								
									str_address = (char **)(values_storage);
									the_string = *str_address;
									number_of_array_elements = strlen(the_string)+1;/* +1 for NULL term.*/
								}							
							}
						}
					}break;				
					default:
					{					
						display_message(ERROR_MESSAGE,
							"get_FE_nodal_array_number_of_elements. Not an array type");
					}break;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_array_number_of_elements. Invalid node/field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"."
			"get_FE_nodal_array_number_of_elements Invalid argument(s)");
	}
	LEAVE;

	return (number_of_array_elements);
} /* get_FE_nodal_array_number_of_elements*/

int get_FE_nodal_double_array_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,double *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Gets a particular double array value (<version>, <type>) for the field <component> 
at the <node> of length number_of_array_values. 
If number_of_array_values > the stored arrays max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_nodal_array_attributes to get the size of an array.
??JW write get_FE_nodal_max_array_size() to avoid many ALLOCATES 
if need to locally and repetatively get many arrays.  

==============================================================================*/
{
	int return_code,the_array_number_of_values,array_size;
	Value_storage *values_storage = NULL;

	double *the_array,**array_address;

	ENTER(get_FE_nodal_double_array_value);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		array)
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,DOUBLE_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(double);

			/* get the address to copy from*/		
			array_address = (double **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_double_array_value. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_double_array_value.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_double_array_value */

int set_FE_nodal_double_array_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,double *array,int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Finds any existing double array at the place specified by (<version>, <type>) 
for the field <component>  at the <node>.

Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the specified 
place in the node->values_storage. 

Therefore, should free the passed array, after passing it to this function.

The nodal values_storage MUST have been previously allocated within 
define_FE_field_at_node.
==============================================================================*/
{
	int return_code,array_size; 
	Value_storage *values_storage = NULL;
	double *pointer,*the_array,**array_address;


	ENTER(set_FE_nodal_double_array_value);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if(find_FE_nodal_values_storage_dest(node,component,version,type,DOUBLE_ARRAY_VALUE,
			&values_storage))
		{				
			/* get the pointer to stored the array, free any existing one */
			array_address = (double **)(values_storage+sizeof(int));
			pointer = *array_address;		
			if(pointer!=NULL)
			{				
				DEALLOCATE(pointer);		
			}
			/* copy the number of array values into field->values_storage*/			
			*((int *)values_storage) = number_of_array_values;
			/* Allocate the space for the array, and copy the data in */
			array_size = number_of_array_values*sizeof(double);
			if(ALLOCATE(the_array,double,array_size))
			{
				memcpy(the_array,array,array_size);
				/*copy the pointer to the array into field->values_storage  */
				*array_address = the_array;				
				return_code=1;
			}
			else
			{
				*array_address = (double *)NULL;	
				*((int *)values_storage) = 0;
				display_message(ERROR_MESSAGE,
					"set_FE_nodal_double_array_value. Out of Memory )");
				return_code=0;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_double_array_value. find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_double_array_value. Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_double_array_value */

int get_FE_nodal_short_array(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,short *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION :
Gets a particular short array value (<version>, <type>) for the field <component> 
at the <node> of length number_of_array_values. 
If number_of_array_values > the stored arrays max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_nodal_array_attributes to get the size of an array.
??JW write get_FE_nodal_max_array_size() to avoid many ALLOCATES 
if need to locally and repetatively get many arrays.  

==============================================================================*/
{
	int return_code,the_array_number_of_values,array_size;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address;

	ENTER(get_FE_nodal_short_array);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		array)
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,SHORT_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(short);

			/* get the address to copy from*/		
			array_address = (short **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_short_array */

int set_FE_nodal_short_array(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,short *array,int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION :
Finds any existing short array at the place specified by (<version>, <type>) 
for the field <component>  at the <node>.

Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the specified 
place in the node->values_storage. 

Therefore, should free the passed array, after passing it to this function.

The nodal values_storage MUST have been previously allocated within 
define_FE_field_at_node.
==============================================================================*/
{
	int return_code,array_size; 
	Value_storage *values_storage = NULL;
	short *pointer,*the_array,**array_address;


	ENTER(set_FE_nodal_short_value);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if(find_FE_nodal_values_storage_dest(node,component,version,type,SHORT_ARRAY_VALUE,
			&values_storage))
		{				
			/* get the pointer to stored the array, free any existing one */
			array_address = (short **)(values_storage+sizeof(int));
			pointer = *array_address;		
			if(pointer!=NULL)
			{				
				DEALLOCATE(pointer);		
			}
			/* copy the number of array values into field->values_storage*/			
			*((int *)values_storage) = number_of_array_values;
			/* Allocate the space for the array, and copy the data in */
			array_size = number_of_array_values*sizeof(short);
			if(ALLOCATE(the_array,short,array_size))
			{
				memcpy(the_array,array,array_size);
				/*copy the pointer to the array into field->values_storage  */
				*array_address = the_array;				
				return_code=1;
			}
			else
			{
				*array_address = (short *)NULL;	
				*((int *)values_storage) = 0;
				display_message(ERROR_MESSAGE,
					"set_FE_nodal_short_array. Out of Memory )");
				return_code=0;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_short_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_short_array. Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_short_array */

int get_FE_nodal_FE_value_array(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,FE_value *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION :
Gets a particular FE_value array value (<version>, <type>) for the field <component> 
at the <node> of length number_of_array_values. 
If number_of_array_values > the stored arrays max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_nodal_array_attributes to get the size of an array.
??JW write get_FE_nodal_max_array_size() to avoid many ALLOCATES 
if need to locally and repetatively get many arrays.  

==============================================================================*/
{
	int return_code,the_array_number_of_values,array_size;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address;

	ENTER(get_FE_nodal_FE_value_array);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		array)
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,FE_VALUE_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(FE_value);

			/* get the address to copy from*/		
			array_address = (FE_value **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_FE_value_array */

int set_FE_nodal_FE_value_array(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,FE_value *array,int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 13 September 2000

DESCRIPTION :
Finds any existing FE_value array at the place specified by (<version>, <type>) 
for the field <component>  at the <node>.

Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the specified 
place in the node->values_storage. 
Can pass a null <array>, with <number_of_array_values>=0.

Therefore, should free the passed array, after passing it to this function.

The nodal values_storage MUST have been previously allocated within 
define_FE_field_at_node.
==============================================================================*/
{
	int return_code,array_size; 
	Value_storage *values_storage = NULL;
	FE_value *pointer,*the_array,**array_address;


	ENTER(set_FE_nodal_FE_value_array);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if(find_FE_nodal_values_storage_dest(node,component,version,type,FE_VALUE_ARRAY_VALUE,
			&values_storage))
		{				
			/* get the pointer to stored the array, free any existing one */
			array_address = (FE_value **)(values_storage+sizeof(int));
			pointer = *array_address;		
			if(pointer!=NULL)
			{				
				DEALLOCATE(pointer);		
			}
			/* copy the number of array values into field->values_storage*/			
			*((int *)values_storage) = number_of_array_values;
			/* Allocate the space for the array, and copy the data in */
			array_size = number_of_array_values*sizeof(FE_value);
			if(array_size)
			{
				if(ALLOCATE(the_array,FE_value,array_size))
				{
					memcpy(the_array,array,array_size);
					/*copy the pointer to the array into field->values_storage  */
					*array_address = the_array;				
					return_code=1;
				}
				else
				{
					*array_address = (FE_value *)NULL;	
					*((int *)values_storage) = 0;
					display_message(ERROR_MESSAGE,
						"set_FE_nodal_FE_value_array. Out of Memory )");
					return_code=0;
				}
			}
			else
			{
				/* no array set yet. This is a valid thing to do*/
				*array_address =(FE_value *)NULL;
				*((int *)values_storage) = 0;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_FE_value_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_FE_value_array. Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_FE_value_array */

FE_value get_FE_nodal_FE_value_array_element(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int element_number)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
Gets a particular FE_value_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 

==============================================================================*/
{
	int the_array_number_of_values;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address,value;

	ENTER(get_FE_nodal_FE_value_array_element);
	value=0.0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,FE_VALUE_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (FE_value **)(values_storage+sizeof(int));
				the_array = *array_address;
				value=the_array[element_number];
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_FE_value_array_element */

FE_value get_FE_nodal_FE_value_array_interpolated_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int element_number,FE_value proportion)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
returns the interpolated value between the array (*element_number= value_low) 
and *(element_number+1)=value_high, according to 
value=<proportion>*value_low+(1-<proportion>)*value_high;
==============================================================================*/
{
	int the_array_number_of_values;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address,value,value_low,value_high;

	ENTER(get_FE_nodal_FE_value_array_interpolated_value);
	value=0.0;
	value_low=0.0;
	value_high=0.0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,FE_VALUE_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (FE_value **)(values_storage+sizeof(int));
				the_array = *array_address;
				/* interpolate between adjacent values */
				value_low=the_array[element_number];
				/* can't go off the end of the array */
				if(element_number==(the_array_number_of_values-1))
				{
					value=value_low;
				}
				else
				{
					value_high=the_array[element_number+1];
					value=proportion*value_low+(1-proportion)*value_high;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_interpolated_value. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_interpolated_value. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array_interpolated_value.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_FE_value_array_interpolated_value */

int set_FE_nodal_FE_value_array_element(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int element_number,FE_value value)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
sets a particular FE_value_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 

==============================================================================*/
{
	int the_array_number_of_values,return_code;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address

	ENTER(set_FE_nodal_FE_value_array_element);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,FE_VALUE_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (FE_value **)(values_storage+sizeof(int));
				the_array = *array_address;
				the_array[element_number]=value;
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"set_FE_nodal_FE_value_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_FE_value_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_FE_value_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_FE_value_array_element */

short get_FE_nodal_short_array_element(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int element_number)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
Gets a particular short_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 

==============================================================================*/
{
	int the_array_number_of_values;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address,value;

	ENTER(get_FE_nodal_short_array_element);
	value=0.0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,SHORT_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (short **)(values_storage+sizeof(int));
				the_array = *array_address;
				value=the_array[element_number];
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_short_array_element */

short get_FE_nodal_short_array_interpolated_value(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int element_number,FE_value proportion)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
returns the interpolated value between the array (*element_number= value_low) 
and *(element_number+1)=value_high, according to 
value=<proportion>*value_low+(1-<proportion>)*value_high;
==============================================================================*/
{
	int the_array_number_of_values;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address,value,value_low,value_high;

	ENTER(get_FE_nodal_short_array_interpolated_value);
	value=0.0;
	value_low=0.0;
	value_high=0.0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,SHORT_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (short **)(values_storage+sizeof(int));
				the_array = *array_address;
				/* interpolate between adjacent values */
				value_low=the_array[element_number];
				/* can't go off the end of the array */
				if(element_number==(the_array_number_of_values-1))
				{
					value=value_low;
				}
				else
				{
					value_high=the_array[element_number+1];
					value=proportion*value_low+(1-proportion)*value_high;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_interpolated_value. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_interpolated_value. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array_interpolated_value.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_short_array_interpolated_value */

int set_FE_nodal_short_array_element(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,int element_number,short value)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
sets a particular short_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 

==============================================================================*/
{
	int the_array_number_of_values,return_code;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address

	ENTER(set_FE_nodal_short_array_element);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,FE_VALUE_ARRAY_VALUE,
			&values_storage))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if(element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (short **)(values_storage+sizeof(int));
				the_array = *array_address;
				the_array[element_number]=value;
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"set_FE_nodal_short_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_short_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_short_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_short_array_element */

int get_FE_field_time_array_index_at_FE_value_time(struct FE_field *field,
	FE_value time,FE_value *the_time_high,FE_value *the_time_low,
	int *the_array_index,int *the_index_high,int *the_index_low)
/*******************************************************************************
LAST MODIFIED : 1 August 2000

DESCRIPTION 
Given a <field> and <time>, checks that <field> has times defined and returns:
<the_array_index>, the array index of <field> times closest to <time>.
<the_index_high>, <the_index_low> the upper and lower limits for <the_array_index>
(ideally <the_index_high>==<the_index_low>==<the_array_index>).
<the_time_low> the time corresponding to <the_index_low>.
<the_time_high> the time corresponding to <the_index_high>.

All this information (rather than just <the_array_index> ) is returned so can
perform interpolation, etc.
==============================================================================*/
{	
	int array_index,done,index_high,index_low,number_of_times,return_code,step;	
	FE_value first_time,last_time,this_time,fe_value_index,time_high,time_low;

	ENTER(get_FE_field_time_array_index_at_FE_value_time);
	return_code=0;
	/* check arguments */
	if(field&&the_time_high&&the_time_low&&the_array_index&&the_index_high&&
		the_index_low&&(number_of_times=get_FE_field_number_of_times(field)))
	{		
		get_FE_field_time_FE_value(field,0,&first_time);
		get_FE_field_time_FE_value(field,number_of_times-1,&last_time);
		/*Initial est. of the array index, assuming times evenly spaced, no gaps */	
		/*This assumption and hence estimate is true for most signal files. */
		fe_value_index=((time-first_time)/(last_time-first_time))*(number_of_times-1);
		fe_value_index+=0.5;/*round float to nearest int */
		array_index=floor(fe_value_index);
		time_low=0;
		time_high=0;
		done=0;
		index_low=0;
		index_high=number_of_times-1;
		/* do binary search for <time>'s array index. Also look at time of */
		/* adjacent array element, as index estimate may be slightly off due to*/
		/* rounding error. This avoids unnecessarily long search from end of array */
		while(!done)
		{	
			if(get_FE_field_time_FE_value(field,array_index,&this_time))
			{
				if(this_time>=time)
				{ 
					index_high=array_index;					
					if(array_index>0)
					{
						/* get adjacent array element*/
						get_FE_field_time_FE_value(field,array_index-1,&time_low);
						/* are we between elements?*/
						if(time_low<time)
						{			
							index_low=array_index-1;
							return_code=1;
							done=1;
						}	
						else
						{
							time_low=0;
						}
					}
					else
					{
						/* can't get lower adjacent array element when array_index=0. Finished*/
						get_FE_field_time_FE_value(field,array_index,&time_low);
						index_low=array_index;
						return_code=1;
						done=1;
					}
				}
				else /* (this_time<time) */
				{
					index_low=array_index;
					if(array_index<(number_of_times-1))
					{
						/* get adjacent array element*/
						get_FE_field_time_FE_value(field,array_index+1,&time_high);	
						/* are we between elements?*/
						if(time_high>time)
						{		
							index_high=array_index+1;
							return_code=1;
							done=1;
						}	
						else
						{
							time_high=0;
						}
					}
					else
					{
						/* can't get higher adjacent array element when */
						/*array_index=(number_of_times-1). Finished*/
						get_FE_field_time_FE_value(field,array_index,&time_high);
						index_high=array_index;
						return_code=1;
						done=1;
					}
				}	
				if(!done)
				{	
					step=(index_high-index_low)/2;	
					/* No exact match, can't subdivide further, must do interpolation.*/
					if(step==0)												
					{	
						done=1;	
						return_code=1;														
					}
					else
					{
						array_index=index_low+step;
					}
						
				}/* if(!done)	*/
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_time_array_index_at_FE_value_time time out of range");
			}
		}	/* while(!done)	*/
		/* index_low and index_high should now be adjacent */
		if(!time_low)
		{
			get_FE_field_time_FE_value(field,index_low,&time_low);
		}
		if(!time_high)
		{
			get_FE_field_time_FE_value(field,index_high,&time_high);
		}
		*the_time_high=time_high;
		*the_time_low=time_low;
		*the_array_index=array_index;
		*the_index_high=index_high;
		*the_index_low=index_low;
	}
	else
	{
		return_code=0;
		display_message(ERROR_MESSAGE,
			"get_FE_field_time_array_index_at_FE_value_time. Invalid arguments time out of range");
	}	
	LEAVE;
	return (return_code);
}/*get_FE_field_time_array_index_at_FE_value_time*/

int get_FE_nodal_FE_value_array_value_at_FE_value_time(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,FE_value time,FE_value *value)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
Gets the FE_value <value> from the node's FE_value array at the given
<component> <version> <type>, using the <time> to index the array.
The field must have time defined for it, and the number of times must match
the number of array elements. If <time> is within the node field's time array's 
range, but doesn't correspond exactly to an array element, interpolates to determine 
<value>.	
 	
==============================================================================*/
{
	int array_number_of_values,array_index,index_high,index_low,number_of_times,
		return_code;	
	FE_value time_high,time_low,prop;
	struct FE_field *field;
	
	ENTER(get_FE_nodal_FE_value_array_value_at_FE_value_time);
	return_code=0;
	/* check arguments */
	if (node&&component&&(field=component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if((get_FE_field_time_value_type(field)==FE_VALUE_VALUE)
			&&(number_of_times=get_FE_field_number_of_times(field)))
		{	
			array_number_of_values = get_FE_nodal_array_number_of_elements(node,
				component,version,type);									
			if(number_of_times==array_number_of_values)
			{
				/* field has the right time values, and is defined at node. We're OK*/
				/*get the field's time array index of <time>*/
				return_code=get_FE_field_time_array_index_at_FE_value_time(field,
					time,&time_high,&time_low,&array_index,&index_high,&index_low);
				prop=(time_high-time)/(time_high-time_low);
				/* interpolate the nodal value at this array index*/
				*value=get_FE_nodal_FE_value_array_interpolated_value(node,component,version,
					type,index_low,prop);					
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_FE_value_array_value_at_FE_value_time."
					" number_of_times!=array_number_of_values");
			}					
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_value_at_FE_value_time."
				" Time is not stored as FE_VALUE_VALUE");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			" get_FE_nodal_FE_value_array_value_at_FE_value_time .Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_FE_value_array_value_at_FE_value_time */

int get_FE_nodal_short_array_value_at_FE_value_time(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,FE_value time,short *value)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
Gets the short <value> from the node's short array at the given
<component> <version> <type>, using the <time> to index the array.
The field must have time defined for it, and the number of times must match
the number of array elements. If <time> is within the node field's time array's 
range, but doesn't correspond exactly to an array element, interpolates to determine 
<value>.	
 	
==============================================================================*/
{
	int array_number_of_values,array_index,index_high,index_low,number_of_times,
		return_code;	
	FE_value time_high,time_low,prop;
	struct FE_field *field;
	
	ENTER(get_FE_nodal_short_array_value_at_FE_value_time);
	return_code=0;
	/* check arguments */
	if (node&&component&&(field=component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if((get_FE_field_time_value_type(field)==FE_VALUE_VALUE)
			&&(number_of_times=get_FE_field_number_of_times(field)))
		{	
			array_number_of_values = get_FE_nodal_array_number_of_elements(node,
				component,version,type);									
			if(number_of_times==array_number_of_values)
			{			
				/* field has the right time values, and is defined at node. We're OK*/
				/*get the field's time array index of <time>*/
				return_code=get_FE_field_time_array_index_at_FE_value_time(field,
					time,&time_high,&time_low,&array_index,&index_high,&index_low);				
				prop=(time_high-time)/(time_high-time_low);		
				/* interpolate the nodal value at this array index*/ 
				*value=get_FE_nodal_short_array_interpolated_value(node,component,version,
					type,index_low,prop);					
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_short_array_value_at_FE_value_time."
					" number_of_times!=array_number_of_values");
			}					
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_value_at_FE_value_time."
				" Time is not stored as FE_VALUE_VALUE");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			" get_FE_nodal_short_array_value_at_FE_value_time .Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_short_array_value_at_FE_value_time */

int get_FE_nodal_FE_value_array_min_max(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,FE_value *minimum,FE_value *maximum)
/*******************************************************************************
LAST MODIFIED : 29 September 1999

DESCRIPTION :
Gets a the minimum and maximum values for the FE_value_array 
(<version>, <type>) for the field <component> at the <node>

==============================================================================*/
{
	int return_code,array_number_of_values,count;
	Value_storage *values_storage = NULL;
	FE_value *array,**array_address,min,max;

	ENTER(get_FE_nodal_FE_value_array_min_max);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,FE_VALUE_ARRAY_VALUE,
			&values_storage))
		{							
			array_number_of_values = *((int *)values_storage);		
			/* get the address to copy from*/		
			array_address = (FE_value **)(values_storage+sizeof(int));
			array = *array_address;	
			min=array[0];
			max=array[0];
			for(count=0;count<array_number_of_values;count++)
			{
				if(array[count]>max)
				{
					max=array[count];
				}
				if(array[count]<min)
				{
					min=array[count];
				}
			}
			*minimum=min;
			*maximum=max;
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_min_max. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array_min_max.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_FE_value_array_min_max */

int get_FE_nodal_short_array_min_max(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,short *minimum,short *maximum)
/*******************************************************************************
LAST MODIFIED : 29 September 1999

DESCRIPTION :
Gets a the minimum and maximum values for the _value_array 
(<version>, <type>) for the field <component> at the <node>

==============================================================================*/
{
	int return_code,array_number_of_values,count;
	Value_storage *values_storage = NULL;
	short *array,**array_address,min,max;

	ENTER(get_FE_nodal_short_array_min_max);
	return_code=0;
	/* check arguments */
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if(find_FE_nodal_values_storage_dest(node,component,version,type,SHORT_ARRAY_VALUE,
			&values_storage))
		{							
			array_number_of_values = *((int *)values_storage);		
			/* get the address to copy from*/		
			array_address = (short **)(values_storage+sizeof(int));
			array = *array_address;	
			min=array[0];
			max=array[0];
			for(count=0;count<array_number_of_values;count++)
			{
				if(array[count]>max)
				{
					max=array[count];
				}
				if(array[count]<min)
				{
					min=array[count];
				}
			}
			*minimum=min;
			*maximum=max;
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_min_max. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array_min_max.Invalid argument(s)");
	}
	LEAVE;
	return (return_code);
} /* get_FE_nodal_short_array_min_max */

int get_FE_nodal_string_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,char **string)
/*******************************************************************************
LAST MODIFIED : 3 September 1999

DESCRIPTION :
Returns a copy of the string for <version>, <type> of <field><component_number> 
at the <node>. Up to the calling function to DEALLOCATE the returned string.
Returned <*string> may be a valid NULL if that is what is in the node.
==============================================================================*/
{
	char *the_string;
	int return_code;
	struct FE_field_component component;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_string_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&string)
	{
		values_storage=(Value_storage *)NULL;
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				values_storage=field->values_storage +
					get_Value_storage_size(STRING_VALUE)*component_number;
				return_code=1;
			} break;
			case GENERAL_FE_FIELD:
			{
				/* Put into a component for the meantime */
				component.field = field;
				component.number = component_number;
				if (find_FE_nodal_values_storage_dest(node,&component,version,type,
					STRING_VALUE,&values_storage))
				{
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,"get_FE_nodal_string_value.  "
						"find_FE_nodal_values_storage_dest failed");
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index;
				struct FE_field_component index_component;

				index_component.field=field->indexer_field;
				index_component.number=0;
				if (get_FE_nodal_int_value(node,&index_component,/*version*/0,
					FE_NODAL_VALUE,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						values_storage=field->values_storage+
							get_Value_storage_size(STRING_VALUE)*
							(field->number_of_indexed_values*component_number+index-1);
						return_code=1;	
					}
					else
					{
						display_message(ERROR_MESSAGE,"get_FE_nodal_string_value.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_string_value.  "
						"Field %s, indexed by %s not defined at node %",
						field->name,field->indexer_field->name,node->cm_node_identifier);
					return_code=0;	
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_string_value.  Unknown FE_field_type");
			} break;
		}
		if (return_code&&values_storage)
		{
			if (the_string = *((char **)values_storage))
			{
				if (ALLOCATE(*string,char,strlen(the_string)+1))
				{
					strcpy(*string,the_string);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_nodal_string_value.  Not enough memory");
					return_code=0;
				}
			}
			else
			{
				/* no string, so successfully return NULL */
				*string = (char *)NULL;
			}
		}
		else
		{
			if (return_code)
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_element_xi_value.  No values storage");
				return_code=0;
			}
		}
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_string_value.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_string_value */

int set_FE_nodal_string_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,char *string)
/*******************************************************************************
LAST MODIFIED : 22 September 1999

DESCRIPTION :
Copies and sets the <string> for <version>, <type> of <field><component_number>
at the <node>. <string> may be NULL.
==============================================================================*/
{
	char *the_string,**string_address;
	int return_code; 
	struct FE_field_component component;
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_string_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		component.field=field;
		component.number=component_number;
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,&component,version,type,
			STRING_VALUE,&values_storage))
		{
			/* get the pointer to the stored string */			
			string_address = (char **)(values_storage);
			if (string)
			{
				/* reallocate the string currently there */
				if (REALLOCATE(the_string,*string_address,char,strlen(string)+1))
				{
					strcpy(the_string,string);
					*string_address=the_string;
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_nodal_string_value.  Not enough memory");
				}
			}
			else
			{
				/* NULL string; free the existing string */
				if (*string_address)
				{
					DEALLOCATE(*string_address);
				}
				return_code=1;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_string_value.  find_FE_nodal_values_storage_dest failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_string_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_string_value */

int set_FE_nodal_field_double_values(struct FE_field *field,
	struct FE_node *node,double *values, int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the doubles in values. 
Returns the number of doubles copied in number_of_values.
Assumes that values is set up with the correct number of doubles.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,number_of_derivatives,
		length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	double *dest,*source;

	ENTER(set_FE_nodal_field_double_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==DOUBLE_VALUE)
		{
			if (node_field =FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))
			{
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (double *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length = (1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_double_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_double_values.  "
				"field->value_type != DOUBLE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_double_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_field_double_values */

int get_FE_nodal_field_number_of_values(struct FE_field *field,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Returns the total number of values stored for that field at the node, equals
sum of <1+num_derivatives>*num_versions for each component.
==============================================================================*/
{
	int number_of_values;
	struct FE_node_field *node_field;
	
	ENTER(get_FE_nodal_field_number_of_values);
	if (field&&node&&node->fields)
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node->fields->node_field_list))
		{
			number_of_values=FE_node_field_get_number_of_values(node_field);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_field_FE_value_values.  Can't find field %s at node %d",
				field->name,node->cm_node_identifier);
			number_of_values=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_field_FE_value_values.  Invalid argument(s)");
		number_of_values=0;
	}
	LEAVE;

	return (number_of_values);
} /* get_FE_nodal_field_number_of_values */

int get_FE_nodal_field_FE_value_values(struct FE_field *field,
	struct FE_node *node,int *number_of_values,FE_value **values)
/*******************************************************************************
LAST MODIFIED : 20 September 1999

DESCRIPTION :
Allocates and returns a copy of the <number_of_values>-length <values> array
stored at the <node> for all components derivatives and versions of <field>.
It is up to the calling function to DEALLOCATE the returned array.
==============================================================================*/
{
	int i,j,length,number_of_derivatives,number_of_versions,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	FE_value *dest,*source;

	ENTER(get_FE_nodal_field_FE_value_values);
	return_code=0;
	if (field&&node&&number_of_values&&values&&node->values_storage)
	{
		if (field->value_type==FE_VALUE_VALUE)
		{
			if ((node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))&&node_field->components)
			{
				*number_of_values=FE_node_field_get_number_of_values(node_field);
				if (ALLOCATE(*values,FE_value,*number_of_values))
				{
					dest= *values;
					for (i=0;i<field->number_of_components;i++)
					{
						component = &(node_field->components[i]);
						source=(FE_value *)(node->values_storage + component->value);
						number_of_versions = component->number_of_versions;
						number_of_derivatives = component->number_of_derivatives;
						length=(1+number_of_derivatives)*number_of_versions;
						for (j=length;0<j;j--)
						{
							*dest = *source;
							dest++;
							source++;
						}
					}
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_nodal_field_FE_value_values.  Not enough memory");
				}
			}
			else
			{	
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_field_FE_value_values.  Can't find field %s at node %d",
					field->name,node->cm_node_identifier);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"get_FE_nodal_field_FE_value_values.  "
				"value_type not FE_VALUE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_field_FE_value_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return(return_code);
} /* get_FE_nodal_field_FE_value_values */

int set_FE_nodal_field_FE_value_values(struct FE_field *field,
	struct FE_node *node,FE_value *values,int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the FE_values in values. 
Returns the number of FE_values copied in number_of_values.
Assumes that values is set up with the correct number of FE_values.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,number_of_derivatives,
		length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	FE_value *dest,*source;

	ENTER(set_FE_nodal_field_FE_value_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==FE_VALUE_VALUE)
		{
			if (node_field =FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))
			{
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (FE_value *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length =(1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_FE_value_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_FE_value_values.  "
				"field->value_type not FE_VALUE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_FE_value_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return(return_code);
} /* set_FE_nodal_field_FE_value_values */

int set_FE_nodal_field_float_values(struct FE_field *field,
	struct FE_node *node,float *values, int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the floats in values. 
Returns the number of floats copied in number_of_values.
Assumes that values is set up with the correct number of floats.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,number_of_derivatives,
		length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	float *dest,*source;

	ENTER(set_FE_nodal_field_float_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==FLT_VALUE)
		{
			if (node_field =FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))
			{		 
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (float *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length =(1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_float_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_float_values.  "
				"field->value_type != FLT_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_float_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return(return_code);
} /* set_FE_nodal_field_float_values */

int get_FE_nodal_field_int_values(struct FE_field *field,
	struct FE_node *node,int *number_of_values,int **values)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Allocates and returns a copy of the <number_of_values>-length <values> array
stored at the <node> for all components derivatives and versions of <field>.
It is up to the calling function to DEALLOCATE the returned array.
==============================================================================*/
{
	int i,j,length,number_of_derivatives,number_of_versions,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	int *dest,*source;

	ENTER(get_FE_nodal_field_int_values);
	return_code=0;
	if (field&&node&&number_of_values&&values&&node->values_storage)
	{
		if (field->value_type==INT_VALUE)
		{
			if ((node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))&&node_field->components)
			{
				*number_of_values=FE_node_field_get_number_of_values(node_field);
				if (ALLOCATE(*values,int,*number_of_values))
				{
					return_code=1;
					dest= *values;
					for (i=0;i<field->number_of_components;i++)
					{
						component = &(node_field->components[i]);
						source=(int *)(node->values_storage + component->value);
						number_of_versions = component->number_of_versions;
						number_of_derivatives = component->number_of_derivatives;
						length=(1+number_of_derivatives)*number_of_versions;
						for (j=length;0<j;j--)
						{
							*dest = *source;
							dest++;
							source++;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_nodal_field_int_values.  Not enough memory");
				}
			}
			else
			{	
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_field_int_values.  Can't find field %s at node %d",
					field->name,node->cm_node_identifier);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"get_FE_nodal_field_int_values.  "
				"value_type not FE_VALUE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_field_int_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return(return_code);
} /* get_FE_nodal_field_int_values */

int set_FE_nodal_field_int_values(struct FE_field *field,
	struct FE_node *node,int *values, int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the integers in values. 
Returns the number of integers copied in number_of_values.
Assumes that values is set up with the correct number of ints.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,
		number_of_derivatives,length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	int *dest,*source;

	ENTER(set_FE_nodal_field_int_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==INT_VALUE)
		{
			if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				field,node->fields->node_field_list))
			{
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (int *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length =(1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_int_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_int_values.  "
				"field->value_type != INT_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_int_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return(return_code);
} /* set_FE_nodal_field_int_values */

int get_FE_node_number_of_values(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 5 November 1998

DESCRIPTION :
Returns the number of values stored at the <node>.
==============================================================================*/
{
	int number_of_values;

	ENTER(get_FE_node_number_of_values);
	if (node&&(node->fields))
	{
		number_of_values=node->fields->number_of_values;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_number_of_values.  Invalid node");
		number_of_values=0;
	}
	LEAVE;

	return (number_of_values);
} /* get_FE_node_number_of_values */

int get_FE_node_number_of_fields(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 5 November 1998

DESCRIPTION :
Returns the number of fields stored at the <node>.
==============================================================================*/
{
	int number_of_fields;

	ENTER(get_FE_node_number_of_fields);
	if (node&&(node->fields))
	{
		number_of_fields=
			NUMBER_IN_LIST(FE_node_field)(node->fields->node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_number_of_fields.  Invalid node");
		number_of_fields=0;
	}
	LEAVE;

	return (number_of_fields);
} /* get_FE_node_number_of_fields */

enum FE_nodal_value_type *get_FE_node_field_component_nodal_value_types(
	struct FE_node *node,struct FE_field *field,int component_number)
/*******************************************************************************
LAST MODIFIED : 20 April 2000

DESCRIPTION :
Returns an array of the (1+number_of_derivatives) value types for the
node field component.
It is up to the calling function to DEALLOCATE the returned array.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_types;
	int i,number_of_derivatives;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;

	ENTER(get_FE_node_field_component_nodal_value_types);
	nodal_value_types=(enum FE_nodal_value_type *)NULL;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components))
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,node->fields->node_field_list))
		{
			component=&(node_field->components[component_number]);
			number_of_derivatives=component->number_of_derivatives;
			if (ALLOCATE(nodal_value_types,enum FE_nodal_value_type,
				1+number_of_derivatives))
			{
				for (i=0;i<=number_of_derivatives;i++)
				{
					/* non-GENERAL_FE_FIELD do not have nodal_value_types since
						 derivatives do not make sense */
					if (component->nodal_value_types)
					{
						nodal_value_types[i]=component->nodal_value_types[i];
					}
					else
					{
						nodal_value_types[i]=FE_NODAL_VALUE;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_node_field_component_nodal_value_types.  Not enough memory");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_node_field_component_nodal_value_types.  "
				"Field %s not defined at node %d",field->name,node->cm_node_identifier);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_component_nodal_value_types.  Invalid argument(s)");
	}
	LEAVE;

	return (nodal_value_types);
} /* get_FE_node_field_component_nodal_value_types */

int get_FE_node_field_component_number_of_derivatives(struct FE_node *node,
	struct FE_field *field,int component_number)
/*******************************************************************************
LAST MODIFIED : 23 September 1999

DESCRIPTION :
Returns the number of derivatives for the node field component.
==============================================================================*/
{
	int number_of_derivatives;
	struct FE_node_field *node_field;

	ENTER(get_FE_node_field_number_of_derivatives);
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components))
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,node->fields->node_field_list))
		{
			number_of_derivatives = 
				node_field->components[component_number].number_of_derivatives;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_node_field_component_number_of_derivatives.  "
				"Field %s not defined at node %d",field->name,node->cm_node_identifier);
			number_of_derivatives=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_number_of_derivatives.  Invalid argument(s)");
		number_of_derivatives=0;
	}
	LEAVE;

	return (number_of_derivatives);
} /* get_FE_node_field_number_of_derivatives */

int get_FE_node_field_component_number_of_versions(struct FE_node *node,
	struct FE_field *field,int component_number)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Returns the number of versions for the node field component.
==============================================================================*/
{
	int number_of_versions;
	struct FE_node_field *node_field;

	ENTER(get_FE_node_field_component_number_of_versions);
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components))
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,node->fields->node_field_list))
		{
			number_of_versions = 
				node_field->components[component_number].number_of_versions;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_node_field_component_number_of_versions.  "
				"Field %s not defined at node %d",field->name,node->cm_node_identifier);
			number_of_versions=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_component_number_of_versions.  Invalid argument(s)");
		number_of_versions=0;
	}
	LEAVE;

	return (number_of_versions);
} /* get_FE_node_field_component_number_of_versions */

int get_FE_node_cm_node_identifier(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 5 November 1998

DESCRIPTION :
Returns the cm_node_identifier of the <node>.
???DB.  GET_OBJECT_IDENTIFIER ?
==============================================================================*/
{
	int cm_node_identifier;

	ENTER(get_FE_node_cm_node_identifier);
	if (node)
	{
		cm_node_identifier=node->cm_node_identifier;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_node_cm_node_identifier.  Invalid node");
		cm_node_identifier=0;
	}
	LEAVE;

	return (cm_node_identifier);
} /* get_FE_node_cm_node_identifier */

int get_FE_node_access_count(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 26 September 2000

DESCRIPTION :
Returns the acccess count of the <node>.
Useful for drawing the access count as a field when trying to debug why things
cannot be destroyed.
==============================================================================*/
{
	int access_count;

	ENTER(get_FE_node_cm_node_identifier);
	if (node)
	{
		access_count=node->access_count;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_node_access_count.  Invalid node");
		access_count=0;
	}
	LEAVE;

	return (access_count);
} /* get_FE_node_access_count */

struct FE_field *get_FE_node_default_coordinate_field(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 5 November 1998

DESCRIPTION :
Returns the default coordinate field of the <node>.
==============================================================================*/
{
	struct FE_field *default_coordinate_field;
	struct FE_node_field *default_coordinate_node_field;

	ENTER(get_FE_node_default_coordinate_field);
	if (node&&(node->fields))
	{	
		if (default_coordinate_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
			FE_node_field_is_type_CM_coordinate,(void *)NULL,
			node->fields->node_field_list))
		{
			default_coordinate_field=default_coordinate_node_field->field;
		}
		else
		{
			default_coordinate_field=(struct FE_field *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_default_coordinate_field.  Invalid node");
		default_coordinate_field=(struct FE_field *)NULL;
	}
	LEAVE;

	return (default_coordinate_field);
} /* get_FE_node_default_coordinate_field */

int merge_FE_node(struct FE_node *destination,struct FE_node *source)
/*******************************************************************************
LAST MODIFIED : 28 April 1999

DESCRIPTION :
Merges the fields in <destination> with those from <source>, leaving the
combined fields in <destination>.  Where a field exists in both <source> and
<destination> then the <destination> field values persist, as in our normal
usage these will actually be the values most recently read in.
???DB.  It is important that the new fields for <destination> are added after
	those for <source> (existing node in the manager) otherwise elements that
	use <source> will be broken
???DB.  This is not ideal, but can't be fixed without having pointers from the
	nodes back to the elements OR by having the FE_element field request a
	particular value for a particular field (object oriented, GMH's way) rather
	a particular numbered value in the array of nodal values.
==============================================================================*/
{
	Value_storage *new_value;
	int number_of_values,values_size,return_code;
	struct FE_node_field_info *destination_info,*source_info;
	struct LIST(FE_node_field) *node_field_list;
	struct Merge_FE_node_field_into_list_data merge_data;
	struct Place_nodal_values_data place_data;

	ENTER(merge_FE_node);
	/* check arguments */
	if (source&&destination)
	{
		source_info=source->fields;
		destination_info=destination->fields;
		if (destination_info&&source_info)
		{	 
			/* check consistency of node field information */
			if (source_info==destination_info)
			{
				/* destination has the new values so nothing needs to be done */
#if defined (OLD_CODE)
				new_value=source->values;
				value=destination->values;
				i=destination_info->number_of_values;
				while (i>0)
				{
					*value= *new_value;
					value++;
					new_value++;
					i--;
				}
#endif /* defined (OLD_CODE) */
				return_code=1;
			} /*if (source_info==destination_info)*/
			else
			{
				return_code=1;
				/* construct a node field information structure which contains both */
				/* duplicate the information for the existing node */				
				node_field_list=(struct LIST(FE_node_field) *)NULL;
				if ((node_field_list=CREATE_LIST(FE_node_field)())&&
					COPY_LIST(FE_node_field)(node_field_list,
					source_info->node_field_list))
				{
					/* count the number of values */
					number_of_values=0;
					values_size =0;
					if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(count_nodal_size,
						(void *)(&values_size),node_field_list))
					{

						FOR_EACH_OBJECT_IN_LIST(FE_node_field)(count_nodal_values,
						(void *)(&number_of_values),node_field_list);

						/* include the new information */
						merge_data.changed_node=0;
						merge_data.values_size=values_size;
						merge_data.number_of_values = number_of_values;
						/* node field list */
						merge_data.list=node_field_list;
				 						
						if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
							merge_FE_node_field_into_list,(void *)(&merge_data),
							destination_info->node_field_list))
						{	
							number_of_values=merge_data.number_of_values;							
							values_size = merge_data.values_size;

							if((ALLOCATE(new_value,Value_storage,values_size))&&
								(copy_FE_node_value_storage(source,&new_value,
									destination_info->node_field_list)))
							{
#if defined (OLD_CODE)
								if (merge_data.changed_node)
#endif /* defined (OLD_CODE) */
								{
									/* create the new node information */
									if (!(destination->fields=CREATE(FE_node_field_info)(
										number_of_values,node_field_list)))
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_node.  Could not modify node");
										DESTROY(FE_node_field_info)(
											&(destination->fields));
										destination->fields=destination_info;
										return_code=0;
									}

								}
								if (return_code)
								{
									/* put the new values in the appropriate places */
									place_data.source_values=destination->values_storage;
									place_data.destination_values=new_value;
									/* node field list */
									place_data.list=node_field_list;
									if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
										place_nodal_values,(void *)(&place_data),
										destination_info->node_field_list))
									{
										DEACCESS(FE_node_field_info)(&destination_info);
										destination_info=
											ACCESS(FE_node_field_info)(destination->fields);
										DEALLOCATE(destination->values_storage);
										destination->values_storage=new_value;
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_node.  Error placing node field values");
										return_code=0;
									}																															 
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"merge_FE_node.  Insufficient memory for new values");
								return_code=0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_node.  Error merging node field list");
							return_code=0;
						}																								
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"merge_FE_node.  Error counting nodal values");
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"merge_FE_node.  Error duplicating node field lists");
					return_code=0;
				}
				DESTROY_LIST(FE_node_field)(&node_field_list);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"merge_FE_node.  Invalid field information for source or destination node");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_node */

int set_FE_node(struct Parse_state *state,void *node_address_void,
	void *node_manager_void)
/*******************************************************************************
LAST MODIFIED : 28 April 1997

DESCRIPTION :
Used in command parsing to translate a node name into an node.
???DB.  Should it be here ?
==============================================================================*/
{
	char *current_token;
	int cm_node_identifier,return_code;
	struct FE_node *node,**node_address;
	struct MANAGER(FE_node) *node_manager;

	ENTER(set_FE_node);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if ((node_address=(struct FE_node **)node_address_void)&&
					(node_manager=(struct MANAGER(FE_node) *)node_manager_void))
				{
					if ((1==sscanf(current_token,"%d",&cm_node_identifier))&&(node=
						FIND_BY_IDENTIFIER_IN_MANAGER(FE_node,cm_node_identifier)(cm_node_identifier,
						node_manager)))
					{
						if (node!= *node_address)
						{
							if (*node_address)
							{
								DEACCESS(FE_node)(node_address);
							}
							*node_address=ACCESS(FE_node)(node);
						}
						return_code=shift_Parse_state(state,1);
					}
					else
					{
						display_message(WARNING_MESSAGE,"Unknown node: %s",current_token);
						display_parse_state_location(state);
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,"set_FE_node.  Invalid argument(s)");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," NODE_NUMBER");
				if ((node_address=(struct FE_node **)node_address_void)&&
					(node= *node_address))
				{
					display_message(INFORMATION_MESSAGE,"[%d]",node->cm_node_identifier);
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing number for node");
			display_parse_state_location(state);
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_node.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node */

#if !defined (WINDOWS_DEV_FLAG)
int list_FE_node(struct FE_node *node,void *list_node_information)
/*******************************************************************************
LAST MODIFIED : 19 July 2000

DESCRIPTION :
Outputs the information contained at the node.
==============================================================================*/
{
	int return_code;

	ENTER(list_FE_node);
	if (node)
	{
		return_code=1;
		/* write the number */
		display_message(INFORMATION_MESSAGE,"node : %d\n",node->cm_node_identifier);
		if (list_node_information)
		{
			/* write the field information */
			if (node->fields)
			{
				FOR_EACH_OBJECT_IN_LIST(FE_node_field)(list_FE_node_field,(void *)node,
					node->fields->node_field_list);
			}
#if defined (DEBUG)
			/*???debug*/
			display_message(INFORMATION_MESSAGE,"  access count = %d\n",
				node->access_count);
#endif /* defined (DEBUG) */
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_node.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_node */
#endif /* !defined (WINDOWS_DEV_FLAG) */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(FE_node)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
#if defined (FINITE_ELEMENT_EXCEPT_FOR_FE_node)
DECLARE_INDEXED_LIST_FUNCTIONS(FE_node)
#else /* FINITE_ELEMENT_EXCEPT_FOR_FE_node */
DECLARE_LIST_FUNCTIONS(FE_node)
#endif /* FINITE_ELEMENT_EXCEPT_FOR_FE_node */
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_node,cm_node_identifier,int,
	compare_int)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
#if defined (FINITE_ELEMENT_EXCEPT_FOR_FE_node)
DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_node,cm_node_identifier,int,
	compare_int)
#else /* FINITE_ELEMENT_EXCEPT_FOR_FE_node */
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_node,cm_node_identifier,int,
	compare_int)
#endif /* FINITE_ELEMENT_EXCEPT_FOR_FE_node */
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

PROTOTYPE_MANAGER_COPY_WITH_IDENTIFIER_FUNCTION(FE_node,cm_node_identifier)
{
	int return_code;

	ENTER(MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier));
	if (source&&destination)
	{
		if (return_code=MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier)(
			destination,source))
		{
			destination->cm_node_identifier=source->cm_node_identifier;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
		"MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier) */

PROTOTYPE_MANAGER_COPY_WITHOUT_IDENTIFIER_FUNCTION(FE_node,cm_node_identifier)
/*******************************************************************************
LAST MODIFIED : 14 April 1999

DESCRIPTION :
Creates an EXACT copy of the node (without the identifier).
==============================================================================*/
{
	int return_code;
	Value_storage *temp_values_storage;

	ENTER(MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier));
	if (source&&destination)
	{
		/* make local copy of source values storage */
		temp_values_storage=(Value_storage *)NULL;
		if(allocate_and_copy_FE_node_value_storage(source,&temp_values_storage))
		{
			if (destination->fields)
			{
				FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
					FE_node_field_free_values_storage_arrays,
					(void *)destination,destination->fields->node_field_list);
				DEALLOCATE(destination->values_storage);
			}
			destination->values_storage=temp_values_storage;
			REACCESS(FE_node_field_info)(&(destination->fields),source->fields);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier).  Could not allocate memory for node");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier) */

PROTOTYPE_MANAGER_COPY_IDENTIFIER_FUNCTION(FE_node,cm_node_identifier,int)
{
	int return_code;

	ENTER(MANAGER_COPY_IDENTIFIER(FE_node,cm_node_identifier));
	/*???RC cannot rename nodes that are in use by any list outside the manager
		since they must be removed and re-added to keep indexed list working. Hence,
		disallow this for now */
	if (destination)
	{
		/*???RC renaming nodes in use by any list outside the manager will cause
			list to be corrupted. Allow identifier change under protest here so that
			control_curve / editor work, but disallow name change in select object for
			any object in use outside the manager. */
		destination->cm_node_identifier=cm_node_identifier;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_IDENTIFIER(FE_node,cm_node_identifier).  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_IDENTIFIER(FE_node,cm_node_identifier) */

DECLARE_MANAGER_FUNCTIONS(FE_node)

DECLARE_MANAGER_IDENTIFIER_FUNCTIONS(FE_node,cm_node_identifier,int)

int overwrite_FE_node_with_cm_node_identifier(struct FE_node *destination,
	struct FE_node *source)
/*******************************************************************************
LAST MODIFIED : 27 September 1995

DESCRIPTION :
Overwrites without merging.
???DB.  Used by node editor.  Merging/overwriting needs sorting out.
==============================================================================*/
{
	int return_code;

	ENTER(overwrite_FE_node_with_cm_node_identifier);
	if (source&&destination)
	{
		if (return_code=overwrite_FE_node_without_cm_node_identifier(destination,source))
		{
			destination->cm_node_identifier=source->cm_node_identifier;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"overwrite_FE_node_cm_node_identifier.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* overwrite_FE_node_with_cm_node_identifier */

int overwrite_FE_node_without_cm_node_identifier(struct FE_node *destination,
	struct FE_node *source)
/*******************************************************************************
LAST MODIFIED : 12 April 1999

DESCRIPTION :
Overwrites without merging.
???DB.  Used by node editor.  Merging/overwriting needs sorting out.
==============================================================================*/
{
	int return_code;
	Value_storage *temp_values_storage;
	ENTER(overwrite_FE_node_without_cm_node_identifier);
	/* check arguments */
	if (source&&destination)
	{
		/* make local copy of source values storage */
		temp_values_storage=(Value_storage *)NULL;		
		if (0<source->fields->number_of_values)
		{		
			if(allocate_and_copy_FE_node_value_storage(source,&temp_values_storage))
			{
				if (destination->fields)
				{
					FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
						FE_node_field_free_values_storage_arrays,
						(void *)destination,destination->fields->node_field_list);
					DEALLOCATE(destination->values_storage);
				}
				destination->values_storage=temp_values_storage;
				REACCESS(FE_node_field_info)(&(destination->fields),source->fields);
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"overwrite_FE_node_without_cm_node_identifier.Error allocating value memory");
				return_code=0;
			}
		}
		else
		{
			destination->values_storage=(Value_storage *)NULL;
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"overwrite_FE_node_without_cm_node_identifier.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* overwrite_FE_node_without_cm_node_identifier */

int get_next_FE_node_number(struct MANAGER(FE_node) *manager,int node_number)
/*******************************************************************************
LAST MODIFIED : 17 February 1996

DESCRIPTION :
Finds the next vacant node number in the manager.
???GMH.  Could speed up...
???DB.  Extend manager functionality ?
==============================================================================*/
{
	int temp_node_number;

	ENTER(get_next_FE_node_number);
	if (node_number<=0)
	{
		temp_node_number=1;
	}
	else
	{
		temp_node_number=node_number;
	}
	while (FIND_BY_IDENTIFIER_IN_MANAGER(FE_node,cm_node_identifier)(temp_node_number,
		manager))
	{
		temp_node_number++;
	}
	LEAVE;

	return (temp_node_number);
} /* get_next_FE_node_number */

DECLARE_MANAGED_GROUP_FUNCTIONS(FE_node)

DECLARE_FIND_BY_IDENTIFIER_IN_GROUP_FUNCTION(FE_node,cm_node_identifier,int,
	compare_int)

#if defined (OLD_CODE)
/* indexed list and manager module functions included with MANAGED_GROUP */
DECLARE_GROUP_FUNCTIONS(FE_node)

DECLARE_FIND_BY_IDENTIFIER_IN_GROUP_FUNCTION(FE_node,cm_node_identifier,int,
	compare_int)

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(GROUP(FE_node))

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(GROUP(FE_node),name, \
	char *,strcmp)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_LIST_FUNCTIONS(GROUP(FE_node))
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(GROUP(FE_node),name, \
	char *,strcmp)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

DECLARE_GROUP_MANAGER_COPY_FUNCTIONS(FE_node)

DECLARE_MANAGER_FUNCTIONS(GROUP(FE_node))

DECLARE_MANAGER_IDENTIFIER_FUNCTIONS(GROUP(FE_node),name,char *)
#endif /* defined (OLD_CODE) */

int set_FE_node_group(struct Parse_state *state,void *node_group_address_void,
	void *node_group_manager_void)
/*******************************************************************************
LAST MODIFIED : 20 February 1998

DESCRIPTION :
Used in command parsing to translate a node group name into an node group.
???DB.  Should it be here ?
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct GROUP(FE_node) *group,**group_address;
	struct MANAGER(GROUP(FE_node)) *node_group_manager;

	ENTER(set_FE_node_group);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if ((group_address=(struct GROUP(FE_node) **)node_group_address_void)&&
					(node_group_manager=
					(struct MANAGER(GROUP(FE_node)) *)node_group_manager_void))
				{
					if (fuzzy_string_compare(current_token,"NONE"))
					{
						if (*group_address)
						{
							DEACCESS(GROUP(FE_node))(group_address);
							*group_address=(struct GROUP(FE_node) *)NULL;
						}
						return_code=shift_Parse_state(state,1);
					}
					else
					{
						if (group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_node),name)(
							current_token,node_group_manager))
						{
							if (group!= *group_address)
							{
								if (*group_address)
								{
									DEACCESS(GROUP(FE_node))(group_address);
								}
								*group_address=ACCESS(GROUP(FE_node))(group);
							}
							return_code=shift_Parse_state(state,1);
						}
						else
						{
							display_message(WARNING_MESSAGE,"Unknown node group: %s",
								current_token);
							display_parse_state_location(state);
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_node_group.  Invalid argument(s)");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," NODE_GROUP_NAME|none");
				if (group_address=(struct GROUP(FE_node) **)node_group_address_void)
				{
					display_message(INFORMATION_MESSAGE,"[");
					if (group= *group_address)
					{
						display_message(INFORMATION_MESSAGE,group->name);
					}
					else
					{
						display_message(INFORMATION_MESSAGE,"none");
					}
					display_message(INFORMATION_MESSAGE,"]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing name for node group");
			display_parse_state_location(state);
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_node_group.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_group */

int set_FE_node_group_list(struct Parse_state *state,void *node_list_void,
	void *node_group_manager_void)
/*******************************************************************************
LAST MODIFIED : 7 October 1996

DESCRIPTION :
Used in command parsing to create a list of node groups.
???DB.  Should it be here ?
==============================================================================*/
{
	char *current_token;
	int end_list,number_of_groups,return_code;
	struct GROUP(FE_node) *group;
	struct LIST(GROUP(FE_node)) *list;
	struct MANAGER(GROUP(FE_node)) *node_group_manager;

	ENTER(set_FE_node_group_list);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if ((list=(struct LIST(GROUP(FE_node)) *)node_list_void)&&
					(node_group_manager=
					(struct MANAGER(GROUP(FE_node)) *)node_group_manager_void))
				{
					if (fuzzy_string_compare(current_token,"NONE"))
					{
						REMOVE_ALL_OBJECTS_FROM_LIST(GROUP(FE_node))(list);
						return_code=1;
					}
					else
					{
						return_code=1;
						end_list=0;
						while (!end_list&&return_code&&(current_token))
						{
							if (group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_node),name)(
								current_token,node_group_manager))
							{
								if (ADD_OBJECT_TO_LIST(GROUP(FE_node))(group,list))
								{
									return_code=shift_Parse_state(state,1);
									if (current_token=state->current_token)
									{
										if (fuzzy_string_compare(current_token,","))
										{
											return_code=shift_Parse_state(state,1);
										}
										else
										{
											end_list=1;
										}
									}
									else
									{
										end_list=1;
									}
								}
								else
								{
									display_message(WARNING_MESSAGE,
										"set_FE_node_group_list.  Could not add group to list");
									return_code=0;
								}
							}
							else
							{
								display_message(WARNING_MESSAGE,"Unknown node group: %s",
									current_token);
								display_parse_state_location(state);
								return_code=0;
							}
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_node_group_list.  Invalid argument(s)");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," NAME_1,NAME_2, ... ,NAME_N|none");
				if (list=(struct LIST(GROUP(FE_node)) *)node_list_void)
				{
					/* we only want a comma after the name if there is another name to
						follow, so pass the number of groups into the iterator procedure */
					number_of_groups=NUMBER_IN_LIST(GROUP(FE_node))(list);
					if (0==number_of_groups)
					{
						display_message(INFORMATION_MESSAGE,"[none]");
					}
					else
					{
						display_message(INFORMATION_MESSAGE,"[");
						FOR_EACH_OBJECT_IN_LIST(GROUP(FE_node))
							(set_FE_node_group_list_sub,(void *)&number_of_groups,list);
						display_message(INFORMATION_MESSAGE,"]");
					}
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"No node groups given");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_node_group_list.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_group_list */

int list_group_FE_node(struct GROUP(FE_node) *node_group,void *list_nodes)
/*******************************************************************************
LAST MODIFIED : 21 September 2000

DESCRIPTION :
Outputs the information contained by the node group.
==============================================================================*/
{
	char *group_name;
	int return_code;
	struct Multi_range *node_ranges;

	ENTER(list_group_FE_node);
	if (node_group)
	{
		if (return_code=GET_NAME(GROUP(FE_node))(node_group,&group_name))
		{
			if (list_nodes)
			{
				display_message(INFORMATION_MESSAGE,"Node group %s:\n",group_name);
				node_ranges=CREATE(Multi_range)();
				if (FOR_EACH_OBJECT_IN_GROUP(FE_node)(
					add_FE_node_number_to_Multi_range,(void *)node_ranges,node_group))
				{
					return_code=Multi_range_display_ranges(node_ranges);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"list_group_FE_node.  Could not get node ranges");
					return_code=0;
				}
				DESTROY(Multi_range)(&node_ranges);
			}
			else
			{
				display_message(INFORMATION_MESSAGE,"  %s\n",group_name);
			}
			DEALLOCATE(group_name);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_group_FE_node.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_group_FE_node */

int FE_node_group_intersects_list(struct GROUP(FE_node) *node_group,
	void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <node_group> contains any nodes in <node_list>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_group_intersects_list);
	if (node_group&&node_list_void)
	{
		return_code = (struct FE_node *)NULL !=
			FIRST_OBJECT_IN_GROUP_THAT(FE_node)(FE_node_is_in_list,
				node_list_void,node_group);
	}
	else
	{
		display_message(WARNING_MESSAGE,
			"FE_node_group_intersects_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_group_intersects_list */

struct FE_basis *CREATE(FE_basis)(int *type)
/*******************************************************************************
LAST MODIFIED : 10 November 1997

DESCRIPTION :
A basis is created with the specified <type> (duplicated).  The basis is
returned.
==============================================================================*/
{
	char valid_type;
	FE_value *blending_matrix,*polygon_blending_matrix,*reorder_1,*reorder_2,
		*temp_matrix;
	int *argument,*arguments,*basis_function_number,*basis_function_numbers,
		*basis_type,i,j,k,number_of_basis_functions,number_of_basis_functions_2,
		number_of_basis_functions_3,number_of_nodes,number_of_polygon_verticies,
		number_of_standard_basis_functions,*number_of_values_at_node,
		number_of_xi_coordinates,polygon_offset,simplex_dimension,simplex_order,
		simplex_type,step_1,step_2,*temp_int_ptr_1,*temp_int_ptr_2,temp_int_1,
		temp_int_2,temp_int_3,temp_int_4,*type_column,*type_entry,xi_coordinate;
	Standard_basis_function *standard_basis;
	struct FE_basis *basis;

	ENTER(CREATE(FE_basis));
	/* check arguments */
	if (type&&((number_of_xi_coordinates= *type)>0))
	{
		/* check that the type is valid */
		if (ALLOCATE(arguments,int,number_of_xi_coordinates+1)&&
			ALLOCATE(blending_matrix,FE_value,1)&&
			ALLOCATE(basis_function_numbers,int,1)&&
			ALLOCATE(number_of_values_at_node,int,1))
		{
/*???debug */
			/*printf("create basis : %d\n",number_of_xi_coordinates);*/
			*arguments=number_of_xi_coordinates;
			*blending_matrix=1;
			*basis_function_numbers=0;
			*number_of_values_at_node=1;
			number_of_nodes=1;
			valid_type=1;
			number_of_basis_functions=1;
			number_of_standard_basis_functions=1;
			xi_coordinate=0;
			type_entry=type+1;
			standard_basis=monomial_basis_functions;
			argument=arguments+1;
			while (valid_type&&(xi_coordinate<number_of_xi_coordinates))
			{
				xi_coordinate++;
				switch (*type_entry)
				{
					case LINEAR_LAGRANGE:
					{
						if (temp_matrix=tensor_product(2,2,
							linear_lagrange_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								2*number_of_basis_functions)&&REALLOCATE(temp_int_ptr_2,
								number_of_values_at_node,int,2*number_of_nodes))
							{
								basis_function_numbers=temp_int_ptr_1;
								number_of_values_at_node=temp_int_ptr_2;
								/* number basis functions so that when the rows of the
									blending are reordered by basis function number the basis
									functions for each node will be sequential */
								basis_function_number=basis_function_numbers;
								for (i=number_of_basis_functions;i>0;i--)
								{
									*(basis_function_number+number_of_basis_functions)=
										(*basis_function_number)+number_of_basis_functions;
									basis_function_number++;
								}
								for (i=0;i<number_of_nodes;i++)
								{
									number_of_values_at_node[i+number_of_nodes]=
										number_of_values_at_node[i];
								}
								number_of_nodes *= 2;
								number_of_basis_functions *= 2;
								number_of_standard_basis_functions *= 2;
								*argument=1;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case QUADRATIC_LAGRANGE:
					{
						if (temp_matrix=tensor_product(3,3,
							quadratic_lagrange_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								3*number_of_basis_functions)&&REALLOCATE(temp_int_ptr_2,
								number_of_values_at_node,int,3*number_of_nodes))
							{
								basis_function_numbers=temp_int_ptr_1;
								number_of_values_at_node=temp_int_ptr_2;
								/* number basis functions so that when the rows of the
									blending are reordered by basis function number the basis
									functions for each node will be sequential */
								basis_function_number=basis_function_numbers;
								temp_int_1=2*number_of_basis_functions;
								for (i=number_of_basis_functions;i>0;i--)
								{
									*(basis_function_number+number_of_basis_functions)=
										(*basis_function_number)+number_of_basis_functions;
									*(basis_function_number+temp_int_1)=
										(*basis_function_number)+temp_int_1;
									basis_function_number++;
								}
								for (i=0;i<number_of_nodes;i++)
								{
									number_of_values_at_node[i+number_of_nodes]=
										number_of_values_at_node[i];
									number_of_values_at_node[i+2*number_of_nodes]=
										number_of_values_at_node[i];
								}
								number_of_nodes *= 3;
								number_of_basis_functions *= 3;
								number_of_standard_basis_functions *= 3;
								*argument=2;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case CUBIC_LAGRANGE:
					{
						if (temp_matrix=tensor_product(4,4,cubic_lagrange_blending_matrix,
							number_of_basis_functions,number_of_standard_basis_functions,
							blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								4*number_of_basis_functions)&&REALLOCATE(temp_int_ptr_2,
								number_of_values_at_node,int,4*number_of_nodes))
							{
								basis_function_numbers=temp_int_ptr_1;
								number_of_values_at_node=temp_int_ptr_2;
								/* number basis functions so that when the rows of the
									blending are reordered by basis function number the basis
									functions for each node will be sequential */
								basis_function_number=basis_function_numbers;
								temp_int_1=2*number_of_basis_functions;
								temp_int_2=temp_int_1+number_of_basis_functions;
								for (i=number_of_basis_functions;i>0;i--)
								{
									*(basis_function_number+number_of_basis_functions)=
										(*basis_function_number)+number_of_basis_functions;
									*(basis_function_number+temp_int_1)=
										(*basis_function_number)+temp_int_1;
									*(basis_function_number+temp_int_2)=
										(*basis_function_number)+temp_int_2;
									basis_function_number++;
								}
								for (i=0;i<number_of_nodes;i++)
								{
									number_of_values_at_node[i+number_of_nodes]=
										number_of_values_at_node[i];
									number_of_values_at_node[i+2*number_of_nodes]=
										number_of_values_at_node[i];
									number_of_values_at_node[i+3*number_of_nodes]=
										number_of_values_at_node[i];
								}
								number_of_nodes *= 4;
								number_of_basis_functions *= 4;
								number_of_standard_basis_functions *= 4;
								*argument=3;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case CUBIC_HERMITE:
					{
						if (temp_matrix=tensor_product(4,4,cubic_hermite_blending_matrix,
							number_of_basis_functions,number_of_standard_basis_functions,
							blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								4*number_of_basis_functions)&&REALLOCATE(temp_int_ptr_2,
								number_of_values_at_node,int,2*number_of_nodes))
							{
								basis_function_numbers=temp_int_ptr_1;
								number_of_values_at_node=temp_int_ptr_2;
								/* number basis functions so that when the rows of the
									blending are reordered by basis function number the basis
									functions for each node will be sequential */
								basis_function_number=basis_function_numbers;
								number_of_basis_functions_2=2*number_of_basis_functions;
								number_of_basis_functions_3=number_of_basis_functions_2+
									number_of_basis_functions;
								for (i=number_of_basis_functions;i>0;i--)
								{
									temp_int_1= *basis_function_number;
									temp_int_2=0;
									j=0;
									while ((j<number_of_nodes)&&
										(temp_int_1-number_of_values_at_node[j]>=0))
									{
										temp_int_1 -= number_of_values_at_node[j];
										temp_int_2 += 2*number_of_values_at_node[j];
										j++;
									}
									temp_int_2 += temp_int_1;
									*basis_function_number=temp_int_2;
									basis_function_number[number_of_basis_functions]=
										temp_int_2+number_of_values_at_node[j];
									basis_function_number[number_of_basis_functions_2]=
										temp_int_2+number_of_basis_functions_2;
									basis_function_number[number_of_basis_functions_3]=
										basis_function_number[number_of_basis_functions]+
										number_of_basis_functions_2;
									basis_function_number++;
								}
								for (i=0;i<number_of_nodes;i++)
								{
									number_of_values_at_node[i] *= 2;
									number_of_values_at_node[i+number_of_nodes]=
										number_of_values_at_node[i];
								}
								number_of_nodes *= 2;
								number_of_basis_functions *= 4;
								number_of_standard_basis_functions *= 4;
								*argument=3;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case HERMITE_LAGRANGE:
					{
						if (temp_matrix=tensor_product(3,3,
							hermite_lagrange_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								3*number_of_basis_functions)&&REALLOCATE(temp_int_ptr_2,
								number_of_values_at_node,int,2*number_of_nodes))
							{
								basis_function_numbers=temp_int_ptr_1;
								number_of_values_at_node=temp_int_ptr_2;
								/* number basis functions so that when the rows of the
									blending are reordered by basis function number the basis
									functions for each node will be sequential */
								basis_function_number=basis_function_numbers;
								number_of_basis_functions_2=2*number_of_basis_functions;
								for (i=number_of_basis_functions;i>0;i--)
								{
									temp_int_1= *basis_function_number;
									basis_function_number[number_of_basis_functions_2]=
										temp_int_1+number_of_basis_functions_2;
									temp_int_2=0;
									j=0;
									while ((j<number_of_nodes)&&
										(temp_int_1-number_of_values_at_node[j]>=0))
									{
										temp_int_1 -= number_of_values_at_node[j];
										temp_int_2 += 2*number_of_values_at_node[j];
										j++;
									}
									temp_int_2 += temp_int_1;
									*basis_function_number=temp_int_2;
									basis_function_number[number_of_basis_functions]=
										temp_int_2+number_of_values_at_node[j];
									basis_function_number++;
								}
								for (i=0;i<number_of_nodes;i++)
								{
									number_of_values_at_node[i+number_of_nodes]=
										number_of_values_at_node[i];
									number_of_values_at_node[i] *= 2;
								}
								number_of_nodes *= 2;
								number_of_basis_functions *= 3;
								number_of_standard_basis_functions *= 3;
								*argument=2;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case LAGRANGE_HERMITE:
					{
						if (temp_matrix=tensor_product(3,3,
							lagrange_hermite_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								3*number_of_basis_functions)&&REALLOCATE(temp_int_ptr_2,
								number_of_values_at_node,int,2*number_of_nodes))
							{
								basis_function_numbers=temp_int_ptr_1;
								number_of_values_at_node=temp_int_ptr_2;
								/* number basis functions so that when the rows of the
									blending are reordered by basis function number the basis
									functions for each node will be sequential */
								basis_function_number=basis_function_numbers;
								number_of_basis_functions_2=2*number_of_basis_functions;
								for (i=number_of_basis_functions;i>0;i--)
								{
									temp_int_1= *basis_function_number;
									temp_int_2=0;
									j=0;
									while ((j<number_of_nodes)&&
										(temp_int_1-number_of_values_at_node[j]>=0))
									{
										temp_int_1 -= number_of_values_at_node[j];
										temp_int_2 += 2*number_of_values_at_node[j];
										j++;
									}
									temp_int_2 += temp_int_1;
									basis_function_number[number_of_basis_functions]=
										number_of_basis_functions+temp_int_2;
									basis_function_number[number_of_basis_functions_2]=
										number_of_basis_functions+temp_int_2+
										number_of_values_at_node[j];
									basis_function_number++;
								}
								for (i=0;i<number_of_nodes;i++)
								{
									number_of_values_at_node[i+number_of_nodes]=
										2*number_of_values_at_node[i];
								}
								number_of_nodes *= 2;
								number_of_basis_functions *= 3;
								number_of_standard_basis_functions *= 3;
								*argument=2;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case POLYGON:
					{
						/* check if the other polygon coordinate is before */
						valid_type=2;
						number_of_polygon_verticies=0;
						type_column=type_entry;
						i=xi_coordinate-1;
						j=number_of_xi_coordinates-xi_coordinate;
						while (valid_type&&(i>0))
						{
							j++;
							type_column -= j;
							if (NO_RELATION!= *type_column)
							{
								if (0<number_of_polygon_verticies)
								{
									valid_type=0;
								}
								else
								{
									if ((number_of_polygon_verticies= *type_column)<3)
									{
										valid_type=0;
									}
								}
							}
							i--;
						}
						if (valid_type)
						{
							if (0<number_of_polygon_verticies)
							{
								/* make sure that it is not connected to a following xi */
								type_entry++;
								i=number_of_xi_coordinates-xi_coordinate;
								while (valid_type&&(i>0))
								{
									if (NO_RELATION!= *type_entry)
									{
										valid_type=0;
									}
									type_entry++;
									i--;
								}
								argument++;
							}
							else
							{
								/* check if the other polygon coordinate is after */
								type_entry++;
								i=number_of_xi_coordinates-xi_coordinate;
								while (valid_type&&(i>0))
								{
									if (NO_RELATION!= *type_entry)
									{
										if (0<number_of_polygon_verticies)
										{
											valid_type=0;
										}
										else
										{
											if ((number_of_polygon_verticies= *type_entry)>2)
											{
												polygon_offset=number_of_xi_coordinates-xi_coordinate+
													1-i;
												if (POLYGON!=type_entry[(polygon_offset*
													(2*(number_of_xi_coordinates-xi_coordinate+1)-
													polygon_offset+1))/2-polygon_offset])
												{
													valid_type=0;
												}
											}
											else
											{
												valid_type=0;
											}
										}
									}
									type_entry++;
									i--;
								}
								if (valid_type&&(0<number_of_polygon_verticies))
								{
									/* see polygon_basis_functions for the polygon blending
										matrix */
									if (ALLOCATE(polygon_blending_matrix,FE_value,
										(number_of_polygon_verticies+1)*
										4*number_of_polygon_verticies))
									{
										temp_matrix=polygon_blending_matrix;
										for (j=number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix=1;
											temp_matrix++;
										}
										for (j=number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix=0;
											temp_matrix++;
										}
										for (j=number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix= -1;
											temp_matrix++;
										}
										for (j=(4*number_of_polygon_verticies+1)*
											number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix=0;
											temp_matrix++;
										}
										temp_matrix=polygon_blending_matrix+
											(6*number_of_polygon_verticies);
										*temp_matrix=1;
										temp_matrix += number_of_polygon_verticies;
										*temp_matrix= -1;
										temp_matrix[number_of_polygon_verticies-1]=1;
										step_1=3*number_of_polygon_verticies+1;
										step_2=number_of_polygon_verticies-1;
										for (j=number_of_polygon_verticies-1;j>0;j--)
										{
											temp_matrix += step_1;
											*temp_matrix=1;
											temp_matrix += step_2;
											*temp_matrix=1;
											temp_matrix++;
											*temp_matrix= -1;
										}
										if (temp_matrix=tensor_product(
											number_of_polygon_verticies+1,
											4*number_of_polygon_verticies,polygon_blending_matrix,
											number_of_basis_functions,
											number_of_standard_basis_functions,blending_matrix))
										{
											DEALLOCATE(blending_matrix);
											blending_matrix=temp_matrix;
											if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
												int,(number_of_polygon_verticies+1)*
												number_of_basis_functions)&&REALLOCATE(temp_int_ptr_2,
												number_of_values_at_node,int,
												(number_of_polygon_verticies+1)*number_of_nodes))
											{
												basis_function_numbers=temp_int_ptr_1;
												number_of_values_at_node=temp_int_ptr_2;
												/* number basis functions so that when the rows of the
													blending are reordered by basis function number the
													basis functions for each node will be sequential */
												basis_function_number=basis_function_numbers;
												for (i=number_of_polygon_verticies*
													number_of_basis_functions;i>0;i--)
												{
													*(basis_function_number+number_of_basis_functions)=
														(*basis_function_number)+
														number_of_basis_functions;
													basis_function_number++;
												}
												for (i=number_of_polygon_verticies*number_of_nodes;
													i>0;i--)
												{
													*(temp_int_ptr_2+number_of_nodes)= *temp_int_ptr_2;
													temp_int_ptr_2++;
												}
												number_of_nodes *= number_of_polygon_verticies+1;
												number_of_basis_functions *=
													number_of_polygon_verticies+1;
												number_of_standard_basis_functions *=
													4*number_of_polygon_verticies;
												*argument= -polygon_offset;
												argument[polygon_offset]=
													-(number_of_xi_coordinates+
													number_of_polygon_verticies);
												argument++;
												standard_basis=polygon_basis_functions;
												valid_type=2;
											}
											else
											{
												valid_type=0;
											}
										}
										else
										{
											valid_type=0;
										}
										DEALLOCATE(polygon_blending_matrix);
									}
									else
									{
										valid_type=0;
									}
								}
								else
								{
									valid_type=0;
								}
							}
						}
					} break;
					case LINEAR_SIMPLEX:
					case QUADRATIC_SIMPLEX:
					{
						/* simplex */
						/* to avoid increment/check of row */
						valid_type=2;
						/* determine if this is the first component of the simplex */
						simplex_dimension=1;
						type_column=type_entry;
						i=xi_coordinate-1;
						j=number_of_xi_coordinates-xi_coordinate;
						while (valid_type&&(i>0))
						{
							j++;
							type_column -= j;
							if (NO_RELATION!= *type_column)
							{
								simplex_dimension++;
							}
							i--;
						}
						if (1==simplex_dimension)
						{
							/* first component of the simplex */
							simplex_type= *type_entry;
								/*???DB.  Maybe able to remove if can work how to calculate the
									blending matrix for an arbitrary order */
							/* determine the simplex dimension */
							type_entry++;
							j=1;
							for (i=1;i<=number_of_xi_coordinates-xi_coordinate;i++)
							{
								if (NO_RELATION!= *type_entry)
								{
									simplex_dimension++;
									*argument= -j;
									j=0;
									k=i;
									argument++;
								}
								type_entry++;
								j++;
							}
							if (2<=simplex_dimension)
							{
								*argument= -k;
								/*???DB.  Should be able to calculate the blending matrix for
									arbitrary dimension and arbitrary order, but get the basics
									going first */
								switch (simplex_type)
								{
									case LINEAR_SIMPLEX:
									{
										simplex_order=1;
										switch (simplex_dimension)
										{
											case 2:
											{
												if (temp_matrix=tensor_product(3,4,
													linear_simplex_2d_blending_matrix,
													number_of_basis_functions,
													number_of_standard_basis_functions,blending_matrix))
												{
													DEALLOCATE(blending_matrix);
													blending_matrix=temp_matrix;
													if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
														int,3*number_of_basis_functions)&&
														REALLOCATE(temp_int_ptr_2,number_of_values_at_node,
														int,3*number_of_nodes))
													{
														basis_function_numbers=temp_int_ptr_1;
														number_of_values_at_node=temp_int_ptr_2;
														/* number basis functions so that when the rows of
															the blending matrix are reordered by basis
															function number the basis functions for each node
															will be sequential */
														basis_function_number=basis_function_numbers;
														temp_int_1=2*number_of_basis_functions;
														for (i=number_of_basis_functions;i>0;i--)
														{
															*(basis_function_number+
																number_of_basis_functions)=
																(*basis_function_number)+
																number_of_basis_functions;
															*(basis_function_number+temp_int_1)=
																(*basis_function_number)+temp_int_1;
															basis_function_number++;
														}
														temp_int_1=2*number_of_nodes;
														for (i=0;i<number_of_nodes;i++)
														{
															number_of_values_at_node[i+number_of_nodes]=
																number_of_values_at_node[i];
															number_of_values_at_node[i+temp_int_1]=
																number_of_values_at_node[i];
														}
														number_of_nodes *= 3;
														number_of_basis_functions *= 3;
														number_of_standard_basis_functions *= 4;
													}
													else
													{
														valid_type=0;
													}
												}
												else
												{
													valid_type=0;
												}
											} break;
											case 3:
											{
												if (temp_matrix=tensor_product(4,8,
													linear_simplex_3d_blending_matrix,
													number_of_basis_functions,
													number_of_standard_basis_functions,blending_matrix))
												{
													DEALLOCATE(blending_matrix);
													blending_matrix=temp_matrix;
													if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
														int,4*number_of_basis_functions)&&
														REALLOCATE(temp_int_ptr_2,number_of_values_at_node,
														int,4*number_of_nodes))
													{
														basis_function_numbers=temp_int_ptr_1;
														number_of_values_at_node=temp_int_ptr_2;
														/* number basis functions so that when the rows of
															the blending matrix are reordered by basis
															function number the basis functions for each node
															will be sequential */
														basis_function_number=basis_function_numbers;
														temp_int_1=2*number_of_basis_functions;
														temp_int_2=temp_int_1+number_of_basis_functions;
														for (i=number_of_basis_functions;i>0;i--)
														{
															*(basis_function_number+
																number_of_basis_functions)=
																(*basis_function_number)+
																number_of_basis_functions;
															*(basis_function_number+temp_int_1)=
																(*basis_function_number)+temp_int_1;
															*(basis_function_number+temp_int_2)=
																(*basis_function_number)+temp_int_2;
															basis_function_number++;
														}
														temp_int_1=2*number_of_nodes;
														temp_int_2=temp_int_1+number_of_nodes;
														for (i=0;i<number_of_nodes;i++)
														{
															number_of_values_at_node[i+number_of_nodes]=
																number_of_values_at_node[i];
															number_of_values_at_node[i+temp_int_1]=
																number_of_values_at_node[i];
															number_of_values_at_node[i+temp_int_2]=
																number_of_values_at_node[i];
														}
														number_of_nodes *= 4;
														number_of_basis_functions *= 4;
														number_of_standard_basis_functions *= 8;
													}
													else
													{
														valid_type=0;
													}
												}
												else
												{
													valid_type=0;
												}
											} break;
											default:
											{
												valid_type=0;
											} break;
										}
									} break;
									case QUADRATIC_SIMPLEX:
									{
										simplex_order=2;
										switch (simplex_dimension)
										{
											case 2:
											{
												if (temp_matrix=tensor_product(6,9,
													quadratic_simplex_2d_blending_matrix,
													number_of_basis_functions,
													number_of_standard_basis_functions,blending_matrix))
												{
													DEALLOCATE(blending_matrix);
													blending_matrix=temp_matrix;
													if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
														int,6*number_of_basis_functions)&&
														REALLOCATE(temp_int_ptr_2,number_of_values_at_node,
														int,6*number_of_nodes))
													{
														basis_function_numbers=temp_int_ptr_1;
														number_of_values_at_node=temp_int_ptr_2;
														/* number basis functions so that when the rows of
															the blending matrix are reordered by basis
															function number the basis functions for each node
															will be sequential */
														basis_function_number=basis_function_numbers;
														temp_int_1=2*number_of_basis_functions;
														temp_int_2=temp_int_1+number_of_basis_functions;
														temp_int_3=temp_int_2+number_of_basis_functions;
														temp_int_4=temp_int_3+number_of_basis_functions;
														for (i=number_of_basis_functions;i>0;i--)
														{
															*(basis_function_number+
																number_of_basis_functions)=
																(*basis_function_number)+
																number_of_basis_functions;
															*(basis_function_number+temp_int_1)=
																(*basis_function_number)+temp_int_1;
															*(basis_function_number+temp_int_2)=
																(*basis_function_number)+temp_int_2;
															*(basis_function_number+temp_int_3)=
																(*basis_function_number)+temp_int_3;
															*(basis_function_number+temp_int_4)=
																(*basis_function_number)+temp_int_4;
															basis_function_number++;
														}
														temp_int_1=2*number_of_nodes;
														temp_int_2=temp_int_1+number_of_nodes;
														temp_int_3=temp_int_2+number_of_nodes;
														temp_int_4=temp_int_3+number_of_nodes;
														for (i=0;i<number_of_nodes;i++)
														{
															number_of_values_at_node[i+number_of_nodes]=
																number_of_values_at_node[i];
															number_of_values_at_node[i+temp_int_1]=
																number_of_values_at_node[i];
															number_of_values_at_node[i+temp_int_2]=
																number_of_values_at_node[i];
															number_of_values_at_node[i+temp_int_3]=
																number_of_values_at_node[i];
															number_of_values_at_node[i+temp_int_4]=
																number_of_values_at_node[i];
														}
														number_of_nodes *= 6;
														number_of_basis_functions *= 6;
														number_of_standard_basis_functions *= 9;
													}
													else
													{
														valid_type=0;
													}
												}
												else
												{
													valid_type=0;
												}
											} break;
											default:
											{
												valid_type=0;
											} break;
										}
									} break;
									default:
									{
										valid_type=0;
									} break;
								}
								*argument -= simplex_order*number_of_xi_coordinates;
								argument++;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							/* skip rest of row */
							type_entry += number_of_xi_coordinates-xi_coordinate+1;
						}
					} break;
					default:
					{
						valid_type=0;
					} break;
				}
				if (1==valid_type)
				{
					/* 1-dimensional basis component */
					type_entry++;
					i=number_of_xi_coordinates-xi_coordinate;
					while (valid_type&&(i>0))
					{
						if (NO_RELATION!= *type_entry)
						{
							valid_type=0;
						}
						type_entry++;
						i--;
					}
				}
			}
			if (valid_type)
			{
				/* allocate memory for the basis */
				if (ALLOCATE(basis,struct FE_basis,1)&&ALLOCATE(basis_type,int,
					1+number_of_xi_coordinates*(number_of_xi_coordinates+1)/2)&&
					ALLOCATE(basis->blending_matrix,FE_value,number_of_basis_functions*
					number_of_standard_basis_functions))
				{
					basis->access_count=0;
					/* copy the basis type */
					basis->type=basis_type;
					type_entry=type;
					for (i=1+number_of_xi_coordinates*(number_of_xi_coordinates+1)/2-1;
						i>=0;i--)
					{
						*basis_type= *type_entry;
						basis_type++;
						type_entry++;
					}
					basis->number_of_basis_functions=number_of_basis_functions;
					basis->number_of_standard_basis_functions=
						number_of_standard_basis_functions;
					/* reorder the basis functions */
					for (i=0;i<number_of_basis_functions;i++)
					{
						basis_function_numbers[i]=
							number_of_basis_functions*basis_function_numbers[i]+i;
					}
					heapsort((void *)basis_function_numbers,number_of_basis_functions,
						sizeof(int),sort_basis_function_numbers);
					/* reorder the blending matrix */
					reorder_1=basis->blending_matrix;
					basis_function_number=basis_function_numbers;
					for (i=0;i<number_of_basis_functions;i++)
					{
						reorder_2=blending_matrix+(((*basis_function_number)%
							number_of_basis_functions)*number_of_standard_basis_functions);
						for (j=0;j<number_of_standard_basis_functions;j++)
						{
							*reorder_1=  *reorder_2;
							reorder_1++;
							reorder_2++;
						}
						basis_function_number++;
					}
/*???debug */
/*{
	FE_value *value;
	int i,j;

	printf("%d) %d %d %d\n",xi_coordinate,number_of_nodes,
		number_of_basis_functions,number_of_standard_basis_functions);
	value=basis->blending_matrix;
	for (i=number_of_standard_basis_functions;i>0;i--)
	{
		for (j=number_of_basis_functions;j>0;j--)
		{
			printf("%g ",*value);
			value++;
		}
		printf("\n");
	}
	for (i=0;i<number_of_basis_functions;i++)
	{
		printf("%d ",basis_function_numbers[i]);
	}
	printf("\n");
	for (i=0;i<=xi_coordinate;i++)
	{
		printf("%d ",arguments[i]);
	}
	printf("\n");
	printf("%p %p %p\n",standard_basis,monomial_basis_functions,
		polygon_basis_functions);
}*/
					/* create the names for the values that multiply the basis
						functions */
						/*???DB.  To be done */
					basis->value_names=(char **)NULL;
					basis->arguments=arguments;
					basis->standard_basis=standard_basis;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_basis).  Could not allocate memory for basis");
					if (basis)
					{
						DEALLOCATE(basis);
						DEALLOCATE(basis_type);
					}
					DEALLOCATE(arguments);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,"CREATE(FE_basis).  Invalid basis type");
				DEALLOCATE(arguments);
				basis=(struct FE_basis *)NULL;
			}
			DEALLOCATE(number_of_values_at_node);
			DEALLOCATE(basis_function_numbers);
			DEALLOCATE(blending_matrix);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_basis).  Could not allocate memory for basis calculation");
			if (arguments)
			{
				DEALLOCATE(arguments);
				if (blending_matrix)
				{
					DEALLOCATE(blending_matrix);
					DEALLOCATE(basis_function_numbers);
				}
			}
			basis=(struct FE_basis *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"CREATE(FE_basis).  Invalid argument(s)");
		basis=(struct FE_basis *)NULL;
	}
	LEAVE;

	return (basis);
} /* CREATE(FE_basis) */

int DESTROY(FE_basis)(struct FE_basis **basis_address)
/*******************************************************************************
LAST MODIFIED : 1 October 1995

DESCRIPTION :
Frees the memory for the basis and sets <*basis_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_basis *basis;

	ENTER(DESTROY(FE_basis));
	/* check the arguments */
	if ((basis_address)&&(basis= *basis_address))
	{
		if (0==basis->access_count)
		{
			DEALLOCATE(basis->type);
			DEALLOCATE(basis->blending_matrix);
			DEALLOCATE(basis->arguments);
			DEALLOCATE(*basis_address);
			return_code=1;
		}
		else
		{
			return_code=1;
			*basis_address=(struct FE_basis *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_basis) */

struct FE_basis *make_FE_basis(int *basis_type,
	struct MANAGER(FE_basis) *basis_manager )
/*******************************************************************************
LAST MODIFIED : 2 August 1999

DESCRIPTION :
Finds the specfied FE_basis in the basis manager. If it isn't there, creates it,
and adds it to the manager.
==============================================================================*/
{
	struct FE_basis *basis;

	ENTER(make_FE_basis);
	if(basis_manager)
	{
		if (!(basis=FIND_BY_IDENTIFIER_IN_MANAGER(FE_basis,type)
			(basis_type,basis_manager)))
		{
			if (basis=CREATE(FE_basis)(basis_type))
			{
				if (!ADD_OBJECT_TO_MANAGER(FE_basis)(basis,basis_manager))
				{
					DESTROY(FE_basis)(&basis);
					display_message(ERROR_MESSAGE,
						"make_FE_basis. Could not add basis to manager");
					basis = (struct FE_basis *)NULL;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"make_FE_basis Could not create a new basis");
				basis = (struct FE_basis *)NULL;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"make_FE_basis. Invalid arguments");
		basis = (struct FE_basis *)NULL;
	}
	LEAVE;

	return(basis);
} /* make_FE_basis */

DECLARE_OBJECT_FUNCTIONS(FE_basis)

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(FE_basis)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_LIST_FUNCTIONS(FE_basis)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_basis,type,int *, \
	compare_FE_basis_type)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_basis,type,int *, \
	compare_FE_basis_type)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

PROTOTYPE_MANAGER_COPY_WITHOUT_IDENTIFIER_FUNCTION(FE_basis,type)
{
	char **destination_value_names,**source_value_name,**value_name;
	FE_value *blending_matrix,*destination_blending_matrix,
		*source_blending_matrix;
	int *argument,*destination_arguments,i,return_code,*source_argument;

	ENTER(MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type));
	if (source&&destination)
	{
		/* copy the source value names */
		if (source_value_name=source->value_names)
		{
			i=source->number_of_basis_functions;
			if (ALLOCATE(destination_value_names,char *,i))
			{
				value_name=destination_value_names;
				return_code=1;
				while (return_code&&(i>0))
				{
					if (*source_value_name)
					{
						if (ALLOCATE(*value_name,char,strlen(*source_value_name)+1))
						{
							strcpy(*value_name,*source_value_name);
							value_name++;
							source_value_name++;
							i--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for value name");
							return_code=0;
							while (i<source->number_of_basis_functions)
							{
								value_name--;
								if (*value_name)
								{
									DEALLOCATE(*value_name);
								}
								i++;
							}
							DEALLOCATE(destination_value_names);
						}
					}
					else
					{
						*value_name=(char *)NULL;
						value_name++;
						source_value_name++;
						i--;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for value names");
				return_code=0;
			}
		}
		else
		{
			return_code=1;
			destination_value_names=(char **)NULL;
		}
		if (return_code)
		{
			/* copy the source blending matrix */
			if (source_blending_matrix=source->blending_matrix)
			{
				i=(source->number_of_basis_functions)*
					(source->number_of_standard_basis_functions);
				if (ALLOCATE(destination_blending_matrix,FE_value,i))
				{
					blending_matrix=destination_blending_matrix;
					while (i>0)
					{
						*blending_matrix= *source_blending_matrix;
						blending_matrix++;
						source_blending_matrix++;
						i--;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for blending matrix");
					return_code=0;
					if (value_name=destination_value_names)
					{
						for (i=source->number_of_basis_functions;i>0;i--)
						{
							if (*value_name)
							{
								DEALLOCATE(*value_name);
							}
							value_name++;
						}
						DEALLOCATE(destination_value_names);
					}
				}
			}
			if (return_code)
			{
				i=(source->number_of_standard_basis_functions)+1;
				if (ALLOCATE(destination_arguments,int,i))
				{
					argument=destination_arguments;
					source_argument=(int *)(source->arguments);
					while (i>0)
					{
						*argument= *source_argument;
						argument++;
						source_argument++;
						i--;
					}
					/* clear the destination value names */
					if (value_name=destination->value_names)
					{
						for (i=destination->number_of_basis_functions;i>0;i--)
						{
							DEALLOCATE(*value_name);
							value_name++;
						}
						DEALLOCATE(destination->value_names);
					}
					destination->number_of_basis_functions=
						source->number_of_basis_functions;
					destination->value_names=destination_value_names;
					/* clear the destination blending matrix */
					DEALLOCATE(destination->blending_matrix);
					destination->blending_matrix=destination_blending_matrix;
					destination->number_of_standard_basis_functions=
						source->number_of_standard_basis_functions;
					/* clear the destination standard basis function arguments */
					DEALLOCATE(destination->arguments);
					destination->arguments=(void *)destination_arguments;
					source->standard_basis=destination->standard_basis;
				}
				else
				{
					display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for arguments");
					return_code=0;
					DEALLOCATE(destination_blending_matrix);
					if (value_name=destination_value_names)
					{
						for (i=source->number_of_basis_functions;i>0;i--)
						{
							if (*value_name)
							{
								DEALLOCATE(*value_name);
							}
							value_name++;
						}
						DEALLOCATE(destination_value_names);
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type) */

PROTOTYPE_MANAGER_COPY_IDENTIFIER_FUNCTION(FE_basis,type,int *)
{
	int *basis_type,*destination_type,i,number_of_xi_coordinates,return_code,size;

	ENTER(MANAGER_COPY_IDENTIFIER(FE_basis,type));
	/* check arguments */
	if (destination&&(basis_type=type)&&((number_of_xi_coordinates= *type)>0))
	{
		size=1+(number_of_xi_coordinates*(number_of_xi_coordinates+1))/2;
		if (ALLOCATE(destination_type,int,size))
		{
			DEALLOCATE(destination->type);
			destination->type=destination_type;
			for (i=size;i>0;i--)
			{
				*destination_type= *basis_type;
				basis_type++;
				destination_type++;
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
"MANAGER_COPY_IDENTIFIER(FE_basis,type).  Could not allocate memory for type");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_IDENTIFIER(FE_basis,type).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_IDENTIFIER(FE_basis,type) */

PROTOTYPE_MANAGER_COPY_WITH_IDENTIFIER_FUNCTION(FE_basis,type)
{
	int return_code;

	ENTER(MANAGER_COPY_WITH_IDENTIFIER(FE_basis,type));
	if (source&&destination)
	{
		if (return_code=MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type)(
			destination,source))
		{
			return_code=MANAGER_COPY_IDENTIFIER(FE_basis,type)(destination,
				source->type);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITH_IDENTIFIER(FE_basis,type).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITH_IDENTIFIER(FE_basis,type) */

DECLARE_MANAGER_FUNCTIONS(FE_basis)

DECLARE_MANAGER_IDENTIFIER_FUNCTIONS(FE_basis,type,int *)

char *FE_basis_type_string(enum FE_basis_type basis_type)
/*******************************************************************************
LAST MODIFIED : 1 April 1999

DESCRIPTION :
Returns a pointer to a static string token for the given <basis_type>.
The calling function must not deallocate the returned string.
???RC Not complete
#### Must ensure implemented correctly for new FE_basis_types ####
==============================================================================*/
{
	char *basis_type_string;

	ENTER(FE_basis_type_string);
	switch (basis_type)
	{
		case NO_RELATION:
		{
			basis_type_string="no_relation";
		} break;
		case BSPLINE:
		{
			basis_type_string="???bspline";
		} break;
		case CUBIC_HERMITE:
		{
			basis_type_string="c.Hermite";
		} break;
		case CUBIC_LAGRANGE:
		{
			basis_type_string="c.Lagrange";
		} break;
		case FOURIER:
		{
			basis_type_string="???fourier";
		} break;
		case HERMITE_LAGRANGE:
		{
			basis_type_string="HermiteLagrange";
		} break;
		case LAGRANGE_HERMITE:
		{
			basis_type_string="LagrangeHermite";
		} break;
		case LINEAR_LAGRANGE:
		{
			basis_type_string="l.Lagrange";
		} break;
		case LINEAR_SIMPLEX:
		{
			basis_type_string="l.simplex";
		} break;
		case POLYGON:
		{
			basis_type_string="polygon";
		} break;
		case QUADRATIC_LAGRANGE:
		{
			basis_type_string="q.Lagrange";
		} break;
		case QUADRATIC_SIMPLEX:
		{
			basis_type_string="q.simplex";
		} break;
		case SERENDIPITY:
		{
			basis_type_string="???serendipity";
		} break;
		case SINGULAR:
		{
			basis_type_string="???singular";
		} break;
		case TRANSITION:
		{
			basis_type_string="???transition";
		} break;
		default:
		{
			display_message(ERROR_MESSAGE,
				"FE_basis_type_string.  Invalid basis_type");
			basis_type_string=(char *)NULL;
		} break;
	}
	LEAVE;

	return (basis_type_string);
} /* FE_basis_type_string */

struct Linear_combination_of_global_values
	*CREATE(Linear_combination_of_global_values)(int number_of_global_values)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Allocates memory and assigns fields for a linear combination of global values.
Allocates storage for the global and coefficient indices and sets to -1.
==============================================================================*/
{
	int *coefficient_index,*global_index,i;
	struct Linear_combination_of_global_values *linear_combination;

	ENTER(CREATE(Linear_combination_of_global_values));
	/* check the arguments */
	if (number_of_global_values>0)
	{
		if ((ALLOCATE(linear_combination,struct Linear_combination_of_global_values,
			1))&&(ALLOCATE(global_index,int,number_of_global_values))&&
			(ALLOCATE(coefficient_index,int,number_of_global_values)))
		{
			linear_combination->number_of_global_values=number_of_global_values;
			linear_combination->global_value_indices=global_index;
			linear_combination->coefficient_indices=coefficient_index;
			for (i=number_of_global_values;i>0;i--)
			{
				*global_index= -1;
				*coefficient_index= -1;
				global_index++;
				coefficient_index++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(Linear_combination_of_global_values).  Could not allocate memory");
			if (linear_combination)
			{
				DEALLOCATE(global_index);
				DEALLOCATE(linear_combination);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(Linear_combination_of_global_values).  Invalid argument(s)");
		linear_combination=(struct Linear_combination_of_global_values *)NULL;
	}
	LEAVE;

	return (linear_combination);
} /* CREATE(Linear_combination_of_global_values) */

int DESTROY(Linear_combination_of_global_values)(
	struct Linear_combination_of_global_values **linear_combination_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Frees the memory for the linear combination and sets
<*linear_combination_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct Linear_combination_of_global_values *linear_combination;

	ENTER(DESTROY(Linear_combination_of_global_values));
	if ((linear_combination_address)&&
		(linear_combination= *linear_combination_address))
	{
		DEALLOCATE(linear_combination->global_value_indices);
		DEALLOCATE(linear_combination->coefficient_indices);
		DEALLOCATE(*linear_combination_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(Linear_combination_of_global_values) */

struct Standard_node_to_element_map *CREATE(Standard_node_to_element_map)(
	int node_index,int number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Allocates memory and assigns fields for a standard node to element map.
Allocates storage for the nodal value and scale factor indices and sets to -1.
==============================================================================*/
{
	int i,*nodal_value_index,*scale_factor_index;
	struct Standard_node_to_element_map *map;

	ENTER(CREATE(Standard_node_to_element_map));
	if ((node_index>=0)&&(number_of_nodal_values>0))
	{
		if ((ALLOCATE(map,struct Standard_node_to_element_map,1))&&
			(ALLOCATE(nodal_value_index,int,number_of_nodal_values))&&
			(ALLOCATE(scale_factor_index,int,number_of_nodal_values)))
		{
			map->node_index=node_index;
			map->number_of_nodal_values=number_of_nodal_values;
			map->nodal_value_indices=nodal_value_index;
			map->scale_factor_indices=scale_factor_index;
			for (i=number_of_nodal_values;i>0;i--)
			{
				*nodal_value_index= -1;
				*scale_factor_index= -1;
				nodal_value_index++;
				scale_factor_index++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(Standard_node_to_element_map).  Could not allocate memory for map");
			if (map)
			{
				DEALLOCATE(nodal_value_index);
				DEALLOCATE(map);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(Standard_node_to_element_map).  Invalid argument(s)");
		map=(struct Standard_node_to_element_map *)NULL;
	}
	LEAVE;

	return (map);
} /* CREATE(Standard_node_to_element_map) */

int DESTROY(Standard_node_to_element_map)(
	struct Standard_node_to_element_map **map_address)
/*******************************************************************************
LAST MODIFIED : 23 September 1995

DESCRIPTION :
Frees the memory for the map and sets <*map_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct Standard_node_to_element_map *map;

	ENTER(DESTROY(Standard_node_to_element_map));
	if ((map_address)&&(map= *map_address))
	{
		DEALLOCATE(map->nodal_value_indices);
		DEALLOCATE(map->scale_factor_indices);
		DEALLOCATE(*map_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(Standard_node_to_element_map) */

struct General_node_to_element_map *CREATE(General_node_to_element_map)(
	int node_index,int number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Allocates memory and assigns fields for a general node to element map.
Allocates storage for the pointers to the linear combinations of field values
and sets to NULL.
==============================================================================*/
{
	int i;
	struct General_node_to_element_map *map;
	struct Linear_combination_of_global_values **element_value;

	ENTER(CREATE(General_node_to_element_map));
	if ((node_index>=0)&&(number_of_nodal_values>0))
	{
		if ((ALLOCATE(map,struct General_node_to_element_map,1))&&
			(ALLOCATE(element_value,struct Linear_combination_of_global_values *,
			number_of_nodal_values)))
		{
			map->node_index=node_index;
			map->number_of_nodal_values=number_of_nodal_values;
			map->element_values=element_value;
			for (i=number_of_nodal_values;i>0;i--)
			{
				*element_value=(struct Linear_combination_of_global_values *)NULL;
				element_value++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(General_node_to_element_map).  Could not allocate memory for map");
			DEALLOCATE(map);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(General_node_to_element_map).  Invalid argument(s)");
		map=(struct General_node_to_element_map *)NULL;
	}
	LEAVE;

	return (map);
} /* CREATE(General_node_to_element_map) */

int DESTROY(General_node_to_element_map)(
	struct General_node_to_element_map **map_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Frees the memory for the map and sets <*map_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct General_node_to_element_map *map;
	struct Linear_combination_of_global_values **linear_combination;

	ENTER(DESTROY(General_node_to_element_map));
	if ((map_address)&&(map= *map_address))
	{
		linear_combination=map->element_values;
		for (i=map->number_of_nodal_values;i>0;i--)
		{
			DESTROY(Linear_combination_of_global_values)(linear_combination);
			linear_combination++;
		}
		DEALLOCATE(map->element_values);
		DEALLOCATE(*map_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(General_node_to_element_map) */

struct FE_element_field_component *CREATE(FE_element_field_component)(
	enum Global_to_element_map_type type,int number_of_maps,
	struct FE_basis *basis,FE_element_field_component_modify modify)
/*******************************************************************************
LAST MODIFIED : 28 September 1998

DESCRIPTION :
Allocates memory and enters values for a component of a element field.
Allocates storage for the global to element maps and sets to NULL.
==============================================================================*/
{
	int i,*number_in_xi;
	struct FE_element_field_component *component;
	struct General_node_to_element_map **general_node_to_element_map;
	struct Linear_combination_of_global_values **element_value;
	struct Standard_node_to_element_map **standard_node_to_element_map;

	ENTER(CREATE(FE_element_field_component));
	/* check arguments */
	if ((number_of_maps>0)&&basis)
	{
		if (ALLOCATE(component,struct FE_element_field_component,1))
		{
			switch (type)
			{
				case STANDARD_NODE_TO_ELEMENT_MAP:
				{
					if (ALLOCATE(component->map.standard_node_based.node_to_element_maps,
						struct Standard_node_to_element_map *,number_of_maps))
					{
						component->map.standard_node_based.number_of_nodes=number_of_maps;
						standard_node_to_element_map=
							component->map.standard_node_based.node_to_element_maps;
						for (i=number_of_maps;i>0;i--)
						{
							*standard_node_to_element_map=
								(struct Standard_node_to_element_map *)NULL;
							standard_node_to_element_map++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
		"CREATE(FE_element_field_component).  Could not allocate memory for maps");
						DEALLOCATE(component);
					}
				} break;
				case GENERAL_NODE_TO_ELEMENT_MAP:
				{
					if (ALLOCATE(component->map.general_node_based.node_to_element_maps,
						struct General_node_to_element_map *,number_of_maps))
					{
						component->map.general_node_based.number_of_nodes=number_of_maps;
						general_node_to_element_map=
							component->map.general_node_based.node_to_element_maps;
						for (i=number_of_maps;i>0;i--)
						{
							*general_node_to_element_map=
								(struct General_node_to_element_map *)NULL;
							general_node_to_element_map++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
		"CREATE(FE_element_field_component).  Could not allocate memory for maps");
						DEALLOCATE(component);
					}
				} break;
				case FIELD_TO_ELEMENT_MAP:
				{
					if (ALLOCATE(component->map.field_based.element_values,
						struct Linear_combination_of_global_values *,number_of_maps))
					{
						component->map.field_based.number_of_element_values=number_of_maps;
						element_value=component->map.field_based.element_values;
						for (i=number_of_maps;i>0;i--)
						{
							*element_value=(struct Linear_combination_of_global_values *)NULL;
							element_value++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
		"CREATE(FE_element_field_component).  Could not allocate memory for maps");
						DEALLOCATE(component);
					}
				} break;
				case ELEMENT_GRID_MAP:
				{
					if (ALLOCATE(component->map.element_grid_based.number_in_xi,int,
						(basis->type)[0]))
					{
						number_in_xi=component->map.element_grid_based.number_in_xi;
						for (i=(basis->type)[0];i>0;i--)
						{
							*number_in_xi=0;
							number_in_xi++;
						}
						component->map.element_grid_based.value_index=0;
					}
					else
					{
						display_message(ERROR_MESSAGE,
"CREATE(FE_element_field_component).  Could not allocate memory for number_in_xi");
						DEALLOCATE(component);
					}
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_element_field_component).  Invalid type");
					DEALLOCATE(component);
				} break;
			}
			if (component)
			{
				component->type=type;
				component->basis=ACCESS(FE_basis)(basis);
				component->modify=modify;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
"CREATE(FE_element_field_component).  Could not allocate memory for component");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field_component).  Invalid argument(s)");
		component=(struct FE_element_field_component *)NULL;
	}
	LEAVE;

	return (component);
} /* CREATE(FE_element_field_component) */

int DESTROY(FE_element_field_component)(
	struct FE_element_field_component **component_address)
/*******************************************************************************
LAST MODIFIED : 28 September 1998

DESCRIPTION :
Frees the memory for the component and sets <*component_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_element_field_component *component;
	struct General_node_to_element_map **general_node_map;
	struct Linear_combination_of_global_values **linear_combination;
	struct Standard_node_to_element_map **standard_node_map;

	ENTER(DESTROY(FE_element_field_component));
	if ((component_address)&&(component= *component_address))
	{
		DEACCESS(FE_basis)(&(component->basis));
		switch (component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
			{
				standard_node_map=
					component->map.standard_node_based.node_to_element_maps;
				for (i=component->map.standard_node_based.number_of_nodes;i>0;i--)
				{
					DESTROY(Standard_node_to_element_map)(standard_node_map);
					standard_node_map++;
				}
				DEALLOCATE(component->map.standard_node_based.node_to_element_maps);
			} break;
			case GENERAL_NODE_TO_ELEMENT_MAP:
			{
				general_node_map=
					component->map.general_node_based.node_to_element_maps;
				for (i=component->map.general_node_based.number_of_nodes;i>0;i--)
				{
					DESTROY(General_node_to_element_map)(general_node_map);
					general_node_map++;
				}
				DEALLOCATE(component->map.general_node_based.node_to_element_maps);
			} break;
			case FIELD_TO_ELEMENT_MAP:
			{
				linear_combination=component->map.field_based.element_values;
				for (i=component->map.field_based.number_of_element_values;i>0;i--)
				{
					DESTROY(Linear_combination_of_global_values)(
						linear_combination);
					linear_combination++;
				}
				DEALLOCATE(component->map.field_based.element_values);
			} break;
			case ELEMENT_GRID_MAP:
			{
				DEALLOCATE(component->map.element_grid_based.number_in_xi);
			} break;
		}
		DEALLOCATE(*component_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field_component) */

struct FE_element_field *CREATE(FE_element_field)(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 2 November 1995

DESCRIPTION :
Allocates memory and assigns fields for an element field.  The storage is
allocated for the pointers to the components and set to NULL.
==============================================================================*/
{
	int i;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;

	ENTER(CREATE(FE_element_field));
	if (field)
	{
		if ((ALLOCATE(element_field,struct FE_element_field,1))&&
			(ALLOCATE(component,struct FE_element_field_component *,
			field->number_of_components)))
		{
			element_field->access_count=0;
			element_field->field=ACCESS(FE_field)(field);
			element_field->components=component;
			for (i=field->number_of_components;i>0;i--)
			{
				*component=(struct FE_element_field_component *)NULL;
				component++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field).  Could not allocate memory for element field");
			DEALLOCATE(element_field);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field).  Invalid argument(s)");
		element_field=(struct FE_element_field *)NULL;
	}
	LEAVE;

	return (element_field);
} /* CREATE(FE_element_field) */

int DESTROY(FE_element_field)(
	struct FE_element_field **element_field_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Frees the memory for element field and sets <*element_field_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;

	ENTER(DESTROY(FE_element_field));
	/* check arguments */
	if ((element_field_address)&&(element_field= *element_field_address))
	{
		if (0==element_field->access_count)
		{
			/* the element field will be destroyed as part as part of destroying
				element field information.  So it will already have been removed from
				the appropriate list */
			/* destroy the global to element maps */
			component=element_field->components;
			for (i=element_field->field->number_of_components;i>0;i--)
			{
				DESTROY(FE_element_field_component)(component);
				component++;
			}
			DEALLOCATE(element_field->components);
			DEACCESS(FE_field)(&(element_field->field));
			DEALLOCATE(*element_field_address);
		}
		else
		{
			*element_field_address=(struct FE_element_field *)NULL;
		}
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field) */

DECLARE_OBJECT_FUNCTIONS(FE_element_field)

static int for_FE_field_at_element_iterator(
	struct FE_element_field *element_field,void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
FE_element_field iterator for for_each_FE_field_at_element.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_element_iterator);
	if (element_field&&(iterator_and_data=
		(struct FE_element_field_iterator_and_data *)iterator_and_data_void)&&
		iterator_and_data->iterator)
	{
		return_code=(iterator_and_data->iterator)(iterator_and_data->element,
			element_field->field,iterator_and_data->user_data);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_element_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_element_iterator */

static int FE_element_field_add_indexer_field_to_list(
	struct FE_element_field *element_field,void *field_list_void)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
If the field in the <element_field> is of type INDEXED_FE_FIELD, function
ensures its indexer_field is put in the <field_list>.
Used by for_each_FE_field_at_element_indexer_first to put indexer_fields into a
priority list for iterating through first.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;
	struct LIST(FE_field) *field_list;

	ENTER(FE_element_field_add_indexer_field_to_list);
	if (element_field&&(field=element_field->field)&&
		(field_list=(struct LIST(FE_field) *)field_list_void))
	{
		return_code=1;
		if (INDEXED_FE_FIELD==field->fe_field_type)
		{
			if (!IS_OBJECT_IN_LIST(FE_field)(field->indexer_field,field_list))
			{
				return_code=
					ADD_OBJECT_TO_LIST(FE_field)(field->indexer_field,field_list);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_add_indexer_field_to_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_add_indexer_field_to_list */

static int for_FE_field_at_element_priority_iterator(
	struct FE_element_field *element_field,void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
FE_element_field iterator for for_each_FE_field_at_element. Only calls the
iterator function if the priority_on flag matches the field status in
priority_list.
==============================================================================*/
{
	int priority_field,return_code;
	struct FE_element_field_priority_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_element_iterator);
	if (element_field&&(iterator_and_data=
		(struct FE_element_field_priority_iterator_and_data *)
		iterator_and_data_void)&&iterator_and_data->iterator)
	{
		priority_field=IS_OBJECT_IN_LIST(FE_field)(element_field->field,
			iterator_and_data->priority_field_list);
		if ((iterator_and_data->priority_on&&priority_field)||
			((!iterator_and_data->priority_on)&&(!priority_field)))
		{
			return_code=(iterator_and_data->iterator)(iterator_and_data->element,
				element_field->field,iterator_and_data->user_data);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_element_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_element_iterator */

int inherit_FE_element_field(struct FE_element *element,struct FE_field *field,
	struct FE_element_field **element_field_address,
	struct FE_element **field_element_address,
	FE_value **coordinate_transformation_address,
	struct FE_element *top_level_element)
/*******************************************************************************
LAST MODIFIED : 1 October 1999

DESCRIPTION :
If <field> is NULL, element values are calculated for the coordinate field.
The optional <top_level_element> forces inheritance from it as needed.
If the dimension of <element> is less than that of the <field_element> from
which the field is inherited, then a <coordinate_transformation> is returned.
This consist of a matrix of dimension(field_element) rows X dimension(element)+1
columns. This represents an affine transformation, b + A xi for calculating the
field_element xi coordinates from those of <element>, where b is the first
column of the <coordinate_transformation> matrix.
==============================================================================*/
{
	FE_value *coordinate_transformation,*coordinate_transformation_value,
		*face_to_element,*face_to_element_value,*new_coordinate_transformation,
		*new_coordinate_transformation_value,value;
	int dimension,dimension_minus_1,face_number,field_element_dimension,i,j,k,
		return_code,transformation_size;
	struct FE_element *field_element,*parent;
	struct FE_element_field *element_field;
	struct FE_element_field_info *field_info;
	struct FE_element_parent *element_parent;
	struct Field_defined_for_parent_data field_defined_for_parent_data;

	ENTER(inherit_FE_element_field);
#if defined (DEBUG)
	/*???debug */
	printf("enter inherit_FE_element_field\n");
#endif /* defined (DEBUG) */
	/* check the arguments */
	if (element&&(element->shape)&&element_field_address&&field_element_address&&
		coordinate_transformation_address)
	{
		/* initialize values to be returned on success */
		element_field=(struct FE_element_field *)NULL;
		field_element=(struct FE_element *)NULL;
		coordinate_transformation=(FE_value *)NULL;
#if defined (DEBUG)
		/*???debug */
		printf("element %d \n",element->cm.number);
#endif /* defined (DEBUG) */
		/* check if the field is defined for the element */
		if ((element->information)&&(field_info=element->information->fields))
		{
			if (field)
			{
				element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,
					field)(field,field_info->element_field_list);
				return_code=1;
			}
			else
			{
				/* if <field> is NULL check for a coordinate field */
				element_field=FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
					FE_element_field_is_type_CM_coordinate,(void *)NULL,
					field_info->element_field_list);
				return_code=1;
			}
		}
		else
		{
			element_field=(struct FE_element_field *)NULL;
			return_code=1;
		}
		if (return_code)
		{
			if (element_field)
			{
				coordinate_transformation=(FE_value *)NULL;
				field_element=element;
			}
			else
			{
				/* check if the field is defined for any of the element's parents */
				field_defined_for_parent_data.field=field;
				field_defined_for_parent_data.field_element=(struct FE_element *)NULL;
				field_defined_for_parent_data.element_field=
					(struct FE_element_field *)NULL;
				field_defined_for_parent_data.coordinate_transformation=
					(FE_value *)NULL;
				/*???RC  Begin change to allow inheriting off given top_level_element */
				field_defined_for_parent_data.top_level_element=top_level_element;
				/*???RC  End change to allow inheriting off given top_level_element */
				if (element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					field_defined_for_parent,(void *)(&field_defined_for_parent_data),
					element->parent_list))
				{
					element_field=field_defined_for_parent_data.element_field;
					field_element=field_defined_for_parent_data.field_element;
					coordinate_transformation=
						field_defined_for_parent_data.coordinate_transformation;
					parent=element_parent->parent;
					face_number=element_parent->face_number;
					dimension=parent->shape->dimension;
					field_element_dimension=field_element->shape->dimension;
#if defined (DEBUG)
					/*???debug */
					printf("shape %p\n",parent->shape);
					face_to_element_value=(parent->shape->face_to_element);
					printf("face_number = %d\n",face_number);
					for (i=0;i<parent->shape->number_of_faces;i++)
					{
						printf("face %d\n",i);
						for (j=dimension;j>0;j--)
						{
							for (k=dimension;k>0;k--)
							{
								printf(" %g",*face_to_element_value);
								face_to_element_value++;
							}
							printf("\n");
						}
					}
#endif /* defined (DEBUG) */
					if (coordinate_transformation)
					{
						if (ALLOCATE(new_coordinate_transformation,FE_value,
							field_element_dimension*dimension))
						{
							/* incorporate the face to element map in the coordinate
								transformation */
							face_to_element=(parent->shape->face_to_element)+
								(face_number*dimension*dimension);
#if defined (DEBUG)
							/*???debug */
							printf("face to element:\n");
							face_to_element_value=face_to_element;
							for (i=dimension;i>0;i--)
							{
								for (j=dimension;j>0;j--)
								{
									printf(" %g",*face_to_element_value);
									face_to_element_value++;
								}
								printf("\n");
							}
#endif /* defined (DEBUG) */
#if defined (DEBUG)
							/*???debug */
							printf("new coordinate transformation:\n");
#endif /* defined (DEBUG) */
							coordinate_transformation_value=coordinate_transformation;
							new_coordinate_transformation_value=
								new_coordinate_transformation;
							dimension_minus_1=dimension-1;
							for (i=field_element_dimension;i>0;i--)
							{
								/* calculate b entry for this row */
								value= *coordinate_transformation_value;
								coordinate_transformation_value++;
								face_to_element_value=face_to_element;
								for (k=dimension;k>0;k--)
								{
									value += (*coordinate_transformation_value)*
										(*face_to_element_value);
									coordinate_transformation_value++;
									face_to_element_value += dimension;
								}
								*new_coordinate_transformation_value=value;
#if defined (DEBUG)
								/*???debug */
								printf(" %g",value);
#endif /* defined (DEBUG) */
								new_coordinate_transformation_value++;
								/* calculate A entries for this row */
								for (j=dimension_minus_1;j>0;j--)
								{
									face_to_element++;
									face_to_element_value=face_to_element;
									coordinate_transformation_value -= dimension;
									value=0;
									for (k=dimension;k>0;k--)
									{
										value += (*coordinate_transformation_value)*
											(*face_to_element_value);
										coordinate_transformation_value++;
										face_to_element_value += dimension;
									}
									*new_coordinate_transformation_value=value;
#if defined (DEBUG)
									/*???debug */
									printf(" %g",value);
#endif /* defined (DEBUG) */
									new_coordinate_transformation_value++;
								}
#if defined (DEBUG)
								/*???debug */
								printf("\n");
#endif /* defined (DEBUG) */
								face_to_element -= dimension_minus_1;
							}
							DEALLOCATE(coordinate_transformation);
							coordinate_transformation=new_coordinate_transformation;
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"inherit_FE_element_field.  Insufficient memory");
							DEALLOCATE(coordinate_transformation);
							return_code=0;
						}
					}
					else
					{
#if defined (DEBUG)
						/*???debug */
						printf("new coordinate transformation %d %d :\n",dimension,
							field_element_dimension);
#endif /* defined (DEBUG) */
						/* use the face to element map as the transformation */
						transformation_size=field_element_dimension*dimension;
						if (ALLOCATE(coordinate_transformation,FE_value,
							transformation_size))
						{
							coordinate_transformation_value=coordinate_transformation;
							face_to_element_value=(parent->shape->face_to_element)+
								(face_number*transformation_size);
							while (transformation_size>0)
							{
								*coordinate_transformation_value= *face_to_element_value;
#if defined (DEBUG)
								/*???debug */
								printf(" %g",*face_to_element_value);
#endif /* defined (DEBUG) */
								coordinate_transformation_value++;
								face_to_element_value++;
								transformation_size--;
#if defined (DEBUG)
								/*???debug */
								if (0==transformation_size%dimension)
								{
									printf("\n");
								}
#endif /* defined (DEBUG) */
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"inherit_FE_element_field.  Insufficient memory");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"inherit_FE_element_field.  Field not defined for parent");
					return_code=0;
				}
			}
		}
		if (return_code)
		{
			/* guarantee this function returns element_field and field_element */
			if (element_field&&field_element)
			{
				*element_field_address=element_field;
				*field_element_address=field_element;
				*coordinate_transformation_address=coordinate_transformation;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"inherit_FE_element_field.  No element_field or field_element");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"inherit_FE_element_field.  Invalid argument(s)");
		return_code=0;
	}
#if defined (DEBUG)
	/*???debug */
	printf("leave inherit_FE_element_field\n");
#endif /* defined (DEBUG) */
	LEAVE;

	return (return_code);
} /* inherit_FE_element_field */

int calculate_grid_field_offsets(int element_dimension,
	int top_level_element_dimension,int *top_level_number_in_xi,
	FE_value *element_to_top_level,int *number_in_xi,int *base_grid_offset,
	int *grid_offset_in_xi)
/*******************************************************************************
LAST MODIFIED : 13 June 2000

DESCRIPTION :
Calculates the factors for converting a grid position on a element of
<element_dimension> to a top_level_element of <top_level_element_dimension>
with <top_level_number_in_xi>, given affine transformation
<element_to_top_level> which has as many rows as <top_level_element_dimension>
and 1 more column than <element_dimension>, converting xi from element to
top_level as follows:
top_level_xi = b + A xi, with b the first column.
The <number_in_xi> of the element is returned, as is the <base_grid_offset> and
the <grid_offset_in_xi> which make up the grid point number conversion:
eg. top_level_grid_point_number = base_grid_offset +
grid_offset_in_xi[i]*grid_number_in_xi[i] (i summed over element_dimension).
Sets values appropriately if element_dimension = top_level_element_dimension.
==============================================================================*/
{
	FE_value *temp_element_to_top_level;
	int i,return_code,top_level_grid_offset_in_xi[MAXIMUM_ELEMENT_XI_DIMENSIONS],
		xi_number;

	ENTER(calculate_grid_field_offsets);
	if ((0<element_dimension)&&(element_dimension<=top_level_element_dimension)&&
		(top_level_element_dimension<=MAXIMUM_ELEMENT_XI_DIMENSIONS)&&
		top_level_number_in_xi&&((element_dimension==top_level_element_dimension)||
			element_to_top_level)&&number_in_xi&&base_grid_offset&&grid_offset_in_xi)
	{
		return_code=1;
		/* clear offsets */
		*base_grid_offset = 0;
		for (i=0;i<element_dimension;i++)
		{
			grid_offset_in_xi[i]=0;
		}
		/* calculate offset in grid_point_number for adjacent points in each xi
			 direction on the top_level_element */
		top_level_grid_offset_in_xi[0]=1;
		for (i=1;i<top_level_element_dimension;i++)
		{
			top_level_grid_offset_in_xi[i]=
				top_level_grid_offset_in_xi[i-1]*(top_level_number_in_xi[i-1]+1);
		}
		if (element_dimension == top_level_element_dimension)
		{
			for (i=0;i<top_level_element_dimension;i++)
			{
				grid_offset_in_xi[i]=top_level_grid_offset_in_xi[i];
				number_in_xi[i]=top_level_number_in_xi[i];
			}
		}
		else
		{
			temp_element_to_top_level=element_to_top_level;
			for (i=0;i<top_level_element_dimension;i++)
			{
				/* a number in the first column indicates either xi decreasing
					 or the direction this is a face/line on */
				if (*temp_element_to_top_level)
				{
					*base_grid_offset +=
						top_level_number_in_xi[i]*top_level_grid_offset_in_xi[i];
				}
				/* find out how (if at all) element xi changes with this
					 field_element xi */
				for (xi_number=0;xi_number<element_dimension;xi_number++)
				{
					if (temp_element_to_top_level[xi_number+1])
					{
						number_in_xi[xi_number] = top_level_number_in_xi[i];
						if (0<temp_element_to_top_level[xi_number+1])
						{
							grid_offset_in_xi[xi_number] = top_level_grid_offset_in_xi[i];
						}
						else
						{
							grid_offset_in_xi[xi_number] = -top_level_grid_offset_in_xi[i];
						}
					}
				}
				temp_element_to_top_level += (element_dimension+1);
			}
		}
		for (i=0;(i<element_dimension)&&return_code;i++)
		{
			if ((0==grid_offset_in_xi[i])||(0==number_in_xi[i]))
			{
				display_message(ERROR_MESSAGE,
					"calculate_grid_field_offsets.  Invalid number_in_xi");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_grid_field_offsets.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* calculate_grid_field_offsets */

int calculate_FE_element_field_values(struct FE_element *element,
	struct FE_field *field,char calculate_derivatives,
	struct FE_element_field_values *element_field_values,
	struct FE_element *top_level_element)
/*******************************************************************************
LAST MODIFIED : 13 June 2000

DESCRIPTION :
If <field> is NULL, element values are calculated for the coordinate field.  The
function fills in the fields of the <element_field_values> structure, but does
not allocate memory for the structure.
The optional <top_level_element> forces inheritance from it as needed.
???DB.  I think that the field=NULL special case should be removed.
==============================================================================*/
{
	FE_value *basis_function_values,*blending_matrix,*coordinate_transformation,
		*derivative_value,*inherited_value,*inherited_values,scalar,
		*second_derivative_value,sum,*sumand,*transformation,*value,
		**values_address;
	int *basis_type,calculate_standard_basis_arguments,component_number,
		*component_number_in_xi,element_dimension,*element_value_offsets,
		field_element_dimension,*field_to_element,*grid_offset_in_xi,i,
		*inherited_standard_basis_argument,j,k,l,maximum_number_of_values,
		*number_in_xi,number_of_components,
		number_of_inherited_values,number_of_polygon_verticies,number_of_values,
		*number_of_values_address,offset,order,*orders,polygon_offset,
		polygon_vertex,power,*reorder_coordinate,*reorder_coordinates,
		*reorder_value,*reorder_values,return_code,row_size,
		*standard_basis_argument,*standard_basis_arguments,
		**standard_basis_arguments_address;
	Standard_basis_function **standard_basis_address;
	struct FE_basis *previous_basis;
	struct FE_element *field_element;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;
	Value_storage **values_storage_address;

	ENTER(calculate_FE_element_field_values);
#if defined (DEBUG)
	/*???debug */
	printf("enter calculate_FE_element_field_values\n");
#endif /* defined (DEBUG) */
	/* check the arguments */
	if (element&&(element->shape)&&element_field_values)
	{
		/* retrieve the element field from which this element inherits the field
			and calculate the affine transformation from the element xi coordinates
			to the xi coordinates for the element field */
		element_field=(struct FE_element_field *)NULL;
		field_element=(struct FE_element *)NULL;
		coordinate_transformation=(FE_value *)NULL;
		if (inherit_FE_element_field(element,field,&element_field,&field_element,
			&coordinate_transformation,top_level_element))
		{
			return_code=1;
#if defined (DEBUG)
			/*???debug */
			printf("element : %d \n",element->cm.number);
			printf("field element : %d \n",field_element->cm.number);
#endif /* defined (DEBUG) */
			element_dimension=element->shape->dimension;
			field_element_dimension=field_element->shape->dimension;
			number_of_components=element_field->field->number_of_components;
#if defined (DEBUG)
			/*???debug */
			printf("coordinate_transformation: %p\n",coordinate_transformation);
			if (value=coordinate_transformation)
			{
				for (i=field_element_dimension;i>0;i--)
				{
					for (j=element_dimension+1;j>0;j--)
					{
						printf(" %g",*value);
						value++;
					}
					printf("\n");
				}
			}
			printf("%d #components=%d\n",field_element_dimension,
				number_of_components);
#endif /* defined (DEBUG) */
			switch (field->fe_field_type)
			{
				case CONSTANT_FE_FIELD:
				{
					/* constant fields do not use the values except to remember the
						 element and field they are for */
					element_field_values->field=ACCESS(FE_field)(field);
					element_field_values->element=ACCESS(FE_element)(element);
					/* store field_element since we are now able to suggest through the
						 top_level_element clue which one we get. Must compare element
						 and field_element to ensure field values are still valid for
						 a given line or face. */
					element_field_values->field_element=
						ACCESS(FE_element)(field_element);
					element_field_values->number_in_xi=(int *)NULL;
					/* derivatives will be calculated in calculate_FE_element_field */
					/*???DB.  Assuming linear */
					element_field_values->derivatives_calculated=1;
					element_field_values->destroy_standard_basis_arguments=0;
					element_field_values->number_of_components=number_of_components;
					element_field_values->component_number_of_values=(int *)NULL;
					element_field_values->component_grid_values_storage=
						(Value_storage **)NULL;
					element_field_values->base_grid_offset=0;
					element_field_values->grid_offset_in_xi=(int *)NULL;
					element_field_values->element_value_offsets=(int *)NULL;
					/* clear arrays not used for grid-based fields */
					element_field_values->component_values=(FE_value **)NULL;
					element_field_values->component_standard_basis_functions=
						(Standard_basis_function **)NULL;
					element_field_values->component_standard_basis_function_arguments=
						(void *)NULL;
					element_field_values->basis_function_values=(FE_value *)NULL;
				} break;
				case INDEXED_FE_FIELD:
				{
					if (calculate_FE_element_field_values(element,field->indexer_field,
						calculate_derivatives,element_field_values,top_level_element))
					{
						/* restore pointer to original field - has the indexer_field in
							 it anyway */
						REACCESS(FE_field)(&(element_field_values->field),field);
					}
					else
					{
						display_message(ERROR_MESSAGE,"calculate_FE_element_field_values.  "
							"Cannot calculate element field values for indexer field");
						return_code=0;
					}
				} break;
				case GENERAL_FE_FIELD:
				{
					/* allocate memory for components */
					if (ELEMENT_GRID_MAP==(*(element_field->components))->type)
					{
						/* grid based element field */
						/* check that components are linear and consistent */
						component=element_field->components;
						number_in_xi=((*component)->map).element_grid_based.number_in_xi;
						component_number=0;
						return_code=1;
						while (return_code&&(component_number<number_of_components))
						{
							if (ELEMENT_GRID_MAP==(*component)->type)
							{
								i=0;
								while ((i<field_element_dimension)&&(number_in_xi[i]==
									(((*component)->map).element_grid_based.number_in_xi)[i]))
								{
									i++;
								}
								if (i>=field_element_dimension)
								{
									basis_type=(*component)->basis->type;
									i=field_element_dimension;
									while (return_code&&(i>0))
									{
										i--;
										basis_type++;
										if (LINEAR_LAGRANGE== *basis_type)
										{
											j=i;
											while (return_code&&(j>0))
											{
												j--;
												basis_type++;
												if (0!= *basis_type)
												{
													return_code=0;
												}
											}
										}
										else
										{
											return_code=0;
										}
									}
									if (!return_code)
									{
										display_message(ERROR_MESSAGE,
											"calculate_FE_element_field_values.  Grid based components must be linear");
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  Inconsistent sub-divisions for grid based components");
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_values.  Cannot mix grid based and non grid based components");
								return_code=0;
							}
							component++;
							component_number++;
						}
						if (return_code)
						{
							maximum_number_of_values=element_dimension+1;
							for (i=element_dimension;i>0;i--)
							{
								maximum_number_of_values *= 2;
							}
							ALLOCATE(values_storage_address,Value_storage *,number_of_components);
							ALLOCATE(number_in_xi,int,element_dimension);
							/* need space for basis function for value and derivatives */
							ALLOCATE(basis_function_values,FE_value,
								(element_dimension+1)*maximum_number_of_values);
							ALLOCATE(grid_offset_in_xi,int,element_dimension);
							ALLOCATE(element_value_offsets,int,maximum_number_of_values);
							if (values_storage_address&&number_in_xi&&basis_function_values&&
								grid_offset_in_xi&&element_value_offsets)
							{
								element_field_values->number_in_xi=number_in_xi;
								element_field_values->field=ACCESS(FE_field)(element_field->field);
								element_field_values->element=ACCESS(FE_element)(element);
								/* store field_element since we are now able to suggest through the
									 top_level_element clue which one we get. Must compare element
									 and field_element to ensure field values are still valid for
									 a given line or face. */
								element_field_values->field_element=
									ACCESS(FE_element)(field_element);
								/* derivatives will be calculated in calculate_FE_element_field */
								/*???DB.  Assuming linear */
								element_field_values->derivatives_calculated=1;
								element_field_values->number_of_components=number_of_components;
								element_field_values->component_number_of_values=(int *)NULL;
								element_field_values->component_grid_values_storage=
									values_storage_address;
								element_field_values->base_grid_offset=0;
								element_field_values->grid_offset_in_xi=grid_offset_in_xi;
								element_field_values->element_value_offsets=element_value_offsets;
								/* clear arrays not used for grid-based fields */
								element_field_values->component_values=(FE_value **)NULL;
								element_field_values->component_standard_basis_functions=
									(Standard_basis_function **)NULL;
								element_field_values->component_standard_basis_function_arguments=
									(void *)NULL;
								element_field_values->basis_function_values=basis_function_values;
								element_field_values->destroy_standard_basis_arguments=0;
								/* get convenient lookup into position in values_storage where
									 values for each component are stored */
								component=element_field->components;
								for (component_number=0;(component_number<number_of_components)&&
											 return_code;component_number++)
								{
									*values_storage_address=
										(field_element->information->values_storage)+
										(((*component)->map).element_grid_based.value_index);
									values_storage_address++;
									component++;
								}
								element_field_values->destroy_standard_basis_arguments=0;
								if (MAXIMUM_ELEMENT_XI_DIMENSIONS >= field_element_dimension)
								{
									component=element_field->components;
									component_number_in_xi=
										((*component)->map).element_grid_based.number_in_xi;
									if (!calculate_grid_field_offsets(element_dimension,
										field_element_dimension,component_number_in_xi,
										coordinate_transformation,number_in_xi,
										&(element_field_values->base_grid_offset),grid_offset_in_xi))
									{
										display_message(ERROR_MESSAGE,
											"calculate_FE_element_field_values.  "
											"Could not calculate grid field offsets");
										return_code=0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  "
										"Dimension out of range: %d",field_element_dimension);
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_values.  "
									"Could not allocate grid calculation information");
								DEALLOCATE(values_storage_address);
								DEALLOCATE(number_in_xi);
								DEALLOCATE(basis_function_values);
								DEALLOCATE(grid_offset_in_xi);
								DEALLOCATE(element_value_offsets);
							}
						}
					}
					else
					{
						/* not grid based element field */
						element_field_values->number_in_xi=(int *)NULL;
						ALLOCATE(number_of_values_address,int,number_of_components);
						ALLOCATE(values_address,FE_value *,number_of_components);
						ALLOCATE(standard_basis_address,Standard_basis_function *,
							number_of_components);
						if (ALLOCATE(standard_basis_arguments_address,int *,
							number_of_components))
						{
							/* clear these addresses since allocated by other functions */
							for (i=0;i<number_of_components;i++)
							{
								standard_basis_arguments_address[i]=(int *)NULL;
							}
						}
						blending_matrix=(FE_value *)NULL;
						if (number_of_values_address&&values_address&&
							standard_basis_address&&standard_basis_arguments_address)
						{
							element_field_values->field=
								ACCESS(FE_field)(element_field->field);
							element_field_values->element=ACCESS(FE_element)(element);
							/* store field_element since we are now able to suggest through
								 the top_level_element clue which one we get. Must compare
								 element and field_element to ensure field values are still
								 valid for a given line or face. */
							element_field_values->field_element=
								ACCESS(FE_element)(field_element);
							element_field_values->derivatives_calculated=
								calculate_derivatives;
							/*???RC arguments should always be destroyed for monomial basis
								functions, it seems, and for polygons only if there is a
								coordinate transformation - hence see later */
							element_field_values->destroy_standard_basis_arguments=1;
#if defined (OLD_CODE)
							if (coordinate_transformation)
							{
								element_field_values->destroy_standard_basis_arguments=1;
							}
							else
							{
								element_field_values->destroy_standard_basis_arguments=0;
							}
#endif /* defined (OLD_CODE) */
							element_field_values->number_of_components=number_of_components;
							element_field_values->component_number_of_values=
								number_of_values_address;
							/* clear arrays only used for grid-based fields */
							element_field_values->component_grid_values_storage=
								(Value_storage **)NULL;
							element_field_values->grid_offset_in_xi=(int *)NULL;
							element_field_values->element_value_offsets=(int *)NULL;

							element_field_values->component_values=values_address;
							element_field_values->component_standard_basis_functions=
								standard_basis_address;
							element_field_values->component_standard_basis_function_arguments=
								(void *)standard_basis_arguments_address;
							/* for each component */
							component=element_field->components;
							previous_basis=(struct FE_basis *)NULL;
							reorder_values=(int *)NULL;
							field_to_element=(int *)NULL;
							reorder_coordinates=(int *)NULL;
							component_number=0;
							return_code=1;
							maximum_number_of_values=0;
							while (return_code&&(component_number<number_of_components))
							{
								if (ELEMENT_GRID_MAP!=(*component)->type)
								{
									/* calculate element values for the element field component */
									if (global_to_element_map_values(field_element,element_field,
										component_number,number_of_values_address,values_address))
									{
#if defined (DEBUG)
										/*???debug */
										printf("component_number %d\n",component_number);
#endif /* defined (DEBUG) */
#if defined (DEBUG)
										/*???debug */
										{
											FE_value *value;
											int i;

											i= *number_of_values_address;
											printf("component=%d, #values=%d\n",component_number,i);
											value= *values_address;
											while (i>0)
											{
												printf("%.10g ",*value);
												i--;
												value++;
											}
											printf("\n");
										}
#endif /* defined (DEBUG) */
										if (previous_basis==(*component)->basis)
										{
											calculate_standard_basis_arguments=0;
											/*???DB.  Changed because of polygons */
											/* *standard_basis_address= *(standard_basis_address-1);*/
											*standard_basis_address=previous_basis->standard_basis;
											*standard_basis_arguments_address=
												*(standard_basis_arguments_address-1);
										}
										else
										{
											calculate_standard_basis_arguments=1;
											previous_basis=(*component)->basis;
											if (blending_matrix)
											{
												/* SAB We don't want to keep the old one */
												DEALLOCATE(blending_matrix);
											}
											*standard_basis_address=previous_basis->standard_basis;
											return_code=calculate_standard_basis_transformation(
												previous_basis,coordinate_transformation,
												element_dimension,standard_basis_arguments_address,
												&number_of_inherited_values,&blending_matrix,
												&field_to_element,&reorder_coordinates);
										}
										if (return_code)
										{
											/* project the element values onto the element using the
												 affine transformation */
											/*???DB.  Projection is dependent on standard basis */
											if (monomial_basis_functions== *standard_basis_address)
											{
#if defined (DEBUG)
												/*???debug */
												printf("number_of_inherited_values=%d\n",
													number_of_inherited_values);
#endif /* defined (DEBUG) */
												/* allocate memory for the element values */
												if (calculate_derivatives)
												{
													ALLOCATE(inherited_values,FE_value,
														(element_dimension+1)*number_of_inherited_values);
												}
												else
												{
													ALLOCATE(inherited_values,FE_value,
														number_of_inherited_values);
												}
												if (inherited_values)
												{
													row_size= *number_of_values_address;
													inherited_value=inherited_values;
													for (j=0;j<number_of_inherited_values;j++)
													{
														sum=0;
														value= *values_address;
														transformation=blending_matrix+j;
														for (i=row_size;i>0;i--)
														{
															sum += (*transformation)*(*value);
															value++;
															transformation += number_of_inherited_values;
														}
														*inherited_value=sum;
#if defined (DEBUG)
														/*???debug */
														printf("inherited %d %g\n",j,sum);
#endif /* defined (DEBUG) */
														inherited_value++;
													}
													DEALLOCATE(*values_address);
													*values_address=inherited_values;
													*number_of_values_address=number_of_inherited_values;
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"calculate_FE_element_field_values.  "
														"Insufficient memory for inherited_values");
													DEALLOCATE(*values_address);
													return_code=0;
												}
											}
											else if (polygon_basis_functions==*standard_basis_address)
											{
#if defined (DEBUG)
												/*???debug */
												printf("polygon_basis_functions %p\n",
													coordinate_transformation);
#endif /* defined (DEBUG) */
												if (coordinate_transformation)
												{
													*standard_basis_address=monomial_basis_functions;
													number_of_inherited_values=1;
													standard_basis_arguments=
														(int *)((*component)->basis->arguments);
													standard_basis_argument=standard_basis_arguments;
													number_of_values= *number_of_values_address;
													offset=1;
													transformation=coordinate_transformation;
#if defined (DEBUG)
													/*???debug */
													printf("arguments : %d",*standard_basis_argument);
#endif /* defined (DEBUG) */
													for (i=0;i<field_element_dimension;i++)
													{
														standard_basis_argument++;
														order= *standard_basis_argument;
#if defined (DEBUG)
														/*???debug */
														printf(" %d",order);
#endif /* defined (DEBUG) */
														if (order<0)
														{
																/* polygon */
															if ((polygon_offset= -order) <
																field_element_dimension)
															{
																/* first polygon component */
																number_of_polygon_verticies=
																	-standard_basis_argument[polygon_offset]-
																	field_element_dimension;
																if (field_to_element[i])
																{
																	if (field_to_element[i+polygon_offset])
																	{
																		/* polygon is in projection */
#if defined (DEBUG)
																		/*???debug */
																		printf("polygon is in projection\n");
#endif /* defined (DEBUG) */
																		*standard_basis_address=
																			polygon_basis_functions;
																		number_of_inherited_values *=
																			4*number_of_polygon_verticies;
																	}
																	else
																	{
																		/* edge of polygon in projection */
																		polygon_vertex=
																			(int)(0.1+(*transformation)*
																				(FE_value)number_of_polygon_verticies);
#if defined (DEBUG)
																		/*???debug */
																		printf("polygon edge is in projection %d\n",
																			polygon_vertex);
#endif /* defined (DEBUG) */
																		value= *values_address;
																		inherited_value=value;
																		if (number_of_polygon_verticies-1==
																			polygon_vertex)
																		{
																			for (j=number_of_values/
																						 (4*number_of_polygon_verticies*
																							 number_of_inherited_values);j>0;j--)
																			{
																				for (k=number_of_inherited_values;k>0;k--)
																				{
																					scalar=value[polygon_vertex*
																						number_of_inherited_values]+
																						value[(polygon_vertex+
																							2*number_of_polygon_verticies)*
																							number_of_inherited_values];
																					inherited_value[
																						number_of_inherited_values]=(*value)+
																						value[2*number_of_polygon_verticies*
																							number_of_inherited_values]-scalar;
																					*inherited_value=scalar;
																					inherited_value++;
																					value++;
																				}
																				inherited_value +=
																					number_of_inherited_values;
																				value +=
																					(4*number_of_polygon_verticies-1)*
																					number_of_inherited_values;
																			}
																		}
																		else
																		{
																			if (number_of_polygon_verticies==
																				polygon_vertex)
																			{
																				polygon_vertex=0;
																			}
																			value +=
																				polygon_vertex*number_of_inherited_values;
																			for (j=number_of_values/
																						 (4*number_of_polygon_verticies*
																							 number_of_inherited_values);j>0;j--)
																			{
																				for (k=number_of_inherited_values;k>0;k--)
																				{
																					*inherited_value= (*value)+
																						value[2*number_of_polygon_verticies*
																							number_of_inherited_values];
																					inherited_value[
																						number_of_inherited_values]=
																						value[number_of_inherited_values]+
																						value[(2*number_of_polygon_verticies+
																							1)*number_of_inherited_values]-
																						*inherited_value;
																					inherited_value++;
																					value++;
																				}
																				inherited_value +=
																					number_of_inherited_values;
																				value +=
																					(4*number_of_polygon_verticies-1)*
																					number_of_inherited_values;
																			}
																		}
																		number_of_values /=
																			4*number_of_polygon_verticies;
																		number_of_values *= 2;
																		number_of_inherited_values *= 2;
																	}
																}
																else
																{
																/* polygon is not in projection */
#if defined (DEBUG)
																/*???debug */
																	printf("polygon is not in projection\n");
#endif /* defined (DEBUG) */
																	polygon_vertex=(int)(0.1+(*transformation)*
																		(FE_value)number_of_polygon_verticies);
																	if (number_of_polygon_verticies==polygon_vertex)
																	{
																		polygon_vertex=0;
																	}
																	value= *values_address;
																	inherited_value=value;
																	value +=
																		polygon_vertex*number_of_inherited_values;
																	for (j=number_of_values/
																				 (4*number_of_polygon_verticies*
																					 number_of_inherited_values);j>0;j--)
																	{
																		for (k=number_of_inherited_values;k>0;k--)
																		{
																			*inherited_value= *value+
																				value[2*number_of_polygon_verticies*
																					number_of_inherited_values];
																			inherited_value++;
																			value++;
																		}
																		value += (4*number_of_polygon_verticies-1)*
																			number_of_inherited_values;
																	}
																	number_of_values /=
																		4*number_of_polygon_verticies;
																}
															}
														}
														else
														{
																/* not polygon */
															if (field_to_element[i])
															{
																/* in projection */
																number_of_inherited_values *= order+1;
															}
															else
															{
																/* not in projection */
																if (*transformation)
																{
																/* assume *transformation (b) is 1 */
																	value= *values_address;
																	inherited_value=value;
																	for (j=number_of_values/
																				 ((order+1)*number_of_inherited_values);j>0;
																			 j--)
																	{
																		for (k=number_of_inherited_values;k>0;k--)
																		{
																			sum= *value;
																			sumand=value;
																			for (l=order;l>0;l--)
																			{
																				sumand += number_of_inherited_values;
																				sum += *sumand;
																			}
																			*inherited_value=sum;
																			inherited_value++;
																			value++;
																		}
																		value=sumand+1;
																	}
																	number_of_values /= order+1;
																}
																else
																{
																/* *transformation (b) is 0 */
																	value= *values_address;
																	inherited_value=value;
																	for (j=number_of_values/
																				 ((order+1)*number_of_inherited_values);j>0;
																			 j--)
																	{
																		for (k=number_of_inherited_values;k>0;k--)
																		{
																			*inherited_value= *value;
																			inherited_value++;
																			value++;
																		}
																		value += order*number_of_inherited_values;
																	}
																	number_of_values /= order+1;
																} break;
															}
														}
														transformation += element_dimension+1;
													}
#if defined (DEBUG)
													/*???debug */
													printf("\n");
													/*???debug */
													printf("inherited values :");
													inherited_value= *values_address;
													for (i=number_of_inherited_values;i>0;i--)
													{
														printf(" %g",*inherited_value);
														inherited_value++;
													}
													printf("\n");
#endif /* defined (DEBUG) */
													*number_of_values_address=number_of_inherited_values;
													/* fill in the element values */
													if (reorder_coordinates)
													{
														/* allocate memory for the element values */
														if (calculate_derivatives)
														{
															ALLOCATE(inherited_values,FE_value,
																(element_dimension+1)*number_of_inherited_values);
														}
														else
														{
															ALLOCATE(inherited_values,FE_value,
																number_of_inherited_values);
														}
														if (inherited_values)
														{
																/* reorder values */
															if (calculate_standard_basis_arguments)
															{
																DEALLOCATE(reorder_values);
																if (ALLOCATE(reorder_values,int,
																	number_of_inherited_values))
																{
																	reorder_value=reorder_values;
																	*reorder_value=0;
																	value= *values_address;
																	*inherited_values= *value;
																	k=1;
																	reorder_coordinate=reorder_coordinates;
																	orders= *standard_basis_arguments_address;
#if defined (DEBUG)
																/*???debug */
																	printf("reorder coordinates :");
#endif /* defined (DEBUG) */
																	for (i=element_dimension;i>0;i--)
																	{
#if defined (DEBUG)
																		/*???debug */
																		printf(" %d",*reorder_coordinate);
#endif /* defined (DEBUG) */
																		orders++;
																		order= *orders;
#if defined (DEBUG)
																		/*???debug */
																		printf(" (%d)",order);
#endif /* defined (DEBUG) */
																		if (order> -element_dimension)
																		{
																			/* not polygon second coordinate */
																			offset=1;
																			inherited_standard_basis_argument=
																				(*standard_basis_arguments_address)+1;
																			for (j=(*reorder_coordinate);j>0;j--)
																			{
																				polygon_offset=
																					*inherited_standard_basis_argument;
																				if (polygon_offset<0)
																				{
																					polygon_offset= -polygon_offset;
																					if (polygon_offset<element_dimension)
																					{
																						offset *= -4*
																							(inherited_standard_basis_argument[
																								polygon_offset]+element_dimension);
																					}
																				}
																				else
																				{
																					offset *= polygon_offset+1;
																				}
																				inherited_standard_basis_argument++;
																			}
																			order= *inherited_standard_basis_argument;
																			if (order<0)
																			{
																				/* polygon */
																				if ((polygon_offset= -order)<
																					element_dimension)
																				{
																					/* first polygon coordinate */
																					order=
																						-4*(inherited_standard_basis_argument[
																							polygon_offset]+element_dimension);
																					reorder_value=reorder_values;
																					for (j=k*(order-1);j>0;j--)
																					{
																						reorder_value[k]=
																							(*reorder_value)+offset;
																						value++;
																						inherited_values[reorder_value[k]]=
																							*value;
																						reorder_value++;
																					}
																					k *= order;
																				}
																			}
																			else
																			{
																				/* not polygon */
																				reorder_value=reorder_values;
																				for (j=k*order;j>0;j--)
																				{
																					reorder_value[k]=
																						(*reorder_value)+offset;
																					value++;
																					inherited_values[reorder_value[k]]=
																						*value;
																					reorder_value++;
																				}
																				k *= (order+1);
																			}
																		}
																		reorder_coordinate++;
																	}
#if defined (DEBUG)
																/*???debug */
																	printf("\n");
																	printf("reorder values :");
																	for (i=0;i<number_of_inherited_values;i++)
																	{
																		printf(" %d",reorder_values[i]);
																	}
																	printf("\n");
#endif /* defined (DEBUG) */
																}
																else
																{
																	display_message(ERROR_MESSAGE,
																		"calculate_FE_element_field_values.  Insufficient memory");
																	DEALLOCATE(reorder_values);
																	DEALLOCATE(inherited_values);
																	return_code=0;
																}
															}
															else
															{
																/* reorder the inherited values */
																reorder_value=reorder_values;
																value= *values_address;
																for (i=number_of_inherited_values;i>0;i--)
																{
																	inherited_values[*reorder_value]= *value;
																	reorder_value++;
																	value++;
																}
															}
															DEALLOCATE(*values_address);
															*values_address=inherited_values;
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"calculate_FE_element_field_values.  Insufficient memory");
															DEALLOCATE(*values_address);
															return_code=0;
														}
													}
													else
													{
														/* allocate memory for the element values */
														if (calculate_derivatives)
														{
															REALLOCATE(inherited_values,*values_address,
																FE_value,(element_dimension+1)*
																number_of_inherited_values);
														}
														else
														{
															REALLOCATE(inherited_values,*values_address,
																FE_value,number_of_inherited_values);
														}
														if (inherited_values)
														{
															*values_address=inherited_values;
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"calculate_FE_element_field_values.  Insufficient memory");
															DEALLOCATE(*values_address);
															return_code=0;
														}
													}
													if (!return_code&&calculate_standard_basis_arguments)
													{
														DEALLOCATE(*standard_basis_arguments_address);
													}
												}
												else
												{
													/*???RC This is the only situation where standard
														basis arguments should not be destroyed, I think */
													element_field_values->destroy_standard_basis_arguments
														=0;
													/*???RC *standard_basis_arguments_address should be
														NULL from calculate_standard_basis_transformation,
														but seems dodgy relying on it */
													*standard_basis_arguments_address=
														(*component)->basis->arguments;
													if (calculate_derivatives)
													{
														if (REALLOCATE(inherited_values,*values_address,
															FE_value,(element_dimension+1)*
															(*number_of_values_address)))
														{
															*values_address=inherited_values;
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"calculate_FE_element_field_values.  Insufficient memory");
															DEALLOCATE(*values_address);
															return_code=0;
														}
													}
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"calculate_FE_element_field_values.  Invalid basis");
												return_code=0;
											}
											if (return_code)
											{
#if defined (DEBUG)
												/*???debug */
												printf("number of values=%d\n",*number_of_values_address);
												printf("inherited values :");
												value= *values_address;
												for (i= *number_of_values_address;i>0;i--)
												{
													printf(" %g",*value);
													value++;
												}
												printf("\n");
												printf("inherited arguments :");
												orders= *standard_basis_arguments_address;
												for (i=element_dimension;i>=0;i--)
												{
													printf(" %d",*orders);
													orders++;
												}
												printf("\n");
#endif /* defined (DEBUG) */
												number_of_values= *number_of_values_address;
												if (calculate_derivatives)
												{
													/* calculate the derivatives with respect to the xi
														 coordinates */
													if (monomial_basis_functions== *standard_basis_address)
													{
														number_of_values= *number_of_values_address;
														value= *values_address;
														derivative_value=value+number_of_values;
														orders= *standard_basis_arguments_address;
														offset=1;
														for (i=element_dimension;i>0;i--)
														{
															orders++;
															order= *orders;
															for (j=0;j<number_of_values;j++)
															{
																/* calculate derivative value */
																power=(j/offset)%(order+1);
																if (order==power)
																{
																	*derivative_value=0;
																}
																else
																{
																	*derivative_value=
																		(FE_value)(power+1)*value[j+offset];
																}
																/* move to the next derivative value */
																derivative_value++;
															}
															offset *= (order+1);
														}
													}
													else
													{
														if (polygon_basis_functions== *standard_basis_address)
														{
															number_of_values= *number_of_values_address;
															value= *values_address;
															derivative_value=value+number_of_values;
															orders= *standard_basis_arguments_address;
															offset=1;
															for (i=element_dimension;i>0;i--)
															{
																orders++;
																order= *orders;
																if (order<0)
																{
																	/* polygon */
																	if ((polygon_offset= -order)<element_dimension)
																	{
																/* calculate derivatives with respect to both
																	 polygon coordinates */
																		second_derivative_value=derivative_value+
																			(polygon_offset*number_of_values);
																		number_of_polygon_verticies=
																			-orders[polygon_offset]-element_dimension;
																		order=4*number_of_polygon_verticies;
																		scalar=(FE_value)number_of_polygon_verticies;
																		for (j=0;j<number_of_values;j++)
																		{
																			/* calculate derivative values */
																			k=(j/offset)%order;
																			switch (k/number_of_polygon_verticies)
																			{
																				case 0:
																				{
																					*derivative_value=scalar*value[j+
																						number_of_polygon_verticies*offset];
																					*second_derivative_value=value[j+
																						2*number_of_polygon_verticies*offset];
																				} break;
																				case 1:
																				{
																					*derivative_value=0;
																					*second_derivative_value=value[j+
																						2*number_of_polygon_verticies*offset];
																				} break;
																				case 2:
																				{
																					*derivative_value=scalar*value[j+
																						number_of_polygon_verticies*offset];
																					*second_derivative_value=0;
																				} break;
																				case 3:
																				{
																					*derivative_value=0;
																					*second_derivative_value=0;
																				} break;
																			}
																			/* move to the next derivative value */
																			derivative_value++;
																			second_derivative_value++;
																		}
																		offset *= order;
																	}
																	else
																	{
																/* second polgon xi.  Derivatives already
																	 calculated */
																		derivative_value += number_of_values;
																	}
																}
																else
																{
																	/* not polygon */
																	for (j=0;j<number_of_values;j++)
																	{
																/* calculate derivative value */
																		power=(j/offset)%(order+1);
																		if (order==power)
																		{
																			*derivative_value=0;
																		}
																		else
																		{
																			*derivative_value=
																				(FE_value)(power+1)*value[j+offset];
																		}
																/* move to the next derivative value */
																		derivative_value++;
																	}
																	offset *= (order+1);
																}
															}
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"calculate_FE_element_field_values.  Invalid basis");
															DEALLOCATE(*values_address);
															if (calculate_standard_basis_arguments)
															{
																DEALLOCATE(*standard_basis_arguments_address);
															}
															return_code=0;
														}
													}
												}
#if defined (DEBUG)
												/*???debug */
												for (i=0;i<3;i++)
												{
													printf("%d :",i);
													for (j=0;j<number_of_values;j++)
													{
														printf(" %g",value[i*number_of_values+j]);
													}
													printf("\n");
												}
#endif /* defined (DEBUG) */
											}
										}
										if (*number_of_values_address>maximum_number_of_values)
										{
											maximum_number_of_values= *number_of_values_address;
										}
										component_number++;
										component++;
										number_of_values_address++;
										values_address++;
										standard_basis_address++;
										standard_basis_arguments_address++;
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"calculate_FE_element_field_values.  Could not calculate values");
										return_code=0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  Cannot mix grid based and non grid based components");
									return_code=0;
								}
							}
							if (return_code)
							{
								if (!((maximum_number_of_values>0)&&(ALLOCATE(element_field_values->
									basis_function_values,FE_value,maximum_number_of_values))))
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  Could not allocate basis_function_values");
									return_code=0;
								}
							}
							if (!return_code)
							{
								/* free the memory that has been allocated */
								while (component_number>0)
								{
									component_number--;
									values_address--;
									standard_basis_arguments_address--;
									DEALLOCATE(*values_address);
									if (coordinate_transformation)
									{
										DEALLOCATE(*standard_basis_arguments_address);
									}
								}
								DEALLOCATE(element_field_values->component_number_of_values);
								DEALLOCATE(element_field_values->component_values);
								DEALLOCATE(
									element_field_values->component_standard_basis_functions);
								DEALLOCATE(element_field_values->
									component_standard_basis_function_arguments);
							}
							DEALLOCATE(reorder_values);
							DEALLOCATE(field_to_element);
							DEALLOCATE(reorder_coordinates);
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"calculate_FE_element_field_values.  Insufficient memory");
							DEALLOCATE(number_of_values_address);
							DEALLOCATE(values_address);
							DEALLOCATE(standard_basis_address);
							DEALLOCATE(standard_basis_arguments_address);
							return_code=0;
						}
						if (blending_matrix)
						{
							DEALLOCATE(blending_matrix);
						}
						if (coordinate_transformation)
						{
							DEALLOCATE(coordinate_transformation);
						}
					}
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_values.  Unknown field type");
					return_code=0;
				} break;
			} /* switch (field->fe_field_type) */
		}
		else
		{
			if (field)
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_values.  %s not defined for (%d)",
					field->name,(element->cm).number);
			}
			else
			{
				display_message(ERROR_MESSAGE,"calculate_FE_element_field_values.  "
					"No coordinate fields defined for (%d)",
					(element->cm).number);
			}
			return_code=0;
#if defined (DEBUG)
			/*???debug*/
			printf("BAD coordinate_transformation=%p\n",coordinate_transformation);
#endif /* defined (DEBUG) */
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_values.  Invalid argument(s)");
		return_code=0;
	}
#if defined (DEBUG)
	/*???debug */
	printf("leave calculate_FE_element_field_values %d\n",return_code);
#endif /* defined (DEBUG) */
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_values */

int FE_element_field_values_are_for_element(
	struct FE_element_field_values *element_field_values,
	struct FE_element *element,struct FE_element *field_element)
/*******************************************************************************
LAST MODIFIED : 1 July 1999

DESCRIPTION :
Returns true if the <element_field_values> originated from <element>, either
directly or inherited from <field_element>. If <field_element> is NULL no match
is required with the field_element in the <element_field_values>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_values_are_for_element);
	if (element_field_values&&element)
	{
		return_code=(element_field_values->element==element)&&
			((!field_element)||(element_field_values->field_element==field_element));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_values_are_for_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_values_are_for_element */

int clear_FE_element_field_values(
	struct FE_element_field_values *element_field_values)
/*******************************************************************************
LAST MODIFIED : 21 October 1999

DESCRIPTION :
Frees the memory for the fields of the <element_field_values> structure.
==============================================================================*/
{
	FE_value **component_values;
	int i,return_code;
	void **component_standard_basis_function_arguments;

	ENTER(clear_FE_element_field_values);
	if (element_field_values)
	{
		DEACCESS(FE_field)(&(element_field_values->field));
		DEACCESS(FE_element)(&(element_field_values->element));
		DEACCESS(FE_element)(&(element_field_values->field_element));
		if (element_field_values->number_in_xi)
		{
			DEALLOCATE(element_field_values->number_in_xi);
		}
		if (element_field_values->component_number_of_values)
		{
			DEALLOCATE(element_field_values->component_number_of_values);
		}
		if (element_field_values->component_grid_values_storage)
		{
			DEALLOCATE(element_field_values->component_grid_values_storage);
		}
		if (element_field_values->grid_offset_in_xi)
		{
			DEALLOCATE(element_field_values->grid_offset_in_xi);
		}
		if (element_field_values->element_value_offsets)
		{
			DEALLOCATE(element_field_values->element_value_offsets);
		}
		if (element_field_values->component_values)
		{
			component_values=element_field_values->component_values;
			for (i=element_field_values->number_of_components;i>0;i--)
			{
				DEALLOCATE(*component_values);
				component_values++;
			}
			DEALLOCATE(element_field_values->component_values);
		}
		if (element_field_values->component_standard_basis_function_arguments)
		{
			if (element_field_values->destroy_standard_basis_arguments)
			{
				component_standard_basis_function_arguments=
					(void **)(element_field_values->
					component_standard_basis_function_arguments);
				for (i=element_field_values->number_of_components;i>0;i--)
				{
					if (*component_standard_basis_function_arguments&&(1==i)||
						(*component_standard_basis_function_arguments!=
							component_standard_basis_function_arguments[1]))
					{
						DEALLOCATE(*component_standard_basis_function_arguments);
					}
					component_standard_basis_function_arguments++;
				}
			}
			DEALLOCATE(element_field_values->
				component_standard_basis_function_arguments);
		}
		if (element_field_values->component_standard_basis_functions)
		{
			DEALLOCATE(element_field_values->component_standard_basis_functions);
		}
		if (element_field_values->basis_function_values)
		{
			DEALLOCATE(element_field_values->basis_function_values);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"clear_FE_element_field_values.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* clear_FE_element_field_values */

int calculate_FE_element_field_nodes(struct FE_element *element,
	struct FE_field *field,struct LIST(FE_node) *element_field_nodes)
/*******************************************************************************
LAST MODIFIED : 15 February 1999

DESCRIPTION :
If <field> is NULL, element nodes are calculated for the coordinate field.  The
function adds the nodes to the list <element_field_nodes>.  Components that are
not node-based are ignored.
???DB.  I think that the field=NULL special case should be removed.
???DB.  Based on calculate_FE_element_field_values
==============================================================================*/
{
	double sum;
	FE_value *blending_matrix,*combined_blending_matrix,
		*coordinate_transformation,*row,*column,*transformation;
	int add,component_number,element_dimension,
		*field_to_element,i,*inherited_basis_arguments,j,k,number_of_components,
		number_of_element_values,number_of_inherited_values,
		number_of_standard_basis_functions,previous_number_of_element_values,
		*reorder_coordinates,*reorder_values,return_code;
	struct FE_basis *basis,*previous_basis;
	struct FE_element *field_element;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component,**component_address;
	struct FE_node **element_value,**element_values,**previous_element_values;

	ENTER(calculate_FE_element_field_nodes);
	/*???debug */
	/*printf("enter calculate_FE_element_field_nodes\n");*/
	/* check the arguments */
	if (element&&(element->shape)&&element_field_nodes)
	{
		/* retrieve the element field from which this element inherits the field
			 and calculate the affine transformation from the element xi coordinates
			 to the xi coordinates for the element field */
		coordinate_transformation=(FE_value *)NULL;
		if (inherit_FE_element_field(element,field,&element_field,&field_element,
			&coordinate_transformation,(struct FE_element *)NULL)&&element_field)
		{
			return_code=1;
			element_dimension=element->shape->dimension;		
			number_of_components=element_field->field->number_of_components;
			/* for each component */
			component_address=element_field->components;
			previous_basis=(struct FE_basis *)NULL;
			previous_number_of_element_values= -1;
			previous_element_values=(struct FE_node **)NULL;
			reorder_values=(int *)NULL;
			field_to_element=(int *)NULL;
			reorder_coordinates=(int *)NULL;
			component_number=0;
			while (return_code&&(component_number<number_of_components))
			{
				component= *component_address;
				if ((STANDARD_NODE_TO_ELEMENT_MAP==component->type)||
					(GENERAL_NODE_TO_ELEMENT_MAP==component->type))
				{
					/* calculate the nodes used by the component in the field_element */
					if (global_to_element_map_nodes(component,field_element,
						element_field->field,&number_of_element_values,&element_values))
					{
						/* check that there is a valid basis */
						if ((basis=component->basis)&&
							(number_of_element_values==basis->number_of_basis_functions)&&
							(basis->standard_basis)&&((number_of_standard_basis_functions=
								basis->number_of_standard_basis_functions)>0))
						{
							if ((i=number_of_element_values)==
								previous_number_of_element_values)
							{
								i--;
								while ((i>=0)&&(element_values[i]==previous_element_values[i]))
								{
									i--;
								}
							}
							if ((i>=0)||(basis!=previous_basis))
							{
								DEALLOCATE(previous_element_values);
								previous_element_values=element_values;
								previous_number_of_element_values=number_of_element_values;
								previous_basis=basis;
								if (calculate_standard_basis_transformation(basis,
									coordinate_transformation,element_dimension,
									&inherited_basis_arguments,&number_of_inherited_values,
									&blending_matrix,&field_to_element,&reorder_coordinates))
								{
									/* project the element values onto the element using the
										 affine transformation */
									/*???DB.  Projection is dependent on standard basis */
									if (monomial_basis_functions==basis->standard_basis)
									{
										if (basis->blending_matrix)
										{
											if (ALLOCATE(combined_blending_matrix,FE_value,
												number_of_element_values*number_of_inherited_values))
											{
												transformation=combined_blending_matrix;
												for (i=0;i<number_of_element_values;i++)
												{
													for (j=0;j<number_of_inherited_values;j++)
													{
														sum=0;
														row=(basis->blending_matrix)+
															(i*number_of_standard_basis_functions);
														column=blending_matrix+j;
														for (k=number_of_standard_basis_functions;k>0;k--)
														{
															sum += (double)(*row)*(double)(*column);
															row++;
															column += number_of_inherited_values;
														}
														*transformation=(FE_value)sum;
														transformation++;
													}
												}
												DEALLOCATE(blending_matrix);
												blending_matrix=combined_blending_matrix;
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"calculate_FE_element_field_nodes.  Could not allocate combined_blending_matrix"
																				);
												return_code=0;
											}
										}
										if (return_code)
										{
											transformation=blending_matrix;
											element_value=element_values;
											i=number_of_element_values;
											while (return_code&&(i>0))
											{
												add=0;
												j=number_of_inherited_values;
												while (!add&&(j>0))
												{
													if (1.e-8<fabs(*transformation))
													{
														add=1;
													}
													transformation++;
													j--;
												}
												transformation += j;
												if (add)
												{
													if (!IS_OBJECT_IN_LIST(FE_node)(*element_value,
														element_field_nodes))
													{
														return_code=ADD_OBJECT_TO_LIST(FE_node)(
															*element_value,element_field_nodes);
													}
												}
												element_value++;
												i--;
											}
										}
										DEALLOCATE(blending_matrix);
									}
									else
									{
										if (polygon_basis_functions==basis->standard_basis)
										{
											/*???debug */
											display_message(ERROR_MESSAGE,
												"calculate_FE_element_field_nodes.  Not yet implemented for polygon_basis_functions");
											return_code=0;
#if defined (TO_BE_DONE)
											if (coordinate_transformation)
											{
												number_of_inherited_values=1;
												standard_basis_arguments=
													(int *)((*component)->basis->arguments);
												standard_basis_argument=standard_basis_arguments;
												number_of_values= *number_of_values_address;
												offset=1;
												transformation=coordinate_transformation;
												for (i=0;i<field_element_dimension;i++)
												{
													standard_basis_argument++;
													order= *standard_basis_argument;
													if (order<0)
													{
														/* polygon */
														if ((polygon_offset= -order)<
															field_element_dimension)
														{
															/* first polygon component */
															number_of_polygon_verticies=
																-standard_basis_argument[polygon_offset]-
																field_element_dimension;
															if (field_to_element[i])
															{
																if (field_to_element[i+polygon_offset])
																{
																	/* polygon is in projection */
																	*standard_basis_address=
																		polygon_basis_functions;
																	number_of_inherited_values *=
																		4*number_of_polygon_verticies;
																}
																else
																{
																	/* edge of polygon in projection */
																	polygon_vertex=
																		(int)(0.1+(*transformation)*(FE_value)
																			number_of_polygon_verticies);
																	value= *values_address;
																	inherited_value=value;
																	if (number_of_polygon_verticies-1==
																		polygon_vertex)
																	{
																		for (j=number_of_values/
																					 (4*number_of_polygon_verticies*
																						 number_of_inherited_values);j>0;j--)
																		{
																			for (k=number_of_inherited_values;
																					 k>0;k--)
																			{
																				scalar=value[polygon_vertex*
																					number_of_inherited_values]+
																					value[(polygon_vertex+
																						2*number_of_polygon_verticies)*
																						number_of_inherited_values];
																				inherited_value[
																					number_of_inherited_values]=
																					(*value)+value[2*
																						number_of_polygon_verticies*
																						number_of_inherited_values]-
																					scalar;
																				*inherited_value=scalar;
																				inherited_value++;
																				value++;
																			}
																			inherited_value +=
																				number_of_inherited_values;
																			value +=
																				(4*number_of_polygon_verticies-1)*
																				number_of_inherited_values;
																		}
																	}
																	else
																	{
																		if (number_of_polygon_verticies==
																			polygon_vertex)
																		{
																			polygon_vertex=0;
																		}
																		value += polygon_vertex*
																			number_of_inherited_values;
																		for (j=number_of_values/
																					 (4*number_of_polygon_verticies*
																						 number_of_inherited_values);j>0;j--)
																		{
																			for (k=number_of_inherited_values;
																					 k>0;k--)
																			{
																				*inherited_value= (*value)+value[
																					2*number_of_polygon_verticies*
																					number_of_inherited_values];
																				inherited_value[
																					number_of_inherited_values]=
																					value[
																						number_of_inherited_values]+
																					value[(2*
																						number_of_polygon_verticies+1)*
																						number_of_inherited_values]-
																					*inherited_value;
																				inherited_value++;
																				value++;
																			}
																			inherited_value +=
																				number_of_inherited_values;
																			value +=
																				(4*number_of_polygon_verticies-1)*
																				number_of_inherited_values;
																		}
																	}
																	number_of_values /=
																		4*number_of_polygon_verticies;
																	number_of_values *= 2;
																	number_of_inherited_values *= 2;
																}
															}
															else
															{
																/* polygon is not in projection */
																polygon_vertex=
																	(int)(0.1+(*transformation)*
																		(FE_value)number_of_polygon_verticies);
																if (number_of_polygon_verticies==
																	polygon_vertex)
																{
																	polygon_vertex=0;
																}
																value= *values_address;
																inherited_value=value;
																value += polygon_vertex*
																	number_of_inherited_values;
																for (j=number_of_values/
																			 (4*number_of_polygon_verticies*
																				 number_of_inherited_values);j>0;j--)
																{
																	for (k=number_of_inherited_values;k>0;
																			 k--)
																	{
																		*inherited_value= *value+
																			value[2*number_of_polygon_verticies*
																				number_of_inherited_values];
																		inherited_value++;
																		value++;
																	}
																	value +=
																		(4*number_of_polygon_verticies-1)*
																		number_of_inherited_values;
																}
																number_of_values /=
																	4*number_of_polygon_verticies;
															}
														}
													}
													else
													{
														/* not polygon */
														if (field_to_element[i])
														{
															/* in projection */
															number_of_inherited_values *= order+1;
														}
														else
														{
															/* not in projection */
															if (*transformation)
															{
																/* assume *transformation (b) is 1 */
																value= *values_address;
																inherited_value=value;
																for (j=number_of_values/((order+1)*
																	number_of_inherited_values);j>0;j--)
																{
																	for (k=number_of_inherited_values;k>0;
																			 k--)
																	{
																		sum= *value;
																		sumand=value;
																		for (l=order;l>0;l--)
																		{
																			sumand +=
																				number_of_inherited_values;
																			sum += *sumand;
																		}
																		*inherited_value=sum;
																		inherited_value++;
																		value++;
																	}
																	value=sumand+1;
																}
																number_of_values /= order+1;
															}
															else
															{
																/* *transformation (b) is 0 */
																value= *values_address;
																inherited_value=value;
																for (j=number_of_values/((order+1)*
																	number_of_inherited_values);j>0;j--)
																{
																	for (k=number_of_inherited_values;k>0;
																			 k--)
																	{
																		*inherited_value= *value;
																		inherited_value++;
																		value++;
																	}
																	value +=
																		order*number_of_inherited_values;
																}
																number_of_values /= order+1;
															} break;
														}
													}
													transformation += element_dimension+1;
												}
												*number_of_values_address=
													number_of_inherited_values;
												/* fill in the element values */
												if (reorder_coordinates)
												{
													/* allocate memory for the element values */
													if (calculate_derivatives)
													{
														ALLOCATE(inherited_values,FE_value,
															(element_dimension+1)*
															number_of_inherited_values);
													}
													else
													{
														ALLOCATE(inherited_values,FE_value,
															number_of_inherited_values);
													}
													if (inherited_values)
													{
														/* reorder values */
														if (calculate_standard_basis_arguments)
														{
															DEALLOCATE(reorder_values);
															if (ALLOCATE(reorder_values,int,
																number_of_inherited_values))
															{
																reorder_value=reorder_values;
																*reorder_value=0;
																value= *values_address;
																*inherited_values= *value;
																k=1;
																reorder_coordinate=reorder_coordinates;
																orders=inherited_standard_basis_arguments;
																for (i=element_dimension;i>0;i--)
																{
																	orders++;
																	order= *orders;
																	if (order> -element_dimension)
																	{
																		/* not polygon second coordinate */
																		offset=1;
																		inherited_standard_basis_argument=
																			inherited_standard_basis_arguments+
																			1;
																		for (j=(*reorder_coordinate);j>0;j--)
																		{
																			polygon_offset=
																				*inherited_standard_basis_argument;
																			if (polygon_offset<0)
																			{
																				polygon_offset= -polygon_offset;
																				if (polygon_offset<
																					element_dimension)
																				{
																					offset *= -4*
																						(inherited_standard_basis_argument[
																							polygon_offset]+
																							element_dimension);
																				}
																			}
																			else
																			{
																				offset *= polygon_offset+1;
																			}
																			inherited_standard_basis_argument++;
																		}
																		order=
																			*inherited_standard_basis_argument;
																		if (order<0)
																		{
																			/* polygon */
																			if ((polygon_offset= -order)<
																				element_dimension)
																			{
																				/* first polygon coordinate */
																				order=
																					-4*(inherited_standard_basis_argument[
																						polygon_offset]+
																						element_dimension);
																				reorder_value=reorder_values;
																				for (j=k*(order-1);j>0;j--)
																				{
																					reorder_value[k]=
																						(*reorder_value)+offset;
																					value++;
																					inherited_values[reorder_value[
																						k]]= *value;
																					reorder_value++;
																				}
																				k *= order;
																			}
																		}
																		else
																		{
																			/* not polygon */
																			reorder_value=reorder_values;
																			for (j=k*order;j>0;j--)
																			{
																				reorder_value[k]=
																					(*reorder_value)+offset;
																				value++;
																				inherited_values[reorder_value[
																					k]]= *value;
																				reorder_value++;
																			}
																			k *= (order+1);
																		}
																	}
																	reorder_coordinate++;
																}
																*standard_basis_arguments_address=(void *)
																	inherited_standard_basis_arguments;
															}
															else
															{
																display_message(ERROR_MESSAGE,
																	"calculate_FE_element_field_nodes.  Insufficient memory");
																DEALLOCATE(reorder_values);
																DEALLOCATE(inherited_values);
																return_code=0;
															}
														}
														else
														{
															/* reorder the inherited values */
															reorder_value=reorder_values;
															value= *values_address;
															for (i=number_of_inherited_values;i>0;i--)
															{
																inherited_values[*reorder_value]= *value;
																reorder_value++;
																value++;
															}
														}
														DEALLOCATE(*values_address);
														*values_address=inherited_values;
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"calculate_FE_element_field_nodes.  Insufficient memory");
														DEALLOCATE(*values_address);
														return_code=0;
													}
												}
												else
												{
													/* allocate memory for the element values */
													if (calculate_derivatives)
													{
														REALLOCATE(inherited_values,*values_address,
															FE_value,(element_dimension+1)*
															number_of_inherited_values);
													}
													else
													{
														REALLOCATE(inherited_values,*values_address,
															FE_value,number_of_inherited_values);
													}
													if (inherited_values)
													{
														*values_address=inherited_values;
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"calculate_FE_element_field_nodes.  Insufficient memory");
														DEALLOCATE(*values_address);
														return_code=0;
													}
												}
												if (!return_code&&
													calculate_standard_basis_arguments)
												{
													DEALLOCATE(*standard_basis_arguments_address);
												}
											}
											else
											{
												*standard_basis_arguments_address=
													(*component)->basis->arguments;
												if (calculate_derivatives)
												{
													if (REALLOCATE(inherited_values,*values_address,
														FE_value,(element_dimension+1)*
														(*number_of_values_address)))
													{
														*values_address=inherited_values;
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"calculate_FE_element_field_nodes.  Insufficient memory");
														DEALLOCATE(*values_address);
														return_code=0;
													}
												}
											}
#endif /* defined (TO_BE_DONE) */
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"calculate_FE_element_field_nodes.  Invalid basis");
											return_code=0;
										}
									}
									DEALLOCATE(inherited_basis_arguments);
								}
								else
								{
									return_code=0;
								}
							}
							else
							{
								DEALLOCATE(element_values);
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"calculate_FE_element_field_nodes.  Invalid basis");
							DEALLOCATE(element_values);
							return_code=0;
						}
					}
				}
				component_number++;
				component_address++;
			}
			DEALLOCATE(previous_element_values);
			DEALLOCATE(reorder_values);
			DEALLOCATE(field_to_element);
			DEALLOCATE(reorder_coordinates);
		}
		else
		{
			if (field)
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_nodes.  %s not defined for (%d )",
					field->name,(element->cm).number);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_nodes.  No coordinate fields defined for (%d )",
					(element->cm).number);
			}
			return_code=0;
		}
		DEALLOCATE(coordinate_transformation);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_nodes.  Invalid argument(s)");
		return_code=0;
	}
	/*???debug */
	/*printf("leave calculate_FE_element_field_nodes %d\n",return_code);*/
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_nodes */

int calculate_FE_element_field(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	FE_value *values,FE_value *jacobian)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Calculates the <values> of the field specified by the <element_field_values> at
the <xi_coordinates>.  The storage for the <values> should have been allocated
outside the function.  The <jacobian> will be calculated if it is not NULL (and
the derivatives values have been calculated).  Only the <component_number>+1
component will be calculated if 0<=component_number<number of components.  For a
single component, the value will be put in the first position of <values> and
the derivatives will start at the first position of <jacobian>.
==============================================================================*/
{
	int comp_no,*component_number_of_values,components_to_calculate,
		*element_value_offset,*element_value_offsets,i,j,k,l,m,*number_in_xi,
		number_of_values,number_of_xi_coordinates,offset,return_code,size,xi_offset;
	FE_value *basis_function_values,*basis_value,*calculated_value,
		**component_values,*derivative,*element_value,sum,temp,xi_coordinate;
	Standard_basis_function *current_standard_basis_function,
		**component_standard_basis_function;
	struct FE_field *field;
	void **component_standard_basis_function_arguments,
		**current_standard_basis_function_arguments;
	Value_storage **component_grid_values_storage,*element_values_storage;

	ENTER(calculate_FE_element_field);
	return_code=0;
	if (element_field_values&&xi_coordinates&&values&&
		(!jacobian||(jacobian&&(element_field_values->derivatives_calculated)))&&
		(field=element_field_values->field)&&(FE_VALUE_VALUE==field->value_type)&&
		((GENERAL_FE_FIELD != field->fe_field_type)||
			(basis_function_values=element_field_values->basis_function_values)))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			comp_no=component_number;
			components_to_calculate=1;
		}
		else
		{
			comp_no=0;
			components_to_calculate=field->number_of_components;
		}
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				return_code=1;
				for (i=0;(i<components_to_calculate)&&return_code;i++)
				{
					if (!get_FE_field_FE_value_value(field,comp_no,&values[i]))
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field.  "
							"Could not get values for constant field %s",field->name);
						return_code=0;
					}
					comp_no++;
				}
				if (jacobian)
				{
					/* derivatives are zero for constant fields */
					derivative=jacobian;
					for (i=(field->number_of_components)*
						element_field_values->element->shape->dimension;0<i;i--)
					{
						*derivative = 0.0;
						derivative++;
					}
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index,value_no;

				REACCESS(FE_field)(&(element_field_values->field),field->indexer_field);
				if (calculate_FE_element_field_int_values(/*component_number*/0,
					element_field_values,xi_coordinates,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						return_code=1;
						value_no = index-1 + comp_no*field->number_of_indexed_values;
						for (i=0;(i<components_to_calculate)&&return_code;i++)
						{
							if (!get_FE_field_FE_value_value(field,value_no,&values[i]))
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field.  "
									"Could not get values for constant field %s",field->name);
								return_code=0;
							}
							value_no += field->number_of_indexed_values;
						}
						if (jacobian)
						{
							/* derivatives are zero for indexed fields */
							derivative=jacobian;
							for (i=(field->number_of_components)*
								element_field_values->element->shape->dimension;0<i;i--)
							{
								*derivative = 0.0;
								derivative++;
							}
						}
					}
					else
					{	
						display_message(ERROR_MESSAGE,"calculate_FE_element_field.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"calculate_FE_element_field.  "
						"Could not calculate index field %s for field %s at %s %",
						field->indexer_field->name,field->name,
						CM_element_type_string(element_field_values->element->cm.type),
						element_field_values->element->cm.number);
				}
				REACCESS(FE_field)(&(element_field_values->field),field);
			} break;
			case GENERAL_FE_FIELD:
			{
				if (number_in_xi=element_field_values->number_in_xi)
				{
					/* grid based */
					number_of_xi_coordinates=
						element_field_values->element->shape->dimension;
					number_of_values=1;
					for (i=number_of_xi_coordinates;i>0;i--)
					{
						number_of_values *= 2;
					}
					/* element_value_offsets now pre-allocated for <number_of_values>
						 ints in calculate_FE_element_field_values */
					if ((element_value_offsets=
						element_field_values->element_value_offsets)&&
						element_field_values->grid_offset_in_xi)
					{
						return_code=1;
						i=0;
						offset=element_field_values->base_grid_offset;
						*basis_function_values=1;
						*element_value_offsets=0;
						m=1;
						while (return_code&&(i<number_of_xi_coordinates))
						{
							xi_coordinate=xi_coordinates[i];
							if ((0<=xi_coordinate)&&(xi_coordinate<=1))
							{
								/* get xi_offset = lower grid number for cell in xi_coordinate
									 i, and xi_coordinate = fractional xi value in grid cell */
								if (1==xi_coordinate)
								{
									xi_offset=number_in_xi[i]-1;
								}
								else
								{
									xi_coordinate *= (FE_value)(number_in_xi[i]);
									xi_offset=(int)floor((double)xi_coordinate);
									xi_coordinate -= (FE_value)xi_offset;
								}
								offset += xi_offset*element_field_values->grid_offset_in_xi[i];
								/* add grid_offset in xi_coordinate i for neighbouring grid
									 points around the linear cell */
								element_value_offset=element_value_offsets;
								for (l=m;l>0;l--)
								{
									element_value_offset[m]=(*element_value_offset)+
										element_field_values->grid_offset_in_xi[i];
									element_value_offset++;
								}
								temp=1-xi_coordinate;
								basis_value=basis_function_values;
								if (jacobian)
								{
									for (j=1;j<=i;j++)
									{
										basis_value=basis_function_values+(j*number_of_values+m);
										for (l=m;l>0;l--)
										{
											basis_value--;
											basis_value[m]=(*basis_value)*xi_coordinate;
											*basis_value *= temp;
										}
									}
									j=(i+1)*number_of_values;
									basis_value=basis_function_values+m;
									for (l=m;l>0;l--)
									{
										basis_value--;
										basis_value[j]= -(*basis_value);
										basis_value[j+m]= *basis_value;
									}
								}
								basis_value=basis_function_values+m;
								for (l=m;l>0;l--)
								{
									basis_value--;
									basis_value[m]=(*basis_value)*xi_coordinate;
									*basis_value *= temp;
								}
								m *= 2;
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field.  Xi must be from 0 to 1");
								return_code=0;
							}
							i++;
						}
						if (return_code)
						{
							size=get_Value_storage_size(field->value_type);
							component_grid_values_storage=
								element_field_values->component_grid_values_storage;
							calculated_value=values;
							derivative=jacobian;
							component_grid_values_storage += comp_no;
							for (i=0;i<components_to_calculate;i++)
							{
								element_values_storage=
									(*component_grid_values_storage)+size*offset;
								basis_value=basis_function_values;
								sum=0;
								element_value_offset=element_value_offsets;
								for (j=number_of_values;j>0;j--)
								{
									sum += (*basis_value)*(*((FE_value *)(
										element_values_storage + size*(*element_value_offset))));
									element_value_offset++;
									basis_value++;
								}
								*calculated_value=sum;
								if (jacobian)
								{
									for (k=number_of_xi_coordinates;k>0;k--)
									{
										sum=0;
										element_value_offset=element_value_offsets;
										for (j=number_of_values;j>0;j--)
										{
											sum += (*basis_value)*
												element_values_storage[size*(*element_value_offset)];
											element_value_offset++;
											basis_value++;
										}
										*derivative=sum;
										derivative++;
									}
								}
								calculated_value++;
								component_grid_values_storage++;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field.  Missing element_value_offsets");
					}
				}
				else
				{
					/* not grid based */
					/* calculate the value for the element field */
					return_code=1;
					/* calculate a value for each component */
					current_standard_basis_function=(Standard_basis_function *)NULL;
					current_standard_basis_function_arguments=(void *)NULL;
					component_number_of_values=
						element_field_values->component_number_of_values;
					component_values=element_field_values->component_values;
					component_standard_basis_function=
						element_field_values->component_standard_basis_functions;
					component_standard_basis_function_arguments=
						element_field_values->component_standard_basis_function_arguments;
					calculated_value=values;
					if (element_field_values->derivatives_calculated)
					{
						derivative=jacobian;
					}
					else
					{
						derivative=(FE_value *)NULL;
					}
					component_number_of_values += comp_no;
					component_values += comp_no;
					component_standard_basis_function += comp_no;
					component_standard_basis_function_arguments += comp_no;
					number_of_xi_coordinates=
						element_field_values->element->shape->dimension;
					for (i=0;(i<components_to_calculate)&&return_code;i++)
					{
						/* save calculation when all components use the same basis */
						/*???DB.  Only good when consecutive components have the same basis.
							Can do better ? */
						if ((*component_standard_basis_function!=
							current_standard_basis_function)||
							(*component_standard_basis_function_arguments!=
								current_standard_basis_function_arguments))
						{
							current_standard_basis_function=
								*component_standard_basis_function;
							current_standard_basis_function_arguments=
								*component_standard_basis_function_arguments;
							number_of_values= *component_number_of_values;
							/* calculate the values for the standard basis functions */
							if (!(current_standard_basis_function)(
								current_standard_basis_function_arguments,xi_coordinates,
								basis_function_values))
							{
								display_message(ERROR_MESSAGE,"calculate_FE_element_field.  "
									"Error calculating standard basis");
								return_code=0;
							}
						}
						/* calculate the element field value as a dot product of the element
							 values and the basis function values */
						basis_value=basis_function_values;
						element_value= *component_values;
						*calculated_value=0;
						for (j=number_of_values;j>0;j--)
						{
							*calculated_value += (*element_value)*(*basis_value);
							basis_value++;
							element_value++;
						}
						if (derivative)
						{
							for (k=number_of_xi_coordinates;k>0;k--)
							{
								*derivative=0;
								basis_value=basis_function_values;
								for (j=number_of_values;j>0;j--)
								{
									*derivative += (*element_value)*(*basis_value);
									basis_value++;
									element_value++;
								}
								derivative++;
							}
						}
						component_number_of_values++;
						component_values++;
						component_standard_basis_function++;
						component_standard_basis_function_arguments++;
						calculated_value++;
					}
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field.  Unknown field type");
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field.  Invalid argument(s)\n"
			"element_field_values %p, xi_coordinates %p, values %p, jacobian %p",
			element_field_values,xi_coordinates,values,jacobian);
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field */

int calculate_FE_element_field_as_string(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	char **string)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Calculates the values of element field specified by the <element_field_values>
at the <xi_coordinates> and returns them as the allocated <string>. Only the
<component_number>+1 component will be calculated if
0<=component_number<number of components. If more than 1 component is calculated
then values are comma separated. Derivatives are not included in the string,
even if calculated for the <element_field_values>.
It is up to the calling function to DEALLOCATE the returned string.
==============================================================================*/
{
	char temp_string[40];
	int components_to_calculate,error,i,return_code;
	struct FE_field *field;

	ENTER(calculate_FE_element_field_as_string);
	return_code=0;
	(*string)=(char *)NULL;
	if (element_field_values&&xi_coordinates&&string&&
		(field=element_field_values->field))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			components_to_calculate=1;
		}
		else
		{
			components_to_calculate=field->number_of_components;
		}
		switch (field->value_type)
		{
			case FE_VALUE_VALUE:
			{
				FE_value *values;

				if (ALLOCATE(values,FE_value,components_to_calculate))
				{
					if (calculate_FE_element_field(component_number,
						element_field_values,xi_coordinates,values,
						/*jacobian*/(FE_value *)NULL))
					{
						error=0;
						for (i=0;i<components_to_calculate;i++)
						{
							if (0<i)
							{
								sprintf(temp_string,",%g",values[i]);
							}
							else
							{
								sprintf(temp_string,"%g",values[i]);
							}
							append_string(string,temp_string,&error);
						}
						return_code= !error;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_as_string.  "
							"Could not calculate FE_value values");
					}
					DEALLOCATE(values);
				}
			} break;
			case INT_VALUE:
			{
				int *values;

				if (ALLOCATE(values,int,components_to_calculate))
				{
					if (calculate_FE_element_field_int_values(component_number,
						element_field_values,xi_coordinates,values))
					{
						error=0;
						for (i=0;i<components_to_calculate;i++)
						{
							if (0<i)
							{
								sprintf(temp_string,",%d",values[i]);
							}
							else
							{
								sprintf(temp_string,"%d",values[i]);
							}
							append_string(string,temp_string,&error);
						}
						return_code= !error;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_as_string.  "
							"Could not calculate int values");
					}
					DEALLOCATE(values);
				}
			} break;
			case STRING_VALUE:
			{
				char **values;

				if (ALLOCATE(values,char *,components_to_calculate))
				{
					if (calculate_FE_element_field_string_values(component_number,
						element_field_values,xi_coordinates,values))
					{
						error=0;
						for (i=0;i<components_to_calculate;i++)
						{
							if (0<i)
							{
								append_string(string,",",&error);
							}
							append_string(string,values[i],&error);
						}
						for (i=0;i<components_to_calculate;i++)
						{
							DEALLOCATE(values[i]);
						}
						return_code= !error;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_as_string.  "
							"Could not calculate string values");
					}
					DEALLOCATE(values);
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_as_string.  Unknown value type %s",
					Value_type_string(field->value_type));
			} break;
		}
		if (!return_code)
		{
			display_message(ERROR_MESSAGE,
				"calculate_FE_element_field_as_string.  Failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_as_string.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_as_string */

int calculate_FE_element_field_int_values(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	int *values)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Calculates the <values> of the integer field specified by the
<element_field_values> at the <xi_coordinates>. The storage for the <values>
should have been allocated outside the function. Only the <component_number>+1
component will be calculated if 0<=component_number<number of components. For a
single component, the value will be put in the first position of <values>.
==============================================================================*/
{
	int comp_no,components_to_calculate,i,*number_in_xi,number_of_xi_coordinates,
		offset,return_code,size,xi_offset;
	int *calculated_value;
	FE_value xi_coordinate;
	struct FE_field *field;
	Value_storage **component_grid_values_storage,*element_values_storage;

	ENTER(calculate_FE_element_field_int_values);
	return_code=0;
	if (element_field_values&&xi_coordinates&&values&&
		(field=element_field_values->field)&&(INT_VALUE==field->value_type))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			comp_no=component_number;
			components_to_calculate=1;
		}
		else
		{
			comp_no=0;
			components_to_calculate=field->number_of_components;
		}
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				return_code=1;
				for (i=0;(i<components_to_calculate)&&return_code;i++)
				{
					if (!get_FE_field_int_value(field,comp_no,&values[i]))
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_int_values.  "
							"Could not get values for constant field %s",field->name);
						return_code=0;
					}
					comp_no++;
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index,value_no;

				REACCESS(FE_field)(&(element_field_values->field),field->indexer_field);
				if (calculate_FE_element_field_int_values(/*component_number*/0,
					element_field_values,xi_coordinates,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						return_code=1;
						value_no = index-1 + comp_no*field->number_of_indexed_values;
						for (i=0;(i<components_to_calculate)&&return_code;i++)
						{
							if (!get_FE_field_int_value(field,value_no,&values[i]))
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_int_values.  "
									"Could not get values for constant field %s",field->name);
								return_code=0;
							}
							value_no += field->number_of_indexed_values;
						}
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_int_values.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_int_values.  "
						"Could not calculate index field %s for field %s at %s %",
						field->indexer_field->name,field->name,
						CM_element_type_string(element_field_values->element->cm.type),
						element_field_values->element->cm.number);
				}
				REACCESS(FE_field)(&(element_field_values->field),field);
			} break;
			case GENERAL_FE_FIELD:
			{
				if (number_in_xi=element_field_values->number_in_xi)
				{
					/* grid based - get nearest value for INT_VALUE */
					number_of_xi_coordinates=
						element_field_values->element->shape->dimension;
					if (element_field_values->grid_offset_in_xi)
					{
						return_code=1;
						offset=element_field_values->base_grid_offset;
						for (i=0;(i<number_of_xi_coordinates)&&return_code;i++)
						{
							xi_coordinate=xi_coordinates[i];
							if ((0<=xi_coordinate)&&(xi_coordinate<=1))
							{
								/* get nearest xi_offset */
								xi_offset=(int)floor(
									(double)number_in_xi[i]*(double)xi_coordinate+0.5);
								offset += xi_offset*element_field_values->grid_offset_in_xi[i];
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_int_values.  "
									"Xi must be from 0 to 1");
								return_code=0;
							}
						}
						if (return_code)
						{
							size=get_Value_storage_size(field->value_type);
							component_grid_values_storage=
								element_field_values->component_grid_values_storage;
							calculated_value=values;
							component_grid_values_storage += comp_no;
							for (i=0;i<components_to_calculate;i++)
							{
								element_values_storage=
									(*component_grid_values_storage)+size*offset;
								*calculated_value = *((int *)element_values_storage);
								calculated_value++;
								component_grid_values_storage++;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_int_values.  "
							"Missing grid_offset_in_xi");
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_int_values.  "
						"Integers only supported for grid-based fields");
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_int_values.  Unknown field type");
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_int_values.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_int_values */

int calculate_FE_element_field_string_values(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	char **values)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Returns allocated copies of the string values of the field specified by the
<element_field_values> at the <xi_coordinates>. <values> must be allocated with
enough space for the number_of_components strings, but the strings themselves
are allocated here. Only the <component_number>+1 component will be calculated
if 0<=component_number<number of components. For a single component, the value
will be put in the first position of <values>.
It is up to the calling function to deallocate the returned string values.
==============================================================================*/
{
	int comp_no,components_to_calculate,i,j,return_code;
	struct FE_field *field;

	ENTER(calculate_FE_element_field_string_values);
	return_code=0;
	if (element_field_values&&xi_coordinates&&values&&
		(field=element_field_values->field)&&(STRING_VALUE==field->value_type))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			comp_no=component_number;
			components_to_calculate=1;
		}
		else
		{
			comp_no=0;
			components_to_calculate=field->number_of_components;
		}
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				return_code=1;
				for (i=0;(i<components_to_calculate)&&return_code;i++)
				{
					if (!get_FE_field_string_value(field,comp_no,&values[i]))
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_string_values.  "
							"Could not get values for constant field %s",field->name);
						return_code=0;
						for (j=0;j<i;j++)
						{
							DEALLOCATE(values[j]);
						}
					}
					comp_no++;
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index,value_no;

				REACCESS(FE_field)(&(element_field_values->field),field->indexer_field);
				if (calculate_FE_element_field_int_values(/*component_number*/0,
					element_field_values,xi_coordinates,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						return_code=1;
						value_no = index-1 + comp_no*field->number_of_indexed_values;
						for (i=0;(i<components_to_calculate)&&return_code;i++)
						{
							if (!get_FE_field_string_value(field,value_no,&values[i]))
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_string_values.  "
									"Could not get values for constant field %s",field->name);
								return_code=0;
								for (j=0;j<i;j++)
								{
									DEALLOCATE(values[j]);
								}
							}
							value_no += field->number_of_indexed_values;
						}
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_string_values.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_string_values.  "
						"Could not calculate index field %s for field %s at %s %",
						field->indexer_field->name,field->name,
						CM_element_type_string(element_field_values->element->cm.type),
						element_field_values->element->cm.number);
				}
				REACCESS(FE_field)(&(element_field_values->field),field);
			} break;
			case GENERAL_FE_FIELD:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_string_values.  "
					"General fields not supported");
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_string_values.  Unknown field type");
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_string_values.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_string_values */

int calculate_FE_element_anatomical(
	struct FE_element_field_values *coordinate_element_field_values,
	struct FE_element_field_values *anatomical_element_field_values,
	FE_value *xi_coordinates,FE_value *x,FE_value *y,FE_value *z,FE_value a[3],
	FE_value b[3],FE_value c[3],FE_value *dx_dxi)
/*******************************************************************************
LAST MODIFIED : 16 November 1998

DESCRIPTION :
Calculates the cartesian coordinates (<x>, <y> and <z>), and the fibre (<a>),
cross-sheet (<b>) and sheet-normal (<c>) vectors from a coordinate element field
and an anatomical element field.  The storage for the <x>, <y>, <z>, <a>, <b>
and <c> should have been allocated outside the function.
If later conversion of a, b and c to vectors in xi space is required, the
optional <dx_dxi> parameter should be supplied and point to a enough memory to
contain the nine derivatives of x,y,z w.r.t. three xi. These are returned in the
order dx/dxi1, dx/dxi2, dx/dxi3, dy/dxi1 etc. Note that there will always be
nine values returned, regardless of the element dimension.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;
	FE_value anatomical_result[3],a_x,a_y,a_z,b_x,b_y,b_z,coordinates[3],
		cos_alpha,cos_beta,cos_gamma,c_x,c_y,c_z,derivative_xi[9],distance,d_xi1_0,
		d_xi1_1,d_xi1_2,d_xi2_0,d_xi2_1,d_xi2_2,d_xi3_0,d_xi3_1,d_xi3_2,f11,
		f12,f13,f21,f22,f23,f31,f32,f33,jacobian[9],sin_alpha,sin_beta,sin_gamma;
	int return_code;
	struct FE_element *element;

	ENTER(calculate_FE_element_anatomical);
	/* check the arguments */
	if (coordinate_element_field_values&&anatomical_element_field_values&&
		xi_coordinates&&x&&y&&z&&a&&b&&c&&(coordinate_element_field_values->field)&&
		(CM_COORDINATE_FIELD==coordinate_element_field_values->field->cm.type)&&
		(anatomical_element_field_values->field)&&
		(CM_ANATOMICAL_FIELD==anatomical_element_field_values->field->cm.type)&&
		(FIBRE==anatomical_element_field_values->field->coordinate_system.type)&&
		(3>=anatomical_element_field_values->field->number_of_components)&&
		(element=coordinate_element_field_values->element)&&
		(element==anatomical_element_field_values->element)&&(element->shape)&&
		((2==element->shape->dimension)||(3==element->shape->dimension))&&
		/* must have at least as many components as xi directions! */
		(element->shape->dimension<=
		coordinate_element_field_values->field->number_of_components))
	{

		coordinate_system = get_FE_field_coordinate_system(
			 coordinate_element_field_values->field);


#if defined (OLD_CODE)
		/* set up storage for the basis function values */
		basis_function_values=preallocated_basis_function_values;
		if (!basis_function_values)
		{
			i=coordinate_element_field_values->number_of_components-1;
			component_number_of_values=
				coordinate_element_field_values->component_number_of_values;
			max_basis_function_values= *component_number_of_values;
			while (i>0)
			{
				i--;
				component_number_of_values++;
				if (*component_number_of_values>max_basis_function_values)
				{
					max_basis_function_values= *component_number_of_values;
				}
			}
			i=anatomical_element_field_values->number_of_components;
			component_number_of_values=
				anatomical_element_field_values->component_number_of_values;
			while (i>0)
			{
				if (*component_number_of_values>max_basis_function_values)
				{
					max_basis_function_values= *component_number_of_values;
				}
				component_number_of_values++;
				i--;
			}
			if (max_basis_function_values>0)
			{
				ALLOCATE(basis_function_values,FE_value,max_basis_function_values);
			}
		}
		if (basis_function_values)
		{
#endif /* defined (OLD_CODE) */
			/* calculate the coordinate field */
			if (calculate_FE_element_field(-1,coordinate_element_field_values,
				xi_coordinates,coordinates,derivative_xi))
			{
				return_code=1;
				/* calculate the fibre field coordinate vectors - f1 (f), f2 (g) and
					f3 (h) - in rectangular cartesian coordinates*/
				/* calculate the base vectors for xi1 and xi2 in rectangular
					cartesian coordinates (use f1 and f2 as temporary storage) */
				switch (element->shape->dimension)
				{
					case 2:
					{
						d_xi1_0=derivative_xi[0];
						d_xi1_1=derivative_xi[2];
						d_xi2_0=derivative_xi[1];
						d_xi2_1=derivative_xi[3];
						if (2==coordinate_element_field_values->field->number_of_components)
						{
							/* clear z components of 2-component, 2-D elements */
							coordinates[2]=0;
							d_xi1_2=0.0;
							d_xi1_2=0.0;
						}
						else
						{
							d_xi1_2=derivative_xi[4];
							d_xi2_2=derivative_xi[5];
						}
						/* need d_xi3_d* for returning dx_dxi */
						d_xi3_0=0.0;
						d_xi3_1=0.0;
						d_xi3_2=0.0;
					} break;
					case 3:
					{
						d_xi1_0=derivative_xi[0];
						d_xi1_1=derivative_xi[3];
						d_xi1_2=derivative_xi[6];
						d_xi2_0=derivative_xi[1];
						d_xi2_1=derivative_xi[4];
						d_xi2_2=derivative_xi[7];
						/* need d_xi3_d* for returning dx_dxi */
						d_xi3_0=derivative_xi[2];
						d_xi3_1=derivative_xi[5];
						d_xi3_2=derivative_xi[8];
					} break;
				}
				if (RECTANGULAR_CARTESIAN!=coordinate_system->type)
				{
					switch (coordinate_system->type)
					{
						case CYLINDRICAL_POLAR:
						{
							cylindrical_polar_to_cartesian(coordinates[0],
								coordinates[1],coordinates[2],x,y,z,jacobian);
						} break;
						case SPHERICAL_POLAR:
						{
							spherical_polar_to_cartesian(coordinates[0],
								coordinates[1],coordinates[2],x,y,z,jacobian);
						} break;
						case PROLATE_SPHEROIDAL:
						{
							prolate_spheroidal_to_cartesian(coordinates[0],
								coordinates[1],coordinates[2],
								coordinate_system->parameters.focus,x,y,z,jacobian);
						} break;
						default:
						{
							display_message(ERROR_MESSAGE,
	"create_fibre_field_from_FE_element.  Invalid coordinate system");
							return_code=0;
						} break;
					}
					if (return_code)
					{
						f11=jacobian[0]*d_xi1_0+jacobian[1]*d_xi1_1+jacobian[2]*d_xi1_2;
						f12=jacobian[3]*d_xi1_0+jacobian[4]*d_xi1_1+jacobian[5]*d_xi1_2;
						f13=jacobian[6]*d_xi1_0+jacobian[7]*d_xi1_1+jacobian[8]*d_xi1_2;
						f21=jacobian[0]*d_xi2_0+jacobian[1]*d_xi2_1+jacobian[2]*d_xi2_2;
						f22=jacobian[3]*d_xi2_0+jacobian[4]*d_xi2_1+jacobian[5]*d_xi2_2;
						f23=jacobian[6]*d_xi2_0+jacobian[7]*d_xi2_1+jacobian[8]*d_xi2_2;
						/* need f3* for returning dx_dxi */
						f31=jacobian[0]*d_xi3_0+jacobian[1]*d_xi3_1+jacobian[2]*d_xi3_2;
						f32=jacobian[3]*d_xi3_0+jacobian[4]*d_xi3_1+jacobian[5]*d_xi3_2;
						f33=jacobian[6]*d_xi3_0+jacobian[7]*d_xi3_1+jacobian[8]*d_xi3_2;
					}
				}
				else
				{
					*x=coordinates[0];
					*y=coordinates[1];
					*z=coordinates[2];
					f11=d_xi1_0;
					f12=d_xi1_1;
					f13=d_xi1_2;
					f21=d_xi2_0;
					f22=d_xi2_1;
					f23=d_xi2_2;
					/* need f3* for returning dx_dxi */
					f31=d_xi3_0;
					f32=d_xi3_1;
					f33=d_xi3_2;
				}
				if (dx_dxi)
				{
					/* return the dx/dxi vectors to the calling function */
					dx_dxi[0]=f11;
					dx_dxi[1]=f21;
					dx_dxi[2]=f31;
					dx_dxi[3]=f12;
					dx_dxi[4]=f22;
					dx_dxi[5]=f32;
					dx_dxi[6]=f13;
					dx_dxi[7]=f23;
					dx_dxi[8]=f33;
				}
				/* f3 is normal to the xi1-xi2 plane */
				f31=f12*f23-f22*f13;
				f32=f13*f21-f23*f11;
				f33=f11*f22-f21*f12;
#if defined (OLD_CODE)
				switch (coordinate_system->type)
				{
					case CYLINDRICAL_POLAR:
					case SPHERICAL_POLAR:
					{
						/* f1 is the intersection of the xi1-xi2 plane with the
							x-y plane, with f1.(xi1 base vector) positive */
						if (0<f11*f33-f13*f31)
						{
							f11=f32;
							f12= -f31;
							f13=0;
						}
						else
						{
							f11= -f32;
							f12=f31;
							f13=0;
						}
					} break;
					case RECTANGULAR_CARTESIAN:
					case PROLATE_SPHEROIDAL:
					{
						/* f1 is the intersection of the xi1-xi2 plane with the
							y-z plane, with f1.(xi1 base vector) positive */
						if (0<f12*f33-f13*f32)
						{
							f11=0;
							f12=f33;
							f13= -f32;
						}
						else
						{
							f11=0;
							f12= -f33;
							f13=f32;
						}
					} break;
				}
#endif /* defined (OLD_CODE) */
				/* f1 is in the xi1 direction */
				/* f2 is in the xi1-xi2 plane normal to f1 */
				f21=f32*f13-f12*f33;
				f22=f33*f11-f13*f31;
				f23=f31*f12-f11*f32;
				/* normalize */
				if (0<(distance=f11*f11+f12*f12+f13*f13))
				{
					distance=sqrt(distance);
					f11 /= distance;
					f12 /= distance;
					f13 /= distance;
				}
				if (0<(distance=f21*f21+f22*f22+f23*f23))
				{
					distance=sqrt(distance);
					f21 /= distance;
					f22 /= distance;
					f23 /= distance;
				}
				if (0<(distance=f31*f31+f32*f32+f33*f33))
				{
					distance=sqrt(distance);
					f31 /= distance;
					f32 /= distance;
					f33 /= distance;
				}
				/* calculate the fibre field */
				if (calculate_FE_element_field(-1,anatomical_element_field_values,
					xi_coordinates,anatomical_result,(FE_value *)NULL))
				{
					sin_alpha=sin(anatomical_result[0]);
					cos_alpha=cos(anatomical_result[0]);
					if (1<anatomical_element_field_values->field->number_of_components)
					{
						sin_beta=sin(anatomical_result[1]);
						cos_beta=cos(anatomical_result[1]);
						/*???RC following was if (1<an...) Was this an error?!? */
						if (2<anatomical_element_field_values->field->number_of_components)
						{
							sin_gamma=sin(anatomical_result[2]);
							cos_gamma=cos(anatomical_result[2]);
						}
						else
						{
							/* default gamma is pi/2 */
							sin_gamma=1;
							cos_gamma=0;
						}
					}
					else
					{
						/* default beta is 0 */
						sin_beta=0;
						cos_beta=1;
						/* default gamma is pi/2 */
						sin_gamma=1;
						cos_gamma=0;
					}
					/* calculate the fibre vector */
					a_x=cos_alpha*f11+sin_alpha*f21;
					a_y=cos_alpha*f12+sin_alpha*f22;
					a_z=cos_alpha*f13+sin_alpha*f23;
					b_x= -sin_alpha*f11+cos_alpha*f21;
					b_y= -sin_alpha*f12+cos_alpha*f22;
					b_z= -sin_alpha*f13+cos_alpha*f23;
					f11=a_x;
					f12=a_y;
					f13=a_z;
					f21=b_x;
					f22=b_y;
					f23=b_z;
					a_x=cos_beta*f11+sin_beta*f31;
					a_y=cos_beta*f12+sin_beta*f32;
					a_z=cos_beta*f13+sin_beta*f33;
					c_x= -sin_beta*f11+cos_beta*f31;
					c_y= -sin_beta*f12+cos_beta*f32;
					c_z= -sin_beta*f13+cos_beta*f33;
					f31=c_x;
					f32=c_y;
					f33=c_z;
					b_x=sin_gamma*f21-cos_gamma*f31;
					b_y=sin_gamma*f22-cos_gamma*f32;
					b_z=sin_gamma*f23-cos_gamma*f33;
					c_x=cos_gamma*f21+sin_gamma*f31;
					c_y=cos_gamma*f22+sin_gamma*f32;
					c_z=cos_gamma*f23+sin_gamma*f33;
					a[0]=a_x;
					a[1]=a_y;
					a[2]=a_z;
					b[0]=b_x;
					b[1]=b_y;
					b[2]=b_z;
					c[0]=c_x;
					c[1]=c_y;
					c[2]=c_z;
				}
				else
				{
					display_message(ERROR_MESSAGE,
				"calculate_FE_element_anatomical.  Error calculating anatomical field");
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"calculate_FE_element_anatomical.  Error calculating coordinate field");
				return_code=0;
			}
#if defined (OLD_CODE)
			if (!preallocated_basis_function_values)
			{
				DEALLOCATE(basis_function_values);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
	"calculate_FE_element_anatomical.  Could not allocate basis_function_values");
			return_code=0;
		}
#endif /* defined (OLD_CODE) */
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_anatomical.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_anatomical */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(FE_element_field)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_element_field,field, \
	struct FE_field *,compare_FE_field)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_LIST_FUNCTIONS(FE_element_field)
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_element_field,field, \
	struct FE_field *,compare_FE_field)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

struct FE_element_field_info *CREATE(FE_element_field_info)(	
	struct LIST(FE_element_field) *element_field_list)
/*******************************************************************************
LAST MODIFIED : 11 February 1999

DESCRIPTION :
Searchs the list of all element field information
(<all_FE_element_field_info>) for one containing the specified element fields.
If one is found it is returned, otherwise a new element field information is
created with duplicated element field lists, added to
<all_FE_element_field_info> and returned.
==============================================================================*/
{
	struct FE_element_field_info *field_info;
	struct LIST(FE_element_field) *duplicate_element_field_list;

	ENTER(CREATE(FE_element_field_info));
	/* check the arguments */
	if (element_field_list)
	{
		/* check for duplicates in the element field lists */		
		if ((duplicate_element_field_list=CREATE_LIST(
			FE_element_field)())&&FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				add_FE_element_field_if_not_duplicate,
				(void *)duplicate_element_field_list,element_field_list))
		{
			if (field_info=find_FE_element_field_info_in_list(
				element_field_list,all_FE_element_field_info))
			{			
				DESTROY_LIST(FE_element_field)(&duplicate_element_field_list);
			}
			else
			{
				/* create a new field information structure */
				if (ALLOCATE(field_info,struct FE_element_field_info,1))
				{						
					field_info->element_field_list=duplicate_element_field_list;
					field_info->access_count=0;
					if (!ADD_OBJECT_TO_LIST(FE_element_field_info)(field_info,
						all_FE_element_field_info))
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_element_field_info).  Could not add to all list");		
						DESTROY_LIST(FE_element_field)(&duplicate_element_field_list);
						DEALLOCATE(field_info);
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_element_field_info).  Insufficient memory");				
					DESTROY_LIST(FE_element_field)(&duplicate_element_field_list);
				}
			}
		}
		else
		{
			DESTROY_LIST(FE_element_field)(&duplicate_element_field_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field_info).  No element fields");
		field_info=(struct FE_element_field_info*)NULL;
	}
	LEAVE;

	return (field_info);
} /* CREATE(FE_element_field_info) */

int DESTROY(FE_element_field_info)(
	struct FE_element_field_info **field_info_address)
/*******************************************************************************
LAST MODIFIED : 11 February 1999

DESCRIPTION :
Removes the information from the list <all_FE_element_field_info>, frees
the memory for the information and sets <*field_info_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_info *field_info;

	ENTER(DESTROY(FE_element_field_info));
	/* check the arguments */
	if ((field_info_address)&&(field_info= *field_info_address))
	{
		/* <=1 is used (instead of <=0) because every element field information
			structure is in <all_FE_element_field_info> */
		if (0==field_info->access_count)
		{	
			DESTROY_LIST(FE_element_field)(&(field_info->element_field_list));
			DEALLOCATE(*field_info_address);
			return_code=1;
		}
		else
		{
			if (1==field_info->access_count)
			{
				return_code=REMOVE_OBJECT_FROM_LIST(FE_element_field_info)(field_info,
					all_FE_element_field_info);
			}
			else
			{
				return_code=1;
			}
			*field_info_address=(struct FE_element_field_info *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field_info) */

DECLARE_ACCESS_OBJECT_FUNCTION(FE_element_field_info)
PROTOTYPE_DEACCESS_OBJECT_FUNCTION(FE_element_field_info)
{ 
	int return_code; 
	struct FE_element_field_info *object; 

	ENTER(DEACCESS(FE_element_field_info)); 
	if (object_address&&(object= *object_address)) 
	{ 
		(object->access_count)--;
		/* <=1 is used (instead of <=0) because every element field information
			structure is in <all_FE_element_field_info> */
		if (object->access_count<=1) 
		{ 			
				return_code=DESTROY(FE_element_field_info)(object_address); 
		} 
		else 
		{ 
			*object_address=(struct FE_element_field_info *)NULL; 
			return_code=1; 
		} 
	} 
	else 
	{ 
		return_code=0; 
	} 
	LEAVE; 

	return (return_code); 
} /* DEACCESS(FE_element_field_info) */

PROTOTYPE_REACCESS_OBJECT_FUNCTION(FE_element_field_info) 
{ 
	int return_code; 
	struct FE_element_field_info *current_object; 

	ENTER(REACCESS(FE_element_field_info)); 
	if (object_address) 
	{ 
		return_code=1; 
		if (new_object) 
		{ 
			/* access the new object */ 
			(new_object->access_count)++; 
		} 
		if (current_object= *object_address) 
		{ 
			/* deaccess the current object */ 
			(current_object->access_count)--; 
			/* <=1 is used (instead of <=0) because every element field information
			structure is in <all_FE_element_field_info> */
			if (current_object->access_count<=1) 
			{ 
				DESTROY(FE_element_field_info)(object_address); 
			} 
		} 
		/* point to the new object */ 
		*object_address=new_object; 
	} 
	else 
	{ 
		display_message(ERROR_MESSAGE, 
			"REACCESS( FE_element_field_info ).  Invalid argument"); 
		return_code=0; 
	} 
	LEAVE; 

	return (return_code); 
} /* REACCESS(FE_element_field_info) */

DECLARE_LIST_FUNCTIONS(FE_element_field_info)

struct FE_element_field_info *find_FE_element_field_info_in_list(
	struct LIST(FE_element_field) *element_field_list,
	struct LIST(FE_element_field_info) *list)
/*******************************************************************************
LAST MODIFIED : 11 February 1999

DESCRIPTION :
Searchs the <list> for the element field_information with the specified element
fields.
==============================================================================*/
{
	struct FE_element_field_info *field_info,element_field_lists;

	ENTER(find_FE_element_field_info_in_list);
	if (list&&(element_field_list))
	{
		element_field_lists.element_field_list=element_field_list;
		field_info=FIRST_OBJECT_IN_LIST_THAT(FE_element_field_info)(
			match_FE_element_field_lists,(void *)(&element_field_lists),list);
	}
	else
	{
		field_info=(struct FE_element_field_info *)NULL;
	}
	LEAVE;

	return (field_info);
} /* find_FE_element_field_info_in_list */

struct Copy_element_grid_map_data
{
	Value_storage *destination_values_storage,*source_values_storage;
}; /* struct Copy_element_grid_map_data */

static int copy_element_grid_map_values_storage(
	struct FE_element_field *element_field,void *copy_element_grid_map_data_void)
/*******************************************************************************
LAST MODIFIED : 18 October 1999

DESCRIPTION :
If the <element_field> is grid based, finds where the values for its components
are stored in <source_values_storage> and copies them to the same location in
<destination_values_storage>. Assumes <destination_values_storage> has already
been allocated but is uninitialised.
==============================================================================*/
{
 	enum Value_type value_type;
	int i,j,*number_in_xi,number_of_values,return_code,value_index;
	struct Copy_element_grid_map_data *copy_data;
	struct FE_element_field_component **component;

	ENTER(copy_element_grid_map_values_storage);
	if (element_field&&element_field->field&&(copy_data=
		(struct Copy_element_grid_map_data *)copy_element_grid_map_data_void))
	{
		return_code=1;
		/* only GENERAL_FE_FIELD has components and can be grid-based */
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			value_type = element_field->field->value_type;
			component=element_field->components;
			for (i=element_field->field->number_of_components;(0<i)&&return_code;i--)
			{
				if (ELEMENT_GRID_MAP==(*component)->type)
				{
					number_in_xi=((*component)->map).element_grid_based.number_in_xi;
					number_of_values=1;
					for (j=((*component)->basis->type)[0];j>0;j--)
					{
						number_of_values *= (*number_in_xi)+1;
						number_in_xi++;
					}
					value_index=((*component)->map).element_grid_based.value_index;
					if (copy_data->destination_values_storage&&
						copy_data->source_values_storage)
					{
						return_code=copy_value_storage_array(
							copy_data->destination_values_storage+value_index,
							value_type,number_of_values,
							copy_data->source_values_storage+value_index);
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"copy_element_grid_map_values_storage.  "
							"Missing source or destination values_storage");
						return_code=0;
					}
				}
				component++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_element_grid_map_values_storage.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* copy_element_grid_map_values_storage */

struct FE_element_node_scale_field_info
	*CREATE(FE_element_node_scale_field_info)(int values_storage_size,
	Value_storage *values_storage,int number_of_nodes,struct FE_node **nodes,
	int number_of_scale_factor_sets,void **scale_factor_set_identifiers,
	int *numbers_in_scale_factor_sets,int number_of_scale_factors,
	FE_value *scale_factors,struct FE_element_field_info *field_info)
/*******************************************************************************
LAST MODIFIED : 18 October 1999

DESCRIPTION :
Allocates memory and assigns fields for an element's node, scale factor and
field information structure.  Note that the arguments are duplicated.
???RC Made it possible to have no scale factor sets.
==============================================================================*/
{
	FE_value *scale_factor;
	int i,j,*number_in_scale_factor_set;
	struct Check_element_grid_map_values_storage_data check_grid_data;
	struct Copy_element_grid_map_data copy_element_grid_map_data;
	struct FE_element_node_scale_field_info *node_scale_field_info;
	struct FE_node **node;
	Value_storage *temp_values_storage;
	void **scale_factor_set_identifier;

	ENTER(CREATE(FE_element_node_scale_field_info));
	/* check the arguments */
	if ((((0==values_storage_size)&&!values_storage)||
		((0<values_storage_size)&&values_storage))&&
		(((0==number_of_nodes)&&!nodes)||((0<number_of_nodes)&&nodes))&&
		((0==number_of_scale_factor_sets) || ((0<number_of_scale_factor_sets)&&
			scale_factor_set_identifiers&&numbers_in_scale_factor_sets&&
			(0<number_of_scale_factors)&&scale_factors))&&field_info)
	{
		/* check the grid based fields */
		check_grid_data.check_sum=0;
		check_grid_data.values_storage_size=values_storage_size;
		if (FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
			check_element_grid_map_values_storage,(void *)&check_grid_data,
			field_info->element_field_list)&&
			(values_storage_size==check_grid_data.check_sum))
		{
			j=0;
			for (i=0;i<number_of_scale_factor_sets;i++)
			{
				j += numbers_in_scale_factor_sets[i];
			}
			if (j==number_of_scale_factors)
			{
				node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
				temp_values_storage=(Value_storage *)NULL;
				node=(struct FE_node **)NULL;
				scale_factor_set_identifier=(void *)NULL;
				number_in_scale_factor_set=(int *)NULL;
				scale_factor=(FE_value *)NULL;
				if (ALLOCATE(node_scale_field_info,
					struct FE_element_node_scale_field_info,1)&&
					(!values_storage||ALLOCATE(temp_values_storage,Value_storage,
						values_storage_size))&&
					(!nodes||ALLOCATE(node,struct FE_node *,number_of_nodes))&&
					((0==number_of_scale_factor_sets)||
					(ALLOCATE(scale_factor_set_identifier,void *,
					   number_of_scale_factor_sets)&&
						ALLOCATE(number_in_scale_factor_set,int,
							number_of_scale_factor_sets)&&
						ALLOCATE(scale_factor,FE_value,number_of_scale_factors))))
				{
					node_scale_field_info->values_storage_size=values_storage_size;
					node_scale_field_info->values_storage=temp_values_storage;
					/* copy values_storage from field_info to node_scale_field_info */
					copy_element_grid_map_data.destination_values_storage=
						node_scale_field_info->values_storage;
					copy_element_grid_map_data.source_values_storage=values_storage;
					FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
						copy_element_grid_map_values_storage,
						&copy_element_grid_map_data,field_info->element_field_list);
					node_scale_field_info->number_of_nodes=number_of_nodes;
					node_scale_field_info->nodes=node;
					for (i=0;i<number_of_nodes;i++)
					{
						if (nodes[i])
						{
							node[i]=ACCESS(FE_node)(nodes[i]);
						}
						else
						{
							node[i]=(struct FE_node *)NULL;
						}
					}
					node_scale_field_info->number_of_scale_factor_sets=
						number_of_scale_factor_sets;
					node_scale_field_info->scale_factor_set_identifiers=
						scale_factor_set_identifier;
					node_scale_field_info->numbers_in_scale_factor_sets=
						number_in_scale_factor_set;
					node_scale_field_info->number_of_scale_factors=
						number_of_scale_factors;
					for (i=0;i<number_of_scale_factor_sets;i++)
					{
						scale_factor_set_identifier[i]=scale_factor_set_identifiers[i];
						number_in_scale_factor_set[i]=numbers_in_scale_factor_sets[i];
					}
					node_scale_field_info->number_of_scale_factors=
						number_of_scale_factors;
					node_scale_field_info->scale_factors=scale_factor;
					for (i=0;i<number_of_scale_factors;i++)
					{
						scale_factor[i]=scale_factors[i];
					}
					node_scale_field_info->fields=ACCESS(FE_element_field_info)(
						field_info);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_element_node_scale_field_info).  Insufficient memory");
					DEALLOCATE(node_scale_field_info);
					DEALLOCATE(temp_values_storage);
					DEALLOCATE(node);
					DEALLOCATE(scale_factor_set_identifier);
					DEALLOCATE(number_in_scale_factor_set);
					DEALLOCATE(scale_factor);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
			"CREATE(FE_element_node_scale_field_info).  Inconsistent scale factors");
				node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
			"CREATE(FE_element_node_scale_field_info).  Inconsistent element values");
			node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_node_scale_field_info).  Invalid argument(s)");
		node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
	}
	LEAVE;

	return (node_scale_field_info);
} /* CREATE(FE_element_node_scale_field_info) */

static int free_element_grid_map_values_storage(
	struct FE_element_field *element_field,void *values_storage_void)
/*******************************************************************************
LAST MODIFIED : 18 October 1999

DESCRIPTION :
If the <element_field> is grid based, finds where the values for its components
are stored in <values_storage> and frees any accesses and dynamic allocations
in them. Only certain value types, eg. arrays, strings, element_xi require this.
==============================================================================*/
{
 	enum Value_type value_type;
	int i,j,*number_in_xi,number_of_values,return_code,value_index;
	struct FE_element_field_component **component;
	Value_storage *values_storage;

	ENTER(free_element_grid_map_values_storage);
	if (element_field&&element_field->field&&
		(values_storage=(Value_storage *)values_storage_void))
	{
		return_code=1;
		/* only GENERAL_FE_FIELD has components and can be grid-based */
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			value_type = element_field->field->value_type;
			component=element_field->components;
			for (i=element_field->field->number_of_components;(0<i)&&return_code;i--)
			{
				if (ELEMENT_GRID_MAP==(*component)->type)
				{
					number_in_xi=((*component)->map).element_grid_based.number_in_xi;
					number_of_values=1;
					for (j=((*component)->basis->type)[0];j>0;j--)
					{
						number_of_values *= (*number_in_xi)+1;
						number_in_xi++;
					}
					value_index=((*component)->map).element_grid_based.value_index;
					return_code=free_value_storage_array(
						values_storage+value_index,value_type,number_of_values);
				}
				component++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"free_element_grid_map_values_storage.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* free_element_grid_map_values_storage */

int DESTROY(FE_element_node_scale_field_info)(
	struct FE_element_node_scale_field_info
	**element_node_scale_field_info_address)
/*******************************************************************************
LAST MODIFIED : 30 September 1998

DESCRIPTION :
Frees the memory for the node, scale and field information and sets
<*element_node_scale_field_info_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_element_node_scale_field_info *node_scale_field_info;
	struct FE_node **node;

	ENTER(DESTROY(FE_element_node_scale_field_info));
	/* check the arguments */
	if ((element_node_scale_field_info_address)&&
		(node_scale_field_info= *element_node_scale_field_info_address))
	{
		/* free values_storage for grid-based fields, if any */
		if (node_scale_field_info->values_storage)
		{
			FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				free_element_grid_map_values_storage,
				(void *)node_scale_field_info->values_storage,
				node_scale_field_info->fields->element_field_list);
			DEALLOCATE(node_scale_field_info->values_storage);
		}
		i=node_scale_field_info->number_of_nodes;
		node=node_scale_field_info->nodes;
		while (i>0)
		{
			DEACCESS(FE_node)(node);
			node++;
			i--;
		}
		DEALLOCATE(node_scale_field_info->nodes);
		DEALLOCATE(node_scale_field_info->scale_factor_set_identifiers);
		DEALLOCATE(node_scale_field_info->numbers_in_scale_factor_sets);
		DEALLOCATE(node_scale_field_info->scale_factors);
		DEACCESS(FE_element_field_info)(&(node_scale_field_info->fields));
		DEALLOCATE(*element_node_scale_field_info_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field_info) */

struct FE_element_shape *CREATE(FE_element_shape)(int dimension,int *type)
/*******************************************************************************
LAST MODIFIED : 7 January 1998

DESCRIPTION :
Searchs the list of all shapes (all_FE_element_shape) for a shape with the
specified <dimension> and <type>.  If one is not found, a shape is created (with
<type> duplicated) and added to the list of all shapes.  The shape is returned.
<type> is analogous to the basis type array, except that the entries are 0 or 1.
==============================================================================*/
{
	FE_value *face_to_element;
	int dimension_2,*face,i,j,k,linked_coordinate,linked_offset,*linked_offsets,
		no_error,number_of_faces,number_of_polygon_verticies,offset,*shape_type,
		simplex_coordinate,simplex_dimension,temp_int,*type_entry,xi_coordinate;
	struct FE_element_shape *shape;

	ENTER(CREATE(FE_element_shape));
/*???debug */
/*printf("enter CREATE(FE_element_shape)\n");*/
	/* check the arguments */
	if ((dimension>0)&&type)
	{
		/* check if the shape already exists */
		if (!(shape=find_FE_element_shape_in_list(dimension,type,
			all_FE_element_shape)))
		{
			ALLOCATE(shape,struct FE_element_shape,1);
			ALLOCATE(shape_type,int,(dimension*(dimension+1))/2);
			/* offsets is working storage used within this function */
			ALLOCATE(linked_offsets,int,dimension);
			if (shape&&shape_type&&linked_offsets)
			{
				shape->access_count=0;
				shape->dimension=dimension;
				shape->type=shape_type;
				if (1==dimension)
				{
					if (LINE_SHAPE== *type)
					{
						*(shape_type)=LINE_SHAPE;
						shape->number_of_faces=0;
						shape->faces=(int *)NULL;
						shape->face_to_element=(FE_value *)NULL;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_element_shape).  Invalid shape type");
						shape=(struct FE_element_shape *)NULL;
					}
				}
				else
				{
					/* copy the type */
					type_entry=type;
					for (i=(dimension*(dimension+1))/2;i>0;i--)
					{
						*shape_type= *type_entry;
						shape_type++;
						type_entry++;
					}
					/* check that the type is valid and calculate the number of faces */
					no_error=1;
					number_of_faces=0;
					xi_coordinate=0;
					shape_type=shape->type;
					while (no_error&&(xi_coordinate<dimension))
					{
						linked_offsets[xi_coordinate]=0;
						xi_coordinate++;
						switch (*shape_type)
						{
							case LINE_SHAPE:
							{
								/* line */
								number_of_faces += 2;
								/* check that not connected to anything else */
								i=dimension-xi_coordinate;
								shape_type++;
								while (no_error&&(i>0))
								{
									if (0!= *shape_type)
									{
										no_error=0;
									}
									shape_type++;
									i--;
								}
							} break;
							case POLYGON_SHAPE:
							{
								/* polygon */
								/* check if the other polygon coordinate is before */
								type_entry=shape_type;
								i=xi_coordinate-1;
								j=dimension-xi_coordinate;
								number_of_polygon_verticies=0;
								while (no_error&&(i>0))
								{
									j++;
									type_entry -= j;
									if (*type_entry)
									{
										if (number_of_polygon_verticies)
										{
											no_error=0;
										}
										else
										{
											number_of_polygon_verticies= *type_entry;
											if (number_of_polygon_verticies>=3)
											{
												linked_offsets[xi_coordinate-1]=i-xi_coordinate;
											}
											else
											{
												no_error=0;
											}
										}
									}
									i--;
								}
								if (no_error)
								{
									if (number_of_polygon_verticies)
									{
										/* other polygon coordinate is before */
										/* check that not connected to anything else */
										i=dimension-xi_coordinate;
										shape_type++;
										while (no_error&&(i>0))
										{
											if (0!= *shape_type)
											{
												no_error=0;
											}
											shape_type++;
											i--;
										}
									}
									else
									{
										/* check if the other polygon coordinate is after */
										shape_type++;
										i=dimension-xi_coordinate;
										number_of_polygon_verticies=0;
										while (no_error&&(i>0))
										{
											if (*shape_type)
											{
												if (number_of_polygon_verticies)
												{
													no_error=0;
												}
												else
												{
													number_of_polygon_verticies= *shape_type;
													if (3<=number_of_polygon_verticies)
													{
														linked_offset=dimension-xi_coordinate+1-i;
														if (POLYGON_SHAPE==shape_type[(linked_offset*
															(2*(dimension-xi_coordinate+1)-linked_offset+1))/
															2-linked_offset])
														{
															linked_offsets[xi_coordinate-1]=linked_offset;
															number_of_faces += number_of_polygon_verticies;
														}
														else
														{
															no_error=0;
														}
													}
													else
													{
														no_error=0;
													}
												}
											}
											shape_type++;
											i--;
										}
										if (number_of_polygon_verticies<3)
										{
											no_error=0;
										}
									}
								}
							} break;
							case SIMPLEX_SHAPE:
							{
								/* simplex */
								/* check preceding dimensions */
								type_entry=shape_type;
								i=xi_coordinate-1;
								j=dimension-xi_coordinate;
								while (no_error&&(i>0))
								{
									j++;
									type_entry -= j;
									if (*type_entry)
									{
										if (SIMPLEX_SHAPE== *(type_entry-(xi_coordinate-i)))
										{
											linked_offsets[xi_coordinate-1]=i-xi_coordinate;
										}
										else
										{
											no_error=0;
										}
									}
									i--;
								}
								if (0==linked_offsets[xi_coordinate-1])
								{
									number_of_faces++;
								}
								else
								{
									/* check intermediary links */
									i=xi_coordinate+linked_offsets[xi_coordinate-1];
									type_entry=shape_type+((i-1)*(2*dimension-i+2))/2;
									j=dimension-xi_coordinate+1;
									k=shape_type-type_entry;
									type_entry=shape_type;
									i++;
									while (no_error&&(i<xi_coordinate))
									{
										j++;
										k -= j;
										type_entry++;
										if (((0== *type_entry)&&(0!=type_entry[k]))||
											((0!= *type_entry)&&(0==type_entry[k])))
										{
											no_error=0;
										}
										i++;
									}
								}
								number_of_faces++;
								/* check succeeding dimensions */
								shape_type++;
								i=dimension-xi_coordinate;
								while (no_error&&(i>0))
								{
									if (*shape_type)
									{
										linked_offset=dimension-xi_coordinate+1-i;
										if (SIMPLEX_SHAPE==shape_type[(linked_offset*
											(2*(dimension-xi_coordinate+1)-linked_offset+1))/
											2-linked_offset])
										{
											if (linked_offsets[xi_coordinate-1]<=0)
											{
												linked_offsets[xi_coordinate-1]=linked_offset;
											}
										}
										else
										{
											no_error=0;
										}
									}
									shape_type++;
									i--;
								}
								if (0==linked_offsets[xi_coordinate-1])
								{
									no_error=0;
								}
							} break;
							default:
							{
								no_error=0;
							} break;
						}
					}
					if (no_error)
					{
						dimension_2=dimension*dimension;
						if (ALLOCATE(face,int,number_of_faces)&&
							ALLOCATE(face_to_element,FE_value,number_of_faces*dimension_2))
						{
							shape->number_of_faces=number_of_faces;
							shape->faces=face;
							shape->face_to_element=face_to_element;
							for (i=number_of_faces*dimension_2;i>0;i--)
							{
								*face_to_element=0;
								face_to_element++;
							}
							face_to_element=shape->face_to_element;
							for (i=number_of_faces;i>0;i--)
							{
								*face=0;
								face++;
							}
							face=shape->faces;
							shape_type=shape->type;
							offset=1;
							for (xi_coordinate=0;xi_coordinate<dimension;xi_coordinate++)
							{
								switch (*shape_type)
								{
									case LINE_SHAPE:
									{
										/* line */
										offset *= 2;
										*face=offset;
										face++;
										*face=offset+1;
										face++;
										face_to_element[dimension_2+xi_coordinate*dimension]=1;
										k=xi_coordinate+1;
										if (k>=dimension)
										{
											k=1;
										}
										for (j=0;j<dimension;j++)
										{
											if (j!=xi_coordinate)
											{
												face_to_element[k]=1;
												face_to_element[dimension_2+k]=1;
												k++;
												if (k>=dimension)
												{
													k=1;
												}
											}
											face_to_element += dimension;
										}
										face_to_element += dimension_2;
									} break;
									case POLYGON_SHAPE:
									{
										/* polygon */
										if (0<(linked_offset=linked_offsets[xi_coordinate]))
										{
											/* first polygon dimension */
											number_of_polygon_verticies=shape_type[linked_offset];
											offset *= number_of_polygon_verticies;
											for (i=0;i<number_of_polygon_verticies;i++)
											{
												*face=offset;
												face++;
												offset++;
												face_to_element[xi_coordinate*dimension]=
													(FE_value)i/(FE_value)number_of_polygon_verticies;
												face_to_element[(xi_coordinate+linked_offset)*
													dimension]=1;
												j=1;
												while (j<=xi_coordinate)
												{
													face_to_element[j]=1;
													j++;
													face_to_element += dimension;
												}
												*face_to_element=
													(FE_value)i/(FE_value)number_of_polygon_verticies;
												face_to_element[j]=
													1./(FE_value)number_of_polygon_verticies;
												j++;
												face_to_element += dimension;
												linked_offset += xi_coordinate;
												while (j<=linked_offset)
												{
													face_to_element[j]=1;
													j++;
													face_to_element += dimension;
												}
												*face_to_element=1;
												face_to_element += dimension;
												while (j<dimension)
												{
													face_to_element[j]=1;
													j++;
													face_to_element += dimension;
												}
											}
										}
									} break;
									case SIMPLEX_SHAPE:
									{
										offset *= 2;
										*face=offset;
										face++;
/*???DB.  Start of new code */
										simplex_dimension=0;
										/* calculate the simplex dimension */
										simplex_coordinate=xi_coordinate;
										do
										{
											simplex_coordinate += linked_offsets[simplex_coordinate];
											simplex_dimension++;
										} while (simplex_coordinate!=xi_coordinate);
										simplex_coordinate=xi_coordinate;
										linked_offset=simplex_dimension;
										if (0<linked_offsets[xi_coordinate])
										{
											do
											{
												simplex_coordinate +=
													linked_offsets[simplex_coordinate];
												linked_offset--;
											} while (linked_offsets[simplex_coordinate]>0);
											face[simplex_coordinate-xi_coordinate] += offset;
										}
										else
										{
											/* last simplex dimension */
											*face += offset+1;
											face++;
										}
										linked_offset--;
										simplex_coordinate += linked_offsets[simplex_coordinate];
										linked_coordinate=simplex_coordinate;
										for (j=simplex_dimension-linked_offset;j>0;j--)
										{
											linked_coordinate += linked_offsets[linked_coordinate];
										}
										k=xi_coordinate+1;
										if (k>=dimension)
										{
											k=1;
										}
										for (j=0;j<dimension;j++)
										{
											if (j==simplex_coordinate)
											{
												simplex_coordinate +=
													linked_offsets[simplex_coordinate];
												linked_offset--;
												if (j!=xi_coordinate)
												{
													if (0==linked_offset)
													{
														face_to_element[0]=1;
														temp_int=xi_coordinate+
															linked_offsets[xi_coordinate];
														while (xi_coordinate<temp_int)
														{
															face_to_element[temp_int]= -1;
															temp_int += linked_offsets[temp_int];
														}
														while (temp_int<xi_coordinate)
														{
															face_to_element[temp_int+1]= -1;
															temp_int += linked_offsets[temp_int];
														}
													}
													else
													{
														if (linked_coordinate<xi_coordinate)
														{
															face_to_element[linked_coordinate+1]=1;
														}
														else
														{
															if (xi_coordinate<linked_coordinate)
															{
																face_to_element[linked_coordinate]=1;
															}
														}
														linked_coordinate +=
															linked_offsets[linked_coordinate];
													}
												}
												else
												{
													linked_coordinate +=
														linked_offsets[linked_coordinate];
												}
											}
											else
											{
												if (j!=xi_coordinate)
												{
													face_to_element[k]=1;
												}
											}
											if (j!=xi_coordinate)
											{
												k++;
												if (k>=dimension)
												{
													k=1;
												}
											}
											face_to_element += dimension;
										}
										if (linked_offsets[xi_coordinate]<0)
										{
											/* last simplex dimension */
											linked_offset=simplex_dimension;
											simplex_coordinate=xi_coordinate+
												linked_offsets[xi_coordinate];
											linked_coordinate=simplex_coordinate;
											k=xi_coordinate+1;
											if (k>=dimension)
											{
												k=1;
											}
											for (j=0;j<dimension;j++)
											{
												if (j==simplex_coordinate)
												{
													simplex_coordinate +=
														linked_offsets[simplex_coordinate];
													linked_offset--;
													if (0==linked_offset)
													{
														face_to_element[0]=1;
														temp_int=xi_coordinate+
															linked_offsets[xi_coordinate];
														while (xi_coordinate<temp_int)
														{
															face_to_element[temp_int]= -1;
															temp_int += linked_offsets[temp_int];
														}
														while (temp_int<xi_coordinate)
														{
															face_to_element[temp_int+1]= -1;
															temp_int += linked_offsets[temp_int];
														}
													}
													else
													{
														if (linked_coordinate<xi_coordinate)
														{
															face_to_element[linked_coordinate+1]=1;
														}
														else
														{
															if (xi_coordinate<linked_coordinate)
															{
																face_to_element[linked_coordinate]=1;
															}
														}
														linked_coordinate +=
															linked_offsets[linked_coordinate];
													}
												}
												else
												{
													if (j!=xi_coordinate)
													{
														face_to_element[k]=1;
													}
												}
												if (j!=xi_coordinate)
												{
													k++;
													if (k>=dimension)
													{
														k=1;
													}
												}
												face_to_element += dimension;
											}
										}
#if defined (OLD_CODE)
										if (0<(linked_offset=linked_offsets[xi_coordinate]))
										{
											while (linked_offsets[xi_coordinate+linked_offset]>0)
											{
												linked_offset +=
													linked_offsets[xi_coordinate+linked_offset];
											}
											face[linked_offset] += offset;
										}
										else
										{
											/* last simplex dimension */
											*face += offset+1;
											face++;
										}
										k=xi_coordinate+1;
										if (k>=dimension)
										{
											k=1;
										}
										for (j=0;j<dimension;j++)
										{
											if (j!=xi_coordinate)
											{
												face_to_element[k]=1;
												k++;
												if (k>=dimension)
												{
													k=1;
												}
											}
											face_to_element += dimension;
										}
										if (linked_offset<0)
										{
											/* last simplex dimension */
											k=xi_coordinate+1;
											if (k>=dimension)
											{
												k=1;
											}
											for (j=0;j<dimension;j++)
											{
												if (j==xi_coordinate)
												{
													face_to_element[0]=1;
													do
													{
														face_to_element[xi_coordinate+1+linked_offset]= -1;
														linked_offset +=
															linked_offsets[xi_coordinate+linked_offset];
													} while
														(0<linked_offsets[xi_coordinate+linked_offset]);
												}
												else
												{
													face_to_element[k]=1;
													k++;
													if (k>=dimension)
													{
														k=1;
													}
												}
												face_to_element += dimension;
											}
										}
#endif /* defined (OLD_CODE) */
									} break;
								}
								shape_type += dimension-xi_coordinate;
							}
/*???debug */
/*face_to_element=shape->face_to_element;
face=shape->faces;
for (i=1;i<=number_of_faces;i++)
{
	printf("face %d %d:\n",i,*face);
	face++;
	for (j=dimension;j>0;j--)
	{
		for (k=dimension;k>0;k--)
		{
			printf(" %g",*face_to_element);
			face_to_element++;
		}
		printf("\n");
	}
}*/
						}
						else
						{
							display_message(ERROR_MESSAGE,
							"CREATE(FE_element_shape).  Could not allocate memory for faces");
							DEALLOCATE(shape);
							DEALLOCATE(shape_type);
							DEALLOCATE(face);
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_element_shape).  Invalid shape type");
						DEALLOCATE(shape->type);
						DEALLOCATE(shape);
					}
				}
				if (shape)
				{
					/* add the shape to the list of all shapes */
					if (!ADD_OBJECT_TO_LIST(FE_element_shape)(shape,all_FE_element_shape))
					{
						display_message(ERROR_MESSAGE,
		"CREATE(FE_element_shape).  Could not add shape to the list of all shapes");
						DEALLOCATE(shape->type);
						DEALLOCATE(shape->faces);
						DEALLOCATE(shape->face_to_element);
						DEALLOCATE(shape);
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_element_shape).  Could not allocate memory for shape");
				DEALLOCATE(shape);
				DEALLOCATE(shape_type);
			}
			DEALLOCATE(linked_offsets)
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_shape).  Invalid argument");
		shape=(struct FE_element_shape *)NULL;
	}
/*???debug */
/*printf("leave CREATE(FE_element_shape)\n");*/
	LEAVE;

	return (shape);
} /* CREATE(FE_element_shape) */

int DESTROY(FE_element_shape)(struct FE_element_shape **element_shape_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Remove the shape from the list of all shapes.  Free the memory for the shape and
sets <*element_shape_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_element_shape *shape;

	ENTER(DESTROY(FE_element_shape));
	/* check the arguments */
	if ((element_shape_address)&&(shape= *element_shape_address))
	{
		/* <=1 is used (instead of <=0) because every shape is in
			<all_FE_element_shape> */
		if (0==shape->access_count)
		{
			DEALLOCATE(shape->type);
			DEALLOCATE(shape->faces);
			DEALLOCATE(shape->face_to_element);
			DEALLOCATE(*element_shape_address);
			return_code=1;
		}
		else
		{
			if (1==shape->access_count)
			{
				/* remove the shape from the list of all shapes */
				return_code=
					REMOVE_OBJECT_FROM_LIST(FE_element_shape)(shape,all_FE_element_shape);
			}
			else
			{
				return_code=1;
			}
			*element_shape_address=(struct FE_element_shape *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_shape) */


DECLARE_ACCESS_OBJECT_FUNCTION(FE_element_shape)
PROTOTYPE_DEACCESS_OBJECT_FUNCTION(FE_element_shape)
{ 
	int return_code; 
	struct FE_element_shape *object; 

	ENTER(DEACCESS(FE_element_shape)); 
	if (object_address&&(object= *object_address)) 
	{ 
		(object->access_count)--; 
		/* <=1 is used (instead of <=0) because every element field information
			 structure is in <all_FE_element_field_info> */
		if (object->access_count<=1) 
		{ 
			return_code=DESTROY(FE_element_shape)(object_address); 
		} 
		else 
		{ 
			*object_address=(struct FE_element_shape *)NULL; 
			return_code=1; 
		} 
	} 
	else 
	{ 
		return_code=0; 
	} 
	LEAVE; 

	return (return_code); 
} /* DEACCESS(FE_element_shape) */

PROTOTYPE_REACCESS_OBJECT_FUNCTION(FE_element_shape) 
{ 
	int return_code; 
	struct FE_element_shape *current_object; 

	ENTER(REACCESS(FE_element_shape)); 
	if (object_address) 
	{ 
		return_code=1; 
		if (new_object) 
		{ 
			/* access the new object */ 
			(new_object->access_count)++; 
		} 
		if (current_object= *object_address) 
		{ 
			/* deaccess the current object */ 
			(current_object->access_count)--; 
			/* <=1 is used (instead of <=0) because every element field information
				 structure is in <all_FE_element_field_info> */
			if (current_object->access_count<=1) 
			{ 
				DESTROY(FE_element_shape)(object_address); 
			} 
		} 
		/* point to the new object */ 
		*object_address=new_object; 
	} 
	else 
	{ 
		display_message(ERROR_MESSAGE, 
			"REACCESS( FE_element_shape ).  Invalid argument"); 
		return_code=0; 
	} 
	LEAVE; 

	return (return_code); 
} /* REACCESS(FE_element_shape) */

DECLARE_LIST_FUNCTIONS(FE_element_shape)

struct FE_element_shape *find_FE_element_shape_in_list(int dimension,int *type,
	struct LIST(FE_element_shape) *list)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Searchs the <list> for the element shape with the specified <dimension> and
<type> and returns the address of the element_shape.
==============================================================================*/
{
	struct Match_FE_element_shape_data match_data;
	struct FE_element_shape *shape;

	ENTER(find_FE_element_shape_in_list);
	if ((dimension>0)&&type&&list)
	{
		match_data.dimension=dimension;
		match_data.type=type;
		shape=FIRST_OBJECT_IN_LIST_THAT(FE_element_shape)(match_FE_element_shape,
			(void *)(&match_data),list);
	}
	else
	{
		shape=(struct FE_element_shape *)NULL;
	}
	LEAVE;

	return (shape);
} /* find_FE_element_shape_in_list */

struct FE_element_shape *get_FE_element_shape_of_face(
	struct FE_element_shape *shape,int face_number)
/*******************************************************************************
LAST MODIFIED : 28 April 1999

DESCRIPTION :
From the parent <shape> returns the FE_element_shape for its face <face_number>.
The <shape> must be of dimension 2 or 3. Faces of 2-D elements are always lines.
The returned shape is ACCESSed here, and should be DEACCESSed when no longer
needed.
==============================================================================*/
{
	int face_code,face_type[3],line_xi_bit,number_of_polygon_vertices;
	struct FE_element_shape *face_shape;

	ENTER(get_FE_element_shape_of_face);
	if (shape&&(0<=face_number)&&(face_number<shape->number_of_faces)&&
		shape->type&&shape->faces)
	{
		switch (shape->dimension)
		{
			case 2:
			{
				/* faces of 2-D shapes are always lines */
				face_type[0]=LINE_SHAPE;
				face_shape=CREATE(FE_element_shape)(/*dimension*/1,face_type);
			} break;
			case 3:
			{
				/* if all shape types on main diagonal are the same, then it is either
					 a square block or a tetrahedron. Sub-triangle of shape->type is then
					 valid for any of its faces */
				if (((shape->type)[0]==(shape->type)[3])&&
					((shape->type)[0]==(shape->type)[5]))
				{
					face_shape=CREATE(FE_element_shape)(/*dimension*/2,shape->type+3);
				}
				else if ((POLYGON_SHAPE==(shape->type)[0])||
					(POLYGON_SHAPE==(shape->type)[3])||
					(POLYGON_SHAPE==(shape->type)[5]))
				{
					/* 2 out of 3 xi directions must be linked in a polygon: hence need
						 to determine if face is a polygon or a square */
					face_code=shape->faces[face_number];
					/* work out number_of_polygon_vertices */
					if (POLYGON_SHAPE==(shape->type)[0])
					{
						if (POLYGON_SHAPE==(shape->type)[3])
						{
							number_of_polygon_vertices=(shape->type)[1];
						}
						else
						{
							number_of_polygon_vertices=(shape->type)[2];
						}
					}
					else
					{
						number_of_polygon_vertices=(shape->type)[4];
					}
					face_code /= number_of_polygon_vertices;
					if (face_code & 2)
					{
						/* face has a polygon shape */
						face_type[0]=POLYGON_SHAPE;
						face_type[1]=number_of_polygon_vertices;
						face_type[2]=POLYGON_SHAPE;
					}
					else
					{
						/* face has a square shape */
						face_type[0]=LINE_SHAPE;
						face_type[1]=0;
						face_type[2]=LINE_SHAPE;
					}
					face_shape=CREATE(FE_element_shape)(/*dimension*/2,face_type);
				}
				else if ((SIMPLEX_SHAPE==(shape->type)[0])||
					(SIMPLEX_SHAPE==(shape->type)[3])||
					(SIMPLEX_SHAPE==(shape->type)[5]))
				{
					/* 2 out of 3 xi directions must be linked in a triangle: hence need
						 to determine if face is a triangle or a square */
					face_code=shape->faces[face_number];
					/* work out which xi direction is not SIMPLEX_SHAPE (=LINE_SHAPE) */
					if (SIMPLEX_SHAPE==(shape->type)[0])
					{
						if (SIMPLEX_SHAPE==(shape->type)[3])
						{
							line_xi_bit=8;
						}
						else
						{
							line_xi_bit=4;
						}
					}
					else
					{
						line_xi_bit=2;
					}
					if (face_code & line_xi_bit)
					{
						/* face has a triangle shape */
						face_type[0]=SIMPLEX_SHAPE;
						face_type[1]=1;
						face_type[2]=SIMPLEX_SHAPE;
					}
					else
					{
						/* face has a square shape */
						face_type[0]=LINE_SHAPE;
						face_type[1]=0;
						face_type[2]=LINE_SHAPE;
					}
					face_shape=CREATE(FE_element_shape)(/*dimension*/2,face_type);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_shape_of_face.  Unknown element shape");
					face_shape=(struct FE_element_shape *)NULL;
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_shape_of_face.  Invalid dimension");
				face_shape=(struct FE_element_shape *)NULL;
			} break;
		}
		if (face_shape)
		{
			ACCESS(FE_element_shape)(face_shape);
		}
		else
		{
			display_message(ERROR_MESSAGE,"get_FE_element_shape_of_face.  Failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_shape_of_face.  Invalid argument(s)");
		face_shape=(struct FE_element_shape *)NULL;
	}
	LEAVE;

	return (face_shape);
} /* get_FE_element_shape_of_face */

struct FE_element_parent *CREATE(FE_element_parent)(struct FE_element *parent,
	int face_number)
/*******************************************************************************
LAST MODIFIED : 23 April 1999

DESCRIPTION :
Creates element parent structure and assigns the fields.
==============================================================================*/
{
	struct FE_element_parent *element_parent;

	ENTER(CREATE(FE_element_parent));
	if (parent&&(0<=face_number)&&(parent->shape)&&
		(face_number<parent->shape->number_of_faces))
	{
		/* create new field */
		if (ALLOCATE(element_parent,struct FE_element_parent,1))
		{
			/* do not use access_FE_element so that can destroy element without
				destroying faces - FE_element_parent structures pointing to parent
				element are destroyed when the parent element is destroyed. */
			element_parent->parent=parent;
			element_parent->face_number=face_number;
			element_parent->access_count=0;
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(FE_element_parent).  Could not allocate memory for element parent");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_parent).  Invalid argument(s)");
		element_parent=(struct FE_element_parent *)NULL;
	}
	LEAVE;

	return (element_parent);
} /* CREATE(FE_element_parent) */

int DESTROY(FE_element_parent)(
	struct FE_element_parent **element_parent_address)
/*******************************************************************************
LAST MODIFIED : 23 April 1999

DESCRIPTION :
Frees the memory for the element parent structure and sets
<*element_parent_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent *element_parent;

	ENTER(DESTROY(FE_element_parent));
	if ((element_parent_address)&&(element_parent= *element_parent_address))
	{
		if (0==element_parent->access_count)
		{
			/* do not use deaccess_FE_element so that can destroy element without
				destroying faces - FE_element_parent structures pointing to parent
				element are destroyed when the parent element is destroyed. */
			DEALLOCATE(*element_parent_address);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,"DESTROY(FE_element_parent).  "
				"Non-zero access_count %d",element_parent->access_count);
			return_code=0;
			*element_parent_address=(struct FE_element_parent *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_parent) */

DECLARE_OBJECT_FUNCTIONS(FE_element_parent)

DECLARE_LIST_FUNCTIONS(FE_element_parent)

DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_element_parent,parent, \
	struct FE_element *,compare_FE_element_parent_parent)

DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_element_parent,face_number,int, \
	compare_FE_element_parent_face_number)

char *CM_element_type_string(enum CM_element_type cm_element_type)
/*******************************************************************************
LAST MODIFIED : 26 August 1999

DESCRIPTION :
Returns a static string describing the <cm_element_type>, eg. CM_LINE = 'line'.
Returned string must not be deallocated!
==============================================================================*/
{
	char *return_string;

	ENTER(CM_element_type_string);
	switch (cm_element_type)
	{
		case CM_ELEMENT:
		{
			return_string="element";
		} break;
		case CM_FACE:
		{
			return_string="face";
		} break;
		case CM_LINE:
		{
			return_string="line";
		} break;
		default:
		{
			display_message(ERROR_MESSAGE,
				"CM_element_type_string.  Unknown CM element type");
			return_string=(char *)NULL;
		} break;
	}
	LEAVE;

	return (return_string);
} /* CM_element_type_string */

struct FE_element *CREATE(FE_element)(struct CM_element_information *cm,
	struct FE_element *template_element)
/*******************************************************************************
LAST MODIFIED : 8 October 1999

DESCRIPTION :
Creates and returns an element with the specified <cm> identifier. The element
is given the same shape, faces and node scale field information as
<template_element>, or is blank if no template is specified. The shape and
node scale field information can be established for a blank element with
set_FE_element_shape and set_FE_element_node_scale_field_info.
The element is returned.
==============================================================================*/
{
	int i,number_of_faces,return_code;
	struct FE_element *element;

	ENTER(CREATE(FE_element));
	element=(struct FE_element *)NULL;
	if (cm)
	{
		/* create a new element */
		if (ALLOCATE(element,struct FE_element,1))
		{
			return_code=1;
			/* clear the new element */
			element->access_count=0;
			/* used for find_by_identifier function */
			element->identifier= &(element->cm);
			element->cm.type=cm->type;
			element->cm.number=cm->number;
			element->shape=(struct FE_element_shape *)NULL;
			element->faces=(struct FE_element **)NULL;
			if (!(element->parent_list=CREATE(LIST(FE_element_parent))()))
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_element).  Could not create parent list");
				return_code=0;
			}
			element->information=(struct FE_element_node_scale_field_info *)NULL;
			if (return_code&&template_element)
			{
				if (return_code&&template_element->shape)
				{
					if (set_FE_element_shape(element,template_element->shape))
					{
						number_of_faces=template_element->shape->number_of_faces;
						if ((0==number_of_faces)||template_element->faces)
						{
							for (i=0;(i<number_of_faces)&&return_code;i++)
							{
								if (template_element->faces[i])
								{
									if (!set_FE_element_face(element,i,
										template_element->faces[i]))
									{
										display_message(ERROR_MESSAGE,
											"CREATE(FE_element).  Could not set face");
										return_code=0;
									}
								}
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"CREATE(FE_element).  Invalid faces in template element");
							return_code=0;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_element).  Could not set element shape");
						return_code=0;
					}
				}
				if (return_code&&template_element->information)
				{
					if (!(element->information=CREATE(FE_element_node_scale_field_info)(
						template_element->information->values_storage_size,
						template_element->information->values_storage,
						template_element->information->number_of_nodes,
						template_element->information->nodes,
						template_element->information->number_of_scale_factor_sets,
						template_element->information->scale_factor_set_identifiers,
						template_element->information->numbers_in_scale_factor_sets,
						template_element->information->number_of_scale_factors,
						template_element->information->scale_factors,
						template_element->information->fields)))
					{
						display_message(ERROR_MESSAGE,"CREATE(FE_element).  "
							"Could not copy node scale field info from template element");
						return_code=0;
					}
				}
			}
			if (!return_code)
			{
				DESTROY(FE_element)(&element);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_element).  Could not allocate memory for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element).  Invalid argument(s)");
	}
	LEAVE;

	return (element);
} /* CREATE(FE_element) */

int DESTROY(FE_element)(struct FE_element **element_address)
/*******************************************************************************
LAST MODIFIED : 23 April 1999

DESCRIPTION :
Frees the memory for the element, sets <*element_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_element *element,**face;
	struct FE_element_parent *face_parent;

	ENTER(DESTROY(FE_element));
	/* check the arguments */
	if ((element_address)&&(element= *element_address))
	{
		if (0==element->access_count)
		{
			if (face=element->faces)
			{
				for (i=element->shape->number_of_faces;i>0;i--)
				{
					if (*face)
					{
						if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
							parent)(element,(*face)->parent_list))
						{
							REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
								(*face)->parent_list);
						}
						(void)DEACCESS(FE_element)(face);
					}
					face++;
				}
			}
			DEALLOCATE(element->faces);
			(void)DEACCESS(FE_element_shape)(&(element->shape));
			/*???DB.  element->parent_list should be NULL otherwise access_count>1 ?*/
			(void)DESTROY_LIST(FE_element_parent)(&(element->parent_list));
			(void)DESTROY(FE_element_node_scale_field_info)(
				&(element->information));
			/* free the memory associated with the element */
			DEALLOCATE(*element_address);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_element).  Element has non-zero access count %d",
				element->access_count);
			*element_address=(struct FE_element *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element) */

PROTOTYPE_COPY_OBJECT_FUNCTION(FE_element)
/*******************************************************************************
LAST MODIFIED : 9 February 1999

DESCRIPTION :
Creates an EXACT copy of the element.
==============================================================================*/
{
	int i,number_of_faces,return_code;
	struct FE_element **element_face,**face;
	struct FE_element_parent *face_parent;

	ENTER(COPY(FE_element));
	return_code=0;
	/* check the arguments */
	if (source&&destination)
	{
		if (destination->shape)
		{
			/* free the old element values */
			face=destination->faces;
			for (i=destination->shape->number_of_faces;i>0;i--)
			{
				if (*face)
				{
					if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
						parent)(destination,(*face)->parent_list))
					{
						REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
							(*face)->parent_list);
					}
					(void)DEACCESS(FE_element)(face);
				}
				face++;
			}
			DEALLOCATE(destination->faces);
			(void)DEACCESS(FE_element_shape)(&(destination->shape));
		}
		(void)DESTROY(FE_element_node_scale_field_info)(
			&(destination->information));
		/* copy the new */
		destination->cm.number=source->cm.number;
		destination->cm.type=source->cm.type;

		destination->shape=ACCESS(FE_element_shape)(source->shape);
		/* duplicate the element information */
		if (!(destination->information=source->information)||
			(destination->information=CREATE(FE_element_node_scale_field_info)(
			source->information->values_storage_size,
			source->information->values_storage,
			source->information->number_of_nodes,source->information->nodes,
			source->information->number_of_scale_factor_sets,
			source->information->scale_factor_set_identifiers,
			source->information->numbers_in_scale_factor_sets,
			source->information->number_of_scale_factors,
			source->information->scale_factors,source->information->fields)))
		{
			/* add the faces */
			if ((number_of_faces=source->shape->number_of_faces)>0)
			{
				if (ALLOCATE(element_face,struct FE_element *,number_of_faces))
				{
					destination->faces=element_face;
					face=source->faces;
					i=0;
					while ((destination->faces)&&(i<number_of_faces))
					{
						if (*face)
						{
							if (face_parent=CREATE(FE_element_parent)(destination,i))
							{
								if (ADD_OBJECT_TO_LIST(FE_element_parent)(face_parent,
									(*face)->parent_list))
								{
									(*element_face)=ACCESS(FE_element)(*face);
									element_face++;
									face++;
									i++;
								}
								else
								{
									display_message(ERROR_MESSAGE,
								"COPY(FE_element).  Could not add element to face parent list");
									DESTROY(FE_element_parent)(&face_parent);
									while (i>0)
									{
										element_face--;
										i--;
										if (face_parent=
											FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
											parent)(destination,(*element_face)->parent_list))
										{
											REMOVE_OBJECT_FROM_LIST(FE_element_parent)(
												face_parent,(*element_face)->parent_list);
										}
										DEACCESS(FE_element)(element_face);
									}
									DEALLOCATE(destination->faces);
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"COPY(FE_element).  Could not create face parent");
								while (i>0)
								{
									element_face--;
									i--;
									if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(
										FE_element_parent,parent)(destination,
										(*element_face)->parent_list))
									{
										REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
											(*element_face)->parent_list);
									}
									DEACCESS(FE_element)(element_face);
								}
								DEALLOCATE(destination->faces);
							}
						}
						else
						{
							*element_face=(struct FE_element *)NULL;
							element_face++;
							face++;
							i++;
						}
					}
					if (destination->faces)
					{
						return_code=1;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"COPY(FE_element).  Could not allocate memory for faces");
				}
			}
			else
			{
				destination->faces=(struct FE_element **)NULL;
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"COPY(FE_element).  Could not create element information");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"COPY(FE_element).  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* COPY(FE_element) */

DECLARE_OBJECT_FUNCTIONS(FE_element)

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(FE_element)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_LIST_FUNCTIONS(FE_element)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_element, \
	identifier,struct CM_element_information *, \
	compare_CM_element_information)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_element, \
	identifier,struct CM_element_information *, \
	compare_CM_element_information)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

#if defined (DEBUG)
/*???DB.  Used for debugging indexed lists */
/*???debug */
static int level=0;

static void write_index_node(struct INDEX_NODE(FE_element) *index)
{
	struct INDEX_NODE(FE_element) **child;
	int i;
	struct FE_element **element;

	printf("%*slevel %d %p\n",level," ",level/2,index->parent);
	level += 2;
	element=index->indices;
	if (child=index->children)
	{
		write_index_node(*child);
		for (i=index->number_of_indices;i>0;i--)
		{
			child++;
			printf("%*s(%d )\n",level," ",(*element)->cm.number);
			write_index_node(*child);
			element++;
		}
	}
	else
	{
		for (i=index->number_of_indices;i>0;i--)
		{
			printf("%*s(%d )\n",level," ",(*element)->cm.number);
			element++;
		}
	}
	level -= 2;
	printf("%*slevel %d\n",level," ",level/2);
}

void write_manager(struct MANAGER(FE_element) *manager)
{
	if (manager)
	{
		write_index_node(manager->object_list->index);
	}
	else
	{
		printf("write_manager.  Missing manager\n");
	}
}
#endif /* defined (DEBUG) */

PROTOTYPE_MANAGER_COPY_WITH_IDENTIFIER_FUNCTION(FE_element,identifier)
{
	int return_code;

	ENTER(MANAGER_COPY_WITH_IDENTIFIER(FE_element,identifier));
	if (source&&destination)
	{
		if (return_code=MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,
			identifier)(destination,source))
		{
			destination->cm.type=source->cm.type;
			destination->cm.number=source->cm.number;	
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITH_IDENTIFIER(FE_element,identifier).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITH_IDENTIFIER(FE_element,identifier) */

PROTOTYPE_MANAGER_COPY_WITHOUT_IDENTIFIER_FUNCTION(FE_element,identifier)
{
	int i,number_of_faces,return_code;
	struct FE_element **element_face,**face;
	struct FE_element_parent *face_parent;

	ENTER(MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier));
	return_code=0;
	if (destination&&source&&(destination != source))
	{
		if (destination->shape)
		{
			/* free the old element values */
			face=destination->faces;
			for (i=destination->shape->number_of_faces;i>0;i--)
			{
				if (*face)
				{
					if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
						parent)(destination,(*face)->parent_list))
					{
						REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
							(*face)->parent_list);
					}
					(void)DEACCESS(FE_element)(face);
				}
				face++;
			}
			DEALLOCATE(destination->faces);
			(void)DEACCESS(FE_element_shape)(&(destination->shape));
		}
		(void)DESTROY(FE_element_node_scale_field_info)(
			&(destination->information));
		/* copy the new */
		destination->shape=ACCESS(FE_element_shape)(source->shape);
		/* duplicate the element information */
		if (!(destination->information=source->information)||
			(destination->information=CREATE(FE_element_node_scale_field_info)(
			source->information->values_storage_size,
			source->information->values_storage,
			source->information->number_of_nodes,source->information->nodes,
			source->information->number_of_scale_factor_sets,
			source->information->scale_factor_set_identifiers,
			source->information->numbers_in_scale_factor_sets,
			source->information->number_of_scale_factors,
			source->information->scale_factors,source->information->fields)))
		{
			/* add the faces */
			if ((number_of_faces=source->shape->number_of_faces)>0)
			{
				if (ALLOCATE(element_face,struct FE_element *,number_of_faces))
				{
					destination->faces=element_face;
					face=source->faces;
					i=0;
					while ((destination->faces)&&(i<number_of_faces))
					{
						if (*face)
						{
							if (face_parent=CREATE(FE_element_parent)(destination,i))
							{
								if (ADD_OBJECT_TO_LIST(FE_element_parent)(face_parent,
									(*face)->parent_list))
								{
									(*element_face)=ACCESS(FE_element)(*face);
									element_face++;
									face++;
									i++;
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
										"Could not add element to face parent list");
									DESTROY(FE_element_parent)(&face_parent);
									while (i>0)
									{
										element_face--;
										i--;
										if (face_parent=
											FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
											parent)(destination,(*element_face)->parent_list))
										{
											REMOVE_OBJECT_FROM_LIST(FE_element_parent)(
												face_parent,(*element_face)->parent_list);
										}
										DEACCESS(FE_element)(element_face);
									}
									DEALLOCATE(destination->faces);
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
									"Could not create face parent");
								while (i>0)
								{
									element_face--;
									i--;
									if (face_parent=
										FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,parent)(
											destination,(*element_face)->parent_list))
									{
										REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
											(*element_face)->parent_list);
									}
									DEACCESS(FE_element)(element_face);
								}
								DEALLOCATE(destination->faces);
							}
						}
						else
						{
							*element_face=(struct FE_element *)NULL;
							element_face++;
							face++;
							i++;
						}
					}
					if (destination->faces)
					{
						return_code=1;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
						"Could not allocate memory for faces");
				}
			}
			else
			{
				destination->faces=(struct FE_element **)NULL;
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
				"Could not create element information");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier) */

int equivalent_FE_fields_at_elements(struct FE_element *element_1,
	struct FE_element *element_2)
/*******************************************************************************
LAST MODIFIED : 23 May 2000

DESCRIPTION :
Returns true if all fields are defined in the same way at the two elements.
==============================================================================*/
{
	int return_code;

	ENTER(equivalent_FE_fields_at_elements);
	return_code=0;
	if (element_1&&(element_1->information)&&element_2&&(element_2->information)&&
		(element_1->information->fields==element_2->information->fields))
	{
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* equivalent_FE_fields_at_elements */

int get_FE_element_dimension(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 4 November 1999

DESCRIPTION :
Returns the dimension of the <element> or an error if it does not have a shape.
==============================================================================*/
{
	int dimension;

	ENTER(get_FE_element_dimension);
	dimension=0;
	if (element)
	{
		if (element->shape)
		{
			dimension=element->shape->dimension;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_dimension.  Element must have a shape");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_dimension.  Missing element");
	}
	LEAVE;

	return (dimension);
} /* get_FE_element_dimension */

int get_FE_element_shape(struct FE_element *element,
	struct FE_element_shape **shape)
/*******************************************************************************
LAST MODIFIED : 12 October 1999

DESCRIPTION :
Returns the <shape> of the <element>, if any. Only newly created blank elements
should have no shape.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_shape);
	if (element&&shape)
	{
		*shape = element->shape;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_shape.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_shape */

int set_FE_element_shape(struct FE_element *element,
	struct FE_element_shape *shape)
/*******************************************************************************
LAST MODIFIED : 6 October 1999

DESCRIPTION :
Sets the <shape> of <element>. Note that the element must not currently have a
shape in order for this to be set, ie. just created. Allocates and clears the
faces array in the element, so this must be clear too.
Should only be called for unmanaged elements.
==============================================================================*/
{
	int i,return_code;
	struct FE_element **faces;

	ENTER(set_FE_element_shape);
	return_code=0;
	if (element&&shape&&(0<=shape->number_of_faces))
	{
		if (element->shape||element->faces)
		{
			display_message(ERROR_MESSAGE,
				"set_FE_element_shape.  Element already has shape/faces");
		}
		else
		{
			faces=(struct FE_element **)NULL;
			if ((0==shape->number_of_faces)||
				ALLOCATE(faces,struct FE_element *,shape->number_of_faces))
			{
				/* clear the faces */
				for (i=0;i<shape->number_of_faces;i++)
				{
					faces[i] = (struct FE_element *)NULL;
				}
				element->faces=faces;
				element->shape=ACCESS(FE_element_shape)(shape);
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_element_shape.  Not enough memory for faces");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_shape.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_shape */

int get_FE_element_face(struct FE_element *element,int face_number,
	struct FE_element **face_element)
/*******************************************************************************
LAST MODIFIED : 12 October 1999

DESCRIPTION :
Returns the <face_element> for face <face_number> of <element>, where NULL means
there is no face. Element must have a shape and face.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_face);
	if (element&&element->shape&&element->faces&&(0<=face_number)&&
		(face_number<element->shape->number_of_faces)&&face_element)
	{
		*face_element=element->faces[face_number];
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_face.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_face */

int set_FE_element_face(struct FE_element *element,int face_number,
	struct FE_element *face_element)
/*******************************************************************************
LAST MODIFIED : 7 October 1999

DESCRIPTION :
Sets face <face_number> of <element> to <face_element>, ensuring the
<face_element> has <element> as a parent. <face_element> may be NULL = no face.
Must have set the shape with set_FE_element_shape first.
Should only be called for unmanaged elements.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent *face_parent;

	ENTER(set_FE_element_face);
	return_code=0;
	if (element&&element->shape&&element->faces&&(0<=face_number)&&
		(face_number<element->shape->number_of_faces))
	{
		return_code=1;
		/* check correct face not already established - otherwise following logic
			 will fail! */
		if (element->faces[face_number] != face_element)
		{
			if (face_element)
			{
				/* set up new face/parent relationship */
				if (face_parent=CREATE(FE_element_parent)(element,face_number))
				{
					if (!ADD_OBJECT_TO_LIST(FE_element_parent)(face_parent,
						face_element->parent_list))
					{
						display_message(ERROR_MESSAGE,
							"set_FE_element_face.  Could not set element as parent of face");
						DESTROY(FE_element_parent)(&face_parent);
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_face.  Could not create face_parent");
					return_code=0;
				}
			}
			if (return_code)
			{
				if (element->faces[face_number])
				{
					/* remove existing face/parent connection */
					if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
						parent)(element,element->faces[face_number]->parent_list))
					{
						REMOVE_OBJECT_FROM_LIST(FE_element_parent)(
							face_parent,element->faces[face_number]->parent_list);
					}
				}
				/* set the new face */
				REACCESS(FE_element)(&(element->faces[face_number]),face_element);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_face.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_face */

int set_FE_element_node_scale_field_info(struct FE_element *element,
	int number_of_scale_factor_sets,void **scale_factor_set_identifiers,
	int *numbers_in_scale_factor_sets,int number_of_nodes)
/*******************************************************************************
LAST MODIFIED : 12 October 1999

DESCRIPTION :
Establishes <element> with FE_element_node_scale_field_information for the
specified scale factor sets and number of nodes. The element is assigned no
fields; fields may be added with define_FE_field_at_element within the framework
of the numbers of scale factors and nodes specified here. Note that the element
must not currently have any such information in order for this to be set, ie.
just created. Must have set the shape with set_FE_element_shape first.
Should only be called for unmanaged elements.
==============================================================================*/
{
	FE_value *scale_factors;
	int i,number_of_scale_factors,return_code;
	struct FE_node **nodes;
	struct LIST(FE_element_field) *element_field_list;
	struct FE_element_field_info *element_field_info;

	ENTER(set_FE_element_node_scale_field_info);
	return_code=0;
	if (element&&(0<=number_of_scale_factor_sets)&&
		((0==number_of_scale_factor_sets)||(scale_factor_set_identifiers&&
			numbers_in_scale_factor_sets))&&(0<=number_of_nodes))
	{
		if (element->information)
		{
			display_message(ERROR_MESSAGE,
				"set_FE_element_node_scale_field_info.  "
				"Element already has node scale field information");
		}
		else
		{
			return_code=1;
			/* count and check number of scale factors */
			number_of_scale_factors=0;
			for (i=0;i<number_of_scale_factor_sets;i++)
			{
				if (0<numbers_in_scale_factor_sets[i])
				{
					number_of_scale_factors += numbers_in_scale_factor_sets[i];
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_node_scale_field_info.  "
						"Must have >0 scale factors in set");
					return_code=0;
				}
			}
			if (return_code)
			{
				scale_factors=(FE_value *)NULL;
				nodes=(struct FE_node **)NULL;
				element_field_list=(struct LIST(FE_element_field) *)NULL;
				element_field_info=(struct FE_element_field_info *)NULL;
				/* create scale_factors, nodes and element_field_info for empty
					 element field list */
				if (((0==number_of_scale_factors)||
					ALLOCATE(scale_factors,FE_value,number_of_scale_factors))&&
					((0==number_of_nodes)||
						ALLOCATE(nodes,struct FE_node *,number_of_nodes))&&
					(element_field_list=CREATE(LIST(FE_element_field))())&&
					(element_field_info=
						CREATE(FE_element_field_info)(element_field_list)))
				{
					/* clear scale_factors and nodes */
					for (i=0;i<number_of_scale_factors;i++)
					{
						scale_factors[i]=FE_VALUE_INITIALIZER;
					}
					for (i=0;i<number_of_nodes;i++)
					{
						nodes[i]=(struct FE_node *)NULL;
					}
					if (!(element->information=CREATE(FE_element_node_scale_field_info)(
						/*values_storage_size*/0,(Value_storage *)NULL,
						number_of_nodes,nodes,number_of_scale_factor_sets,
						scale_factor_set_identifiers,numbers_in_scale_factor_sets,
						number_of_scale_factors,scale_factors,element_field_info)))
					{
						display_message(ERROR_MESSAGE,
							"set_FE_element_node_scale_field_info.  "
							"Could not create element information");
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_node_scale_field_info.  Not enough memory");
					return_code=0;
				}
				if (scale_factors)
				{
					DEALLOCATE(scale_factors);
				}
				if (nodes)
				{
					DEALLOCATE(nodes);
				}
				if (element_field_list)
				{
					DESTROY(LIST(FE_element_field))(&element_field_list);
				}
				if (element_field_info)
				{
					DESTROY(FE_element_field_info)(&element_field_info);
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_node_scale_field_info.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_node_scale_field_info */

int get_FE_element_node(struct FE_element *element,int node_number,
	struct FE_node **node)
/*******************************************************************************
LAST MODIFIED : 10 November 1999

DESCRIPTION :
Gets node <node_number>, from 0 to number_of_nodes-1 of <element> in <node>.
<element> must already have a shape and node_scale_field_information.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_node);
	if (element&&element->shape&&element->information&&
		element->information->nodes&&(0<=node_number)&&
		(node_number<element->information->number_of_nodes)&&node)
	{
		*node=element->information->nodes[node_number];
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_node */

int set_FE_element_node(struct FE_element *element,int node_number,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 11 October 1999

DESCRIPTION :
Sets node <node_number>, from 0 to number_of_nodes-1 of <element> to <node>.
<element> must already have a shape and node_scale_field_information.
Should only be called for unmanaged elements.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_element_node);
	if (element&&element->shape&&element->information&&
		element->information->nodes&&(0<=node_number)&&
		(node_number<element->information->number_of_nodes)&&node)
	{
		return_code=
			REACCESS(FE_node)(&(element->information->nodes[node_number]),node);
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_node */

int get_FE_element_scale_factor(struct FE_element *element,
	int scale_factor_number,FE_value *scale_factor)
/*******************************************************************************
LAST MODIFIED : 15 November 1999

DESCRIPTION :
Gets scale_factor <scale_factor_number>, from 0 to number_of_scale_factors-1 of
<element> to <scale_factor>.
<element> must already have a shape and node_scale_field_information.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_scale_factor);
	if (element&&element->shape&&element->information&&
		element->information->scale_factors&&(0<=scale_factor_number)&&
		(scale_factor_number<element->information->number_of_scale_factors)&&
			scale_factor)
	{
		return_code=1;
		*scale_factor=element->information->scale_factors[scale_factor_number];
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_scale_factor.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_scale_factor */

int set_FE_element_scale_factor(struct FE_element *element,
	int scale_factor_number,FE_value scale_factor)
/*******************************************************************************
LAST MODIFIED : 15 November 1999

DESCRIPTION :
Sets scale_factor <scale_factor_number>, from 0 to number_of_scale_factors-1 of
<element> to <scale_factor>.
<element> must already have a shape and node_scale_field_information.
Should only be called for unmanaged elements.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_element_scale_factor);
	if (element&&element->shape&&element->information&&
		element->information->scale_factors&&(0<=scale_factor_number)&&
		(scale_factor_number<element->information->number_of_scale_factors))
	{
		return_code=1;
		element->information->scale_factors[scale_factor_number]=scale_factor;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_scale_factor.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_scale_factor */

int define_FE_field_at_element(struct FE_element *element,
	struct FE_field *field,struct FE_element_field_component **components)
/*******************************************************************************
LAST MODIFIED : 18 October 1999

DESCRIPTION :
Defines <field> at <element> using the given <components>. <element> must
already have a shape and node_scale_field_information.
Checks the range of nodes, scale factors etc. referred to by the components are
within the range of the node_scale_field_information, and that the basis
functions are compatible with the element shape.
If the components indicate the field is grid-based, checks that all the
components are grid-based with same number_in_xi and value_index=0.
Value types other than FE_VALUE_VALUE are only supported for grid-based element
fields and constant and indexed FE_fields.
The <components> are duplicated by this functions, so the calling function must
destroy them.
Should only be called for unmanaged elements.
???RC Should have more checks for STANDARD_NODE_TO_ELEMENT_MAP etc.
==============================================================================*/
{
	int i,j,*last_number_in_xi,number_of_grid_based_components,number_of_values,
		return_code,*this_number_in_xi;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;
	struct FE_element_field_info *field_info;
	struct FE_element_field_lists_merge_data merge;
	struct LIST(FE_element_field) *element_field_list;
	Value_storage *values_storage;

	ENTER(define_FE_field_at_element);
	return_code=0;
	if (element&&element->shape&&element->information&&
		element->information->fields&&field&&
		(0<field->number_of_components)&&components)
	{
		return_code=1;
		/* check if the field is already defined at the element */
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(field,
			element->information->fields->element_field_list))
		{
			display_message(ERROR_MESSAGE,
				"define_FE_field_at_element.  Field %s already defined at %s %d",
				field->name,CM_element_type_string(element->cm.type),
				element->cm.number);
			return_code=0;
		}
		values_storage=(Value_storage *)NULL;
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				/* nothing to check */
			} break;
			case INDEXED_FE_FIELD:
			{
				/* no longer perform this check since it prevents us from reading in
					 indexed fields when the indexer is not in the same header */
#if defined (OLD_CODE)
				/* check that the indexer field is defined at the node */
				if (!FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
					field->indexer_field,
					element->information->fields->element_field_list))
				{
					display_message(ERROR_MESSAGE,"define_FE_field_at_element.  "
						"Indexer field %s for field %s not defined at %s %d",
						field->indexer_field->name,field->name,
						CM_element_type_string(element->cm.type),element->cm.number);
					return_code=0;
				}
#endif /* defined (OLD_CODE) */
			} break;
			case GENERAL_FE_FIELD:
			{
				/* check the components are all there, and if grid-based ensure they
					 have consistent number_in_xi and all have value_index set to 0 */
				number_of_grid_based_components=0;
				number_of_values=0;
				last_number_in_xi=(int *)NULL;
				component=components;
				for (i=0;(i<field->number_of_components)&&return_code;i++)
				{
					if (*component)
					{
						if (ELEMENT_GRID_MAP==(*component)->type)
						{
							number_of_grid_based_components++;
							this_number_in_xi=
								(*component)->map.element_grid_based.number_in_xi;
							if (last_number_in_xi)
							{
								for (j=0;(j<element->shape->dimension)&&return_code;j++)
								{
									if (this_number_in_xi[j] != last_number_in_xi[j])
									{
										display_message(ERROR_MESSAGE,
											"define_FE_field_at_element.  Grid-map components must "
											"have same number of cells in xi");
										return_code=0;
									}
								}
							}
							else
							{
								last_number_in_xi=this_number_in_xi;
								number_of_values=1;
								for (j=0;(j<element->shape->dimension)&&return_code;j++)
								{
									if (0<this_number_in_xi[j])
									{
										number_of_values *= (this_number_in_xi[j]+1);
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"define_FE_field_at_element.  "
											"Grid-map components number of cells in xi < 1");
										number_of_values=0;
										return_code=0;
									}
								}
							}
							/* check value_index is 0 for all components, ie. pointing at
								 start of values_storage allocated below */
							if ((*component)->map.element_grid_based.value_index != 0)
							{
								display_message(ERROR_MESSAGE,"define_FE_field_at_element.  "
									"Grid-map components must have 0 value_index");
								return_code=0;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"define_FE_field_at_element.  Missing component");
						return_code=0;
					}
					component++;
				}
				if (!((0==number_of_grid_based_components)||
					(number_of_grid_based_components==field->number_of_components)))
				{
					display_message(ERROR_MESSAGE,
						"define_FE_field_at_element.  Only some components are grid-based");
					return_code=0;
				}
				if (number_of_grid_based_components==field->number_of_components)
				{
					/* value_index of 0 points into values_storage for each component */
					if (!(values_storage=
						make_value_storage_array(field->value_type,number_of_values)))
					{
						display_message(ERROR_MESSAGE,
							"define_FE_field_at_element.  Could not allocate values_storage");
						return_code=0;
					}
				}
				else
				{
					/* only FE_VALUE_VALUE supported by these other types */
					if (FE_VALUE_VALUE != field->value_type)
					{
						display_message(ERROR_MESSAGE,"define_FE_field_at_element.  "
							"%s type only supported for grid, constant and indexed fields",
							Value_type_string(field->value_type));
						return_code=0;
					}
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"define_FE_field_at_element.  Unknown field type");
				return_code=0;
			} break;
		}
		if (return_code)
		{
			if (element_field=CREATE(FE_element_field)(field))
			{
				ACCESS(FE_element_field)(element_field);
				/* make a copy of the element_field_list to put new element_field in */
				if ((element_field_list=CREATE_LIST(FE_element_field)())&&
					(COPY_LIST(FE_element_field)(element_field_list,
						element->information->fields->element_field_list)))
				{
					if (GENERAL_FE_FIELD==field->fe_field_type)
					{
						/* put components in element_field for merge */
						for (i=0;i<field->number_of_components;i++)
						{
							element_field->components[i]=components[i];
						}
						/* use merge_FE_element_field_into_list to add field to element */
						merge.list=element_field_list;
						merge.values_storage_size_address=
							&(element->information->values_storage_size);
						merge.values_storage_address=
							&(element->information->values_storage);
						/* merge information about the new field */
						merge.new_values_storage=values_storage;
						merge.new_number_of_nodes=element->information->number_of_nodes;
						merge.new_nodes=element->information->nodes;
						merge.new_number_of_scale_factor_sets=
							element->information->number_of_scale_factor_sets;
						merge.new_scale_factor_set_identifiers=
							element->information->scale_factor_set_identifiers;
						merge.new_numbers_in_scale_factor_sets=
							element->information->numbers_in_scale_factor_sets;
						merge.new_number_of_scale_factors=
							element->information->number_of_scale_factors;
						/* merge information about existing fields - same nodes and scale
							 factors as above since same element */
						merge.number_of_nodes=element->information->number_of_nodes;
						merge.nodes=element->information->nodes;
						merge.number_of_scale_factor_sets=
							element->information->number_of_scale_factor_sets;
						merge.scale_factor_set_identifiers=
							element->information->scale_factor_set_identifiers;
						merge.numbers_in_scale_factor_sets=
							element->information->numbers_in_scale_factor_sets;
						merge.number_of_scale_factors=
							element->information->number_of_scale_factors;
						if (!merge_FE_element_field_into_list(element_field,(void *)&merge))
						{
							display_message(ERROR_MESSAGE,
								"define_FE_field_at_element.  Could not merge element field");
							return_code=0;
						}
						/* clear the components from element_field since they are owned by
							 the calling function and do not want them destroyed here */
						for (i=0;i<field->number_of_components;i++)
						{
							element_field->components[i]=
								(struct FE_element_field_component *)NULL;
						}
					}
					else
					{
						if (!ADD_OBJECT_TO_LIST(FE_element_field)(element_field,
							element_field_list))
						{
							display_message(ERROR_MESSAGE,
								"define_FE_field_at_element.  Could not add element field");
							return_code=0;
						}
					}
					if (return_code)
					{
						if (field_info=CREATE(FE_element_field_info)(element_field_list))
						{
							REACCESS(FE_element_field_info)(
								&(element->information->fields),field_info);
						}
						else
						{
							display_message(ERROR_MESSAGE,"define_FE_field_at_element.  "
								"Could not create element field info");
							return_code=0;
						}
					}
					DESTROY_LIST(FE_element_field)(&element_field_list);
				}
				else
				{
					display_message(ERROR_MESSAGE,"define_FE_field_at_element.  "
						"Could not duplicate element_field_list");
					return_code=0;
				}
				DEACCESS(FE_element_field)(&element_field);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"define_FE_field_at_element.  Could not create element_field");
				return_code=0;
			}
		}
		if (values_storage)
		{
			free_value_storage_array(values_storage,
				field->value_type,number_of_values);
			DEALLOCATE(values_storage);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"define_FE_field_at_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* define_FE_field_at_element */

static int FE_element_field_has_element_grid_map(
	struct FE_element_field *element_field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Returns true if <element_field> components are of type ELEMENT_GRID_MAP.
Only checks the first component since we assume all subsequent components have
the same basis and numbers of grid cells in xi.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_has_element_grid_map);
	USE_PARAMETER(dummy_void);
	return_code=0;
	if (element_field&&element_field->field)
	{
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			if (element_field->components)
			{
				if (ELEMENT_GRID_MAP == (*(element_field->components))->type)
				{
					return_code=1;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_has_element_grid_map.  Missing components");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_has_element_grid_map.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_has_element_grid_map */

int FE_element_has_grid_based_fields(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
Returns true if any of the fields defined for element
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_has_grid_based_fields);
	return_code=0;
	if (element&&element->information&&element->information->fields)
	{
		if (FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
			FE_element_field_has_element_grid_map,(void *)NULL,
			element->information->fields->element_field_list))
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_grid_based_fields.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_grid_based_fields */

static int FE_element_field_has_FE_field_values(
	struct FE_element_field *element_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 19 October 1999

DESCRIPTION:
Returns true if <element_field> has a field with values_storage.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_has_FE_field_values);
	USE_PARAMETER(dummy);
	if (element_field&&element_field->field)
	{
		return_code=(0<element_field->field->number_of_values);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_has_FE_field_values.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* FE_element_field_has_FE_field_values */

int FE_element_has_FE_field_values(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Returns true if any single field defined at <element> has values stored with
the field. Returns 0 without error if no field information at element.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_has_FE_field_values);
	return_code=0;
	if (element)
	{
		if (element->information&&element->information->fields)
		{
			return_code=((struct FE_element_field *)NULL != 
				FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
					FE_element_field_has_FE_field_values,(void *)NULL,
					element->information->fields->element_field_list));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_FE_field_values.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_FE_field_values */

int for_FE_field_at_element(struct FE_field *field,
	FE_element_field_iterator_function *iterator,void *user_data,
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
If an <iterator> is supplied and the <field> is defined at the <element> then
the result of the <iterator> is returned.  Otherwise, if an <iterator> is not
supplied and the <field> is defined at the <element> then a non-zero is
returned. Otherwise, zero is returned.
???DB.  Multiple behaviour dangerous ?
==============================================================================*/
{
	int return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_iterator_and_data iterator_and_data;

	ENTER(for_FE_field_at_element);
	return_code=0;
	if (field&&element)
	{
		if (element->information&&element->information->fields&&
			(element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(field,
				element->information->fields->element_field_list)))
		{
			if (iterator)
			{
				iterator_and_data.iterator=iterator;
				iterator_and_data.user_data=user_data;
				iterator_and_data.element=element;
				return_code=for_FE_field_at_element_iterator(element_field,
					&iterator_and_data);
			}
			else
			{
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"for_FE_field_at_element.  Field not defined at element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_element */

int for_each_FE_field_at_element(FE_element_field_iterator_function *iterator,
	void *user_data,struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
Calls the <iterator> for each field defined at the <element> until the
<iterator> returns 0 or it runs out of fields.  Returns the result of the last
<iterator> called.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_element);
	return_code=0;
	if (iterator&&element)
	{
		if (element->information&&element->information->fields)
		{
			iterator_and_data.iterator=iterator;
			iterator_and_data.user_data=user_data;
			iterator_and_data.element=element;	
			return_code=FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				for_FE_field_at_element_iterator,&iterator_and_data,
				element->information->fields->element_field_list);
		}
		else
		{
			/* no fields */
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_element */

int for_each_FE_field_at_element_indexer_first(
	FE_element_field_iterator_function *iterator,void *user_data,
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
Calls the <iterator> for each field defined at the <element> until the
<iterator> returns 0 or it runs out of fields.  Returns the result of the last
<iterator> called. This version insists that any field used as an indexer_field
for another field in the list is output first.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_priority_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_element);
	return_code=0;
	if (iterator&&element)
	{
		if (element->information&&element->information->fields)
		{
			if (iterator_and_data.priority_field_list=CREATE(LIST(FE_field))())
			{
				/* make priority list of indexer fields for fields defined at element */
				FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
					FE_element_field_add_indexer_field_to_list,
					(void *)(iterator_and_data.priority_field_list),
					element->information->fields->element_field_list);
				iterator_and_data.iterator=iterator;
				iterator_and_data.user_data=user_data;
				iterator_and_data.element=element;
				/* call iterator function for fields in priority list */
				iterator_and_data.priority_on=1;
				return_code=FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
					for_FE_field_at_element_priority_iterator,&iterator_and_data,
					element->information->fields->element_field_list);
				/* call iterator function for fields not in priority list */
				iterator_and_data.priority_on=0;
				return_code=FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
					for_FE_field_at_element_priority_iterator,&iterator_and_data,
					element->information->fields->element_field_list);
				DESTROY(LIST(FE_field))(&(iterator_and_data.priority_field_list));
			}
		}
		else
		{
			/* no fields */
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_element */

struct FE_field *get_FE_element_default_coordinate_field(
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 13 May 1999

DESCRIPTION :
Returns the first coordinate field defined over <element>, recursively getting
it from its first parent if it has no node scale field information.
==============================================================================*/
{
	struct FE_element_field *element_field;
	struct FE_element_parent *element_parent;
	struct FE_field *field;

	ENTER(get_FE_element_default_coordinate_field);
	if (element)
	{
		if (element->information&&element->information->fields)
		{
			if (element_field=FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
				FE_element_field_is_type_CM_coordinate,(void *)NULL,
				element->information->fields->element_field_list))
			{
				field=element_field->field;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_default_coordinate_field.  No coordinate field found");
				field=(struct FE_field *)NULL;
			}
		}
		else
		{
			/* get first coordinate field of first parent element */
			if (element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				(LIST_ITERATOR_FUNCTION(FE_element_parent) *)NULL,(void *)NULL,
				element->parent_list))
			{
				if (!(field=
					get_FE_element_default_coordinate_field(element_parent->parent)))
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_default_coordinate_field.  "
						"No coordinate field found in parent");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_default_coordinate_field.  "
					"%s %d (%p) has no information and no parents",
					CM_element_type_string(element->cm.type),element->cm.number,element);
				field=(struct FE_field *)NULL;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_default_coordinate_field.  Missing element");
		field=(struct FE_field *)NULL;
	}
	LEAVE;

	return (field);
} /* get_FE_element_default_coordinate_field */

int FE_element_is_top_level_in_Multi_range(struct FE_element *element,
	void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Conditional function returning true if <element> is a CM_ELEMENT whose number
is in the <multi_range>.
==============================================================================*/
{
	int return_code;
	struct Multi_range *multi_range;

	ENTER(FE_element_is_top_level_in_Multi_range);
	if (element&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		return_code = (CM_ELEMENT == element->cm.type) &&
			Multi_range_is_value_in_range(multi_range,element->cm.number);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_top_level_in_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_top_level_in_Multi_range */

int FE_element_is_not_top_level_in_Multi_range(struct FE_element *element,
	void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Conditional function returning true if <element> is either not a CM_ELEMENT
or whose number is NOT in the <multi_range>.
==============================================================================*/
{
	int return_code;
	struct Multi_range *multi_range;

	ENTER(FE_element_is_not_top_level_in_Multi_range);
	if (element&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		return_code = (CM_ELEMENT != element->cm.type) ||
			(!Multi_range_is_value_in_range(multi_range,element->cm.number));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_not_top_level_in_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_not_top_level_in_Multi_range */

int add_FE_element_line_number_to_Multi_range(struct FE_element *element,
	void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 22 March 2000

DESCRIPTION :
Iterator function for adding the number of <element> to <multi_range> if it is
a CM_LINE.
==============================================================================*/
{
	int element_number,return_code;
	struct Multi_range *multi_range;

	ENTER(add_FE_element_line_number_to_Multi_range);
	if (element&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		if (CM_LINE==element->cm.type)
		{
			element_number=element->cm.number;
			return_code=Multi_range_add_range(multi_range,element_number,
				element_number);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_line_number_to_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_line_number_to_Multi_range */

int add_FE_element_face_number_to_Multi_range(struct FE_element *element,
	void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 22 March 2000

DESCRIPTION :
Iterator function for adding the number of <element> to <multi_range> if it is
a CM_FACE.
==============================================================================*/
{
	int element_number,return_code;
	struct Multi_range *multi_range;

	ENTER(add_FE_element_face_number_to_Multi_range);
	if (element&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		if (CM_FACE==element->cm.type)
		{
			element_number=element->cm.number;
			return_code=Multi_range_add_range(multi_range,element_number,
				element_number);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_face_number_to_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_face_number_to_Multi_range */

int add_FE_element_element_number_to_Multi_range(struct FE_element *element,
	void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 22 March 2000

DESCRIPTION :
Iterator function for adding the number of <element> to <multi_range> if it is
a CM_ELEMENT.
==============================================================================*/
{
	int element_number,return_code;
	struct Multi_range *multi_range;

	ENTER(add_FE_element_element_number_to_Multi_range);
	if (element&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		if (CM_ELEMENT==element->cm.type)
		{
			element_number=element->cm.number;
			return_code=Multi_range_add_range(multi_range,element_number,
				element_number);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_element_number_to_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_element_number_to_Multi_range */

int FE_element_is_in_group(struct FE_element *element,void *element_group_void)
/*******************************************************************************
LAST MODIFIED : 22 March 2000

DESCRIPTION :
Returns true if <element> is in <element_group>.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_element) *element_group;

	ENTER(FE_element_is_in_group);
	if (element&&(element_group=(struct GROUP(FE_element) *)element_group_void))
	{
		return_code=(struct FE_element *)NULL != 
			IS_OBJECT_IN_GROUP(FE_element)(element,element_group);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_in_group */

int FE_element_is_in_list(struct FE_element *element,void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 22 March 2000

DESCRIPTION :
Returns true if <element> is in <element_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_is_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		return_code=IS_OBJECT_IN_LIST(FE_element)(element,element_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_in_list */

static int FE_element_parent_has_top_level_parent_not_in_list(
	struct FE_element_parent *element_parent,void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if the parent element referred to by the <element_parent> is
top_level and NOT in the <element_list> or is not top_level and has a parent
element that is not in the <element_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_parent_has_top_level_parent_not_in_list);
	if (element_parent&&element_parent->parent&&
		(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		return_code = !FE_element_has_all_top_level_parents_in_list(
			element_parent->parent,element_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_top_level_parent_not_in_list.  "
			"Invalid argument(s)");
		return_code=0;
	}

	return (return_code);
} /* FE_element_parent_has_top_level_parent_not_in_list */

int FE_element_has_all_top_level_parents_in_list(
	struct FE_element *element,void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <element> is a top_level_element in <element_list>, or all its
top_level_parents are in the list.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_has_all_top_level_parents_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if (CM_ELEMENT==element->cm.type)
		{
			return_code=IS_OBJECT_IN_LIST(FE_element)(element,element_list);
		}
		else
		{
			/* satisfied if cannot find a single parent that does not match this
				 criteria */
			return_code = (struct FE_element_parent *)NULL ==
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_has_top_level_parent_not_in_list,
					(void *)element_list,element->parent_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_all_top_level_parents_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_all_top_level_parents_in_list */

int add_FE_element_and_faces_to_group(struct FE_element *element,
	struct GROUP(FE_element) *element_group)
/*******************************************************************************
LAST MODIFIED : 6 September 2000

DESCRIPTION :
Ensures <element>, its faces (and theirs etc.) are in <element_group>.
Note: this function is recursive.
==============================================================================*/
{
	int i,return_code;
	struct FE_element **face;

	ENTER(add_FE_element_and_faces_to_group);
	if (element&&element_group&&element->shape)
	{
		return_code=1;
		if (face=element->faces)
		{
			for (i=element->shape->number_of_faces;(0<i)&&return_code;i--)
			{
				if (*face)
				{
					if (!add_FE_element_and_faces_to_group(*face,element_group))
					{
						display_message(ERROR_MESSAGE,
							"add_FE_element_and_faces_to_group.  Could not add face");
						return_code=0;
					}
				}
				face++;
			}
		}
		if (return_code)
		{
			if (!IS_OBJECT_IN_GROUP(FE_element)(element,element_group))
			{
				if (!ADD_OBJECT_TO_GROUP(FE_element)(element,element_group))
				{
					display_message(ERROR_MESSAGE,
						"add_FE_element_and_faces_to_group.  Could not add element");
					return_code=0;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_and_faces_to_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_and_faces_to_group */

struct Add_FE_element_and_faces_to_manager_data
  *CREATE(Add_FE_element_and_faces_to_manager_data)(
	struct MANAGER(FE_element) *element_manager)
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
Creates data for function add_FE_element_and_faces_to_manager. For efficiency,
use the created structure for as many calls to that function as possible,
however, it must be destroyed and recreated if any existing elements are
modified.
==============================================================================*/
{
	struct Add_FE_element_and_faces_to_manager_data *add_element_data;

	ENTER(CREATE(Add_FE_element_and_faces_to_manager_data));
	if (element_manager)
	{
		if (ALLOCATE(add_element_data,
			struct Add_FE_element_and_faces_to_manager_data,1)&&
			(add_element_data->element_type_node_sequence_list=
				CREATE(LIST(FE_element_type_node_sequence))()))
		{
			add_element_data->first_time_called=1;
			add_element_data->next_free_face_identifier.type=CM_FACE;
			add_element_data->next_free_face_identifier.number=1;
			add_element_data->next_free_line_identifier.type=CM_LINE;
			add_element_data->next_free_line_identifier.number=1;
			add_element_data->element_manager=element_manager;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(Add_FE_element_and_faces_to_manager_data).  Not enough memory");
			DEALLOCATE(add_element_data);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(Add_FE_element_and_faces_to_manager_data).  Invalid argument(s)");
		add_element_data=(struct Add_FE_element_and_faces_to_manager_data *)NULL;
	}
	LEAVE;

	return (add_element_data);
} /* CREATE(Add_FE_element_and_faces_to_manager_data) */

int DESTROY(Add_FE_element_and_faces_to_manager_data)(
	struct Add_FE_element_and_faces_to_manager_data **add_element_data_address)
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
Cleans up memory used by the Add_FE_element_and_faces_to_manager_data. Must be
called to clean up user_data passed to add_FE_element_and_faces_to_manager.
==============================================================================*/
{
	int return_code;
	struct Add_FE_element_and_faces_to_manager_data *add_element_data;

	ENTER(DESTROY(Add_FE_element_and_faces_to_manager_data));
	if (add_element_data_address&&
		(add_element_data= *add_element_data_address))
	{
		DESTROY(LIST(FE_element_type_node_sequence))(
			&(add_element_data->element_type_node_sequence_list));
		DEALLOCATE(*add_element_data_address);
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(Add_FE_element_and_faces_to_manager_data).  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(Add_FE_element_and_faces_to_manager_data) */

int add_FE_element_and_faces_to_manager(struct FE_element *element,
	void *add_FE_element_and_faces_to_manager_data_void)
/*******************************************************************************
LAST MODIFIED : 30 April 1999

DESCRIPTION :
Iterator function ensuring <element> is in the <element_manager>, and does the
same for any faces of the element, creating them if they do not already exist.
Function ensures that elements share existing faces and lines in preference to
creating new ones if they have matching shape and nodes. Only top-level elements
should be passed to this function. 
Notes:
- Since it is quite expensive to find faces/lines for a number of elements, the 
  user_data passed to this function must be created with
    CREATE(Add_FE_element_and_faces_to_manager_data), and destroyed with
    DESTROY(Add_FE_element_and_faces_to_manager_data) after the function is no
  longer to be called. This structure contains an indexed list for efficiently
  finding matching faces and lines that is very costly to establish.
- Enclose calls to this function in MANAGER_BEGIN/END_CACHE calls for the
  element manager.
- This function is recursive.

???RC Can only match faces correctly for coordinate fields with standard node
to element maps and no versions. A grid-based coordinate field would fail
utterly since it has no nodes. A possible future solution for all cases is to
match the geometry exactly either by using the FE_element_field_values
(coefficients of the monomial basis functions), although there is a problem with
xi-directions not matching up, or actual centre positions of the face being a
trivial rejection, narrowing down to a single face or list of faces to compare
against.
==============================================================================*/
{
	int face_number,return_code;
	struct Add_FE_element_and_faces_to_manager_data *add_element_data;
	struct CM_element_information *face_identifier;
	struct FE_element *face,*existing_face;
	struct FE_element_shape *face_shape,*shape;
	struct FE_element_type_node_sequence *element_type_node_sequence,
		*existing_element_type_node_sequence;
	struct LIST(FE_element_type_node_sequence) *element_type_node_sequence_list;
	struct MANAGER(FE_element) *element_manager;

	ENTER(add_FE_element_and_faces_to_manager);
	if (element&&(shape=element->shape)&&
		((0==shape->number_of_faces)||element->faces)&&
		(add_element_data=(struct Add_FE_element_and_faces_to_manager_data *)
			add_FE_element_and_faces_to_manager_data_void)&&
		(element_type_node_sequence_list=
			add_element_data->element_type_node_sequence_list)&&
		(element_manager=add_element_data->element_manager))
	{
		return_code=1;
		if (0 < shape->number_of_faces)
		{
			for (face_number=0;(face_number<shape->number_of_faces)&&return_code;
				face_number++)
			{
				/* is there already a face? */
				if (!(element->faces[face_number]))
				{
					if (face_shape=get_FE_element_shape_of_face(shape,face_number))
					{
						/* get unique CM_element_identifier for face to be created */
						if (2==face_shape->dimension)
						{
							face_identifier = &add_element_data->next_free_face_identifier;
						}
						else
						{
							face_identifier = &add_element_data->next_free_line_identifier;
						}
						while (existing_face=FIND_BY_IDENTIFIER_IN_MANAGER(FE_element,
							identifier)(face_identifier,element_manager))
						{
							(face_identifier->number)++;
						}
						if ((face=CREATE(FE_element)(face_identifier,
							(struct FE_element *)NULL))&&
							set_FE_element_shape(face,face_shape)&&
							set_FE_element_face(element,face_number,face))
						{
							/* try to find an existing face in the manager with the same
								 shape and the same nodes as face */
							if (element_type_node_sequence=ACCESS(FE_element_type_node_sequence)(
								CREATE(FE_element_type_node_sequence)(face)))
							{
								if (!FE_element_type_node_sequence_is_collapsed(
									element_type_node_sequence))
								{
									if (add_element_data->first_time_called)
									{
										/* create FE_element_type_node_sequence objects for all
											 existing faces and lines so can be rapidly recalled */
										if (!FOR_EACH_OBJECT_IN_MANAGER(FE_element)(
											FE_element_face_line_to_element_type_node_sequence_list,
											(void *)element_type_node_sequence_list,
											element_manager))
										{
											display_message(ERROR_MESSAGE,
												"add_FE_element_and_faces_to_manager.  "
												"May not be able to share faces properly - perhaps "
												"2 existing faces have same shape and node list?");
										}
										add_element_data->first_time_called=0;
									}
									if (existing_element_type_node_sequence=
										FIND_BY_IDENTIFIER_IN_LIST(FE_element_type_node_sequence,
											identifier)(element_type_node_sequence->identifier,
												element_type_node_sequence_list))
									{
										/* add the face_parent to the existing_face */
										if (existing_face=
											existing_element_type_node_sequence->element)
										{
											/* get the element to use existing face */
											set_FE_element_face(element,face_number,existing_face);
										}
										else
										{
											return_code=0;
										}
									}
									else
									{
										/* add new FE_element_type_node_sequence to list */
										if (!ADD_OBJECT_TO_LIST(FE_element_type_node_sequence)(
											element_type_node_sequence,
											element_type_node_sequence_list))
										{
											return_code=0;
										}
									}
								}
								else
								{
									/* collapsed face = NULL face */
									set_FE_element_face(element,face_number,
										(struct FE_element *)NULL);
								}
								DEACCESS(FE_element_type_node_sequence)(&element_type_node_sequence);
							}
							else
							{
								return_code=0;
							}
							if (!return_code)
							{
								set_FE_element_face(element,face_number,
									(struct FE_element *)NULL);
							}
						}
						else
						{
							if (face)
							{
								DESTROY(FE_element)(&face);
							}
							return_code=0;
						}
						DEACCESS(FE_element_shape)(&face_shape);
					}
					else
					{
						/* could not get face_shape */
						return_code=0;
					}
				} /* ok: already have a face */
				if (element->faces[face_number])
				{
					/* ensure the face and its lines are in the manager and group */
					return_code=add_FE_element_and_faces_to_manager(
						element->faces[face_number],
						add_FE_element_and_faces_to_manager_data_void);
				}
			} /* loop over faces */
		} /* ok: had no faces to add */
		if (return_code)
		{
			/* make sure the element is in the manager */
			if (!FIND_BY_IDENTIFIER_IN_MANAGER(FE_element,identifier)(
				element->identifier,element_manager))
			{
				return_code=ADD_OBJECT_TO_MANAGER(FE_element)(element,element_manager);
			}
		}
		if (!return_code)
		{
			display_message(ERROR_MESSAGE,
				"add_FE_element_and_faces_to_manager.  Failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_and_faces_to_manager.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_and_faces_to_manager */

int remove_FE_element_and_faces_from_group(struct FE_element *element,
	struct GROUP(FE_element) *element_group)
/*******************************************************************************
LAST MODIFIED : 15 April 1999

DESCRIPTION :
Removes <element> and all its faces that are not shared with other elements in
the group from <element_group>. Only top-level elements should be passed to this
function.
Notes:
- function assumes the element and all its faces etc. are in the element_group,
  so NUMEROUS errors will be reported if this is not the case. If in doubt, use
  FIND_BY_IDENTIFIER_IN_GROUP on the top-level element before passing it to
  this function. Note that partner function add_FE_element_and_faces_to_group
	guarantees that all faces are added with the element to the group.
- this function is recursive.
==============================================================================*/
{
	int i,return_code;
	struct FE_element **face,**temp_face;

	ENTER(remove_FE_element_and_faces_from_group);
	if (element&&element_group&&element->shape)
	{
		return_code=1;
		/* remove element from group only if it has no parents still in the group */
		if (!FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
			FE_element_parent_is_in_group,(void *)element_group,element->parent_list))
		{
			/* access element in case it is only accessed by its faces */
			ACCESS(FE_element)(element);
			REMOVE_OBJECT_FROM_GROUP(FE_element)(element,element_group);
			/* remove all the element's faces from group */
			if (face=element->faces)
			{
				for (i=element->shape->number_of_faces;(0<i)&&return_code;i--)
				{
					if (*face)
					{
						/* if a face is repeated in the faces array, the following avoids
							 removing it again. This happens at the bottom of the heart */
						temp_face=face;
						do
						{
							temp_face--;
						}
						while ((temp_face > element->faces)&&(*face != *temp_face));
						if (*face != *temp_face)
						{
							remove_FE_element_and_faces_from_group(*face,element_group);
						}
					}
					face++;
				}
			}
			DEACCESS(FE_element)(&element);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"remove_FE_element_and_faces_from_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* remove_FE_element_and_faces_from_group */

static int FE_element_parent_has_other_parent(
	struct FE_element_parent *element_parent,void *first_parent_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if the parent element referred to by the <element_parent> is
of the same CM_element_type as first_parent_void yet not the same.
==============================================================================*/
{
	int return_code;
	struct FE_element *first_parent;

	ENTER(FE_element_parent_has_other_parent);
	if (element_parent&&element_parent->parent&&
		(first_parent=(struct FE_element *)first_parent_void))
	{
		return_code = ((element_parent->parent->cm.type == first_parent->cm.type)&&
			(element_parent->parent != first_parent))||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_has_other_parent,first_parent_void,
				element_parent->parent->parent_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_other_parent.  Invalid argument(s)");
		return_code=0;
	}

	return (return_code);
} /* FE_element_parent_has_other_parent */

int FE_element_has_other_parent_or_can_be_destroyed(struct FE_element *element,
	struct FE_element *first_parent)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if a different parent of the same CM_element_type as <first_parent>
can be found for <element>, or <element> itself can be destroyed.
Notes:
- Faces do not access their parents - see CREATE(FE_element_parent).
- Called by FE_element_can_be_destroyed to ensure that all faces and lines in
  it can either be destroyed with it or left on there own due to the presence
  of other parent elements.
- This function is recursive.
==============================================================================*/
{
	int i,parent_access_count,return_code;
	struct FE_element **face;

	ENTER(FE_element_has_other_parent_or_can_be_destroyed);
	if (element&&element->shape)
	{
		if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
			FE_element_parent_has_other_parent,(void *)first_parent,
			element->parent_list))
		{
			return_code=1;
		}
		else
		{
			/* valid access count is 1 from manager and 1 from each parent */
			parent_access_count=
				NUMBER_IN_LIST(FE_element_parent)(element->parent_list);
			if ((1+parent_access_count)==element->access_count)
			{
				/* ensure all faces (and their faces) satisfy this function too */
				return_code=1;
				if (face=element->faces)
				{
					for (i=element->shape->number_of_faces;(0<i)&&return_code;i--)
					{
						if (*face)
						{
							return_code=FE_element_has_other_parent_or_can_be_destroyed(
								*face,first_parent);
						}
					}
					face++;
				}
			}
			else
			{
				if (parent_access_count >= element->access_count)
				{
					display_message(ERROR_MESSAGE,
						"FE_element_has_other_parent_or_can_be_destroyed.  "
						"Access count of %d is less sum of manager(1) and parents(%d)",
						element->access_count,parent_access_count);
				}
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_other_parent_or_can_be_destroyed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_other_parent_or_can_be_destroyed */

int FE_element_can_be_destroyed(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if the <element> is only accessed by its manager (ie. starting
access count of 1) and its parents, and that either all its faces have other
parents or can themselves be destroyed.
Notes:
- Faces do not access their parents - see CREATE(FE_element_parent).
- Ensure this function returns true before passing the element to
  remove_FE_element_and_faces_from_manager.
- This function is recursive.
==============================================================================*/
{
	int i,parent_access_count,return_code;
	struct FE_element **face;

	ENTER(FE_element_can_be_destroyed);
	if (element&&element->shape)
	{
		/* valid access count is 1 from manager and 1 from each parent */
		parent_access_count=NUMBER_IN_LIST(FE_element_parent)(element->parent_list);
		if ((1+parent_access_count)==element->access_count)
		{
			/* ensure all faces (and their faces) either have another parent to
				 hang around with, or can be destroyed with this element */
			return_code=1;
			if (face=element->faces)
			{
				for (i=element->shape->number_of_faces;(0<i)&&return_code;i--)
				{
					if (*face)
					{
						return_code=
							FE_element_has_other_parent_or_can_be_destroyed(*face,element);
					}
					face++;
				}
			}
		}
		else
		{
			if (parent_access_count >= element->access_count)
			{
				display_message(ERROR_MESSAGE,"FE_element_can_be_destroyed.  "
					"Access count of %d is less sum of manager(1) and parents(%d)",
					element->access_count,parent_access_count);
			}
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_can_be_destroyed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_can_be_destroyed */

int remove_FE_element_and_faces_from_manager(struct FE_element *element,
	struct MANAGER(FE_element) *element_manager)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Removes <element> and all its faces that are not shared with other elements in
the manager from <element_manager>. The <element> is only removed from the
<element_manager> if its access_count becomes 1 after removing parent/face
connections. Before removing an element from the manager with this function,
make sure you get a true result from function FE_element_can_be_destroyed.
Only top-level elements should be passed to this function.
Notes:
- function assumes the element and all its faces etc. are in the
	element_manager, so NUMEROUS errors will be reported if this is
	not the case. If in doubt, use FIND_BY_IDENTIFIER_IN_MANAGER on the
  top-level element before passing it to this function. Note that partner
  function add_FE_element_and_faces_to_manager guarantees that any
	faces it finds or creates are added to the element_manager.
- this function is recursive.
==============================================================================*/
{
	int i,return_code;
	struct FE_element **face,*temp_element;

	ENTER(remove_FE_element_and_faces_from_manager);
	if (element&&element_manager&&element->shape)
	{
		return_code=1;
		/* access element in case it is only accessed by faces/parents */
		temp_element=ACCESS(FE_element)(element);
		/* get faces to remove themselves */
		if (face=element->faces)
		{
			for (i=0;(i<element->shape->number_of_faces)&&return_code;i++)
			{
				if (*face)
				{
					/* either leave the face with another parent, or remove it from
						 the manager */
					if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
						FE_element_parent_has_other_parent,(void *)element,
						(*face)->parent_list))
					{
						set_FE_element_face(element,i,(struct FE_element *)NULL);
					}
					else
					{
						return_code=
							remove_FE_element_and_faces_from_manager(*face,element_manager);
					}
				}
				face++;
			}
		}
		/* remove element from its parents, and empty its parent_list */
		if ((return_code=(return_code&&FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
			FE_element_parent_remove_face,(void *)element,element->parent_list)&&
			REMOVE_ALL_OBJECTS_FROM_LIST(FE_element_parent)(element->parent_list)))&&
			(2==element->access_count))
		{
			/* remove element from manager since accessed only here and by manager */
			DEACCESS(FE_element)(&temp_element);
			return_code=
				REMOVE_OBJECT_FROM_MANAGER(FE_element)(element,element_manager);
		}
		else
		{
			DEACCESS(FE_element)(&temp_element);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"remove_FE_element_and_faces_from_manager.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* remove_FE_element_and_faces_from_manager */

#if defined (OLD_CODE_TO_KEEP)
struct Create_absolute_element_field_list_data
/*******************************************************************************
LAST MODIFIED : 7 April 1999

DESCRIPTION :
Data for obsolete function create_absolute_element_field_list.
==============================================================================*/
{
	int number_of_nodes;
	struct LIST(FE_element_field) *list;
	struct FE_node **node;
}; /* struct Create_absolute_element_field_list_data */
#endif /* defined (OLD_CODE_TO_KEEP) */

#if defined (OLD_CODE_TO_KEEP)
int create_absolute_element_field_list(
	struct FE_element_field *element_field,
	void *void_create_absolute_element_field_list_data)
/*******************************************************************************
LAST MODIFIED : 7 April 1999

DESCRIPTION :
???DB.  Came from import_finite_element .  Needs to know too much about nodes
	to stay there
???RC This is not needed now that elements use relative offsets into nodal
values - like in the .exelem files.
==============================================================================*/
{
	int i,j,k,*new_nodal_value_index,*new_scale_factor_index,*nodal_value_index,
		node_index,node_value_end,node_value_start,*number_in_xi,
		number_of_components,number_of_xi_coordinates,return_code,
		*scale_factor_index;
	struct Create_absolute_element_field_list_data
		*create_absolute_element_field_list_data;
	struct FE_element_field *new_element_field;
	struct FE_element_field_component **element_component,**new_element_component;
	struct FE_field *field;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_component;
	struct FE_node_field_info *node_field_info;
	struct Standard_node_to_element_map **new_standard_node_to_element_map,
		**standard_node_to_element_map;

	ENTER(create_absolute_element_field_list);
	/* check arguments */
	if (element_field&&(field=element_field->field)&&
		(0<(number_of_components=field->number_of_components))&&
		(element_component=element_field->components)&&
		(create_absolute_element_field_list_data=
		(struct Create_absolute_element_field_list_data *)
		void_create_absolute_element_field_list_data))
	{
		if (new_element_field=CREATE(FE_element_field)(field))
		{
			return_code=1;
			new_element_component=new_element_field->components;
			i=0;
			while (return_code&&(i<number_of_components))
			{
				if (*element_component)
				{
					switch ((*element_component)->type)
					{
						case STANDARD_NODE_TO_ELEMENT_MAP:
						{
							if ((0<(j=((*element_component)->map).standard_node_based.
								number_of_nodes))&&(standard_node_to_element_map=
								((*element_component)->map).standard_node_based.
								node_to_element_maps)&&(*new_element_component=
								CREATE(FE_element_field_component)(STANDARD_NODE_TO_ELEMENT_MAP,
									j,(*element_component)->basis,
									(*element_component)->modify)))
							{
								new_standard_node_to_element_map=((*new_element_component)->
									map).standard_node_based.node_to_element_maps;
								while (return_code&&(j>0))
								{
									if ((*standard_node_to_element_map)&&
										(0<=(node_index=(*standard_node_to_element_map)->
										node_index))&&(node_index<
										create_absolute_element_field_list_data->number_of_nodes)&&
										(0<(k=(*standard_node_to_element_map)->
										number_of_nodal_values))&&(nodal_value_index=
										(*standard_node_to_element_map)->nodal_value_indices)&&
										(scale_factor_index=(*standard_node_to_element_map)->
										scale_factor_indices)&&(*new_standard_node_to_element_map=
										CREATE(Standard_node_to_element_map)(node_index,k)))
									{
										new_nodal_value_index=(*new_standard_node_to_element_map)->
											nodal_value_indices;
										new_scale_factor_index=(*new_standard_node_to_element_map)->
											scale_factor_indices;
										if ((create_absolute_element_field_list_data->node)
											[node_index]&&(node_field_info=
											((create_absolute_element_field_list_data->node)
											[node_index])->fields))
										{
											switch (field->cm.type)
											{											
												case CM_FIELD: 
												case CM_COORDINATE_FIELD: 
												case CM_ANATOMICAL_FIELD: 
												{
													node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,
														field)(field,
														node_field_info->node_field_list);
												} break;
												default:
												{
													node_field=(struct FE_node_field *)NULL;
												} break;
											}
											if (node_field&&(node_field->components))
											{
												node_component= &((node_field->components)[i]);
												node_value_start=node_component->value;
												node_value_end=node_value_start+
													((node_component->number_of_versions)*
													((node_component->number_of_derivatives)+1)-1);
#if defined (OLD_CODE)
/*???DB.  Assume that always relative */
												if ((node_value_start<= *nodal_value_index)&&
													(*nodal_value_index<=node_value_end))
												{
													/* absolute element field component */
													k--;
													*new_nodal_value_index= *nodal_value_index;
													*new_scale_factor_index= *scale_factor_index;
													while (return_code&&(k>0))
													{
														nodal_value_index++;
														new_nodal_value_index++;
														if (-1== *nodal_value_index)
														{
															*new_nodal_value_index= -1;
														}
														else
														{
															if ((node_value_start<= *nodal_value_index)&&
																(*nodal_value_index<=node_value_end))
															{
																*new_nodal_value_index= *nodal_value_index;
															}
															else
															{
																display_message(ERROR_MESSAGE,
							"create_absolute_element_field_list.  Invalid nodal value index");
																return_code=0;
															}
														}
														scale_factor_index++;
														new_scale_factor_index++;
														*new_scale_factor_index= *scale_factor_index;
														k--;
													}
												}
												else
#endif
												{
													/* relative element field component */
													while (return_code&&(k>0))
													{
														if (-1== *nodal_value_index)
														{
															*new_nodal_value_index= -1;
														}
														else
														{
															*new_nodal_value_index=node_value_start+
																*nodal_value_index;
															if ((node_value_start> *new_nodal_value_index)||
																(*new_nodal_value_index>node_value_end))
															{
																display_message(ERROR_MESSAGE,
							"create_absolute_element_field_list.  Invalid nodal value index");
																return_code=0;
															}
														}
														nodal_value_index++;
														new_nodal_value_index++;
														*new_scale_factor_index= *scale_factor_index;
														scale_factor_index++;
														new_scale_factor_index++;
														k--;
													}
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
										"create_absolute_element_field_list.  Node missing field");
												return_code=0;
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
										"create_absolute_element_field_list.  Node missing field");
											return_code=0;
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
	"create_absolute_element_field_list.  Invalid standard node to element map");
										return_code=0;
									}
									j--;
									standard_node_to_element_map++;
									new_standard_node_to_element_map++;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
				"create_absolute_element_field_list.  Invalid standard node based map");
								return_code=0;
							}
						} break;
						case ELEMENT_GRID_MAP:
						{
							/* OK, just copy */
								/*???DB.  Waste ? */
							number_of_xi_coordinates=((*element_component)->basis->type)[0];
							if ((*new_element_component=CREATE(FE_element_field_component)(
								ELEMENT_GRID_MAP,1,(*element_component)->basis,
								(*element_component)->modify))&&ALLOCATE(number_in_xi,int,
								number_of_xi_coordinates))
							{
								((*new_element_component)->map).element_grid_based.number_in_xi=
									number_in_xi;
								for (i=0;i<number_of_xi_coordinates;i++)
								{
									number_in_xi[i]=(((*element_component)->map).
										element_grid_based.number_in_xi)[i];
								}
								((*new_element_component)->map).element_grid_based.value_index=
									((*element_component)->map).element_grid_based.value_index;
							}
							else
							{
								display_message(ERROR_MESSAGE,
				"create_absolute_element_field_list.  Invalid element grid based map");
								return_code=0;
							}
						} break;
						default:
						{
							display_message(ERROR_MESSAGE,
		"create_absolute_element_field_list.  Invalid global to element map type");
							return_code=0;
						} break;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
				"create_absolute_element_field_list.  Missing element field component");
					return_code=0;
				}
				i++;
				element_component++;
				new_element_component++;
			}
			if (return_code)
			{
				if (!ADD_OBJECT_TO_LIST(FE_element_field)(new_element_field,
					create_absolute_element_field_list_data->list))
				{
					display_message(ERROR_MESSAGE,
		"create_absolute_element_field_list.  Could not add element field to list");
					DESTROY(FE_element_field)(&new_element_field);
					return_code=0;
				}
			}
			else
			{
				DESTROY(FE_element_field)(&new_element_field);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"create_absolute_element_field_list.  Could not create new element field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"create_absolute_element_field_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* create_absolute_element_field_list */
#endif /* defined (OLD_CODE_TO_KEEP) */

int merge_FE_element(struct FE_element *destination,struct FE_element *source)
/*******************************************************************************
LAST MODIFIED : 9 November 2000

DESCRIPTION :
Merges the fields in <destination> with those from <source>, leaving the
combined fields in <destination>.
==============================================================================*/
{
	FE_value *destination_scale_factor,*scale_factor,*scale_factors,
		*source_scale_factor;
	int destination_dimension,*destination_number_in_scale_factor_set,i,j,
		*number_in_scale_factor_set,number_of_nodes,
		number_of_scale_factors,number_of_scale_factor_sets,
		*numbers_in_scale_factor_sets,return_code,*source_number_in_scale_factor_set,
		values_storage_size;
	struct Copy_element_grid_map_data copy_element_grid_map_data;
	struct FE_element **destination_face,**source_face;
	struct FE_element_field_info *destination_field_info;
	struct FE_element_node_scale_field_info *destination_info,*source_info;
	struct FE_node **destination_node,**node,**nodes,**source_node;
	struct LIST(FE_element_field)*element_field_list;
	void **destination_scale_factor_set_identifier,**scale_factor_set_identifier,
		**scale_factor_set_identifiers,**source_scale_factor_set_identifier;
	Value_storage *values_storage;

	ENTER(merge_FE_element);
	if (source && destination)
	{
		/* check the element shape for consistency */
			/*???DB.  If things are set up properly, non-equality should imply that
				they're different */
		if (source->shape && (source->shape == destination->shape))
		{
			return_code=1;
			/* check faces are consistent if both source and destination have them */
			if (0 < source->shape->number_of_faces)
			{
				/* Note set_FE_element_shape should ensure following is true */
				if (source->faces && destination->faces)
				{
					source_face = source->faces;
					destination_face = destination->faces;
					i = source->shape->number_of_faces;
					while ((0 < i) && return_code)
					{
						if ((!(*source_face)) || (!(*destination_face)) ||
							(*source_face == *destination_face))
						{
							source_face++;
							destination_face++;
							i--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_element.  Faces do not match");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"merge_FE_element.  Missing source or destination faces");
					return_code=0;
				}
			}
			if (return_code)
			{
				/* check the element's node, scale factor and field information.
					Expand if necessary */
				if ((source_info=source->information)&&
					(destination_info=destination->information))
				{
					/* duplicate the source values_storage */
					values_storage_size=source_info->values_storage_size;
					if (0<values_storage_size)
					{
						if (ALLOCATE(values_storage,Value_storage,values_storage_size))
						{
							copy_element_grid_map_data.destination_values_storage=
								values_storage;
							copy_element_grid_map_data.source_values_storage=
								source_info->values_storage;
							FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
								copy_element_grid_map_values_storage,
								&copy_element_grid_map_data,
								source_info->fields->element_field_list);
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_element.  Could not allocate values_storage");
							return_code=0;
						}
					}
					else
					{
						values_storage=(Value_storage *)NULL;
					}
					if (return_code)
					{
						/* merge the faces */
						source_face = source->faces;
						destination_face = destination->faces;
						for (i = source->shape->number_of_faces; 0 < i; i--)
						{
							if ((!(*destination_face)) && (*source_face))
							{
								*destination_face = ACCESS(FE_element)(*source_face);
							}
							source_face++;
							destination_face++;
						}

						/* merge the node information */
						number_of_nodes=source_info->number_of_nodes;
						nodes=(struct FE_node **)NULL;
						if ((0==(number_of_nodes+(destination_info->number_of_nodes)))||
							ALLOCATE(nodes,struct FE_node *,
								number_of_nodes+(destination_info->number_of_nodes)))
						{
							/* copy source nodes */
							source_node=source_info->nodes;
							node=nodes;
							for (i=number_of_nodes;i>0;i--)
							{
								*node=ACCESS(FE_node)(*source_node);
								node++;
								source_node++;
							}
							/* include the new nodes */
							destination_node=destination_info->nodes;
							for (i=destination_info->number_of_nodes;i>0;i--)
							{
								node=nodes;
								j=number_of_nodes;
								while ((j>0)&&(*destination_node!= *node))
								{
									j--;
									node++;
								}
								if (j<=0)
								{
									*node=ACCESS(FE_node)(*destination_node);
									number_of_nodes++;
								}
								destination_node++;
							}
							node=nodes;
							if ((0==number_of_nodes)||
								REALLOCATE(node,nodes,struct FE_node *,number_of_nodes))
							{
								nodes=node;
								/* merge the scale factor information */
								number_of_scale_factor_sets=
									source_info->number_of_scale_factor_sets;
								number_of_scale_factors=
									source_info->number_of_scale_factors;
								scale_factors=(FE_value *)NULL;
								scale_factor_set_identifiers=(void **)NULL;
								numbers_in_scale_factor_sets=(int *)NULL;
								if ((0==(number_of_scale_factors+
									destination_info->number_of_scale_factors))||
									(ALLOCATE(scale_factors,FE_value,number_of_scale_factors+
										destination_info->number_of_scale_factors)&&
										ALLOCATE(scale_factor_set_identifiers,void *,
											number_of_scale_factor_sets+
											(destination_info->number_of_scale_factor_sets))&&
										ALLOCATE(numbers_in_scale_factor_sets,int,
											number_of_scale_factor_sets+
											(destination_info->number_of_scale_factor_sets))))
								{
									/* copy the element scale factors */
									source_scale_factor=source_info->scale_factors;
									scale_factor=scale_factors;
									for (i=number_of_scale_factors;i>0;i--)
									{
										*scale_factor= *source_scale_factor;
										scale_factor++;
										source_scale_factor++;
									}
									/* copy scale factor set identifiers and the number of
										scale factors in each set */
									source_scale_factor_set_identifier=
										source_info->scale_factor_set_identifiers;
									scale_factor_set_identifier=scale_factor_set_identifiers;
									source_number_in_scale_factor_set=
										source_info->numbers_in_scale_factor_sets;
									number_in_scale_factor_set=numbers_in_scale_factor_sets;
									for (i=number_of_scale_factor_sets;i>0;i--)
									{
										*scale_factor_set_identifier=
											*source_scale_factor_set_identifier;
										source_scale_factor_set_identifier++;
										scale_factor_set_identifier++;
										*number_in_scale_factor_set=
											*source_number_in_scale_factor_set;
										number_in_scale_factor_set++;
										source_number_in_scale_factor_set++;
									}
									/* include the new scale factor information */
									destination_scale_factor_set_identifier=
										destination_info->scale_factor_set_identifiers;
									destination_number_in_scale_factor_set=
										destination_info->numbers_in_scale_factor_sets;
									destination_scale_factor=destination_info->scale_factors;
									i=destination_info->number_of_scale_factor_sets;
									while (return_code&&(i>0))
									{
										scale_factor_set_identifier=
											scale_factor_set_identifiers;
										number_in_scale_factor_set=
											numbers_in_scale_factor_sets;
										scale_factor=scale_factors;
										j=number_of_scale_factor_sets;
										while ((j>0)&&(*scale_factor_set_identifier!=
											*destination_scale_factor_set_identifier))
										{
											j--;
											scale_factor += *number_in_scale_factor_set;
											scale_factor_set_identifier++;
											number_in_scale_factor_set++;
										}
										if (j>0)
										{
											/* existing scale factor set */
											if (*number_in_scale_factor_set==
											*destination_number_in_scale_factor_set)
											{
												for (j= *number_in_scale_factor_set;j>0;j--)
												{
													*scale_factor= *destination_scale_factor;
													destination_scale_factor++;
													scale_factor++;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
											"merge_FE_element.  Incompatability in scale factor set");
												return_code=0;
												DEALLOCATE(scale_factors);
												DEALLOCATE(scale_factor_set_identifiers);
												DEALLOCATE(numbers_in_scale_factor_sets);
												DEALLOCATE(nodes);
											}
										}
										else
										{
											/* new scale factor set */
											for (j= *destination_number_in_scale_factor_set;j>0;j--)
											{
												*scale_factor= *destination_scale_factor;
												scale_factor++;
												destination_scale_factor++;
											}
											*scale_factor_set_identifier=
												*destination_scale_factor_set_identifier;
											*number_in_scale_factor_set=
												*destination_number_in_scale_factor_set;
											number_of_scale_factors +=
												*destination_number_in_scale_factor_set;
											number_of_scale_factor_sets++;
										}
										destination_scale_factor_set_identifier++;
										destination_number_in_scale_factor_set++;
										i--;
									}
									if (return_code)
									{
										scale_factor=scale_factors;
										scale_factor_set_identifier=scale_factor_set_identifiers;
										number_in_scale_factor_set=numbers_in_scale_factor_sets;
										if ((0==number_of_scale_factors)||(
											REALLOCATE(scale_factor,scale_factors,FE_value,
												number_of_scale_factors)&&
											REALLOCATE(scale_factor_set_identifier,
												scale_factor_set_identifiers,void *,
												number_of_scale_factor_sets)&&
											REALLOCATE(number_in_scale_factor_set,
												numbers_in_scale_factor_sets,int,
												number_of_scale_factor_sets)))
										{
											scale_factors=scale_factor;
											scale_factor_set_identifiers=scale_factor_set_identifier;
											numbers_in_scale_factor_sets=number_in_scale_factor_set;
											/* check the field information */
											if ((source_info->fields)&&(destination_info->fields))
											{
												/* merge the general element field lists */
												if (merge_FE_element_field_lists(
													destination_info->fields->element_field_list,
													destination_info->values_storage,
													destination_info->number_of_nodes,
													destination_info->nodes,
													destination_info->number_of_scale_factor_sets,
													destination_info->scale_factor_set_identifiers,
													destination_info->numbers_in_scale_factor_sets,
													destination_info->number_of_scale_factors,
													source_info->fields->element_field_list,
													number_of_nodes,nodes,
													number_of_scale_factor_sets,
													scale_factor_set_identifiers,
													numbers_in_scale_factor_sets,
													number_of_scale_factors,&values_storage_size,
													&values_storage,&element_field_list))
												{
													if (destination_field_info=
														CREATE(FE_element_field_info)(element_field_list))
													{															
														DESTROY_LIST(FE_element_field)(
															&element_field_list);
														if (ALLOCATE(destination_info,
															struct FE_element_node_scale_field_info,1))
														{
															destination_info->values_storage_size=
																values_storage_size;
															destination_info->values_storage=values_storage;
															destination_info->number_of_nodes=
																number_of_nodes;
															destination_info->nodes=nodes;
															destination_info->
																number_of_scale_factor_sets=
																number_of_scale_factor_sets;
															destination_info->
																scale_factor_set_identifiers=
																scale_factor_set_identifiers;
															destination_info->
																numbers_in_scale_factor_sets=
																numbers_in_scale_factor_sets;
															destination_info->number_of_scale_factors=
																number_of_scale_factors;
															destination_info->scale_factors=
																scale_factors;
															destination_info->fields=
																ACCESS(FE_element_field_info)(
																	destination_field_info);
															DESTROY(FE_element_node_scale_field_info)(
																&(destination->information));
															destination->information=destination_info;
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"merge_FE_element.  Could not create node, scale factor and field information");
															return_code=0;
															DEALLOCATE(scale_factors);
															DEALLOCATE(scale_factor_set_identifiers);
															DEALLOCATE(numbers_in_scale_factor_sets);
															DEALLOCATE(nodes);
														}
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"merge_FE_element.  Could not create field information");
														return_code=0;															
														DESTROY_LIST(FE_element_field)(
															&element_field_list);
														DEALLOCATE(scale_factors);
														DEALLOCATE(scale_factor_set_identifiers);
														DEALLOCATE(numbers_in_scale_factor_sets);
														DEALLOCATE(nodes);
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element.  Could not merge element field lists");
													return_code=0;														
													DEALLOCATE(scale_factors);
													DEALLOCATE(scale_factor_set_identifiers);
													DEALLOCATE(numbers_in_scale_factor_sets);
													DEALLOCATE(nodes);
												}											
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"merge_FE_element.  Invalid field info");
												return_code=0;
												DEALLOCATE(scale_factors);
												DEALLOCATE(scale_factor_set_identifiers);
												DEALLOCATE(numbers_in_scale_factor_sets);
												DEALLOCATE(nodes);
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
								"merge_FE_element.  Could not merge scale factor information");
											return_code=0;
											if (scale_factor)
											{
												DEALLOCATE(scale_factor);
												if (scale_factor_set_identifier)
												{
													DEALLOCATE(scale_factor_set_identifier);
												}
												else
												{
													DEALLOCATE(scale_factor_set_identifiers);
												}
											}
											else
											{
												DEALLOCATE(scale_factors);
												DEALLOCATE(scale_factor_set_identifiers);
											}
											DEALLOCATE(numbers_in_scale_factor_sets);
											DEALLOCATE(nodes);
										}
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
		"merge_FE_element.  Insufficient memory to merge scale factor information");
									if (scale_factors)
									{
										DEALLOCATE(scale_factors);
										DEALLOCATE(scale_factor_set_identifiers);
									}
									DEALLOCATE(nodes);
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"merge_FE_element.  Could not merge node information");
								return_code=0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
						"merge_FE_element.  Insufficient memory to merge node information");
							return_code=0;
						}
					}
				}
				else
				{
					/*???DB.  Can this be incorporated in rest ? */
					if (source_info)
					{
						/* check that the information is compatible with the shape */
						destination_dimension=destination->shape->dimension;
						if (source_info->fields)
						{
							/* check coordinate, anatomical and general element fields */
							if (FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
								check_FE_element_field_dimension,(void *)&destination_dimension,
								source_info->fields->element_field_list))
							{
								if (!(destination->information=
									CREATE(FE_element_node_scale_field_info)(
									source_info->values_storage_size,source_info->values_storage,
									source_info->number_of_nodes,source_info->nodes,
									source_info->number_of_scale_factor_sets,
									source_info->scale_factor_set_identifiers,
									source_info->numbers_in_scale_factor_sets,
									source_info->number_of_scale_factors,
									source_info->scale_factors,source_info->fields)))
								{
									display_message(ERROR_MESSAGE,
										"merge_FE_element.  Could not create information");
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"merge_FE_element.  Inconsistent field information");
								return_code=0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_element.  No fields in information");
							return_code=0;
						}
					}
				}
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"merge_FE_element.  Inconsistent or missing element shape(s)");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_element */

int list_FE_element_name(struct FE_element *element,void *dummy)
/*******************************************************************************
LAST MODIFIED : 26 August 1999

DESCRIPTION :
Outputs the name of the element as element/face/line #.
==============================================================================*/
{
	int return_code;

	ENTER(list_FE_element_name);
	USE_PARAMETER(dummy);
	if (element)
	{
		return_code=1;
		/* write the identifier */
		display_message(INFORMATION_MESSAGE,"%s %d\n",
			CM_element_type_string(element->cm.type),element->cm.number);
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_element_name.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element_name */

int list_FE_element(struct FE_element *element,void *dummy)
/*******************************************************************************
LAST MODIFIED : 26 August 1999

DESCRIPTION :
Outputs the information contained at the element.
==============================================================================*/
{
	char line[91];
	FE_value *scale_factor;
	int i,line_length,number_of_characters,return_code;
	struct FE_element **face;
#if defined (DEBUG)
	/*???debug*/
	struct LIST(FE_node) *nodes_on_face;
#endif /* defined (DEBUG) */

	ENTER(list_FE_element);
	USE_PARAMETER(dummy);
	if (element)
	{
		return_code=1;
		/* write the identifier */
		sprintf(line,"element : %d \n",element->cm.number);
		display_message(INFORMATION_MESSAGE,line);
		sprintf(line,"  access count=%d\n",element->access_count);
		display_message(INFORMATION_MESSAGE,line);
		if (element->shape)
		{
			sprintf(line,"  dimension=%d\n",element->shape->dimension);
			display_message(INFORMATION_MESSAGE,line);
			/* write the faces */
			if ((face=element->faces)&&
				(0<(i=element->shape->number_of_faces)))
			{
				sprintf(line,"  #faces=%d\n",i);
				display_message(INFORMATION_MESSAGE,line);
				line_length=0;
				while (i>0)
				{
					if (*face)
					{
						sprintf(line+line_length," (%d)%n",
							(*face)->cm.number,&number_of_characters);
					}
					else
					{
						sprintf(line+line_length," (0 0 0)%n", &number_of_characters);
					}
					line_length += number_of_characters;
					if (70<=line_length)
					{
						sprintf(line+line_length,"\n");
						display_message(INFORMATION_MESSAGE,line);
						line_length=0;
					}
#if defined (DEBUG)
					/*???debug*/
					/*write the nodes in the faces */
					display_message(INFORMATION_MESSAGE,"\n### Nodes on face %d:\n",
						(*face)->cm.number);
					nodes_on_face=CREATE(LIST(FE_node))();
					if (calculate_FE_element_field_nodes(*face,
						(struct FE_field *)NULL,nodes_on_face))
					{
						FOR_EACH_OBJECT_IN_LIST(FE_node)(list_FE_node,(void *)NULL,
							nodes_on_face);
					}
					DESTROY(LIST(FE_node))(&nodes_on_face);
#endif /* defined (DEBUG) */
					face++;
					i--;
				}
				if (1<line_length)
				{
					sprintf(line+line_length,"\n");
					display_message(INFORMATION_MESSAGE,line);
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE,"  No faces\n");
			}
			/* write the parents */
			if (0<NUMBER_IN_LIST(FE_element_parent)(element->parent_list))
			{
				display_message(INFORMATION_MESSAGE,"  parents\n");
				*line='\0';
				FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(list_FE_element_parent,
					(void *)line,element->parent_list);
				if (0<strlen(line))
				{
					display_message(INFORMATION_MESSAGE,line);
					display_message(INFORMATION_MESSAGE,"\n");
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE,"  No parents\n");
			}
			if (element->information)
			{
				if (element->information->fields)
				{
					display_message(INFORMATION_MESSAGE,"  Field information\n");				
					FOR_EACH_OBJECT_IN_LIST(FE_element_field)(list_FE_element_field,
						(void *)NULL,
						element->information->fields->element_field_list);
				}
				else
				{
					display_message(ERROR_MESSAGE,"list_FE_element.  Missing field info");
					return_code=0;
				}
				if ((scale_factor=element->information->scale_factors)&&
					(i=element->information->number_of_scale_factors))
				{
					sprintf(line,"  #Scale factors=%d\n",i);
					display_message(INFORMATION_MESSAGE,line);
					sprintf(line,"    %n",&line_length);
					while (i>0)
					{
						sprintf(line+line_length,"%13g %n",*scale_factor,
							&number_of_characters);
						line_length += number_of_characters;
						if (line_length>=70)
						{
							sprintf(line+line_length,"\n");
							display_message(INFORMATION_MESSAGE,line);
							number_of_characters=0;
							sprintf(line,"    %n",&line_length);
						}
						i--;
						scale_factor++;
					}
					if (number_of_characters>0)
					{
						sprintf(line+line_length,"\n");
						display_message(INFORMATION_MESSAGE,line);
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"list_FE_element.  Missing scale factors");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE,"  No field information\n");
			}
/*???debug */
{
	struct LIST(FE_node) *node_list;

	if (node_list=CREATE_LIST(FE_node)())
	{
		if (calculate_FE_element_field_nodes(element,(struct FE_field *)NULL,
			node_list))
		{
			FOR_EACH_OBJECT_IN_LIST(FE_node)(list_FE_node,(void *)NULL,node_list);
		}
		REMOVE_ALL_OBJECTS_FROM_LIST(FE_node)(node_list);
		DESTROY_LIST(FE_node)(&node_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"list_FE_element.  Could not create node list");
	}
}
		}
		else
		{
			display_message(INFORMATION_MESSAGE,"  Missing shape\n");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_element.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element */

PROTOTYPE_MANAGER_COPY_IDENTIFIER_FUNCTION(FE_element,identifier,
	struct CM_element_information *)
{
	int return_code;

	ENTER(MANAGER_COPY_IDENTIFIER(FE_element,identifier));
	if (identifier&&destination)
	{
		/*???RC renaming elements in use by any list outside the manager will cause
			list to be corrupted. Allow identifier change under protest here so that
			control_curve / editor work, but disallow name change in select object for
			any object in use outside the manager. */
		destination->cm.type=identifier->type;
		destination->cm.number=identifier->number;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_IDENTIFIER(FE_element,identifier).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_IDENTIFIER(FE_element,identifier) */

DECLARE_MANAGER_FUNCTIONS(FE_element)

DECLARE_MANAGER_IDENTIFIER_FUNCTIONS(FE_element,identifier, \
	struct CM_element_information *)

DECLARE_MANAGED_GROUP_FUNCTIONS(FE_element)

DECLARE_FIND_BY_IDENTIFIER_IN_GROUP_FUNCTION(FE_element,identifier, \
	struct CM_element_information *,compare_CM_element_information)

#if defined (OLD_CODE)
/* indexed list and manager module functions included with MANAGED_GROUP */
DECLARE_GROUP_FUNCTIONS(FE_element)

DECLARE_FIND_BY_IDENTIFIER_IN_GROUP_FUNCTION(FE_element,identifier, \
	struct CM_element_information *,compare_CM_element_information)

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(GROUP(FE_element))

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(GROUP(FE_element),name, \
	char *,strcmp)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_LIST_FUNCTIONS(GROUP(FE_element))
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(GROUP(FE_element),name, \
	char *,strcmp)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

DECLARE_GROUP_MANAGER_COPY_FUNCTIONS(FE_element)

DECLARE_MANAGER_FUNCTIONS(GROUP(FE_element))

DECLARE_MANAGER_IDENTIFIER_FUNCTIONS(GROUP(FE_element),name,char *)
#endif /* defined (OLD_CODE) */

int set_FE_element_group(struct Parse_state *state,
	void *element_group_address_void,void *element_group_manager_void)
/*******************************************************************************
LAST MODIFIED : 20 February 1998

DESCRIPTION :
Used in command parsing to translate a element group name into an element group.
???DB.  Should it be here ?
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct GROUP(FE_element) *group,**group_address;
	struct MANAGER(GROUP(FE_element)) *element_group_manager;

	ENTER(set_FE_element_group);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if ((group_address=
					(struct GROUP(FE_element) **)element_group_address_void)&&
					(element_group_manager=
					(struct MANAGER(GROUP(FE_element)) *)element_group_manager_void))
				{
					if (fuzzy_string_compare(current_token,"NONE"))
					{
						if (*group_address)
						{
							DEACCESS(GROUP(FE_element))(group_address);
							*group_address=(struct GROUP(FE_element) *)NULL;
						}
						return_code=shift_Parse_state(state,1);
					}
					else
					{
						if (group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_element),name)(
							current_token,element_group_manager))
						{
							if (group!= *group_address)
							{
								if (*group_address)
								{
									DEACCESS(GROUP(FE_element))(group_address);
								}
								*group_address=ACCESS(GROUP(FE_element))(group);
							}
							return_code=shift_Parse_state(state,1);
						}
						else
						{
							display_message(WARNING_MESSAGE,"Unknown element group: %s",
								current_token);
							display_parse_state_location(state);
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_group.  Invalid argument(s)");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," ELEMENT_GROUP_NAME|none");
				if (group_address=
					(struct GROUP(FE_element) **)element_group_address_void)
				{
					display_message(INFORMATION_MESSAGE,"[");
					if (group= *group_address)
					{
						display_message(INFORMATION_MESSAGE,group->name);
					}
					else
					{
						display_message(INFORMATION_MESSAGE,"none");
					}
					display_message(INFORMATION_MESSAGE,"]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing element group name");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_group.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_group */

int set_FE_element_group_or_all(struct Parse_state *state,
	void *element_group_address_void,void *element_group_manager_void)
/*******************************************************************************
LAST MODIFIED : 13 December 1999

DESCRIPTION :
Used in command parsing to translate a element group name into an element group.Valid NULL group means "all" groups.
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct GROUP(FE_element) *group,**group_address;
	struct MANAGER(GROUP(FE_element)) *element_group_manager;

	ENTER(set_FE_element_group_or_all);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if ((group_address=
					(struct GROUP(FE_element) **)element_group_address_void)&&
					(element_group_manager=
					(struct MANAGER(GROUP(FE_element)) *)element_group_manager_void))
				{
					if (fuzzy_string_compare(current_token,"ALL"))
					{
						if (*group_address)
						{
							DEACCESS(GROUP(FE_element))(group_address);
							*group_address=(struct GROUP(FE_element) *)NULL;
						}
						return_code=shift_Parse_state(state,1);
					}
					else
					{
						if (group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_element),name)(
							current_token,element_group_manager))
						{
							if (group!= *group_address)
							{
								if (*group_address)
								{
									DEACCESS(GROUP(FE_element))(group_address);
								}
								*group_address=ACCESS(GROUP(FE_element))(group);
							}
							return_code=shift_Parse_state(state,1);
						}
						else
						{
							display_message(WARNING_MESSAGE,"Unknown element group: %s",
								current_token);
							display_parse_state_location(state);
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_group_or_all.  Invalid argument(s)");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," ELEMENT_GROUP_NAME|all");
				if (group_address=
					(struct GROUP(FE_element) **)element_group_address_void)
				{
					display_message(INFORMATION_MESSAGE,"[");
					if (group= *group_address)
					{
						display_message(INFORMATION_MESSAGE,group->name);
					}
					else
					{
						display_message(INFORMATION_MESSAGE,"all");
					}
					display_message(INFORMATION_MESSAGE,"]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing name of element group or ALL");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_group_or_all.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_group_or_all */

int list_group_FE_element(struct GROUP(FE_element) *element_group,void *dummy)
/*******************************************************************************
LAST MODIFIED : 26 August 1999

DESCRIPTION :
Outputs the information contained by the element group.
==============================================================================*/
{
	char *group_name;
	int return_code;

	ENTER(list_group_FE_element);
	if (element_group&&!dummy)
	{
		if (return_code=GET_NAME(GROUP(FE_element))(element_group,&group_name))
		{
			display_message(INFORMATION_MESSAGE,"Element group %s:\n",group_name);
			FOR_EACH_OBJECT_IN_GROUP(FE_element)(list_FE_element_name,(void *)NULL,
				element_group);
			DEALLOCATE(group_name);	
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_group_FE_element.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_group_FE_element */

int list_group_FE_element_name(struct GROUP(FE_element) *element_group,
	void *dummy)
/*******************************************************************************
LAST MODIFIED : 26 August 199

DESCRIPTION :
Outputs the name of the <element_group>.
==============================================================================*/
{
	char *group_name;
	int return_code;

	ENTER(list_group_FE_element_name);
	if (element_group&&!dummy)
	{
		if (return_code=GET_NAME(GROUP(FE_element))(element_group,&group_name))
		{
			display_message(INFORMATION_MESSAGE,"  %s\n",group_name);
			DEALLOCATE(group_name);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"list_group_FE_element_name.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_group_FE_element_name */

int FE_element_group_intersects_list(struct GROUP(FE_element) *element_group,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <element_group> contains any elements in <element_list>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_group_intersects_list);
	if (element_group&&element_list_void)
	{
		return_code = (struct FE_element *)NULL !=
			FIRST_OBJECT_IN_GROUP_THAT(FE_element)(FE_element_is_in_list,
				element_list_void,element_group);
	}
	else
	{
		display_message(WARNING_MESSAGE,
			"FE_element_group_intersects_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_group_intersects_list */

#if defined (OLD_CODE)
int theta_increasing_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,int number_of_values,
	FE_value *values)
/*******************************************************************************
LAST MODIFIED : 30 January 1994

DESCRIPTION :
Modifies the already calculated <values>.
==============================================================================*/
{
	enum FE_basis_type *basis_type;
	FE_value *element_value,offset,start_value,value;
	int i,j,number_of_nodes_in_xi1,number_of_xi_coordinates,return_code;
	struct Standard_node_to_element_map **node_to_element_map;

	ENTER(theta_increasing_in_xi1);
	/* check arguments */
	if (component&&(STANDARD_NODE_TO_ELEMENT_MAP==component->type)&&
		(component->basis)&&(basis_type=component->basis->type)&&element&&field&&
		(0<number_of_values)&&values)
	{
		basis_type++;
		/* determine the number of nodes in the xi1 direction */
		switch (*basis_type)
		{
			case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
				case HERMITE_LAGRANGE:
			{
				number_of_nodes_in_xi1=2;
			} break;
			case QUADRATIC_LAGRANGE:
			{
				number_of_nodes_in_xi1=3;
			} break;
			case CUBIC_LAGRANGE:
			{
				number_of_nodes_in_xi1=4;
			} break;
		}
		/* check that the basis is a tensor product of the xi1 basis with the
			basis for the other directions */
		number_of_xi_coordinates=component->basis->number_of_xi_coordinates;
		basis_type++;
		i=2;
		while ((i<=number_of_xi_coordinates)&&(NO_RELATION== *basis_type))
		{
			basis_type += i;
			i++;
		}
		if ((i>number_of_xi_coordinates)&&(0==(component->map).standard_node_based.
			number_of_nodes%number_of_nodes_in_xi1)&&(node_to_element_map=
			(component->map).standard_node_based.node_to_element_maps))
		{
			element_value=values;
			offset=0;
			for (i=(component->map).standard_node_based.number_of_nodes/
				number_of_nodes_in_xi1;i>0;i--)
			{
				start_value= *element_value;
				for (j=number_of_nodes_in_xi1-1;j>0;j--)
				{
					value= *element_value;
					element_value += (*node_to_element_map)->number_of_nodal_values;
					*element_value += offset;
					if (value>= *element_value)
					{
						*element_value += 2*PI;
					}
					node_to_element_map++;
				}
				if (i>1)
				{
					element_value += (*node_to_element_map)->number_of_nodal_values;
					node_to_element_map++;
					value= *element_value;
					if (value>start_value+PI)
					{
						offset= -2*PI;
						*element_value += offset;
					}
					else
					{
						if (value<start_value-PI)
						{
							offset=2*PI;
							*element_value += offset;
						}
						else
						{
							offset=0;
						}
					}
				}
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"theta_increasing_in_xi1.  Not a tensor product basis");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"theta_increasing_in_xi1.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* theta_increasing_in_xi1 */
#endif

int theta_increasing_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,int number_of_values,
	FE_value *values)
/*******************************************************************************
LAST MODIFIED : 8 April 1999

DESCRIPTION :
Modifies the already calculated <values>.
???DB.  Only for certain bases
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	char all_on_axis;
	enum Coordinate_system_type coordinate_system_type;
	FE_value *element_value,*element_value_2,node_value,offset_xi1_xi2,
		offset_xi2_xi3,value_xi1,value_xi2,value_xi3;
	int *basis_type,i,j,k,number_of_nodes_in_xi1,number_of_nodes_in_xi2,
		number_of_nodes_in_xi3,return_code,xi2_basis_type;
	struct FE_element_field *element_field;
	struct FE_element_field_component *axis_component;
	struct FE_node **node;
	struct Standard_node_to_element_map **node_to_element_map,
		**node_to_element_map_2;

	ENTER(theta_increasing_in_xi1);
	/* check arguments */
	if (component&&(STANDARD_NODE_TO_ELEMENT_MAP==component->type)&&
		(node_to_element_map=(component->map).standard_node_based.
		node_to_element_maps)&&(component->basis)&&
		(basis_type=component->basis->type)&&((1== *basis_type)||
		((2== *basis_type)&&(NO_RELATION==basis_type[2]))||
		((3== *basis_type)&&(NO_RELATION==basis_type[2])&&
		(NO_RELATION==basis_type[3])&&(NO_RELATION==basis_type[5])))&&
		element&&field&&(0<number_of_values)&&values)
	{
		coordinate_system_type=get_coordinate_system_type(
			get_FE_field_coordinate_system(field));
		if ((3==get_FE_field_number_of_components(field))&&
			((CYLINDRICAL_POLAR==coordinate_system_type)||
			(OBLATE_SPHEROIDAL==coordinate_system_type)||
			(PROLATE_SPHEROIDAL==coordinate_system_type)))
		{
		
			element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				field,element->information->fields->element_field_list);
	
			if (element_field)
			{
				switch (coordinate_system_type)
				{
					case CYLINDRICAL_POLAR:
					{
						if (component==(element_field->components)[1])
						{
							axis_component=(element_field->components)[0];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
					case OBLATE_SPHEROIDAL:
					case PROLATE_SPHEROIDAL:
					{
						if (component==(element_field->components)[2])
						{
							axis_component=(element_field->components)[1];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
				}
			}
			if (element_field)
			{
				/* determine the number of nodes in the xi1 direction */
				switch (basis_type[1])
				{
					case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
						case HERMITE_LAGRANGE:
					{
						number_of_nodes_in_xi1=2;
					} break;
					case QUADRATIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=3;
					} break;
					case CUBIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=4;
					} break;
				}
				/* determine the number of nodes in the xi2 direction */
				if (1== *basis_type)
				{
					number_of_nodes_in_xi2=1;
				}
				else
				{
					if (2== *basis_type)
					{
						xi2_basis_type=basis_type[3];
					}
					else
					{
						xi2_basis_type=basis_type[4];
					}
					switch (xi2_basis_type)
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi2=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=4;
						} break;
					}
				}
				/* determine the number of nodes in the xi3 direction */
				if (3== *basis_type)
				{
					switch (basis_type[6])
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi3=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=4;
						} break;
					}
				}
				else
				{
					number_of_nodes_in_xi3=1;
				}
				/* check for nodes on the z axis */
				node=element->information->nodes;
				/* xi2=0 face */
				if (1<number_of_nodes_in_xi2)
				{
					all_on_axis=1;
				}
				else
				{
					all_on_axis=0;
				}
				node_to_element_map=(axis_component->map).standard_node_based.
					node_to_element_maps;
				k=number_of_nodes_in_xi3;
				while (all_on_axis&&(k>0))
				{
					i=number_of_nodes_in_xi1;
					while (all_on_axis&&(i>0))
					{
						switch (coordinate_system_type)
						{
							case PROLATE_SPHEROIDAL:
							case OBLATE_SPHEROIDAL:
							{
								calculate_FE_field(field,1,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if ((0!=node_value)&&(PI!=node_value))
								{
									all_on_axis=0;
								}
							} break;
							case CYLINDRICAL_POLAR:
							{
								calculate_FE_field(field,0,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if (0!=node_value)
								{
									all_on_axis=0;
								}
							} break;
						}
						node_to_element_map++;
						i--;
					}
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k--;
				}
				if (all_on_axis)
				{
					element_value=values;
					node_to_element_map=(component->map).standard_node_based.
						node_to_element_maps;
					element_value_2=values;
					node_to_element_map_2=node_to_element_map;
					for (i=number_of_nodes_in_xi1;i>0;i--)
					{
						element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
						node_to_element_map_2++;
					}
					for (k=number_of_nodes_in_xi3;k>0;k--)
					{
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							*element_value= *element_value_2;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 +=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
						}
						if (k>1)
						{
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
				}
				else
				{
					/* xi2=1 face */
					if (1<number_of_nodes_in_xi2)
					{
						all_on_axis=1;
					}
					else
					{
						all_on_axis=0;
					}
					node_to_element_map=(axis_component->map).standard_node_based.
						node_to_element_maps;
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k=number_of_nodes_in_xi3;
					while (all_on_axis&&(k>0))
					{
						i=number_of_nodes_in_xi1;
						while (all_on_axis&&(i>0))
						{
							switch (coordinate_system_type)
							{
								case PROLATE_SPHEROIDAL:
								case OBLATE_SPHEROIDAL:
								{
									calculate_FE_field(field,1,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if ((0!=node_value)&&(PI!=node_value))
									{
										all_on_axis=0;
									}
								} break;
								case CYLINDRICAL_POLAR:
								{
									calculate_FE_field(field,0,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if (0!=node_value)
									{
										all_on_axis=0;
									}
								} break;
							}
							node_to_element_map++;
							i--;
						}
						node_to_element_map +=
							(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
						k--;
					}
					if (all_on_axis)
					{
						element_value=values;
						node_to_element_map=(component->map).standard_node_based.
							node_to_element_maps;
						for (j=number_of_nodes_in_xi2;j>1;j--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
							}
						}
						element_value_2=element_value;
						node_to_element_map_2=node_to_element_map;
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							element_value_2 -=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2--;
						}
						for (k=number_of_nodes_in_xi3;k>0;k--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								*element_value= *element_value_2;
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
					else
					{
						/* xi3=0 face */
						if (1<number_of_nodes_in_xi3)
						{
							all_on_axis=1;
						}
						else
						{
							all_on_axis=0;
						}
						node_to_element_map=(axis_component->map).standard_node_based.
							node_to_element_maps;
						j=number_of_nodes_in_xi2;
						while (all_on_axis&&(j>0))
						{
							i=number_of_nodes_in_xi1;
							while (all_on_axis&&(i>0))
							{
								switch (coordinate_system_type)
								{
									case PROLATE_SPHEROIDAL:
									case OBLATE_SPHEROIDAL:
									{
										calculate_FE_field(field,1,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if ((0!=node_value)&&(PI!=node_value))
										{
											all_on_axis=0;
										}
									} break;
									case CYLINDRICAL_POLAR:
									{
										calculate_FE_field(field,0,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if (0!=node_value)
										{
											all_on_axis=0;
										}
									} break;
								}
								node_to_element_map++;
								i--;
							}
							j--;
						}
						if (all_on_axis)
						{
							element_value=values;
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							element_value_2=values;
							node_to_element_map_2=node_to_element_map;
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>0;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									*element_value= *element_value_2;
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
						else
						{
							/* xi3=1 face */
							if (1<number_of_nodes_in_xi3)
							{
								all_on_axis=1;
							}
							else
							{
								all_on_axis=0;
							}
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							node_to_element_map += (number_of_nodes_in_xi3-1)*
								number_of_nodes_in_xi2*number_of_nodes_in_xi1;
							j=number_of_nodes_in_xi2;
							while (all_on_axis&&(j>0))
							{
								i=number_of_nodes_in_xi1;
								while (all_on_axis&&(i>0))
								{
									switch (coordinate_system_type)
									{
										case PROLATE_SPHEROIDAL:
										case OBLATE_SPHEROIDAL:
										{
											calculate_FE_field(field,1,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if ((0!=node_value)&&(PI!=node_value))
											{
												all_on_axis=0;
											}
										} break;
										case CYLINDRICAL_POLAR:
										{
											calculate_FE_field(field,0,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if (0!=node_value)
											{
												all_on_axis=0;
											}
										} break;
									}
									node_to_element_map++;
									i--;
								}
								j--;
							}
							if (all_on_axis)
							{
								element_value=values;
								node_to_element_map=(component->map).standard_node_based.
									node_to_element_maps;
								for (k=number_of_nodes_in_xi3;k>1;k--)
								{
									for (j=number_of_nodes_in_xi2;j>0;j--)
									{
										for (i=number_of_nodes_in_xi1;i>0;i--)
										{
											element_value +=
												(*node_to_element_map)->number_of_nodal_values;
											node_to_element_map++;
										}
									}
								}
								element_value_2=element_value;
								node_to_element_map_2=node_to_element_map;
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										element_value_2 -= (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2--;
									}
								}
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										*element_value= *element_value_2;
										element_value += (*node_to_element_map)->
											number_of_nodal_values;
										node_to_element_map++;
										element_value_2 += (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2++;
									}
								}
							}
						}
					}
				}
#if defined (OLD_CODE)
				element_value=values;
				element_value_2=values;
				node_to_element_map_2=node_to_element_map;
				for (i=number_of_nodes_in_xi1;i>0;i--)
				{
					element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
					node_to_element_map_2++;
				}
				for (k=number_of_nodes_in_xi3;k>0;k--)
				{
					for (j=number_of_nodes_in_xi2;j>1;j--)
					{
						for (i=number_of_nodes_in_xi1;i>1;i--)
						{
							if (*element_value== *(element_value+((*node_to_element_map)->
								number_of_nodal_values)))
							{
								*element_value= *element_value_2;
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
								element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
								node_to_element_map_2++;
								*element_value= *element_value_2;
							}
							else
							{
								if (*element_value_2== *(element_value_2+((*node_to_element_map)->
									number_of_nodal_values)))
								{
									*element_value_2= *element_value;
									element_value += (*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 +=
										(*node_to_element_map_2)->number_of_nodal_values;
									node_to_element_map_2++;
									*element_value_2= *element_value;
								}
								else
								{
									element_value += (*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 +=
										(*node_to_element_map_2)->number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
						element_value += (*node_to_element_map)->number_of_nodal_values;
						node_to_element_map++;
						element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
						node_to_element_map_2++;
					}
					if (k>1)
					{
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
						}
					}
				}
#endif /* defined (OLD_CODE) */
				element_value=values;
				node_to_element_map=(component->map).standard_node_based.
					node_to_element_maps;
				offset_xi1_xi2=0;
				offset_xi2_xi3=0;
				/* make sure increasing in xi1 and smooth in xi2 & xi3 */
				for (k=number_of_nodes_in_xi3;k>0;k--)
				{
					value_xi3= *element_value;
					for (j=number_of_nodes_in_xi2;j>0;j--)
					{
						value_xi2= *element_value;
						for (i=number_of_nodes_in_xi1;i>1;i--)
						{
							value_xi1= *element_value;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							*element_value += offset_xi1_xi2+offset_xi2_xi3;
							/*???DB.  <= needed for single prolate, but seems to cause
								problems for heart */
							if (value_xi1>= *element_value)
							{
								*element_value += 2*PI;
							}
							node_to_element_map++;
						}
						element_value += (*node_to_element_map)->number_of_nodal_values;
						node_to_element_map++;
						if (j>1)
						{
							value_xi1= *element_value;
							if (value_xi1>value_xi2+PI)
							{
								offset_xi1_xi2= -2*PI;
								*element_value += offset_xi1_xi2;
							}
							else
							{
								if (value_xi1<value_xi2-PI)
								{
									offset_xi1_xi2=2*PI;
									*element_value += offset_xi1_xi2;
								}
								else
								{
									offset_xi1_xi2=0;
								}
							}
						}
					}
					if (k>1)
					{
						offset_xi1_xi2=0;
						value_xi2= *element_value;
						if (value_xi2>value_xi3+PI)
						{
							offset_xi2_xi3= -2*PI;
							*element_value += offset_xi2_xi3;
						}
						else
						{
							if (value_xi2<value_xi3-PI)
							{
								offset_xi2_xi3=2*PI;
								*element_value += offset_xi2_xi3;
							}
							else
							{
								offset_xi2_xi3=0;
							}
						}
					}
				}
			}
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"theta_increasing_in_xi1.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* theta_increasing_in_xi1 */

int theta_non_decreasing_in_xi1(
	struct FE_element_field_component *component,struct FE_element *element,
	struct FE_field *field,int number_of_values,FE_value *values)
/*******************************************************************************
LAST MODIFIED : 8 April 1999

DESCRIPTION :
Modifies the already calculated <values>.
???DB.  Only for certain bases
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	char all_on_axis;
	enum Coordinate_system_type coordinate_system_type;
	FE_value *element_value,*element_value_2,node_value,offset_xi1_xi2,
		offset_xi2_xi3,value_xi1,value_xi2,value_xi3;
	int *basis_type,i,j,k,number_of_nodes_in_xi1,number_of_nodes_in_xi2,
		number_of_nodes_in_xi3,return_code,xi2_basis_type;
	struct FE_element_field *element_field;
	struct FE_element_field_component *axis_component;
	struct FE_node **node;
	struct Standard_node_to_element_map **node_to_element_map,
		**node_to_element_map_2;

	ENTER(theta_non_decreasing_in_xi1);
	/* check arguments */
	if (component&&(STANDARD_NODE_TO_ELEMENT_MAP==component->type)&&
		(node_to_element_map=(component->map).standard_node_based.
		node_to_element_maps)&&(component->basis)&&
		(basis_type=component->basis->type)&&((1== *basis_type)||
		((2== *basis_type)&&(NO_RELATION==basis_type[2]))||
		((3== *basis_type)&&(NO_RELATION==basis_type[2])&&
		(NO_RELATION==basis_type[3])&&(NO_RELATION==basis_type[5])))&&
		element&&field&&(0<number_of_values)&&values)
	{
		coordinate_system_type=get_coordinate_system_type(
			get_FE_field_coordinate_system(field));
		if ((3==get_FE_field_number_of_components(field))&&
			((CYLINDRICAL_POLAR==coordinate_system_type)||
			(OBLATE_SPHEROIDAL==coordinate_system_type)||
			(PROLATE_SPHEROIDAL==coordinate_system_type)))
		{
				
			element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
					field,element->information->fields->element_field_list);
		
			if (element_field)
			{
				switch (coordinate_system_type)
				{
					case CYLINDRICAL_POLAR:
					{
						if (component==(element_field->components)[1])
						{
							axis_component=(element_field->components)[0];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
					case OBLATE_SPHEROIDAL:
					case PROLATE_SPHEROIDAL:
					{
						if (component==(element_field->components)[2])
						{
							axis_component=(element_field->components)[1];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
				}
			}
			if (element_field)
			{
				/* determine the number of nodes in the xi1 direction */
				switch (basis_type[1])
				{
					case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
						case HERMITE_LAGRANGE:
					{
						number_of_nodes_in_xi1=2;
					} break;
					case QUADRATIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=3;
					} break;
					case CUBIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=4;
					} break;
				}
				/* determine the number of nodes in the xi2 direction */
				if (1== *basis_type)
				{
					number_of_nodes_in_xi2=1;
				}
				else
				{
					if (2== *basis_type)
					{
						xi2_basis_type=basis_type[3];
					}
					else
					{
						xi2_basis_type=basis_type[4];
					}
					switch (xi2_basis_type)
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi2=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=4;
						} break;
					}
				}
				/* determine the number of nodes in the xi3 direction */
				if (3== *basis_type)
				{
					switch (basis_type[6])
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi3=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=4;
						} break;
					}
				}
				else
				{
					number_of_nodes_in_xi3=1;
				}
				/* check for nodes on the z axis */
				node=element->information->nodes;
				/* xi2=0 face */
				if (1<number_of_nodes_in_xi2)
				{
					all_on_axis=1;
				}
				else
				{
					all_on_axis=0;
				}
				node_to_element_map=(axis_component->map).standard_node_based.
					node_to_element_maps;
				k=number_of_nodes_in_xi3;
				while (all_on_axis&&(k>0))
				{
					i=number_of_nodes_in_xi1;
					while (all_on_axis&&(i>0))
					{
						switch (coordinate_system_type)
						{
							case PROLATE_SPHEROIDAL:
							case OBLATE_SPHEROIDAL:
							{
								calculate_FE_field(field,1,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if ((0!=node_value)&&(PI!=node_value))
								{
									all_on_axis=0;
								}
							} break;
							case CYLINDRICAL_POLAR:
							{
								calculate_FE_field(field,0,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if (0!=node_value)
								{
									all_on_axis=0;
								}
							} break;
						}
						node_to_element_map++;
						i--;
					}
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k--;
				}
				if (all_on_axis)
				{
					element_value=values;
					node_to_element_map=(component->map).standard_node_based.
						node_to_element_maps;
					element_value_2=values;
					node_to_element_map_2=node_to_element_map;
					for (i=number_of_nodes_in_xi1;i>0;i--)
					{
						element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
						node_to_element_map_2++;
					}
					for (k=number_of_nodes_in_xi3;k>0;k--)
					{
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							*element_value= *element_value_2;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 +=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
						}
						if (k>1)
						{
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
				}
				else
				{
					/* xi2=1 face */
					if (1<number_of_nodes_in_xi2)
					{
						all_on_axis=1;
					}
					else
					{
						all_on_axis=0;
					}
					node_to_element_map=(axis_component->map).standard_node_based.
						node_to_element_maps;
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k=number_of_nodes_in_xi3;
					while (all_on_axis&&(k>0))
					{
						i=number_of_nodes_in_xi1;
						while (all_on_axis&&(i>0))
						{
							switch (coordinate_system_type)
							{
								case PROLATE_SPHEROIDAL:
								case OBLATE_SPHEROIDAL:
								{
									calculate_FE_field(field,1,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if ((0!=node_value)&&(PI!=node_value))
									{
										all_on_axis=0;
									}
								} break;
								case CYLINDRICAL_POLAR:
								{
									calculate_FE_field(field,0,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if (0!=node_value)
									{
										all_on_axis=0;
									}
								} break;
							}
							node_to_element_map++;
							i--;
						}
						node_to_element_map +=
							(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
						k--;
					}
					if (all_on_axis)
					{
						element_value=values;
						node_to_element_map=(component->map).standard_node_based.
							node_to_element_maps;
						for (j=number_of_nodes_in_xi2;j>1;j--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
							}
						}
						element_value_2=element_value;
						node_to_element_map_2=node_to_element_map;
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							element_value_2 -=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2--;
						}
						for (k=number_of_nodes_in_xi3;k>0;k--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								*element_value= *element_value_2;
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
					else
					{
						/* xi3=0 face */
						if (1<number_of_nodes_in_xi3)
						{
							all_on_axis=1;
						}
						else
						{
							all_on_axis=0;
						}
						node_to_element_map=(axis_component->map).standard_node_based.
							node_to_element_maps;
						j=number_of_nodes_in_xi2;
						while (all_on_axis&&(j>0))
						{
							i=number_of_nodes_in_xi1;
							while (all_on_axis&&(i>0))
							{
								switch (coordinate_system_type)
								{
									case PROLATE_SPHEROIDAL:
									case OBLATE_SPHEROIDAL:
									{
										calculate_FE_field(field,1,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if ((0!=node_value)&&(PI!=node_value))
										{
											all_on_axis=0;
										}
									} break;
									case CYLINDRICAL_POLAR:
									{
										calculate_FE_field(field,0,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if (0!=node_value)
										{
											all_on_axis=0;
										}
									} break;
								}
								node_to_element_map++;
								i--;
							}
							j--;
						}
						if (all_on_axis)
						{
							element_value=values;
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							element_value_2=values;
							node_to_element_map_2=node_to_element_map;
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>0;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									*element_value= *element_value_2;
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
						else
						{
							/* xi3=1 face */
							if (1<number_of_nodes_in_xi3)
							{
								all_on_axis=1;
							}
							else
							{
								all_on_axis=0;
							}
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							node_to_element_map += (number_of_nodes_in_xi3-1)*
								number_of_nodes_in_xi2*number_of_nodes_in_xi1;
							j=number_of_nodes_in_xi2;
							while (all_on_axis&&(j>0))
							{
								i=number_of_nodes_in_xi1;
								while (all_on_axis&&(i>0))
								{
									switch (coordinate_system_type)
									{
										case PROLATE_SPHEROIDAL:
										case OBLATE_SPHEROIDAL:
										{
											calculate_FE_field(field,1,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if ((0!=node_value)&&(PI!=node_value))
											{
												all_on_axis=0;
											}
										} break;
										case CYLINDRICAL_POLAR:
										{
											calculate_FE_field(field,0,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if (0!=node_value)
											{
												all_on_axis=0;
											}
										} break;
									}
									node_to_element_map++;
									i--;
								}
								j--;
							}
							if (all_on_axis)
							{
								element_value=values;
								node_to_element_map=(component->map).standard_node_based.
									node_to_element_maps;
								for (k=number_of_nodes_in_xi3;k>1;k--)
								{
									for (j=number_of_nodes_in_xi2;j>0;j--)
									{
										for (i=number_of_nodes_in_xi1;i>0;i--)
										{
											element_value +=
												(*node_to_element_map)->number_of_nodal_values;
											node_to_element_map++;
										}
									}
								}
								element_value_2=element_value;
								node_to_element_map_2=node_to_element_map;
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										element_value_2 -= (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2--;
									}
								}
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										*element_value= *element_value_2;
										element_value += (*node_to_element_map)->
											number_of_nodal_values;
										node_to_element_map++;
										element_value_2 += (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2++;
									}
								}
							}
						}
					}
				}
#if defined (OLD_CODE)
		element_value=values;
		element_value_2=values;
		node_to_element_map_2=node_to_element_map;
		for (i=number_of_nodes_in_xi1;i>0;i--)
		{
			element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
			node_to_element_map_2++;
		}
		for (k=number_of_nodes_in_xi3;k>0;k--)
		{
			for (j=number_of_nodes_in_xi2;j>1;j--)
			{
				for (i=number_of_nodes_in_xi1;i>1;i--)
				{
					if (*element_value== *(element_value+((*node_to_element_map)->
						number_of_nodal_values)))
					{
						*element_value= *element_value_2;
						element_value += (*node_to_element_map)->number_of_nodal_values;
						node_to_element_map++;
						element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
						node_to_element_map_2++;
						*element_value= *element_value_2;
					}
					else
					{
						if (*element_value_2== *(element_value_2+((*node_to_element_map)->
							number_of_nodal_values)))
						{
							*element_value_2= *element_value;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 +=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
							*element_value_2= *element_value;
						}
						else
						{
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 +=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
						}
					}
				}
				element_value += (*node_to_element_map)->number_of_nodal_values;
				node_to_element_map++;
				element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
				node_to_element_map_2++;
			}
			if (k>1)
			{
				for (i=number_of_nodes_in_xi1;i>0;i--)
				{
					element_value += (*node_to_element_map)->number_of_nodal_values;
					node_to_element_map++;
					element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
					node_to_element_map_2++;
				}
			}
		}
#endif /* defined (OLD_CODE) */
				element_value=values;
				node_to_element_map=(component->map).standard_node_based.
					node_to_element_maps;
				offset_xi1_xi2=0;
				offset_xi2_xi3=0;
				/* make sure non-decreasing in xi1 and smooth in xi2 & xi3 */
				for (k=number_of_nodes_in_xi3;k>0;k--)
				{
					value_xi3= *element_value;
					for (j=number_of_nodes_in_xi2;j>0;j--)
					{
						value_xi2= *element_value;
						for (i=number_of_nodes_in_xi1;i>1;i--)
						{
							value_xi1= *element_value;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							*element_value += offset_xi1_xi2+offset_xi2_xi3;
							/*???DB.  <= needed for single prolate, but seems to cause
								problems for heart */
							if (value_xi1> *element_value)
							{
								*element_value += 2*PI;
							}
							node_to_element_map++;
						}
						element_value += (*node_to_element_map)->number_of_nodal_values;
						node_to_element_map++;
						if (j>1)
						{
							value_xi1= *element_value;
							if (value_xi1>value_xi2+PI)
							{
								offset_xi1_xi2= -2*PI;
								*element_value += offset_xi1_xi2;
							}
							else
							{
								if (value_xi1<value_xi2-PI)
								{
									offset_xi1_xi2=2*PI;
									*element_value += offset_xi1_xi2;
								}
								else
								{
									offset_xi1_xi2=0;
								}
							}
						}
					}
					if (k>1)
					{
						offset_xi1_xi2=0;
						value_xi2= *element_value;
						if (value_xi2>value_xi3+PI)
						{
							offset_xi2_xi3= -2*PI;
							*element_value += offset_xi2_xi3;
						}
						else
						{
							if (value_xi2<value_xi3-PI)
							{
								offset_xi2_xi3=2*PI;
								*element_value += offset_xi2_xi3;
							}
							else
							{
								offset_xi2_xi3=0;
							}
						}
					}
				}
			}
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"theta_non_decreasing_in_xi1.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* theta_non_decreasing_in_xi1 */

#if defined (CODE_FRAGMENTS)
int theta_decreasing_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,int number_of_values,
	FE_value *values)
/*******************************************************************************
LAST MODIFIED : 30 January 1994

DESCRIPTION :
Modifies the already calculated <values>.
==============================================================================*/
{
	enum FE_basis_type *basis_type;
	FE_value *element_value,offset,start_value,value;
	int i,j,number_of_nodes_in_xi1,number_of_xi_coordinates,return_code;
	struct Standard_node_to_element_map **node_to_element_map;

	ENTER(theta_decreasing_in_xi1);
	/* check arguments */
	if (component&&(STANDARD_NODE_TO_ELEMENT_MAP==component->type)&&
		(component->basis)&&(basis_type=component->basis->type)&&element&&field&&
		(0<number_of_values)&&values)
	{
		basis_type++;
		/* determine the number of nodes in the xi1 direction */
		switch (*(basis_type))
		{
			case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
				case HERMITE_LAGRANGE:
			{
				number_of_nodes_in_xi1=2;
			} break;
			case QUADRATIC_LAGRANGE:
			{
				number_of_nodes_in_xi1=3;
			} break;
			case CUBIC_LAGRANGE:
			{
				number_of_nodes_in_xi1=4;
			} break;
		}
		/* check that the basis is a tensor product of the xi1 basis with the
			basis for the other directions */
		number_of_xi_coordinates=component->basis->number_of_xi_coordinates;
		basis_type++;
		i=2;
		while ((i<=number_of_xi_coordinates)&&(NO_RELATION== *basis_type))
		{
			basis_type += i;
			i++;
		}
		if ((i>number_of_xi_coordinates)&&(0==(component->map).standard_node_based.
			number_of_nodes%number_of_nodes_in_xi1)&&(node_to_element_map=
			(component->map).standard_node_based.node_to_element_maps))
		{
			element_value=values;
			offset=0;
			for (i=(component->map).standard_node_based.number_of_nodes/
				number_of_nodes_in_xi1;i>0;i--)
			{
				start_value= *element_value;
				for (j=number_of_nodes_in_xi1-1;j>0;j--)
				{
					value= *element_value;
					element_value += (*node_to_element_map)->number_of_nodal_values;
					*element_value += offset;
					if (value<= *element_value)
					{
						*element_value -= 2*PI;
					}
					node_to_element_map++;
				}
				if (i>1)
				{
					element_value += (*node_to_element_map)->number_of_nodal_values;
					node_to_element_map++;
					value= *element_value;
					if (value>start_value+PI)
					{
						offset= -2*PI;
						*element_value += offset;
					}
					else
					{
						if (value<start_value-PI)
						{
							offset=2*PI;
							*element_value += offset;
						}
						else
						{
							offset=0;
						}
					}
				}
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"theta_decreasing_in_xi1.  Not a tensor product basis");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"theta_decreasing_in_xi1.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* theta_decreasing_in_xi1 */
#endif

int theta_decreasing_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,int number_of_values,
	FE_value *values)
/*******************************************************************************
LAST MODIFIED : 8 April 1999

DESCRIPTION :
Modifies the already calculated <values>.
???DB.  Only for certain bases
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	char all_on_axis;
	enum Coordinate_system_type coordinate_system_type;
	FE_value *element_value,*element_value_2,node_value,offset_xi1_xi2,
		offset_xi2_xi3,value_xi1,value_xi2,value_xi3;
	int *basis_type,i,j,k,number_of_nodes_in_xi1,number_of_nodes_in_xi2,
		number_of_nodes_in_xi3,return_code,xi2_basis_type;
	struct FE_element_field *element_field;
	struct FE_element_field_component *axis_component;
	struct FE_node **node;
	struct Standard_node_to_element_map **node_to_element_map,
		**node_to_element_map_2;

	ENTER(theta_decreasing_in_xi1);
	/* check arguments */
	if (component&&(STANDARD_NODE_TO_ELEMENT_MAP==component->type)&&
		(node_to_element_map=(component->map).standard_node_based.
		node_to_element_maps)&&(component->basis)&&
		(basis_type=component->basis->type)&&((1== *basis_type)||
		((2== *basis_type)&&(NO_RELATION==basis_type[2]))||
		((3== *basis_type)&&(NO_RELATION==basis_type[2])&&
		(NO_RELATION==basis_type[3])&&(NO_RELATION==basis_type[5])))&&
		element&&field&&(0<number_of_values)&&values)
	{
		coordinate_system_type=get_coordinate_system_type(
			get_FE_field_coordinate_system(field));
		if ((3==get_FE_field_number_of_components(field))&&
			((CYLINDRICAL_POLAR==coordinate_system_type)||
			(OBLATE_SPHEROIDAL==coordinate_system_type)||
			(PROLATE_SPHEROIDAL==coordinate_system_type)))
		{
		
			element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
					field,element->information->fields->element_field_list);
	
			if (element_field)
			{
				switch (coordinate_system_type)
				{
					case CYLINDRICAL_POLAR:
					{
						if (component==(element_field->components)[1])
						{
							axis_component=(element_field->components)[0];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
					case OBLATE_SPHEROIDAL:
					case PROLATE_SPHEROIDAL:
					{
						if (component==(element_field->components)[2])
						{
							axis_component=(element_field->components)[1];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
				}
			}
			if (element_field)
			{
				/* determine the number of nodes in the xi1 direction */
				switch (basis_type[1])
				{
					case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
						case HERMITE_LAGRANGE:
					{
						number_of_nodes_in_xi1=2;
					} break;
					case QUADRATIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=3;
					} break;
					case CUBIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=4;
					} break;
				}
				/* determine the number of nodes in the xi2 direction */
				if (1== *basis_type)
				{
					number_of_nodes_in_xi2=1;
				}
				else
				{
					if (2== *basis_type)
					{
						xi2_basis_type=basis_type[3];
					}
					else
					{
						xi2_basis_type=basis_type[4];
					}
					switch (xi2_basis_type)
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi2=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=4;
						} break;
					}
				}
				/* determine the number of nodes in the xi3 direction */
				if (3== *basis_type)
				{
					switch (basis_type[6])
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi3=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=4;
						} break;
					}
				}
				else
				{
					number_of_nodes_in_xi3=1;
				}
				/* check for nodes on the z axis */
				node=element->information->nodes;
				/* xi2=0 face */
				if (1<number_of_nodes_in_xi2)
				{
					all_on_axis=1;
				}
				else
				{
					all_on_axis=0;
				}
				node_to_element_map=(axis_component->map).standard_node_based.
					node_to_element_maps;
				k=number_of_nodes_in_xi3;
				while (all_on_axis&&(k>0))
				{
					i=number_of_nodes_in_xi1;
					while (all_on_axis&&(i>0))
					{
						switch (coordinate_system_type)
						{
							case PROLATE_SPHEROIDAL:
							case OBLATE_SPHEROIDAL:
							{
								calculate_FE_field(field,1,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if ((0!=node_value)&&(PI!=node_value))
								{
									all_on_axis=0;
								}
							} break;
							case CYLINDRICAL_POLAR:
							{
								calculate_FE_field(field,0,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if (0!=node_value)
								{
									all_on_axis=0;
								}
							} break;
						}
						node_to_element_map++;
						i--;
					}
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k--;
				}
				if (all_on_axis)
				{
					element_value=values;
					node_to_element_map=(component->map).standard_node_based.
						node_to_element_maps;
					element_value_2=values;
					node_to_element_map_2=node_to_element_map;
					for (i=number_of_nodes_in_xi1;i>0;i--)
					{
						element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
						node_to_element_map_2++;
					}
					for (k=number_of_nodes_in_xi3;k>0;k--)
					{
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							*element_value= *element_value_2;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 +=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
						}
						if (k>1)
						{
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
				}
				else
				{
					/* xi2=1 face */
					if (1<number_of_nodes_in_xi2)
					{
						all_on_axis=1;
					}
					else
					{
						all_on_axis=0;
					}
					node_to_element_map=(axis_component->map).standard_node_based.
						node_to_element_maps;
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k=number_of_nodes_in_xi3;
					while (all_on_axis&&(k>0))
					{
						i=number_of_nodes_in_xi1;
						while (all_on_axis&&(i>0))
						{
							switch (coordinate_system_type)
							{
								case PROLATE_SPHEROIDAL:
								case OBLATE_SPHEROIDAL:
								{
									calculate_FE_field(field,1,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if ((0!=node_value)&&(PI!=node_value))
									{
										all_on_axis=0;
									}
								} break;
								case CYLINDRICAL_POLAR:
								{
									calculate_FE_field(field,0,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if (0!=node_value)
									{
										all_on_axis=0;
									}
								} break;
							}
							node_to_element_map++;
							i--;
						}
						node_to_element_map +=
							(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
						k--;
					}
					if (all_on_axis)
					{
						element_value=values;
						node_to_element_map=(component->map).standard_node_based.
							node_to_element_maps;
						for (j=number_of_nodes_in_xi2;j>1;j--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
							}
						}
						element_value_2=element_value;
						node_to_element_map_2=node_to_element_map;
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							element_value_2 -=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2--;
						}
						for (k=number_of_nodes_in_xi3;k>0;k--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								*element_value= *element_value_2;
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
					else
					{
						/* xi3=0 face */
						if (1<number_of_nodes_in_xi3)
						{
							all_on_axis=1;
						}
						else
						{
							all_on_axis=0;
						}
						node_to_element_map=(axis_component->map).standard_node_based.
							node_to_element_maps;
						j=number_of_nodes_in_xi2;
						while (all_on_axis&&(j>0))
						{
							i=number_of_nodes_in_xi1;
							while (all_on_axis&&(i>0))
							{
								switch (coordinate_system_type)
								{
									case PROLATE_SPHEROIDAL:
									case OBLATE_SPHEROIDAL:
									{
										calculate_FE_field(field,1,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if ((0!=node_value)&&(PI!=node_value))
										{
											all_on_axis=0;
										}
									} break;
									case CYLINDRICAL_POLAR:
									{
										calculate_FE_field(field,0,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if (0!=node_value)
										{
											all_on_axis=0;
										}
									} break;
								}
								node_to_element_map++;
								i--;
							}
							j--;
						}
						if (all_on_axis)
						{
							element_value=values;
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							element_value_2=values;
							node_to_element_map_2=node_to_element_map;
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>0;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									*element_value= *element_value_2;
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
						else
						{
							/* xi3=1 face */
							if (1<number_of_nodes_in_xi3)
							{
								all_on_axis=1;
							}
							else
							{
								all_on_axis=0;
							}
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							node_to_element_map += (number_of_nodes_in_xi3-1)*
								number_of_nodes_in_xi2*number_of_nodes_in_xi1;
							j=number_of_nodes_in_xi2;
							while (all_on_axis&&(j>0))
							{
								i=number_of_nodes_in_xi1;
								while (all_on_axis&&(i>0))
								{
									switch (coordinate_system_type)
									{
										case PROLATE_SPHEROIDAL:
										case OBLATE_SPHEROIDAL:
										{
											calculate_FE_field(field,1,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if ((0!=node_value)&&(PI!=node_value))
											{
												all_on_axis=0;
											}
										} break;
										case CYLINDRICAL_POLAR:
										{
											calculate_FE_field(field,0,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if (0!=node_value)
											{
												all_on_axis=0;
											}
										} break;
									}
									node_to_element_map++;
									i--;
								}
								j--;
							}
							if (all_on_axis)
							{
								element_value=values;
								node_to_element_map=(component->map).standard_node_based.
									node_to_element_maps;
								for (k=number_of_nodes_in_xi3;k>1;k--)
								{
									for (j=number_of_nodes_in_xi2;j>0;j--)
									{
										for (i=number_of_nodes_in_xi1;i>0;i--)
										{
											element_value +=
												(*node_to_element_map)->number_of_nodal_values;
											node_to_element_map++;
										}
									}
								}
								element_value_2=element_value;
								node_to_element_map_2=node_to_element_map;
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										element_value_2 -= (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2--;
									}
								}
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										*element_value= *element_value_2;
										element_value += (*node_to_element_map)->
											number_of_nodal_values;
										node_to_element_map++;
										element_value_2 += (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2++;
									}
								}
							}
						}
					}
				}
				element_value=values;
				node_to_element_map=(component->map).standard_node_based.
					node_to_element_maps;
				offset_xi1_xi2=0;
				offset_xi2_xi3=0;
				/* make sure decreasing in xi1 and smooth in xi2 & xi3 */
				for (k=number_of_nodes_in_xi3;k>0;k--)
				{
					value_xi3= *element_value;
					for (j=number_of_nodes_in_xi2;j>0;j--)
					{
						value_xi2= *element_value;
						for (i=number_of_nodes_in_xi1;i>1;i--)
						{
							value_xi1= *element_value;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							*element_value += offset_xi1_xi2+offset_xi2_xi3;
							/*???DB.  <= needed for single prolate, but seems to cause
								problems for heart */
							if (value_xi1<= *element_value)
							{
								*element_value -= 2*PI;
							}
							node_to_element_map++;
						}
						element_value += (*node_to_element_map)->number_of_nodal_values;
						node_to_element_map++;
						if (j>1)
						{
							value_xi1= *element_value;
							if (value_xi1>value_xi2+PI)
							{
								offset_xi1_xi2= -2*PI;
								*element_value += offset_xi1_xi2;
							}
							else
							{
								if (value_xi1<value_xi2-PI)
								{
									offset_xi1_xi2=2*PI;
									*element_value += offset_xi1_xi2;
								}
								else
								{
									offset_xi1_xi2=0;
								}
							}
						}
					}
					if (k>1)
					{
						offset_xi1_xi2=0;
						value_xi2= *element_value;
						if (value_xi2>value_xi3+PI)
						{
							offset_xi2_xi3= -2*PI;
							*element_value += offset_xi2_xi3;
						}
						else
						{
							if (value_xi2<value_xi3-PI)
							{
								offset_xi2_xi3=2*PI;
								*element_value += offset_xi2_xi3;
							}
							else
							{
								offset_xi2_xi3=0;
							}
						}
					}
				}
			}
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"theta_decreasing_in_xi1.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* theta_decreasing_in_xi1 */

int theta_non_increasing_in_xi1(
	struct FE_element_field_component *component,struct FE_element *element,
	struct FE_field *field,int number_of_values,FE_value *values)
/*******************************************************************************
LAST MODIFIED : 8 April 1999

DESCRIPTION :
Modifies the already calculated <values>.
???DB.  Only for certain bases
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	char all_on_axis;
	enum Coordinate_system_type coordinate_system_type;
	FE_value *element_value,*element_value_2,node_value,offset_xi1_xi2,
		offset_xi2_xi3,value_xi1,value_xi2,value_xi3;
	int *basis_type,i,j,k,number_of_nodes_in_xi1,number_of_nodes_in_xi2,
		number_of_nodes_in_xi3,return_code,xi2_basis_type;
	struct FE_element_field *element_field;
	struct FE_element_field_component *axis_component;
	struct FE_node **node;
	struct Standard_node_to_element_map **node_to_element_map,
		**node_to_element_map_2;

	ENTER(theta_non_increasing_in_xi1);
	/* check arguments */
	if (component&&(STANDARD_NODE_TO_ELEMENT_MAP==component->type)&&
		(node_to_element_map=(component->map).standard_node_based.
		node_to_element_maps)&&(component->basis)&&
		(basis_type=component->basis->type)&&((1== *basis_type)||
		((2== *basis_type)&&(NO_RELATION==basis_type[2]))||
		((3== *basis_type)&&(NO_RELATION==basis_type[2])&&
		(NO_RELATION==basis_type[3])&&(NO_RELATION==basis_type[5])))&&
		element&&field&&(0<number_of_values)&&values)
	{
		coordinate_system_type=get_coordinate_system_type(
			get_FE_field_coordinate_system(field));
		if ((3==get_FE_field_number_of_components(field))&&
			((CYLINDRICAL_POLAR==coordinate_system_type)||
			(OBLATE_SPHEROIDAL==coordinate_system_type)||
			(PROLATE_SPHEROIDAL==coordinate_system_type)))
		{
	
			element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
					field,element->information->fields->element_field_list);
		
			if (element_field)
			{
				switch (coordinate_system_type)
				{
					case CYLINDRICAL_POLAR:
					{
						if (component==(element_field->components)[1])
						{
							axis_component=(element_field->components)[0];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
					case OBLATE_SPHEROIDAL:
					case PROLATE_SPHEROIDAL:
					{
						if (component==(element_field->components)[2])
						{
							axis_component=(element_field->components)[1];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
				}
			}
			if (element_field)
			{
				/* determine the number of nodes in the xi1 direction */
				switch (basis_type[1])
				{
					case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
						case HERMITE_LAGRANGE:
					{
						number_of_nodes_in_xi1=2;
					} break;
					case QUADRATIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=3;
					} break;
					case CUBIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=4;
					} break;
				}
				/* determine the number of nodes in the xi2 direction */
				if (1== *basis_type)
				{
					number_of_nodes_in_xi2=1;
				}
				else
				{
					if (2== *basis_type)
					{
						xi2_basis_type=basis_type[3];
					}
					else
					{
						xi2_basis_type=basis_type[4];
					}
					switch (xi2_basis_type)
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi2=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=4;
						} break;
					}
				}
				/* determine the number of nodes in the xi3 direction */
				if (3== *basis_type)
				{
					switch (basis_type[6])
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi3=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=4;
						} break;
					}
				}
				else
				{
					number_of_nodes_in_xi3=1;
				}
				/* check for nodes on the z axis */
				node=element->information->nodes;
				/* xi2=0 face */
				if (1<number_of_nodes_in_xi2)
				{
					all_on_axis=1;
				}
				else
				{
					all_on_axis=0;
				}
				node_to_element_map=(axis_component->map).standard_node_based.
					node_to_element_maps;
				k=number_of_nodes_in_xi3;
				while (all_on_axis&&(k>0))
				{
					i=number_of_nodes_in_xi1;
					while (all_on_axis&&(i>0))
					{
						switch (coordinate_system_type)
						{
							case PROLATE_SPHEROIDAL:
							case OBLATE_SPHEROIDAL:
							{
								calculate_FE_field(field,1,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if ((0!=node_value)&&(PI!=node_value))
								{
									all_on_axis=0;
								}
							} break;
							case CYLINDRICAL_POLAR:
							{
								calculate_FE_field(field,0,node[(*node_to_element_map)->
									node_index],(struct FE_element *)NULL,(FE_value *)NULL,
									&node_value);
								if (0!=node_value)
								{
									all_on_axis=0;
								}
							} break;
						}
						node_to_element_map++;
						i--;
					}
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k--;
				}
				if (all_on_axis)
				{
					element_value=values;
					node_to_element_map=(component->map).standard_node_based.
						node_to_element_maps;
					element_value_2=values;
					node_to_element_map_2=node_to_element_map;
					for (i=number_of_nodes_in_xi1;i>0;i--)
					{
						element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
						node_to_element_map_2++;
					}
					for (k=number_of_nodes_in_xi3;k>0;k--)
					{
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							*element_value= *element_value_2;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 +=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
						}
						if (k>1)
						{
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
				}
				else
				{
					/* xi2=1 face */
					if (1<number_of_nodes_in_xi2)
					{
						all_on_axis=1;
					}
					else
					{
						all_on_axis=0;
					}
					node_to_element_map=(axis_component->map).standard_node_based.
						node_to_element_maps;
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k=number_of_nodes_in_xi3;
					while (all_on_axis&&(k>0))
					{
						i=number_of_nodes_in_xi1;
						while (all_on_axis&&(i>0))
						{
							switch (coordinate_system_type)
							{
								case PROLATE_SPHEROIDAL:
								case OBLATE_SPHEROIDAL:
								{
									calculate_FE_field(field,1,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if ((0!=node_value)&&(PI!=node_value))
									{
										all_on_axis=0;
									}
								} break;
								case CYLINDRICAL_POLAR:
								{
									calculate_FE_field(field,0,node[(*node_to_element_map)->
										node_index],(struct FE_element *)NULL,(FE_value *)NULL,
										&node_value);
									if (0!=node_value)
									{
										all_on_axis=0;
									}
								} break;
							}
							node_to_element_map++;
							i--;
						}
						node_to_element_map +=
							(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
						k--;
					}
					if (all_on_axis)
					{
						element_value=values;
						node_to_element_map=(component->map).standard_node_based.
							node_to_element_maps;
						for (j=number_of_nodes_in_xi2;j>1;j--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
							}
						}
						element_value_2=element_value;
						node_to_element_map_2=node_to_element_map;
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							element_value_2 -=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2--;
						}
						for (k=number_of_nodes_in_xi3;k>0;k--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								*element_value= *element_value_2;
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
					else
					{
						/* xi3=0 face */
						if (1<number_of_nodes_in_xi3)
						{
							all_on_axis=1;
						}
						else
						{
							all_on_axis=0;
						}
						node_to_element_map=(axis_component->map).standard_node_based.
							node_to_element_maps;
						j=number_of_nodes_in_xi2;
						while (all_on_axis&&(j>0))
						{
							i=number_of_nodes_in_xi1;
							while (all_on_axis&&(i>0))
							{
								switch (coordinate_system_type)
								{
									case PROLATE_SPHEROIDAL:
									case OBLATE_SPHEROIDAL:
									{
										calculate_FE_field(field,1,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if ((0!=node_value)&&(PI!=node_value))
										{
											all_on_axis=0;
										}
									} break;
									case CYLINDRICAL_POLAR:
									{
										calculate_FE_field(field,0,node[(*node_to_element_map)->
											node_index],(struct FE_element *)NULL,(FE_value *)NULL,
											&node_value);
										if (0!=node_value)
										{
											all_on_axis=0;
										}
									} break;
								}
								node_to_element_map++;
								i--;
							}
							j--;
						}
						if (all_on_axis)
						{
							element_value=values;
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							element_value_2=values;
							node_to_element_map_2=node_to_element_map;
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>0;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									*element_value= *element_value_2;
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
						else
						{
							/* xi3=1 face */
							if (1<number_of_nodes_in_xi3)
							{
								all_on_axis=1;
							}
							else
							{
								all_on_axis=0;
							}
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							node_to_element_map += (number_of_nodes_in_xi3-1)*
								number_of_nodes_in_xi2*number_of_nodes_in_xi1;
							j=number_of_nodes_in_xi2;
							while (all_on_axis&&(j>0))
							{
								i=number_of_nodes_in_xi1;
								while (all_on_axis&&(i>0))
								{
									switch (coordinate_system_type)
									{
										case PROLATE_SPHEROIDAL:
										case OBLATE_SPHEROIDAL:
										{
											calculate_FE_field(field,1,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if ((0!=node_value)&&(PI!=node_value))
											{
												all_on_axis=0;
											}
										} break;
										case CYLINDRICAL_POLAR:
										{
											calculate_FE_field(field,0,node[(*node_to_element_map)->
												node_index],(struct FE_element *)NULL,(FE_value *)NULL,
												&node_value);
											if (0!=node_value)
											{
												all_on_axis=0;
											}
										} break;
									}
									node_to_element_map++;
									i--;
								}
								j--;
							}
							if (all_on_axis)
							{
								element_value=values;
								node_to_element_map=(component->map).standard_node_based.
									node_to_element_maps;
								for (k=number_of_nodes_in_xi3;k>1;k--)
								{
									for (j=number_of_nodes_in_xi2;j>0;j--)
									{
										for (i=number_of_nodes_in_xi1;i>0;i--)
										{
											element_value +=
												(*node_to_element_map)->number_of_nodal_values;
											node_to_element_map++;
										}
									}
								}
								element_value_2=element_value;
								node_to_element_map_2=node_to_element_map;
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										element_value_2 -= (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2--;
									}
								}
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										*element_value= *element_value_2;
										element_value += (*node_to_element_map)->
											number_of_nodal_values;
										node_to_element_map++;
										element_value_2 += (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2++;
									}
								}
							}
						}
					}
				}
				element_value=values;
				node_to_element_map=(component->map).standard_node_based.
					node_to_element_maps;
				offset_xi1_xi2=0;
				offset_xi2_xi3=0;
				/* make sure non-increasing in xi1 and smooth in xi2 & xi3 */
				for (k=number_of_nodes_in_xi3;k>0;k--)
				{
					value_xi3= *element_value;
					for (j=number_of_nodes_in_xi2;j>0;j--)
					{
						value_xi2= *element_value;
						for (i=number_of_nodes_in_xi1;i>1;i--)
						{
							value_xi1= *element_value;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							*element_value += offset_xi1_xi2+offset_xi2_xi3;
							/*???DB.  <= needed for single prolate, but seems to cause
								problems for heart */
							if (value_xi1< *element_value)
							{
								*element_value -= 2*PI;
							}
							node_to_element_map++;
						}
						element_value += (*node_to_element_map)->number_of_nodal_values;
						node_to_element_map++;
						if (j>1)
						{
							value_xi1= *element_value;
							if (value_xi1>value_xi2+PI)
							{
								offset_xi1_xi2= -2*PI;
								*element_value += offset_xi1_xi2;
							}
							else
							{
								if (value_xi1<value_xi2-PI)
								{
									offset_xi1_xi2=2*PI;
									*element_value += offset_xi1_xi2;
								}
								else
								{
									offset_xi1_xi2=0;
								}
							}
						}
					}
					if (k>1)
					{
						offset_xi1_xi2=0;
						value_xi2= *element_value;
						if (value_xi2>value_xi3+PI)
						{
							offset_xi2_xi3= -2*PI;
							*element_value += offset_xi2_xi3;
						}
						else
						{
							if (value_xi2<value_xi3-PI)
							{
								offset_xi2_xi3=2*PI;
								*element_value += offset_xi2_xi3;
							}
							else
							{
								offset_xi2_xi3=0;
							}
						}
					}
				}
			}
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"theta_non_increasing_in_xi1.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* theta_non_increasing_in_xi1 */

char *CM_field_type_string(enum CM_field_type cm_field_type)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Returns a pointer to a static string describing the <value_type>, eg.
CM_ANATOMICAL_FIELD == "anatomical". This string should match the command used
to create the edit object. The returned string must not be DEALLOCATEd!
==============================================================================*/
{
	char *return_string;

	ENTER(CM_field_type_string);
	switch (cm_field_type)
	{
		case CM_ANATOMICAL_FIELD:
		{
			return_string="anatomical";
		} break;
		case CM_COORDINATE_FIELD:
		{
			return_string="coordinate";
		} break;
		case CM_FIELD:
		{
			return_string="field";
		} break;
		case CM_DEPENDENT_FIELD:
		{
			return_string="dependent";
		} break;
		case CM_UNKNOWN_FIELD:
		{
			return_string="unknown";
		} break;
		default:
		{
			display_message(ERROR_MESSAGE,
				"CM_field_type_string.  Unknown cm_field_type");
			return_string=(char *)NULL;
		} break;
	}
	LEAVE;

	return (return_string);
} /* CM_field_type_string */

enum CM_field_type CM_field_type_from_string(char *cm_field_type_string)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Returns the cm_field_type from the string, eg "coordinate" =
CM_COORDINATE_FIELD.
Returns CM_UNKNOWN_FIELD without error if cm_field_type_string not recognized.
==============================================================================*/
{
	char *compare_type_string;
	enum CM_field_type cm_field_type;

	ENTER(CM_field_type_from_string);
	if (cm_field_type_string)
	{
		cm_field_type=CM_FIELD_TYPE_BEFORE_FIRST;
		cm_field_type++;
		while ((cm_field_type<CM_FIELD_TYPE_AFTER_LAST)&&
			(compare_type_string=CM_field_type_string(cm_field_type))&&
			(!(fuzzy_string_compare_same_length(compare_type_string,
				cm_field_type_string))))
		{
			cm_field_type++;
		}
		if (!fuzzy_string_compare_same_length(compare_type_string,
			cm_field_type_string))
		{
			cm_field_type=CM_FIELD_TYPE_INVALID;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CM_field_type_from_string.  Invalid argument(s)");
		cm_field_type=CM_FIELD_TYPE_INVALID;
	}
	LEAVE;

	return (cm_field_type);
} /* CM_field_type_from_string */

char **CM_field_type_get_valid_strings(int *number_of_valid_strings)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Returns and allocated array of pointers to all static strings for valid
CM_field_types - obtained from function CM_field_type_string.
Up to calling function to deallocate returned array - but not the strings in it!
==============================================================================*/
{
	char **valid_strings;
	enum CM_field_type cm_field_type;
	int i;

	ENTER(CM_field_type_get_valid_strings);
	if (number_of_valid_strings)
	{
		*number_of_valid_strings=0;
		cm_field_type=CM_FIELD_TYPE_BEFORE_FIRST;
		cm_field_type++;
		while (cm_field_type<CM_FIELD_TYPE_AFTER_LAST)
		{
			(*number_of_valid_strings)++;
			cm_field_type++;
		}
		if (ALLOCATE(valid_strings,char *,*number_of_valid_strings))
		{
			cm_field_type=CM_FIELD_TYPE_BEFORE_FIRST;
			cm_field_type++;
			i=0;
			while (cm_field_type<CM_FIELD_TYPE_AFTER_LAST)
			{
				valid_strings[i]=CM_field_type_string(cm_field_type);
				i++;
				cm_field_type++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CM_field_type_get_valid_strings.  Not enough memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CM_field_type_get_valid_strings.  Invalid argument");
		valid_strings=(char **)NULL;
	}
	LEAVE;

	return (valid_strings);
} /* CM_field_type_get_valid_strings */

struct FE_field *CREATE(FE_field)(void)
/*******************************************************************************
LAST MODIFIED : 21 June 2000

DESCRIPTION :
Creates and returns a struct FE_field. The new field defaults to 1 component, 
field_type FIELD, NOT_APPLICABLE coordinate system, no field values, 
no name, and the single component is named "1".
==============================================================================*/
{
	struct FE_field *field;

	ENTER(CREATE(FE_field));
	if (ALLOCATE(field,struct FE_field,1))
	{
		field->name=(char *)NULL;
		field->fe_field_type=GENERAL_FE_FIELD;
		field->indexer_field=(struct FE_field *)NULL;
		field->number_of_indexed_values=0;
		set_CM_field_information(&field->cm,CM_FIELD,(int *)NULL);
		field->number_of_components=1;
		/* don't allocate component names until we have custom names */
		field->component_names=(char **)NULL;
		field->coordinate_system.type = NOT_APPLICABLE;
		field->number_of_values=0;
		field->values_storage=(Value_storage *)NULL;
		field->value_type = UNKNOWN_VALUE;
		field->access_count=0;
		field->number_of_times =0;
		field->time_value_type = UNKNOWN_VALUE;
		field->times = (Value_storage *)NULL;
	}
	else
	{
		display_message(ERROR_MESSAGE,"CREATE(FE_field).  Not enough memory");
		if (field)
		{
			DEALLOCATE(field);
		}
	}
	LEAVE;

	return (field);
} /* CREATE(FE_field) */

int DESTROY(FE_field)(struct FE_field **field_address)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Frees the memory for the field and sets <*field_address> to NULL.
==============================================================================*/
{
	char **component_name;
	int i,return_code;
	struct FE_field *field;

	ENTER(DESTROY(FE_field));
	if ((field_address)&&(field= *field_address))
	{
		if (0==field->access_count)
		{
			/* free the field name */
			if (field->name)
			{
				DEALLOCATE(field->name);
			}

			REACCESS(FE_field)(&(field->indexer_field),(struct FE_field *)NULL);
			if (field->values_storage)
			{
				/* free any arrays pointed to by field->values_storage */
				free_value_storage_array(field->values_storage,field->value_type,
					field->number_of_values);		
				/* free the global values */
				DEALLOCATE(field->values_storage);
			}

			/* free the component names */
			if (component_name=field->component_names)
			{
				for (i=field->number_of_components;i>0;i--)
				{
					DEALLOCATE(*component_name);
					component_name++;
				}
				DEALLOCATE(field->component_names);
			}
			DEALLOCATE(*field_address);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_field).  Non-zero access_count (%d)",field->access_count);
			return_code=0;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_field) */

int list_FE_field(struct FE_field *field,void *dummy)
/*******************************************************************************
LAST MODIFIED : 29 February 2000

DESCRIPTION :
Outputs the information contained in <field>.
==============================================================================*/
{
	char *component_name, line[91];
	int i, number_of_components, return_code;

	ENTER(list_FE_field);
	USE_PARAMETER(dummy);
	if (field)
	{
		return_code=1;
		/* write the identifier */
		sprintf(line,"field : %s \n",field->name);
		display_message(INFORMATION_MESSAGE,line);
		sprintf(line,"  access count=%d\n",field->access_count);
		display_message(INFORMATION_MESSAGE,line);

		switch (field->cm.type)
		{
			case CM_COORDINATE_FIELD:
			{
				display_message(INFORMATION_MESSAGE,", coordinate");
			} break;
			case CM_ANATOMICAL_FIELD:
			{
				display_message(INFORMATION_MESSAGE,", anatomical");
			} break;
			case CM_FIELD:
			{
				display_message(INFORMATION_MESSAGE,", field");
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"list_FE_node_field.  Invalid field type");
				return_code=0;
			} break;
		}
		switch (field->coordinate_system.type)
		{
			case RECTANGULAR_CARTESIAN:
			{
				display_message(INFORMATION_MESSAGE,", rectangular cartesian");
			} break;
			case CYLINDRICAL_POLAR:
			{
				display_message(INFORMATION_MESSAGE,", cylindrical polar");
			} break;
			case SPHERICAL_POLAR:
			{
				display_message(INFORMATION_MESSAGE,", spherical polar");
			} break;
			case PROLATE_SPHEROIDAL:
			{
				display_message(INFORMATION_MESSAGE,", prolate spheroidal");
			} break;
			case OBLATE_SPHEROIDAL:
			{
				display_message(INFORMATION_MESSAGE,", oblate spheroidal");
			} break;
			case FIBRE:
			{
				display_message(INFORMATION_MESSAGE,", fibre");
			} break;
			case NOT_APPLICABLE:
			{
				display_message(INFORMATION_MESSAGE,", no coordinate system");
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"list_FE_node_field.  Invalid field coordinate system");
				return_code=0;
			} break;
		}
		number_of_components=field->number_of_components;
		display_message(INFORMATION_MESSAGE,", #Components=%d\n",
			number_of_components);
		i=0;
		while (return_code&&(i<number_of_components))
		{
			if (component_name = get_FE_field_component_name(field, i))
			{
				display_message(INFORMATION_MESSAGE,"    %s", component_name);
				DEALLOCATE(component_name);
			}
			/* display field based information*/
			if(field->number_of_values)
			{	
				int count;

				display_message(INFORMATION_MESSAGE,"field based values: ");							
				switch(field->value_type)
				{
					case FE_VALUE_VALUE:
					{
						display_message(INFORMATION_MESSAGE,"\n");
						/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
						for (count=0;count<field->number_of_values;count++)
						{
							display_message(INFORMATION_MESSAGE," %"FE_VALUE_STRING,
								*((FE_value*)(field->values_storage + count*sizeof(FE_value)) ));
							if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
								(0==((count+1) % DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
							{
								display_message(INFORMATION_MESSAGE,"\n");
							}											
						}																							
					} break;
					default:
					{
						display_message(INFORMATION_MESSAGE,"list_FE_node_field: "
							"Can't display that field value_type yet. Write the code!");
					} break;
				}	/* switch() */							
			}
			display_message(INFORMATION_MESSAGE,"\n");
			i++;
		}
		
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_field.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_field */

DECLARE_OBJECT_FUNCTIONS(FE_field)
DECLARE_DEFAULT_GET_OBJECT_NAME_FUNCTION(FE_field)

#if !defined (FINITE_ELEMENT_USE_SAFE_LIST)
DECLARE_INDEXED_LIST_FUNCTIONS(FE_field)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_field,name,char *,strcmp)
#else /* FINITE_ELEMENT_USE_SAFE_LIST */
DECLARE_LIST_FUNCTIONS(FE_field)
DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_field,name,char *,strcmp)
#endif /* FINITE_ELEMENT_USE_SAFE_LIST */

PROTOTYPE_MANAGER_COPY_WITH_IDENTIFIER_FUNCTION(FE_field,name)
{
	char *name;
	int return_code;

	ENTER(MANAGER_COPY_WITH_IDENTIFIER(FE_field,name));
	if (source&&destination)
	{
		if (source->name)
		{
			if (ALLOCATE(name,char,strlen(source->name)+1))
			{
				strcpy(name,source->name);
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"MANAGER_COPY_WITH_IDENTIFIER(FE_field,name).  "
					"Insufficient memory");
				return_code=0;
			}
		}
		else
		{
			name=(char *)NULL;
			return_code=1;
		}
		if (return_code)
		{
			if (return_code = MANAGER_COPY_WITHOUT_IDENTIFIER(FE_field,name)(
				destination, source))
			{
				/* copy values */
				DEALLOCATE(destination->name);
				destination->name=name;
			}
			else
			{
				DEALLOCATE(name);
				display_message(ERROR_MESSAGE,
					"MANAGER_COPY_WITH_IDENTIFIER(FE_field,name).  "
					"Could not copy without identifier");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITH_IDENTIFIER(FE_field,name).  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITH_IDENTIFIER(FE_field,name) */

PROTOTYPE_MANAGER_COPY_WITHOUT_IDENTIFIER_FUNCTION(FE_field,name)
/*******************************************************************************
LAST MODIFIED : 15 September 1999

DESCRIPTION :
If the <destination> has an access_count > 1 then it is deemed to be in use. In
such cases only the values_storage and times may be copied - the function fails
if any other <source> and <destination> parameters do not match.
==============================================================================*/
{
	char **component_names;
	int i,matching_fields,return_code;
	Value_storage *times,*values_storage;

	ENTER(MANAGER_COPY_WITHOUT_IDENTIFIER(FE_field,name));
	if (source&&destination)
	{
		return_code=1;
		component_names=(char **)NULL;
		values_storage=(Value_storage *)NULL;
		times=(Value_storage *)NULL;
		matching_fields=FE_fields_match(destination,source);
		if ((1 >= destination->access_count)||matching_fields)
		{
			/* try to avoid copying matching information */
			if (!matching_fields)
			{
				if (source->component_names)
				{
					if (ALLOCATE(component_names,char *,source->number_of_components))
					{
						for (i=0;i<source->number_of_components;i++)
						{
							component_names[i]=(char *)NULL;
						}
						/* copy the old names, clear any new ones */
						for (i=0;i<(source->number_of_components)&&return_code;i++)
						{
							if (source->component_names[i])
							{
								if (ALLOCATE(component_names[i],char,
									strlen(source->component_names[i])+1))
								{
									strcpy(component_names[i],source->component_names[i]);
								}
								else
								{
									return_code=0;
								}
							}
						}
					}
					else
					{
						return_code=0;
					}
				}
			}
			if (0<source->number_of_values)
			{
				if (!((values_storage=make_value_storage_array(source->value_type,
					source->number_of_values))&&
					copy_value_storage_array(values_storage,source->value_type,
						source->number_of_values,source->values_storage)))
				{
					return_code=0;
				}
			}
			if (0<source->number_of_times)
			{
				if (!((times=make_value_storage_array(source->time_value_type,
					source->number_of_times))&&
					copy_value_storage_array(times,source->time_value_type,
						source->number_of_times,source->times)))
				{
					return_code=0;
				}
			}
			if (return_code)
			{
				if (!matching_fields)
				{
					COPY(CM_field_information)(&(destination->cm),&(source->cm));
					destination->fe_field_type=source->fe_field_type;
					REACCESS(FE_field)(&(destination->indexer_field),
						source->indexer_field);
					destination->number_of_indexed_values=
						source->number_of_indexed_values;
					destination->number_of_components=source->number_of_components;
					destination->component_names=component_names;
					COPY(Coordinate_system)(&(destination->coordinate_system),
						&(source->coordinate_system));
					destination->value_type=source->value_type;
					destination->time_value_type=source->time_value_type;
				}
				/* replace old values_storage with new */
				if (0<destination->number_of_values)
				{
					free_value_storage_array(destination->values_storage,
						destination->value_type,destination->number_of_values);
					DEALLOCATE(destination->values_storage);
				}
				destination->number_of_values=source->number_of_values;
				destination->values_storage=values_storage;
				/* replace old times with new */
				if (0<destination->number_of_times)
				{
					free_value_storage_array(destination->times,
						destination->time_value_type,destination->number_of_times);
					DEALLOCATE(destination->times);
				}
				destination->number_of_times=source->number_of_times;
				destination->times=times;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_field,name).  "
					"Could not copy dynamic contents");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_field,name).  "
				"Cannot change major field properties while it is in use");
			return_code=0;
		}
		if (!return_code)
		{
			if (component_names)
			{
				for (i=0;i<source->number_of_components;i++)
				{
					if (component_names[i])
					{
						DEALLOCATE(component_names[i]);
					}
				}
				DEALLOCATE(component_names);
			}
			if (values_storage)
			{
				free_value_storage_array(values_storage,source->value_type,
					source->number_of_values);
				DEALLOCATE(values_storage);
			}
			if (times)
			{
				free_value_storage_array(times,source->time_value_type,
					source->number_of_times);
				DEALLOCATE(times);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_field,name).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITHOUT_IDENTIFIER(FE_field,name) */

PROTOTYPE_MANAGER_COPY_IDENTIFIER_FUNCTION(FE_field,name,char *)
{
	char *destination_name;
	int return_code;

	ENTER(MANAGER_COPY_IDENTIFIER(FE_field,name));
	if (name&&destination)
	{
		if (name)
		{
			if (ALLOCATE(destination_name,char,strlen(name)+1))
			{
				strcpy(destination_name,name);
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"MANAGER_COPY_IDENTIFIER(FE_field,name).  Insufficient memory");
				return_code=0;
			}
		}
		else
		{
			name=(char *)NULL;
			return_code=1;
		}
		if (return_code)
		{
			/* copy name */
			DEALLOCATE(destination->name);
			destination->name=destination_name;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_IDENTIFIER(FE_field,name).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_IDENTIFIER(FE_field,name) */

DECLARE_MANAGER_FUNCTIONS(FE_field)

DECLARE_MANAGER_IDENTIFIER_FUNCTIONS(FE_field,name,char *)

int calculate_FE_field(struct FE_field *field,int component_number,
	struct FE_node *node,struct FE_element *element,FE_value *xi_coordinates,
	FE_value *value)
/*******************************************************************************
LAST MODIFIED : 12 April 1999

DESCRIPTION :
Calculates the <value> of the <field> for the specified <node> or <element> and
<xi_coordinates>.  If 0<=component_number<=number_of_components, then only the
specified component is calculated, otherwise all components are calculated.  The
storage for the <value> should have been allocated outside the function.
???DB.  Picks up the first version for the node.
==============================================================================*/
{
	Value_storage *component_nodal_value,*nodal_values;
	int i,return_code;
	struct FE_element_field_values element_field_values;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct FE_node_field_info *node_field_info;

	ENTER(calculate_FE_field);
	/* check the arguments */
	if (field&&((node&&!element&&!xi_coordinates)||
		(!node&&element&&xi_coordinates))&&value)
	{
		if (node)
		{
			/* calculate field for node */
			if ((nodal_values=node->values_storage)&&(node_field_info=node->fields))
			{
				if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
					field,node_field_info->node_field_list))
				{
					if(field->value_type == FE_VALUE_VALUE)
					{
						if (((i=field->number_of_components)>0)&&
							(node_field_component=node_field->components))
						{
							if ((0<=component_number)&&(component_number<i))
							{
								nodal_values += (node_field_component[component_number]).value;
								*value = *((FE_value *)nodal_values);
							}
							else
							{
								while (i>0)
								{	
									component_nodal_value=nodal_values+node_field_component->value;								
									*value = *((FE_value *)component_nodal_value);				
									node_field_component++;
									value++;
									i--;
								}					
								return_code=1;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"calculate_FE_field.  Missing node field components");
							return_code=0;
						}
					}/* if(field->value_type == FE_VALUE_VALUE) */
					else
					{
						display_message(ERROR_MESSAGE,
								"calculate_FE_field. field->value_type must be FE_VALUE_VALUE ");
							return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"calculate_FE_field.  Field not defined for node");
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_field.  Missing node values or fields");
				return_code=0;
			}
		}
		else	
		{
			/* calculate field for element */
			/* determine if the field is defined over the element */
			if (calculate_FE_element_field_values(element,field,
				/*calculate_derivatives*/0,&element_field_values,
				/*top_level_element*/(struct FE_element *)NULL))
			{
				/* calculate the value for the element field */
				return_code=calculate_FE_element_field(component_number,
					&element_field_values,xi_coordinates,value,(FE_value *)NULL);
				clear_FE_element_field_values(&element_field_values);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_field.  Field not defined for element");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"calculate_FE_field.  Invalid argument(s)\n"
			"field %p, node %p, element %p, xi_coordinates %p, value %p",field,node,
			element,xi_coordinates,value);
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_field */

int FE_field_matches_description(struct FE_field *field,char *name,
	enum FE_field_type fe_field_type,
	struct FE_field *indexer_field,int number_of_indexed_values,
	struct CM_field_information *cm_field_information,
	struct Coordinate_system *coordinate_system,enum Value_type value_type,
	int number_of_components,char **component_names,
	int number_of_times,enum Value_type time_value_type)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Returns true if <field> has exactly the same <name>, <field_info>... etc. as
those given in the parameters.
==============================================================================*/
{
	char *component_name,*field_component_name;
	int i,return_code;

	ENTER(FE_field_matches_description);
	/* does not match until proven so */
	return_code=0;
	if (field&&name&&cm_field_information&&coordinate_system&&
		(0<=number_of_times))
	{
		if (field->name&&(0==strcmp(field->name,name))&&
			(fe_field_type==field->fe_field_type)&&
			((INDEXED_FE_FIELD != fe_field_type)||
				((indexer_field==field->indexer_field)&&
					(number_of_indexed_values==field->number_of_indexed_values)))&&
			(cm_field_information->type==field->cm.type)&&
			Coordinate_systems_match(&(field->coordinate_system),coordinate_system)&&
			(value_type == field->value_type)&&
			(number_of_components==field->number_of_components)&&
			(number_of_times==field->number_of_times)&&
			(time_value_type == field->time_value_type))
		{
			/* matches until disproven */
			return_code=1;
			/* check the component names match */
			i=number_of_components;
			while ((i>0)&&return_code)
			{
				i--;
				if ((field_component_name=
					get_automatic_component_name(field->component_names,i))&&
					(component_name=get_automatic_component_name(component_names,i)))
				{
					if (strcmp(component_name,field_component_name))
					{
						return_code=0;
					}
					DEALLOCATE(component_name);
				}
				else
				{
					return_code=0;
				}
				DEALLOCATE(field_component_name);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_matches_description.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_matches_description */

int FE_fields_match(struct FE_field *field1,struct FE_field *field2)
/*******************************************************************************
LAST MODIFIED : 25 August 1999

DESCRIPTION :
Returns true if <field1> and <field2> are equivalent. Does this by calling
FE_field_matches_description for <field1> with the description for <field2>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_fields_match);
	if (field1&&field2)
	{
		return_code=FE_field_matches_description(field1,field2->name,
			field2->fe_field_type,field2->indexer_field,
			field2->number_of_indexed_values,&(field2->cm),
			&(field2->coordinate_system),field2->value_type,
			field2->number_of_components,field2->component_names,
			field2->number_of_times,field2->time_value_type);
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_fields_match.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_fields_match */

struct FE_field *get_FE_field_manager_matched_field(
	struct MANAGER(FE_field) *fe_field_manager,char *name,
	enum FE_field_type fe_field_type,
	struct FE_field *indexer_field,int number_of_indexed_values,
	struct CM_field_information *cm_field_information,
	struct Coordinate_system *coordinate_system,enum Value_type value_type,
	int number_of_components,char **component_names,
	int number_of_times,enum Value_type time_value_type)
/*******************************************************************************
LAST MODIFIED : 29 November 1999

DESCRIPTION :
Using searches the <fe_field_manager> for a field, if one is found it is
checked to have the given parameters using FE_field_matches_description, with
an error reported if they do not properly match. If no field of the same name
exists, one is created and added to the manager. Note that <indexer_field> and
<number_of_indexed_values> are for INDEXED_FE_FIELD type only.
The field is returned, or NULL in case of inconsistency.
==============================================================================*/
{
	char *component_name;
	int i;
	struct FE_field *field;

	ENTER(get_FE_field_manager_matched_field);
	field=(struct FE_field *)NULL;
	if (fe_field_manager&&name&&cm_field_information&&coordinate_system&&
		(0<number_of_components))
	{
		/* search the manager for a field of that name */
		if (field=
			FIND_BY_IDENTIFIER_IN_MANAGER(FE_field,name)(name,fe_field_manager))
		{
			/* make sure the field matches in every way */
			if (!FE_field_matches_description(field,name,fe_field_type,
				indexer_field,number_of_indexed_values,cm_field_information,
				coordinate_system,value_type,number_of_components,component_names,
				number_of_times,time_value_type))
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_manager_matched_field.  "
					"Inconsistent with field of same name in manager");
				field=(struct FE_field *)NULL;
			}
		}
		else
		{
#if defined (DEBUG)
			/*???debug */
			printf("create field : /%s/ %d %d\n",name,cm_field_information->type,
				coordinate_system->type);
#endif /* defined (DEBUG) */
			if ((field=CREATE(FE_field)())&&
				set_FE_field_name(field,name)&&						
				set_FE_field_value_type(field,value_type)&&
				set_FE_field_number_of_components(field,number_of_components)&&
				((CONSTANT_FE_FIELD != fe_field_type)||
					set_FE_field_type_constant(field))&&
				((GENERAL_FE_FIELD != fe_field_type)||
					set_FE_field_type_general(field))&&
				((INDEXED_FE_FIELD != fe_field_type)||set_FE_field_type_indexed(field,
					indexer_field,number_of_indexed_values))&&
				set_FE_field_CM_field_information(field,cm_field_information)&&
				set_FE_field_coordinate_system(field,coordinate_system)&&
				set_FE_field_time_value_type(field,time_value_type)&&
				set_FE_field_number_of_times(field,number_of_times))
			{
				if (component_names)
				{
					for (i=0;(i<number_of_components)&&field;i++)
					{
						if (component_name=component_names[i])
						{
							if (!set_FE_field_component_name(field,i,component_name))
							{
								DESTROY(FE_field)(&field);	
							}
						}
					}
				}
			}
			else
			{
				DESTROY(FE_field)(&field);
			}
			if (field)
			{
				/* add new field to fe_field_manager */
				if (!ADD_OBJECT_TO_MANAGER(FE_field)(field,fe_field_manager))
				{
					DESTROY(FE_field)(&field);					
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_manager_matched_field.  Could not create new field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_manager_matched_field.  Invalid argument(s)");
		field=(struct FE_field *)NULL;
	}
	LEAVE;

	return (field);
} /* get_FE_field_manager_matched_field */

struct FE_field *find_first_time_field_at_FE_node(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

Find the first time based field at a node
==============================================================================*/
{
	struct FE_field *time_field;
	struct FE_node_field *time_node_field;
	ENTER(find_first_time_field_at_FE_node);
	time_field = (struct FE_field *)NULL;
	time_node_field = (struct FE_node_field *)NULL;
	if(node)
	{
		if(time_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
			FE_node_field_has_time,(void *)(NULL),
			node->fields->node_field_list))
		{			
			time_field = time_node_field->field;			
		}
		else
		{
			display_message(ERROR_MESSAGE,"find_first_time_field_at_FE_node."
				" Failed to find time_field in node");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"find_first_time_field_at_FE_node."
				" Invalid arguments");
	}
	LEAVE;
	return(time_field);
} /* find_first_time_field_at_FE_node */

int FE_field_can_be_destroyed(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 19 August 1999

DESCRIPTION :
Returns true if the <field> is only accessed once (assumed to be by the manager).
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_can_be_destroyed);
	if (field)
	{
		return_code=(1==field->access_count);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_can_be_destroyed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_can_be_destroyed */

int set_FE_field(struct Parse_state *state,void *field_address_void,
	void *fe_field_manager_void)
/*******************************************************************************
LAST MODIFIED : 28 January 1999

DESCRIPTION :
Modifier function to set the field from the command line.
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct FE_field **field_address,*temp_FE_field;
	struct MANAGER(FE_field) *fe_field_manager;

	ENTER(set_FE_field);
	if (state&&(field_address=(struct FE_field **)field_address_void)&&
		(fe_field_manager=(struct MANAGER(FE_field) *)fe_field_manager_void))
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (fuzzy_string_compare(current_token,"NONE"))
				{
					if (*field_address)
					{
						DEACCESS(FE_field)(field_address);
						*field_address=(struct FE_field *)NULL;
					}
					return_code=shift_Parse_state(state,1);
				}
				else
				{
					if (temp_FE_field=FIND_BY_IDENTIFIER_IN_MANAGER(FE_field,name)(
						current_token,fe_field_manager))
					{
						if (*field_address!=temp_FE_field)
						{
							DEACCESS(FE_field)(field_address);
							*field_address=ACCESS(FE_field)(temp_FE_field);
						}
						return_code=shift_Parse_state(state,1);
					}
					else
					{
						display_message(ERROR_MESSAGE,"Unknown field: %s",current_token);
						display_parse_state_location(state);
						return_code=0;
					}
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," FIELD_NAME|none");
				if (temp_FE_field= *field_address)
				{
					display_message(INFORMATION_MESSAGE,"[%s]",temp_FE_field->name);
				}
				else
				{
					display_message(INFORMATION_MESSAGE,"[none]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing field name");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_field.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field */

int FE_field_has_value_type(struct FE_field *field,
	void *user_data_value_type)
/*******************************************************************************
LAST MODIFIED : 4 May 1999

DESCRIPTION :
Returns true if the VALUE_TYPE specified in the <user_data_value_type> matches
the VALUE_TYPE of the <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_value_type);
	if (field)
	{
		if(((enum Value_type)user_data_value_type)==field->value_type)
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_has_value_type.  Invalid field");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_has_value_type */

int set_FE_field_conditional(struct Parse_state *state,
	void *field_address_void,void *set_field_data_void)
/*******************************************************************************
LAST MODIFIED : 18 May 2000

DESCRIPTION :
Modifier function to set the field from a command. <set_field_data_void> should
point to a struct Set_FE_field_conditional_data containing the
fe_field_manager and an optional conditional function for narrowing the
range of fields available for selection. If the conditional_function is NULL,
this function works just like set_FE_field.
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct FE_field **field_address,*selected_field,*temp_field;
	struct Set_FE_field_conditional_data *set_field_data;

	ENTER(set_FE_field_conditional);
	if (state&&(field_address=(struct FE_field **)field_address_void)&&
		(set_field_data=
			(struct Set_FE_field_conditional_data *)set_field_data_void)&&
		set_field_data->fe_field_manager)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (fuzzy_string_compare(current_token,"NONE"))
				{
					if (*field_address)
					{
						DEACCESS(FE_field)(field_address);
						*field_address=(struct FE_field *)NULL;
					}
					return_code=1;
				}
				else
				{
					if (selected_field=
						FIND_BY_IDENTIFIER_IN_MANAGER(FE_field,name)(current_token,
						set_field_data->fe_field_manager))
					{
						if ((NULL==set_field_data->conditional_function)||
							((set_field_data->conditional_function)(selected_field,
								set_field_data->conditional_function_user_data)))
						{
							if (*field_address != selected_field)
							{
								DEACCESS(FE_field)(field_address);
								*field_address=ACCESS(FE_field)(selected_field);
							}
							return_code=1;
						}
						else
						{
							display_message(ERROR_MESSAGE,"Field of incorrect type : %s",
								current_token);
							return_code=0;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,"Unknown field : %s",current_token);
						return_code=0;
					}
				}
				shift_Parse_state(state,1);
			}
			else
			{
				display_message(INFORMATION_MESSAGE," FIELD_NAME|none");
				/* if possible, then write the name */
				if (temp_field= *field_address)
				{
					display_message(INFORMATION_MESSAGE,"[%s]",temp_field->name);
				}
				else
				{
					display_message(INFORMATION_MESSAGE,"[none]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing field name");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_conditional.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_conditional */

char *get_FE_field_component_name(struct FE_field *field,int component_no)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Returns the name of component <component_no> of <field>. If no name is stored
for the component, a string comprising the value component_no+1 is returned.
Up to calling function to DEALLOCATE the returned string.
==============================================================================*/
{
	char *component_name;

	ENTER(get_FE_field_component_name);
	if (field&&(0<=component_no)&&(component_no<field->number_of_components))
	{
		component_name=
			get_automatic_component_name(field->component_names,component_no);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_component_name.  Invalid argument(s)");
		component_name=(char *)NULL;
	}
	LEAVE;

	return (component_name);
} /* get_FE_field_component_name */

int set_FE_field_component_name(struct FE_field *field,int component_no,
	char *component_name)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Sets the name of component <component_no> of <field>. Only sets name if it is
different from that already returned for field to preserve default names if can.
==============================================================================*/
{
	char *temp_component_name;
	int different_name,i,return_code;

	ENTER(set_FE_field_component_name);
	if (field&&(0<=component_no)&&(component_no<field->number_of_components)&&
		component_name)
	{
		if (temp_component_name=get_FE_field_component_name(field,component_no))
		{
			different_name=strcmp(temp_component_name,component_name);
			DEALLOCATE(temp_component_name);
		}
		else
		{
			different_name=1;
		}
		if (different_name)
		{
			if (ALLOCATE(temp_component_name,char,strlen(component_name)+1))
			{
				strcpy(temp_component_name,component_name);
				/* component_names array may be non-existent if default names used */
				if (field->component_names)
				{
					if (field->component_names[component_no])
					{
						DEALLOCATE(field->component_names[component_no]);
					}
				}
				else
				{
					if (ALLOCATE(field->component_names,char *,
						field->number_of_components))
					{
						/* clear the pointers to names */
						for (i=0;i<field->number_of_components;i++)
						{
							field->component_names[i]=(char *)NULL;
						}
					}
				}
				if (field->component_names)
				{
					field->component_names[component_no]=temp_component_name;
					return_code=1;
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				return_code=0;
			}
		}
		else
		{
			return_code=1;
		}
		if (!return_code)
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_component_name.  Not enough memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_component_name.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_component_name */

struct Coordinate_system *get_FE_field_coordinate_system(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 22 January 1999

DESCRIPTION :
Returns a pointer to the coordinate system for the <field>.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;

	ENTER(get_FE_field_coordinate_system);
	if (field)
	{
		coordinate_system = &field->coordinate_system;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_coordinate_system.  Invalid field");
		coordinate_system = (struct Coordinate_system *)NULL;	
	}
	LEAVE;

	return (coordinate_system);
} /* get_FE_field_coordinate_system */

int set_FE_field_coordinate_system(struct FE_field *field,
	struct Coordinate_system *coordinate_system)
/*******************************************************************************
LAST MODIFIED : 28 January 1999

DESCRIPTION :
Sets the coordinate system of the <field>.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_coordinate_system);
	if (field&&coordinate_system)
	{
		return_code=
			COPY(Coordinate_system)(&field->coordinate_system,coordinate_system);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_coordinate_system.  Invalid argument(s)");
		return_code=0;	
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_coordinate_system */

int get_FE_field_number_of_components(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 16 November 1998

DESCRIPTION :
Returns the number of components for the <field>.
==============================================================================*/
{
	int number_of_components;

	ENTER(get_FE_field_number_of_components);
	if (field)
	{
		number_of_components=field->number_of_components;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_number_of_components.  Missing field");
		number_of_components=0;
	}
	LEAVE;

	return (number_of_components);
} /* get_FE_field_number_of_components */

int set_FE_field_number_of_components(struct FE_field *field,
	int number_of_components)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Sets the number of components in the <field>. Automatically assumes names for
any new components. Clears/reallocates the values_storage for FE_field_types
that use them, eg. CONSTANT_FE_FIELD and INDEXED_FE_FIELD - but only if number
of components changes. If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	char **component_names;
	int i,number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_number_of_components);
	if (field&&(0<number_of_components))
	{
		return_code=1;
		if (number_of_components != field->number_of_components)
		{
			/* 1. make dynamic allocations for number_of_components-specific data */
			component_names=(char **)NULL;
			if (field->component_names)
			{
				if (ALLOCATE(component_names,char *,number_of_components))
				{
					/* copy the old names, clear any new ones */
					for (i=0;i<number_of_components;i++)
					{
						if (i<field->number_of_components)
						{
							component_names[i]=field->component_names[i];
						}
						else
						{
							component_names[i]=(char *)NULL;
						}
					}
				}
				else
				{
					return_code=0;
				}
			}
			values_storage=(Value_storage *)NULL;
			number_of_values=0;
			switch (field->fe_field_type)
			{
				case CONSTANT_FE_FIELD:
				{
					number_of_values=number_of_components;
				} break;
				case GENERAL_FE_FIELD:
				{
					number_of_values=0;
				} break;
				case INDEXED_FE_FIELD:
				{
					number_of_values=field->number_of_indexed_values*number_of_components;
				} break;
				default:
				{
					return_code=0;
				}
			}
			if (number_of_values != field->number_of_values)
			{
				if (!(values_storage=make_value_storage_array(field->value_type,
					number_of_values)))
				{
					return_code=0;
				}
			}
			if (return_code)
			{
				/* 2. free current number_of_components-specific data */
				DEALLOCATE(field->component_names);
				if (field->values_storage)
				{
					free_value_storage_array(field->values_storage,field->value_type,
						field->number_of_values);		
					DEALLOCATE(field->values_storage);
				}
				/* 3. establish the new number_of_components and associated data */
				field->number_of_components=number_of_components;
				field->component_names=component_names;
				field->values_storage=values_storage;
				field->number_of_values=number_of_values;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_field_number_of_components.  Not enough memory");
				DEALLOCATE(component_names);
				DEALLOCATE(values_storage);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_number_of_components.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_number_of_components */

int get_FE_field_number_of_values(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 18 November 1998

DESCRIPTION :
Returns the number of global values for the <field>.
==============================================================================*/
{
	int number_of_values;

	ENTER(get_FE_field_number_of_values);
	if (field)
	{
		number_of_values=field->number_of_values;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_number_of_values.  Invalid field");
		number_of_values=0;
	}
	LEAVE;

	return (number_of_values);
} /* get_FE_field_number_of_values */

int get_FE_field_number_of_times(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Returns the number of global times for the <field>.
==============================================================================*/
{
	int number_of_times;

	ENTER(get_FE_field_number_of_times);
	if (field)
	{
		number_of_times=field->number_of_times;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_number_of_times.  Invalid field");
		number_of_times=0;
	}
	LEAVE;

	return (number_of_times);
} /* get_FE_field_number_of_times */

int set_FE_field_number_of_times(struct FE_field *field,
	int number_of_times)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Sets the number of times stored with the <field>
REALLOCATES the requires memory in field->value_storage, based upon the 
field->time_value_type. 

For non-array types, the contents of field->times_storage is:
   | data type (eg FE_value) | x number_of_times

For array types, the contents of field->times is:
   ( | int (number of array values) | pointer to array (eg double *) | x number_of_times )

Sets data in this memory to 0, pointers to NULL.

MUST have called set_FE_field_time_value_type before calling this function.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int i,j, return_code,size;
	Value_storage *new_value, *times;

	ENTER(set_FE_field_number_of_times);
	if (field&&(0<=number_of_times))
	{					
		return_code=1;
		if(number_of_times != 0)
		{	
			field->number_of_times=number_of_times;			
			size = get_Value_storage_size(field->time_value_type);		

			if(REALLOCATE(times,field->times,Value_storage,
				size*number_of_times))	
			{		
				field->times = times;		 	
				for (i=0;i<number_of_times;i++)
				{
					switch(field->time_value_type) 
					{
						/* set values to zero*/
						case DOUBLE_VALUE: 
						{						
							*((double *)times) = 0;
						}	break;
						case ELEMENT_XI_VALUE:
						{						
							new_value = times;
							*((struct FE_element **)new_value) = (struct FE_element *)NULL;
							new_value+=sizeof(struct FE_element *);
							for (j = 0 ; j < MAXIMUM_ELEMENT_XI_DIMENSIONS ; j++)
							{
								*((FE_value *)new_value) = 0;
								new_value+=sizeof(FE_value);
							}
						}	break;
						case FE_VALUE_VALUE:
						{						
							*((FE_value *)times) = 0;
						}	break;
						case FLT_VALUE: 
						{							
							*((float *)times) = 0;
						}break;	
						case SHORT_VALUE: 
						{							
							display_message(ERROR_MESSAGE," set_FE_field_number_of_times." 
								"SHORT_VALUE. Code not written yet. Beware alignment problems ");
							return_code =0;
						}break;
						case INT_VALUE: 
						{						
							*((int *)times) = 0;
						}	break;	
						case UNSIGNED_VALUE: 
						{							
							*((unsigned *)times) = 0;
						}	break;
						/* set number of array values to 0, array pointers to NULL*/
						case DOUBLE_ARRAY_VALUE:
						{ 						
							double **array_address;
							/* copy the number of array values (0!) to times*/						
							*((int *)times) = 0;
							/* copy the pointer to the array values (currently NULL), to times*/
							array_address = (double **)(times+sizeof(int));
							*array_address = (double *)NULL;
						}break;
						case FE_VALUE_ARRAY_VALUE:				
						{	
							FE_value **array_address;												
							*((int *)times) = 0;						
							array_address = (FE_value **)(times+sizeof(int));
							*array_address = (FE_value *)NULL;
						}break;
						case FLT_ARRAY_VALUE:			
						{		
							float **array_address;												
							*((int *)times) = 0;						
							array_address = (float **)(times+sizeof(int));
							*array_address = (float *)NULL;
						}break;	
						case SHORT_ARRAY_VALUE:			
						{		
							short **array_address;												
							*((int *)times) = 0;						
							array_address = (short **)(times+sizeof(int));
							*array_address = (short *)NULL;
						}break;			
						case INT_ARRAY_VALUE:								
						{	
							int **array_address;												
							*((int *)times) = 0;						
							array_address = (int **)(times+sizeof(int));
							*array_address = (int *)NULL;
						}break;	
						case UNSIGNED_ARRAY_VALUE:			
						{ 
							unsigned **array_address;												
							*((int *)times) = 0;						
							array_address = (unsigned **)(times+sizeof(int));
							*array_address = (unsigned *)NULL;
						}break;	
						case STRING_VALUE:
						{	
							char **str_address;							
							str_address = (char **)(times);
							*str_address = (char *)NULL;	
						}break;
						case UNKNOWN_VALUE:
						{
							display_message(ERROR_MESSAGE," set_FE_field_number_of_times." 
								" UNKNOWN_VALUE");
							return_code =0;
						}break;
					}	/*	switch(field->time_value_type) */				
					times += size;	
				}/* (i=0;i<number_of_times;i++) */
			}/* if(REALLOCATE */
			else
			{
				display_message(ERROR_MESSAGE,"set_FE_field_number_of_times."
					" Not enough memory");
				return_code=0;
			}	
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_number_of_times.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_number_of_times */

enum CM_field_type get_FE_field_CM_field_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 31 August 1999

DESCRIPTION :
Returns the CM_field_type for the <field>.
==============================================================================*/
{
	enum CM_field_type type;

	ENTER(get_FE_field_CM_field_type);
	if (field)
	{
		type=field->cm.type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_CM_field_type.  Invalid field");
		type=CM_UNKNOWN_FIELD;
	}
	LEAVE;

	return (type);
} /* get_FE_field_CM_field_type */

int set_FE_field_CM_field_type(struct FE_field *field,
	enum CM_field_type cm_field_type)
/*******************************************************************************
LAST MODIFIED : 31 August 1999

DESCRIPTION :
Sets the CM_field_type of the <field>.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_CM_field_type);
	if (field)
	{
		field->cm.type=cm_field_type;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_CM_field_type.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_CM_field_type */

enum FE_field_type get_FE_field_FE_field_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 31 August 1999

DESCRIPTION :
Returns the FE_field_type for the <field>.
==============================================================================*/
{
	enum FE_field_type fe_field_type;

	ENTER(get_FE_field_FE_field_type);
	if (field)
	{
		fe_field_type=field->fe_field_type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_FE_field_type.  Invalid field");
		fe_field_type=UNKNOWN_FE_FIELD;
	}
	LEAVE;

	return (fe_field_type);
} /* get_FE_field_FE_field_type */

int set_FE_field_type_constant(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Converts the <field> to type CONSTANT_FE_FIELD.
Allocates and clears the values_storage of the field to fit
field->number_of_components of the current value_type.
If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_type_constant);
	return_code=0;
	if (field)
	{
		/* 1. make dynamic allocations for any new type-specific data */
		number_of_values=field->number_of_components;
		if (values_storage=make_value_storage_array(field->value_type,
			number_of_values))
		{
			/* 2. free current type-specific data */
			if (field->values_storage)
			{
				free_value_storage_array(field->values_storage,field->value_type,
					field->number_of_values);		
				DEALLOCATE(field->values_storage);
			}
			REACCESS(FE_field)(&(field->indexer_field),NULL);
			field->number_of_indexed_values=0;
			/* 3. establish the new type */
			field->fe_field_type=CONSTANT_FE_FIELD;
			field->values_storage=values_storage;
			field->number_of_values=number_of_values;
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_type_constant.  Could not allocate values_storage");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_type_constant.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_type_constant */

int set_FE_field_type_general(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Converts the <field> to type GENERAL_FE_FIELD.
Frees any values_storage currently in use by the field.
If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_type_general);
	return_code=0;
	if (field)
	{
		/* 1. make dynamic allocations for any new type-specific data */
		/* none */
		/* 2. free current type-specific data */
		if (field->values_storage)
		{
			free_value_storage_array(field->values_storage,field->value_type,
				field->number_of_values);		
			DEALLOCATE(field->values_storage);
		}
		REACCESS(FE_field)(&(field->indexer_field),NULL);
		field->number_of_indexed_values=0;
		/* 3. establish the new type */
		field->fe_field_type=GENERAL_FE_FIELD;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_type_general.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_type_general */

int get_FE_field_type_indexed(struct FE_field *field,
	struct FE_field **indexer_field,int *number_of_indexed_values)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
If the field is of type INDEXED_FE_FIELD, the indexer_field and
number_of_indexed_values it uses are returned - otherwise an error is reported.
Use function get_FE_field_FE_field_type to determine the field type.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_type_indexed);
	if (field&&(INDEXED_FE_FIELD==field->fe_field_type)&&indexer_field&&
		number_of_indexed_values)
	{
		*indexer_field=field->indexer_field;
		*number_of_indexed_values=field->number_of_indexed_values;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_type_indexed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_type_indexed */

int set_FE_field_type_indexed(struct FE_field *field,
	struct FE_field *indexer_field,int number_of_indexed_values)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Converts the <field> to type INDEXED_FE_FIELD, indexed by the given
<indexer_field> and with the given <number_of_indexed_values>. The indexer_field
must return a single integer value to be valid.
Allocates and clears the values_storage of the field to fit
field->number_of_components x number_of_indexed_values of the current
value_type. If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_type_indexed);
	return_code=0;
	if (field&&indexer_field&&(0<number_of_indexed_values)&&
		(1==get_FE_field_number_of_components(indexer_field))&&
		(INT_VALUE==get_FE_field_value_type(indexer_field))&&
		/* and to avoid possible endless loops... */
		(INDEXED_FE_FIELD != get_FE_field_FE_field_type(indexer_field)))
	{
		/* 1. make dynamic allocations for any new type-specific data */
		number_of_values=field->number_of_components*number_of_indexed_values;
		if (values_storage=make_value_storage_array(field->value_type,
			number_of_values))
		{
			/* 2. free current type-specific data */
			if (field->values_storage)
			{
				free_value_storage_array(field->values_storage,field->value_type,
					field->number_of_values);		
				DEALLOCATE(field->values_storage);
			}
			/* 3. establish the new type */
			field->fe_field_type=INDEXED_FE_FIELD;
			REACCESS(FE_field)(&(field->indexer_field),indexer_field);
			field->number_of_indexed_values=number_of_indexed_values;
			field->values_storage=values_storage;
			field->number_of_values=number_of_values;
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_type_indexed.  Could not allocate values_storage");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_type_indexed.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_type_indexed */

enum Value_type get_FE_field_value_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 31 August 1999

DESCRIPTION :
Returns the value_type of the <field>.
==============================================================================*/
{
	enum Value_type value_type;

	ENTER(get_FE_field_value_type);
	if (field)
	{
		value_type=field->value_type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_value_type.  Invalid field");
		value_type=UNKNOWN_VALUE;
	}
	LEAVE;

	return (value_type);
} /* get_FE_field_value_type */

int set_FE_field_value_type(struct FE_field *field,enum Value_type value_type)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Sets the value_type of the <field>. Clears/reallocates the values_storage for
FE_field_types that use them, eg. CONSTANT_FE_FIELD and INDEXED_FE_FIELD - but
only if the value_type changes. If function fails the field is left exactly as
it was. Should only call this function for unmanaged fields.
=========================================================================*/
{
	int number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_value_type);
	if (field)
	{
		return_code=1;
		if (value_type != field->value_type)
		{
			/* 1. make dynamic allocations for value_type-specific data */
			values_storage=(Value_storage *)NULL;
			number_of_values=field->number_of_values;
			if (0!=number_of_values)
			{
				if (!(values_storage=make_value_storage_array(value_type,
					number_of_values)))
				{
					return_code=0;
				}
			}
			if (return_code)
			{
				/* 2. free current value_type-specific data */
				if (field->values_storage)
				{
					free_value_storage_array(field->values_storage,field->value_type,
						field->number_of_values);		
					DEALLOCATE(field->values_storage);
				}
				/* 3. establish the new value_type and associated data */
				field->value_type=value_type;
				field->values_storage=values_storage;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_field_value_type.  Not enough memory");
				DEALLOCATE(values_storage);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_value_type.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/* set_FE_field_value_type */

enum Value_type get_FE_field_time_value_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Returns the time_value_type of the <field>.
==============================================================================*/
{
	enum Value_type time_value_type;

	ENTER(get_FE_field_time_value_type);
	if (field)
	{
		time_value_type=field->time_value_type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_time_value_type.  Invalid field");
		time_value_type=UNKNOWN_VALUE;
	}
	LEAVE;

	return (time_value_type);
} /*get_FE_field_time_value_type */

int set_FE_field_time_value_type(struct FE_field *field,enum Value_type time_value_type)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Sets the time_value_type of the <field>.
Should only call this function for unmanaged fields.
=========================================================================*/
{
	int return_code;

	ENTER(set_FE_field_time_value_type);
	if (field)
	{
		field->time_value_type=time_value_type;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_field_time_value_type.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/*set_FE_field_time_value_type */

int get_FE_field_max_array_size(struct FE_field *field,int *max_number_of_array_values, 
	enum Value_type *value_type)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Given the field, search vaules_storage  for the largest array, and return it in
max_number_of_array_values. Return the field value_type.
====================================================================================*/
{
 int return_code,size,i,number_of_array_values;
 
	Value_storage *values_storage;

	ENTER(get_FE_field_max_array_size);
	if (field)
	{
		if(field->number_of_values)
		{
			return_code=1;
			*value_type = field->value_type;
			switch(field->value_type)
			{
				case DOUBLE_ARRAY_VALUE:
				case FE_VALUE_ARRAY_VALUE:
				case FLT_ARRAY_VALUE:
				case SHORT_ARRAY_VALUE:
				case INT_ARRAY_VALUE:
				case UNSIGNED_ARRAY_VALUE:	
				case STRING_VALUE:
				{	
					*max_number_of_array_values = 0;
					size = get_Value_storage_size(*value_type);
					values_storage = field->values_storage;
					for(i=0;i<field->number_of_values;i++)
					{		
						if(field->value_type == STRING_VALUE)
						{
							char *the_string,**str_address;										
							/* get the string's length*/					
							str_address = (char **)(values_storage);
							the_string = *str_address;
							number_of_array_values = strlen(the_string)+1;/* +1 for null termination*/
							if(number_of_array_values > *max_number_of_array_values)
							{
								*max_number_of_array_values = number_of_array_values;
							}
						}
						else	
						{	
							/* get the number of array values  for the specified array in vaules_storage */
							number_of_array_values = *((int *)values_storage);
							if(number_of_array_values > *max_number_of_array_values)
							{
								*max_number_of_array_values = number_of_array_values;
							}
						}
						values_storage+=(i*size);
					}
				}break;		
				default:
				{
					display_message(ERROR_MESSAGE," get_FE_field_max_array_size. Not an array type)");
					number_of_array_values = 0;
					return_code=0;
				}break;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE," get_FE_field_max_array_size. No values at field");
			
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE," get_FE_field_max_array_size. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* get_FE_field_max_array_size */

int get_FE_field_array_attributes(struct FE_field *field, int value_number,
 int *number_of_array_values, enum Value_type *value_type)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Get the value_type and the number of array values for the array in field->values_storage 
specified by value_number. 
Give an error if field->values_storage isn't storing array types.
====================================================================================*/
{

  int return_code,size;
 
	Value_storage *values_storage;

	ENTER(get_FE_field_array_attributes);
	if (field&&(0<=value_number)&&(value_number<=field->number_of_values))
	{
		if(field->number_of_values)
		{
			return_code=1;
			*value_type = field->value_type;
			switch(field->value_type)
			{
				case DOUBLE_ARRAY_VALUE:
				case FE_VALUE_ARRAY_VALUE:
				case FLT_ARRAY_VALUE: 
				case SHORT_ARRAY_VALUE:
				case INT_ARRAY_VALUE:
				case UNSIGNED_ARRAY_VALUE:
				{				
					/* get the correct offset*/	
					size = get_Value_storage_size(*value_type);
					values_storage = field->values_storage+(value_number*size);
					/* get the number of array values  for the specified array in vaules_storage */			
					*number_of_array_values = *((int *)values_storage);
				}break;
				case STRING_VALUE:
				{
					char *the_string,**str_address;
					/* get the correct offset*/	
					size = get_Value_storage_size(*value_type);
					values_storage = field->values_storage+(value_number*size);
					/* get the string*/	
					str_address = (char **)(values_storage);
					the_string = *str_address;
					*number_of_array_values = strlen(the_string)+1;/* +1 for null termination*/
				}break;
				default:
				{
					display_message(ERROR_MESSAGE,"get_FE_field_array_attributes. Not an array type)");
					number_of_array_values = 0;
					return_code=0;
				}break;
			}
		}
		else
		{
			return_code=0;
			display_message(ERROR_MESSAGE,"get_FE_field_array_attributes. No values at the field");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,"get_FE_field_array_attributes. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* get_FE_field_array_attributes */

int get_FE_field_double_array_value(struct FE_field *field, int value_number,
	double *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Get the double array in field->values_storage specified by value_number, of
of length number_of_array_values. If number_of_array_values > the stored arrays 
max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_field_array_attributes() or get_FE_field_max_array_size() 
to get the size of an array.
==============================================================================*/
{

	int return_code,size,the_array_number_of_values,array_size;
	

	Value_storage *values_storage;
	double *the_array,**array_address;

	ENTER(get_FE_field_double_array_value);
	if (field&&array&&(0<=value_number)&&(value_number<=field->number_of_values))
	{
		if(field->number_of_values)
		{
			return_code=1;	 			 
			size = get_Value_storage_size(DOUBLE_ARRAY_VALUE);
			/* get the correct offset*/
			values_storage = field->values_storage+(value_number*size);
			/* get the number of array values  for the specified array in vaules_storage */	
			the_array_number_of_values = *((int *)values_storage);
			if(number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(double);

			/* get the address to copy from*/	
			array_address = (double **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
		}
		else
		{	
			display_message(ERROR_MESSAGE,"get_FE_field_double_array_value. No values at field");
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,"get_FE_field_double_array_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
}/* get_FE_field_double_array_value */

int set_FE_field_double_array_value(struct FE_field *field, int value_number,
	double *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Finds any existing double array at the place specified by  value_number in 
field->values_storage.
Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the
specified  place in the field->values_storage. 

Therefore, should free the passed array, after passing it to this function.

The <field> must be of the correct FE_field_type to have such values and
<number> must be within the range valid for that type.
==============================================================================*/
{

	int return_code,size,array_size;

	double *pointer,*the_array,**array_address;

	Value_storage *values_storage;
	ENTER(set_FE_field_double_array_value);
	if (field&&array&&(0<=value_number)&&(value_number<=field->number_of_values))
	{
		return_code=1;	 
	
		if(field->value_type!=DOUBLE_ARRAY_VALUE)
		{
			display_message(ERROR_MESSAGE,"set_FE_field_double_array_value. "
				" value type doesn't match");
			return_code=0;
		}								

		size = get_Value_storage_size(DOUBLE_ARRAY_VALUE);

		/* get the correct offset*/
		values_storage = field->values_storage+(value_number*size);
		/* get the pointer to stored the array, free any existing one */	
		array_address = (double **)(values_storage+sizeof(int));
		pointer = *array_address;
		if(pointer!=NULL)
			DEALLOCATE(pointer);		
		/* copy the number of array values into field->values_storage*/	
		*((int *)values_storage) = number_of_array_values; 
		/* Allocate the space for the array, and copy the data in */
		array_size = number_of_array_values*sizeof(double);
		if(ALLOCATE(the_array,double,array_size))
		{
			memcpy(the_array,array,array_size);
			/*copy the pointer to the array into field->values_storage  */		
			*array_address = the_array;
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_field_double_array_value. Out of Memory )");
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,"set_FE_field_double_array_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
}/* set_FE_field_double_array_value */

int get_FE_field_string_value(struct FE_field *field,int value_number,
	char **string)
/*******************************************************************************
LAST MODIFIED : 22 September 1999

DESCRIPTION :
Returns a copy of the string stored at <value_number> in the <field>.
Up to the calling function to DEALLOCATE the returned string.
Returned <*string> may be a valid NULL if that is what is in the field.
==============================================================================*/
{
	int return_code,size;
	char *the_string,**string_address;
	
	ENTER(get_FE_field_string_value);
	return_code=0;
	if (field&&(0<=value_number)&&(value_number<field->number_of_values)&&string)
	{
		/* get the pointer to the stored string */			
		size = get_Value_storage_size(STRING_VALUE);
		string_address = (char **)(field->values_storage+value_number*size);
		if (the_string = *string_address)
		{
			if (ALLOCATE(*string,char,strlen(the_string)+1))
			{
				strcpy(*string,the_string);
				return_code=1;	 
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_string_value.  Not enough memory");
			}
		}
		else
		{
			/* no string, so successfully return NULL */
			*string = (char *)NULL;
			return_code=1;	 
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"get_FE_field_string_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_string_value */

int set_FE_field_string_value(struct FE_field *field,int value_number,
	char *string)
/*******************************************************************************
LAST MODIFIED : 22 September 1999

DESCRIPTION :
Copies and sets the <string> stored at <value_number> in the <field>.
<string> may be NULL.
==============================================================================*/
{
	int return_code,size;
	char *the_string,**string_address;

	ENTER(set_FE_field_string_value);
	return_code=0;
	if (field&&(0<=value_number)&&(value_number<field->number_of_values))
	{
		/* get the pointer to the stored string */			
		size = get_Value_storage_size(STRING_VALUE);
		string_address = (char **)(field->values_storage+value_number*size);
		if (string)
		{
			/* reallocate the string currently there */
			if (REALLOCATE(the_string,*string_address,char,strlen(string)+1))
			{
				strcpy(the_string,string);
				*string_address=the_string;
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_field_string_value.  Not enough memory");
			}
		}
		else
		{
			/* NULL string; free the existing string */
			if (*string_address)
			{
				DEALLOCATE(*string_address);
			}
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_string_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	

	return (return_code);
} /* set_FE_field_string_value */

int get_FE_field_element_xi_value(struct FE_field *field,int number,
	struct FE_element **element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Gets the specified global value for the <field>.
==============================================================================*/
{
	int i, number_of_xi_dimensions, return_code;
	Value_storage *values_storage;

	ENTER(get_FE_field_element_xi_value);
	if (field&&(0<=number)&&(number<field->number_of_values)
		&&(field->value_type==ELEMENT_XI_VALUE))
	{
		if(field->number_of_values)
		{
			return_code=1;

			/* get the correct offset*/
			values_storage = field->values_storage + (number*(sizeof(struct FE_element *) +
				MAXIMUM_ELEMENT_XI_DIMENSIONS * sizeof(FE_value)));

			/* copy the element and xi out */	
			*element = *((struct FE_element **)values_storage);
			values_storage += sizeof(struct FE_element *);
			number_of_xi_dimensions = (*element)->shape->dimension;
			if(number_of_xi_dimensions <= MAXIMUM_ELEMENT_XI_DIMENSIONS)
			{
				/* Extract the xi values */
				for(i = 0 ; i < number_of_xi_dimensions ; i++)
				{
					xi[i] = *((FE_value *)values_storage);
					values_storage += sizeof(FE_value);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_element_xi_value.  Number of xi dimensions of element exceeds maximum");
				return_code=0;
			}
		}
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_field_element_xi_value. no values at field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_element_xi_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/* get_FE_field_element_xi_value */

int set_FE_field_element_xi_value(struct FE_field *field,int number,
	struct FE_element *element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 14 September 1999

DESCRIPTION :
Sets the specified global value for the <field>, to the passed Element and xi.
The <field> must be of the correct FE_field_type to have such values and
<number> must be within the range valid for that type.
==============================================================================*/
{
	int i, number_of_xi_dimensions, return_code;
	Value_storage  *values_storage;

	ENTER(set_FE_field_element_xi_value);
	if (field&&(0<=number)&&(number<=field->number_of_values)
		&&(field->value_type==ELEMENT_XI_VALUE) && element && xi)
	{
		return_code=1;	 
		number_of_xi_dimensions = element->shape->dimension;
		if (number_of_xi_dimensions <= MAXIMUM_ELEMENT_XI_DIMENSIONS)
		{

			/* get the correct offset*/
			values_storage = field->values_storage + (number*(sizeof(struct FE_element *) +
				MAXIMUM_ELEMENT_XI_DIMENSIONS * sizeof(FE_value)));
			
			/* copy the element in ensuring correct accessing */	
			REACCESS(FE_element)(((struct FE_element **)values_storage), element);
			values_storage += sizeof(struct Element *);
			/* Write in the xi values */
			for (i=0;i<MAXIMUM_ELEMENT_XI_DIMENSIONS;i++)
			{
				if (i<number_of_xi_dimensions)
				{
					*((FE_value *)values_storage) = xi[i];
				}
				else
				{
					/* set spare xi values to 0 */
					*((FE_value *)values_storage) = 0.0;
				}
				values_storage += sizeof(FE_value);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_element_xi_value.  Number of xi dimensions of element exceeds maximum");
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE," set_FE_field_element_xi_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* set_FE_field_element_xi_value */

int get_FE_field_FE_value_value(struct FE_field *field,int number,
	FE_value *value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Gets the specified global FE_value <value> from <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_FE_value_value);
	if (field&&(FE_VALUE_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values)&&value)
	{
		*value = *((FE_value *)(field->values_storage+(number*sizeof(FE_value))));
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_FE_value_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_FE_value_value */

int set_FE_field_FE_value_value(struct FE_field *field,int number,
	FE_value value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Sets the specified global FE_value <value> in <field>.
The <field> must be of type FE_VALUE_VALUE to have such values and
<number> must be within the range from get_FE_field_number_of_values.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_FE_value_value);
	if (field&&(FE_VALUE_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values))
	{
		*((FE_value *)(field->values_storage+(number*sizeof(FE_value)))) = value;
		return_code=1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"set_FE_field_FE_value_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_FE_value_value */

int get_FE_field_int_value(struct FE_field *field,int number,int *value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Gets the specified global int <value> from <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_int_value);
	if (field&&(INT_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values)&&value)
	{
		*value = *((int *)(field->values_storage+(number*sizeof(int))));
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_int_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_int_value */

int set_FE_field_int_value(struct FE_field *field,int number,int value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Sets the specified global int <value> in <field>.
The <field> must be of type INT_VALUE to have such values and
<number> must be within the range from get_FE_field_number_of_values.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_int_value);
	if (field&&(INT_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values))
	{
		*((int *)(field->values_storage+(number*sizeof(int)))) = value;
		return_code=1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"set_FE_field_int_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_int_value */

int get_FE_field_time_FE_value(struct FE_field *field,int number,FE_value *value)
/*******************************************************************************
LAST MODIFIED : 10 June 1999

DESCRIPTION :
Gets the specified global time value for the <field>.
==============================================================================*/
{
	int return_code;
	Value_storage *times;

	ENTER(get_FE_field_time_FE_value);
	if (field&&(0<=number)&&(number<field->number_of_times))
	{
		if(field->number_of_times)
		{
			return_code=1;
			/* get the correct offset*/
			times = field->times+(number*sizeof(FE_value));
			/* copy the value in*/	
			*value = *((FE_value *)times);		
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_field_time_FE_value.  no times at field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_time_FE_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/*get_FE_field_time_FE_value */

int set_FE_field_time_FE_value(struct FE_field *field,int number,FE_value value)
/*******************************************************************************
LAST MODIFIED : l0 June 1999

DESCRIPTION :
Sets the specified global time value for the <field>, to the passed FE_value
The field value MUST have been previously allocated with set_FE_field_number_of_times
==============================================================================*/
{

	int return_code; 
	FE_value *times;

	ENTER( set_FE_field_time_FE_value);
	if (field&&(0<=number)&&(number<=field->number_of_times))
	{
		return_code=1;	 	
		if(field->time_value_type!=FE_VALUE_VALUE)
		{
			display_message(ERROR_MESSAGE," set_FE_field_time_FE_value. "
				" value type doesn't match");
			return_code=0;
		}								
		/* get the correct offset*/
		times = (FE_value *)(field->times+(number*sizeof(FE_value)));
		/* copy the value in*/		
		*times = value;
	}
	else
	{	
		display_message(ERROR_MESSAGE," set_FE_field_time_FE_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* set_FE_field_time_FE_value */

char *get_FE_field_name(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 19 February 1999

DESCRIPTION :
Returns a pointer to the name for the <field>.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	char *name;

	ENTER(get_FE_field_name);
	if (field)
	{
		name = field->name;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_name.  Invalid argument(s)");
		name = (char *)NULL;
	}
	LEAVE;

	return(name);
}/*get_FE_field_name */

int set_FE_field_name(struct FE_field *field, char *name)
/*******************************************************************************
LAST MODIFIED : 19 February 1999

DESCRIPTION :
Sets the name of the <field>.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_name);
	if (field&&name)
	{
		if (ALLOCATE(field->name,char,strlen(name)+1))
		{
			strcpy(field->name,name);	
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_field_name.  Not enough memory");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_field_name.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_name */

int get_FE_field_CM_field_information(struct FE_field *field,
	struct CM_field_information *cm_field_information)
/*******************************************************************************
LAST MODIFIED : 25 August 1999

DESCRIPTION :
Returns the <cm_field_information> of the <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_CM_field_information);
	if (field&&cm_field_information)
	{
		return_code=COPY(CM_field_information)(cm_field_information,&(field->cm));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_CM_field_information.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_CM_field_information */

int set_FE_field_CM_field_information(struct FE_field *field,
	struct CM_field_information *cm_field_information)
/*******************************************************************************
LAST MODIFIED : 25 August 1999

DESCRIPTION :
Sets the <cm_field_information> of the <field>.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_CM_field_information);
	if (field&&cm_field_information)
	{
		return_code=COPY(CM_field_information)(&(field->cm),cm_field_information);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_CM_field_information.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_CM_field_information */

PROTOTYPE_GET_OBJECT_NAME_FUNCTION(FE_field_component)
/*****************************************************************************
LAST MODIFIED : 2 February 1999

DESCRIPTION :
Returns the FE_field_component component name.
Up to the calling function to deallocate the returned char string.
============================================================================*/
{
	int return_code;

	ENTER(GET_NAME(FE_field_component));
	if (object&&name_ptr)
	{
		if (*name_ptr=get_FE_field_component_name(object->field,object->number))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"GET_NAME(FE_field_component).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* GET_NAME(FE_field_component) */

int set_FE_field_component(struct Parse_state *state,void *component_void,
	void *fe_field_manager_void)
/*******************************************************************************
LAST MODIFIED : 28 January 1999

DESCRIPTION :
Used in command parsing to translate a field component name into an field
component.
???DB.  Should it be here ?
???RC.  Does not ACCESS the field (unlike set_FE_field, above).
==============================================================================*/
{
	char *current_token,*field_component_name,*temp_name;
	int field_component_number,i,return_code;
	struct FE_field *field;
	struct FE_field_component *component;
	struct MANAGER(FE_field) *fe_field_manager;

	ENTER(set_FE_field_component);
	if (state&&(component=(struct FE_field_component *)component_void)&&
		(fe_field_manager=(struct MANAGER(FE_field) *)fe_field_manager_void))
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (field_component_name=strchr(current_token,'.'))
				{
					*field_component_name='\0';
					field_component_name++;
				}
				if (field=FIND_BY_IDENTIFIER_IN_MANAGER(FE_field,name)(current_token,
					fe_field_manager))
				{
					if (field_component_name)
					{
						return_code=1;
						field_component_number=-1;
						for (i=0;(0>field_component_number)&&
							(i<field->number_of_components)&&return_code;i++)
						{
							if (temp_name=get_FE_field_component_name(field,i))
							{
								if (0==strcmp(field_component_name,temp_name))
								{
									field_component_number=i;
								}
								DEALLOCATE(temp_name);
							}
							else
							{
								display_message(WARNING_MESSAGE,
									"set_FE_field_component.  Not enough memory");
								return_code=0;
							}
						}
						if (return_code)
						{
							if (0 <= field_component_number)
							{
								component->field=field;
								component->number=field_component_number;
							}
							else
							{
								display_message(WARNING_MESSAGE,
									"Unknown field component %s.%s",current_token,
									field_component_name);
								return_code=0;
							}
						}
					}
					else
					{
						component->field=field;
						component->number=0;
						return_code=1;
					}
				}
				else
				{
					display_message(WARNING_MESSAGE,"Unknown field %s",current_token);
					return_code=1;
				}
				shift_Parse_state(state,1);
			}
			else
			{
				display_message(INFORMATION_MESSAGE," FIELD_NAME.COMPONENT_NAME");
				if (component->field)
				{
					if (1<component->field->number_of_components)
					{
						display_message(INFORMATION_MESSAGE,"[%s.%s]",
							component->field->name,
							(component->field->component_names)[component->number]);
					}
					else
					{
						display_message(INFORMATION_MESSAGE,"[%s]",component->field->name);
					}
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing field component name");
			display_parse_state_location(state);
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_component.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_component */

int FE_element_get_top_level_xi_number(struct FE_element *element,int xi_number)
/*******************************************************************************
LAST MODIFIED : 12 October 1998

DESCRIPTION :
Returns the xi_number of the parent or parent's parent that changes with the
<xi_number> (0..dimension-1) of <element>.  If there is no parent, then
<xi_number> is returned, or 0 if there is an error.
???RC Could stuff up for graphical finite elements if parent is not in same
element_group and xi directions are different for neighbouring elements.
==============================================================================*/
{
	FE_value *face_to_element;
	int dimension,face_number,top_level_xi_number;
	struct FE_element *parent;
	struct FE_element_parent *element_parent;

	ENTER(FE_element_get_top_level_xi_number);
	if (element&&(element->shape)&&(0<=xi_number)&&
		(xi_number<element->shape->dimension))
	{
		switch (element->shape->dimension)
		{
			case 1:
			{
				if ((element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					(LIST_ITERATOR_FUNCTION(FE_element_parent) *)NULL,(void *)NULL,
					element->parent_list))&&(parent=element_parent->parent))
				{
					face_number=element_parent->face_number;
					dimension=parent->shape->dimension;
					face_to_element=(parent->shape->face_to_element)+
						(face_number*dimension*dimension+1);
					if (*face_to_element)
					{
						top_level_xi_number=FE_element_get_top_level_xi_number(parent,0);
					}
					else
					{
						top_level_xi_number=FE_element_get_top_level_xi_number(parent,1);
					}
				}
				else
				{
					top_level_xi_number=0;
				}
			} break;
			case 2:
			{
				if ((element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					(LIST_ITERATOR_FUNCTION(FE_element_parent) *)NULL,(void *)NULL,
					element->parent_list))&&(parent=element_parent->parent))
				{
					face_number=element_parent->face_number;
					dimension=parent->shape->dimension;
					face_to_element=(parent->shape->face_to_element)+
						(face_number*dimension*dimension+1);
					/* look in column of face_to_element for this xi_number */
					if (face_to_element[xi_number])
					{
						top_level_xi_number=0;
					}
					else
					{
						if (face_to_element[dimension+xi_number])
						{
							top_level_xi_number=1;
						}
						else
						{
							top_level_xi_number=2;
						}
					}
				}
				else
				{
					/* no parents */
					top_level_xi_number=xi_number;
				}
			} break;
			case 3:
			{
				/* 3-D: no parents */
				top_level_xi_number=xi_number;
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"FE_element_get_top_level_xi_number.  Invalid dimension");
				top_level_xi_number=0;
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_top_level_xi_number.  Invalid argument(s)");
		top_level_xi_number=0;
	}
	LEAVE;

	return (top_level_xi_number);
} /* FE_element_get_top_level_xi_number */

static int FE_element_parent_element_in_group(
	struct FE_element_parent *element_parent,void *element_group_void)
/*******************************************************************************
LAST MODIFIED : 15 February 1999

DESCRIPTION :
Returns true if the element referred to by <element_parent> is in the given
<element_group>.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_element) *element_group;

	ENTER(FE_element_parent_element_in_group);
	if (element_parent&&element_parent->parent&&
		(element_group=(struct GROUP(FE_element) *)element_group_void))
	{
		if (FIND_BY_IDENTIFIER_IN_GROUP(FE_element,identifier)(
			element_parent->parent->identifier,element_group))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_element_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_element_in_group */

int FE_element_parent_face_of_element_in_group(
	struct FE_element_parent *element_parent,void *face_in_group_data_void)
/*******************************************************************************
LAST MODIFIED : 20 August 1999

DESCRIPTION :
Returns true if the <element_parent> refers to the given <face_number> of the
parent element AND the parent element is also in the <element_group>.
Conditional function for determining if a 1-D or 2-D element is on a particular
face of a 3-D element in the given element_group. Recursive to handle 1-D case.
If the element group is omitted, no check is made on membership in it.
==============================================================================*/
{
	int return_code;
	struct FE_element *parent;
	struct FE_element_parent_face_of_element_in_group_data *face_in_group_data;

	ENTER(FE_element_parent_face_of_element_in_group);
	if (element_parent&&(parent=element_parent->parent)&&parent->shape&&
		(face_in_group_data=(struct FE_element_parent_face_of_element_in_group_data
			*)face_in_group_data_void))
	{
		if (2==parent->shape->dimension)
		{
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_face_of_element_in_group,
				face_in_group_data_void,parent->parent_list))
			{
				return_code=1;
			}
			else
			{
				return_code=0;
			}
		}
		else
		{
			return_code=
				(element_parent->face_number==face_in_group_data->face_number)&&
				(!(face_in_group_data->element_group)||
					FIND_BY_IDENTIFIER_IN_GROUP(FE_element,identifier)(
						parent->identifier,face_in_group_data->element_group));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_face_of_element_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_face_of_element_in_group */

int FE_element_has_top_level_element(struct FE_element *element,
	void *top_level_element_void)
/*******************************************************************************
LAST MODIFIED : 8 June 2000

DESCRIPTION :
Returns true if <top_level_element> is indeed a top_level parent of <element>.
==============================================================================*/
{
	int return_code;
	struct FE_element *top_level_element;

	ENTER(FE_element_has_top_level_element);
	if (element&&(top_level_element=(struct FE_element *)top_level_element_void)&&
		(CM_ELEMENT==top_level_element->cm.type))
	{
		if ((element==top_level_element)||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				top_level_element_void,element->parent_list))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_top_level_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_top_level_element */

int FE_element_or_parent_is_element(
	struct FE_element *element,void *match_element_void)
/*******************************************************************************
LAST MODIFIED : 21 June 2000

DESCRIPTION :
Returns true if <element> or any of its parents matches <match_element>.
==============================================================================*/
{
	int return_code;
	struct FE_element *match_element;

	ENTER(FE_element_or_parent_is_element);
	if (element&&(match_element=(struct FE_element *)match_element_void))
	{
		if ((element==match_element)||((struct FE_element_parent *)NULL !=
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				match_element_void,element->parent_list)))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_is_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /*  FE_element_or_parent_is_element*/

int FE_element_is_top_level_parent_of_element(
	struct FE_element *top_level_element,void *element_void)
/*******************************************************************************
LAST MODIFIED : 8 June 2000

DESCRIPTION :
Returns true if <top_level_element> is a top_level parent of <element>.
==============================================================================*/
{
	int return_code;
	struct FE_element *element;

	ENTER(FE_element_is_top_level_parent_of_element);
	if (top_level_element&&(element=(struct FE_element *)element_void))
	{
		if ((CM_ELEMENT==top_level_element->cm.type)&&
			((element==top_level_element)||
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_element_matches_recursive,
					(void *)top_level_element,element->parent_list)))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_top_level_parent_of_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_top_level_parent_of_element */

struct FE_element *FE_element_get_top_level_element_conversion(
	struct FE_element *element,struct FE_element *check_top_level_element,
	struct GROUP(FE_element) *element_group,int face_number,
	FE_value *element_to_top_level)
/*******************************************************************************
LAST MODIFIED : 29 June 1999

DESCRIPTION :
Returns the/a top level [ultimate parent] element for <element>. If supplied,
the function attempts to verify that the <check_top_level_element> is in
fact a valid top_level_element for <element>, otherwise it tries to find one in
the <element_group> and with <element> on its <face_number> (if positive), if
either are specified.

If the returned element is different to <element> (ie. is of higher dimension),
then this function also fills the matrix <element_to_top_level> with values for
converting the xi coordinates in <element> to those in the returned element.
<element_to_top_level> should be preallocated to store at least nine FE_values.

The use of the <element_to_top_level> matrix is similar to <face_to_element> in
FE_element_shape - in fact it is either a copy of it, or calculated from it.
It gives the transformation xi(top_level) = b + A xi(element), where b is in the
first column of the matrix, and the rest of the matrix is A. Its size depends
on the dimension of element:top_level, ie.,
1:2 First 4 values, in form of 2 row X 2 column matrix, used only.
1:3 First 6 values, in form of 3 row X 2 column matrix, used only.
2:3 First 9 values, in form of 3 row X 3 column matrix, used only.
NOTE: recursive to handle 1-D to 3-D case.
==============================================================================*/
{
	int i,size;
	FE_value *face_to_element;
	struct FE_element *parent,*top_level_element;
	struct FE_element_parent *element_parent,*first_element_parent;
	struct FE_element_parent_face_of_element_in_group_data face_in_group_data;

	ENTER(FE_element_get_top_level_element_conversion);
	if (element&&element_to_top_level)
	{
		if (first_element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
			(LIST_CONDITIONAL_FUNCTION(FE_element_parent) *)NULL,(void *)NULL,
			element->parent_list))
		{
			if (!(check_top_level_element&&(element_parent=
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_element_matches_recursive,
					(void *)check_top_level_element,element->parent_list))))
			{
				if (element_group)
				{
					if (0>face_number)
					{
						element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
							FE_element_parent_element_in_group,(void *)element_group,
							element->parent_list);
					}
					else
					{
						face_in_group_data.face_number=face_number;
						face_in_group_data.element_group=element_group;
						element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
							FE_element_parent_face_of_element_in_group,
							(void *)&face_in_group_data,element->parent_list);
					}
				}
				else
				{
					if (0>face_number)
					{
						element_parent=first_element_parent;
					}
					else
					{
						element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
							FE_element_parent_has_face_number,(void *)&face_number,
							element->parent_list);
					}
				}
			}
			if ((element_parent||(element_parent=first_element_parent))&&
				(parent=element_parent->parent)&&parent->shape&&
				parent->shape->face_to_element&&
				(top_level_element=FE_element_get_top_level_element_conversion(
					parent,check_top_level_element,element_group,face_number,
					element_to_top_level)))
			{
				face_to_element=parent->shape->face_to_element +
					(element_parent->face_number*
						parent->shape->dimension*parent->shape->dimension);
				size=top_level_element->shape->dimension;
				if (parent == top_level_element)
				{
					/* element_to_top_level = face_to_element of appropriate face */
					for (i=size*size-1;0<=i;i--)
					{
						element_to_top_level[i]=face_to_element[i];
					}
				}
				else
				{
					/* multiply face_to_element of top_level_element (currently in
						 element_to_top_level) by face_to_element of parent */
					/* this is the 1:3 case */
#if defined (DEBUG)
					if (1==element->shape->dimension)
					{
						printf("\n");
						printf("f=[%6.3f %6.3f]\n",face_to_element[0],face_to_element[1]);
						printf("  [%6.3f %6.3f]\n",face_to_element[2],face_to_element[3]);
						printf("e=[%6.3f %6.3f %6.3f]\n",element_to_top_level[0],
							element_to_top_level[1],element_to_top_level[2]);
						printf("  [%6.3f %6.3f %6.3f]\n",element_to_top_level[3],
							element_to_top_level[4],element_to_top_level[5]);
						printf("  [%6.3f %6.3f %6.3f]\n",element_to_top_level[6],
							element_to_top_level[7],element_to_top_level[8]);
					}
#endif /* defined (DEBUG) */
					for (i=0;i<size;i++)
					{
						element_to_top_level[i*2  ] = element_to_top_level[i*size] +
							element_to_top_level[i*size+1]*face_to_element[0]+
							element_to_top_level[i*size+2]*face_to_element[2];
						element_to_top_level[i*2+1] =
							element_to_top_level[i*size+1]*face_to_element[1]+
							element_to_top_level[i*size+2]*face_to_element[3];
					}
#if defined (DEBUG)
					if (1==element->shape->dimension)
					{
						printf("\n");
						printf("[%6.3f %6.3f]\n",element_to_top_level[0],
							element_to_top_level[1]);
						printf("[%6.3f %6.3f]\n",element_to_top_level[2],
							element_to_top_level[3]);
						printf("[%6.3f %6.3f]\n",element_to_top_level[4],
							element_to_top_level[5]);
					}
#endif /* defined (DEBUG) */
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_get_top_level_element_conversion.  Invalid parent");
				top_level_element=(struct FE_element *)NULL;
			}
		}
		else
		{
			/* no parents */
			top_level_element=element;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_top_level_element_conversion.  Invalid argument(s)");
		top_level_element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (top_level_element);
} /* FE_element_get_top_level_element_conversion */

int get_FE_element_discretization_from_top_level(struct FE_element *element,
	int *number_in_xi,struct FE_element *top_level_element,
	int *top_level_number_in_xi,FE_value *element_to_top_level)
/*******************************************************************************
LAST MODIFIED : 21 December 1999

DESCRIPTION :
Returns in <number_in_xi> the equivalent discretization of <element> for its
position - element, face or line - in <top_level_element>. Uses
<element_to_top_level> array for line/face conversion as returned by
FE_element_get_top_level_element_conversion.
<number_in_xi> must have space at lease MAXIMUM_ELEMENT_XI_DIMENSIONS integers,
as remaining values up to this size are cleared to zero.
==============================================================================*/
{
	int dimension,i,j,return_code,top_level_dimension;

	ENTER(get_FE_element_discretization_from_top_level);
	if (element&&number_in_xi&&top_level_element&&top_level_number_in_xi)
	{
		return_code=1;
		dimension=get_FE_element_dimension(element);
		if (top_level_element==element)
		{
			for (i=0;i<dimension;i++)
			{
				number_in_xi[i]=top_level_number_in_xi[i];
			}
		}
		else if (element_to_top_level)
		{
			top_level_dimension=get_FE_element_dimension(top_level_element);
			for (i=0;(i<dimension)&&return_code;i++)
			{
				number_in_xi[i]=0;
				for (j=0;(0==number_in_xi[i])&&(j<top_level_dimension);j++)
				{
					if (0.1<fabs(element_to_top_level[j*(dimension+1)+i+1]))
					{
						number_in_xi[i]=top_level_number_in_xi[j];
					}
				}
				if (0==number_in_xi[i])
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_discretization_from_top_level.  "
						"Could not get discretization");
					return_code=0;
				}
			}
			for (i=dimension;i<MAXIMUM_ELEMENT_XI_DIMENSIONS;i++)
			{
				number_in_xi[i]=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_discretization_from_top_level.  "
				"Missing element_to_top_level matrix");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_discretization_from_top_level.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_discretization_from_top_level */

int get_FE_element_discretization(struct FE_element *element,
	struct GROUP(FE_element) *element_group,int face_number,
	struct FE_field *native_discretization_field,
	int *top_level_number_in_xi,struct FE_element **top_level_element,
	int *number_in_xi)
/*******************************************************************************
LAST MODIFIED : 1 March 2000

DESCRIPTION :
Returns the discretization as <number_in_xi> for displaying graphics over
<element>, given its <element_group>, <face_number> and suggested
<*top_level_element>. If <native_discretization_field> is defined over the
element and is grid-based, it's native discretization is used in preference
to the <top_level_number_in_xi>.
<*top_level_element> can be NULL; final element used will be returned.
<top_level_number_in_xi> should be set by the caller as it will be used if there
is no native_discretization field or it is not defined over the element; in
either case the top_level_number_in_xi used is returned.
==============================================================================*/
{
	FE_value element_to_top_level[9];
	int return_code;

	ENTER(get_FE_element_discretization);
	if (element&&top_level_number_in_xi&&top_level_element&&number_in_xi)
	{
		if (*top_level_element=FE_element_get_top_level_element_conversion(
			element,*top_level_element,element_group,face_number,
			element_to_top_level))
		{
			/* get the discretization requested for top-level element, from native
				 discretization field if not NULL and is element based in element */
			if (native_discretization_field&&
				FE_element_field_is_grid_based(*top_level_element,
					native_discretization_field))
			{
				get_FE_element_field_grid_map_number_in_xi(*top_level_element,
					native_discretization_field,top_level_number_in_xi);
			}
			if (get_FE_element_discretization_from_top_level(element,number_in_xi,
				*top_level_element,top_level_number_in_xi,element_to_top_level))
			{
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_discretization.  Error getting discretization");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"get_FE_element_discretization.  "
				"Error getting top_level_element");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_discretization.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_discretization */

int FE_element_or_parent_contains_node(struct FE_element *element,
	void *node_void)
/*******************************************************************************
LAST MODIFIED : 25 February 1998

DESCRIPTION :
FE_element conditional function returning 1 if <element> or all of its parents
or parent's parents contains <node>.
Routine is used with graphical finite elements to redraw only those elements
affected by a node change when the mesh is edited.
==============================================================================*/
{
	int i,number_of_nodes,return_code;
	struct FE_node *node,**nodes;

	ENTER(FE_element_or_parent_contains_node);
	if (element&&(node=(struct FE_node *)node_void))
	{
		if (element->information)
		{
			return_code=0;
			if ((0<(number_of_nodes=element->information->number_of_nodes))&&
				(nodes=element->information->nodes))
			{
				i=number_of_nodes;
				while ((i>0)&&!return_code)
				{
					if (*nodes==node)
					{
						return_code=1;
					}
					nodes++;
					i--;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_or_parent_contains_node.  Invalid node information");
			}
		}
		else
		{
			if (0<NUMBER_IN_LIST(FE_element_parent)(element->parent_list))
			{
				/* return true if all parents (or their parents) contain the node */
				/*???RC not an exact algorithm, but a clever trivial rejection device */
				return_code=FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
					FE_element_parent_contains_node,node_void,element->parent_list);
			}
			else
			{
				display_message(ERROR_MESSAGE,"FE_element_or_parent_contains_node.  "
					"Element has neither node information nor parents");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_contains_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_or_parent_contains_node */

int FE_element_parent_is_exterior(struct FE_element_parent *element_parent,
	void *dummy_user_data)
/*******************************************************************************
LAST MODIFIED : 12 October 1998

DESCRIPTION :
Returns true if <element_parent> is an exterior surface (ie. has exactly one
parent).
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_parent_is_exterior);
	if (element_parent&&!dummy_user_data)
	{
		return_code=(1 == NUMBER_IN_LIST(FE_element_parent)(
			element_parent->parent->parent_list));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_is_exterior.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_is_exterior */

int FE_element_parent_has_face_number(struct FE_element_parent *element_parent,
	void *void_face_number)
/*******************************************************************************
LAST MODIFIED : 12 August 1997

DESCRIPTION :
Returns true if <element_parent> (a 2-D surface) has no parents itself, or
it is a face, with the given face_number, of one of its parent.
==============================================================================*/
{
	int face_number,return_code;
	struct FE_element *element;

	ENTER(FE_element_parent_has_face_number);
	if (element_parent&&(element=element_parent->parent))
	{
		face_number= *((int *)void_face_number);
		return_code=(
			(0<NUMBER_IN_LIST(FE_element_parent)(element->parent_list))&&
			((FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,face_number)(face_number,
				element->parent_list))));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_face_number.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_has_face_number */

int FE_element_is_dimension(struct FE_element *element,void *dimension_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1998

DESCRIPTION :
Returns true if <element> is of the given <dimension>.
<dimension_void> must be a pointer to an int containing the dimension.
==============================================================================*/
{
	int *dimension,return_code;

	ENTER(FE_element_is_dimension);
	if (element&&element->shape&&(dimension=(int *)dimension_void))
	{
		return_code = (element->shape->dimension == *dimension);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_dimension.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_dimension */

int FE_element_is_dimension_3(struct FE_element *element,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 1 December 1999

DESCRIPTION :
Returns true if <element> is a 3-D element (ie. not a 2-D face or 1-D line).
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_is_dimension_3);
	USE_PARAMETER(dummy_void);
	if (element&&element->shape)
	{
		return_code=(3==element->shape->dimension);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_dimension_3.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_dimension_3 */

int FE_element_is_top_level(struct FE_element *element,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 1 December 1999

DESCRIPTION :
Returns true if <element> is a top-level element - CM_ELEMENT/no parents.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_is_top_level);
	USE_PARAMETER(dummy_void);
	if (element)
	{
		return_code=(CM_ELEMENT==element->cm.type);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_top_level.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_top_level */

int FE_element_is_not_top_level(struct FE_element *element,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 20 July 2000

DESCRIPTION :
Returns true if <element> is not a top-level element = CM_ELEMENT/no parents.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_is_not_top_level);
	USE_PARAMETER(dummy_void);
	if (element)
	{
		return_code=(CM_ELEMENT != element->cm.type);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_not_top_level.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_not_top_level */

int FE_element_to_element_string(struct FE_element *element,char **name_ptr)
/*******************************************************************************
LAST MODIFIED : 24 May 2000

DESCRIPTION :
Writes the cm.number of <element> into a newly allocated string and
points <*name_ptr> at it.
==============================================================================*/
{
	char temp_string[30];
	int return_code;

	ENTER(FE_element_to_element_string);
	if (element&&name_ptr)
	{
		sprintf(temp_string,"%d",element->cm.number);
		*name_ptr=duplicate_string(temp_string);
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_to_element_string.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_to_element_string */

struct FE_element *element_string_to_FE_element(char *name,
	struct MANAGER(FE_element) *element_manager)
/*******************************************************************************
LAST MODIFIED : 17 February 1999

DESCRIPTION :
Converts the <name> into a CM_element_information.number sets 
CM_element_information.type to CM_ELEMENT, finds
and returns the element in the <element_manager> with that CM_element_information.
==============================================================================*/
{
	struct FE_element *element;
	struct CM_element_information cm;

	ENTER(element_string_to_FE_element);
	if (name&&element_manager)
	{
		cm.number=atoi(name);
		cm.type=CM_ELEMENT;
		element=FIND_BY_IDENTIFIER_IN_MANAGER(FE_element,identifier)(
			&cm,element_manager);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"element_string_to_FE_element.  Invalid argument(s)");
		element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (element);
} /* element_string_to_FE_element */

int FE_element_to_any_element_string(struct FE_element *element,
	char **name_ptr)
/*******************************************************************************
LAST MODIFIED : 29 May 2000

DESCRIPTION :
Writes the element as an allocated string containing TYPE NUMBER. Now does not
write element for CM_ELEMENT types.
==============================================================================*/
{
	char temp_string[30];
	int return_code;

	ENTER(FE_element_to_any_element_string);
	if (element&&name_ptr)
	{
		if (CM_ELEMENT==element->cm.type)
		{
			sprintf(temp_string,"%d",element->cm.number);
		}
		else
		{
			sprintf(temp_string,"%s %d",CM_element_type_string(element->cm.type),
				element->cm.number);
		}
		*name_ptr=duplicate_string(temp_string);
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_to_any_element_string.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_to_any_element_string */

struct FE_element *any_element_string_to_FE_element(char *name,
	struct MANAGER(FE_element) *element_manager)
/*******************************************************************************
LAST MODIFIED : 26 May 2000

DESCRIPTION :
Converts name string of format "TYPE NUMBER" to a CM_element_information and
returns the element in the <element_manager> with that CM_element_information.
==============================================================================*/
{
	char *number_string,*type_string;
	struct FE_element *element;
	struct CM_element_information cm;

	ENTER(any_element_string_to_FE_element);
	element=(struct FE_element *)NULL;
	if (name&&element_manager)
	{
		if (type_string=strpbrk(name,"eEfFlL"))
		{
			if (('l'== *type_string)||('L'== *type_string))
			{
				cm.type=CM_LINE;
			}
			else if (('f'== *type_string)||('F'== *type_string))
			{
				cm.type=CM_FACE;
			}
			else
			{
				cm.type=CM_ELEMENT;
			}
		}
		else
		{
			cm.type=CM_ELEMENT;
		}
		if (number_string=strpbrk(name,"+-0123456789"))
		{
			cm.number=atoi(number_string);
			element=FIND_BY_IDENTIFIER_IN_MANAGER(FE_element,identifier)(
				&cm,element_manager);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"any_element_string_to_FE_element.  Invalid argument(s)");
	}
	LEAVE;

	return (element);
} /* any_element_string_to_FE_element */

int set_FE_element_dimension_3(struct Parse_state *state,
	void *element_address_void,void *element_manager_void)
/*******************************************************************************
LAST MODIFIED : 5 July 1999

DESCRIPTION :
A modifier function for specifying a 3-D element (as opposed to a 2-D face or
1-D line number), used (eg.) to set the seed element for a volume texture.
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct FE_element *element,**element_address;
	struct CM_element_information cm;
	struct MANAGER(FE_element) *element_manager;

	ENTER(set_FE_element_dimension_3);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (element_address=
					(struct FE_element **)element_address_void)
				{
					if (1==sscanf(current_token,"%d",&(cm.number)))
					{
						cm.type = CM_ELEMENT;
						if (element_manager=
							(struct MANAGER(FE_element) *)element_manager_void)
						{
							if (element=FIND_BY_IDENTIFIER_IN_MANAGER(
								FE_element,identifier)(&cm,element_manager))
							{
								REACCESS(FE_element)(element_address,element);
								if  ((element->shape) && (3 == element->shape->dimension))
								{
									return_code=shift_Parse_state(state,1);
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"Top level element %s is not dimension 3",current_token);
									display_parse_state_location(state);
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,"Unknown seed element: %s",
									current_token);
								display_parse_state_location(state);
								return_code=0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"set_FE_element_dimension_3.  Missing element_manager");
							return_code=0;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,"Invalid seed element number: %s",
							current_token);
						display_parse_state_location(state);
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_dimension_3.  Missing element_address");
					return_code=0;
				}
			}
			else
			{
				if ((element_address=(struct FE_element **)element_address_void)&&
					(*element_address))
				{
					display_message(INFORMATION_MESSAGE," #[%d]",
						((*element_address)->cm).number);
				}
				else
				{
					display_message(INFORMATION_MESSAGE," #[none]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"Missing seed element number");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_dimension_3.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_dimension_3 */

int set_FE_element_top_level(struct Parse_state *state,
	void *element_address_void,void *element_manager_void)
/*******************************************************************************
LAST MODIFIED : 5 July 1999

DESCRIPTION :
A modifier function for specifying a top level element
, used (eg.) to set the seed element for a xi_texture_coordinate computed_field.
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct FE_element *element,**element_address;
	struct CM_element_information cm;
	struct MANAGER(FE_element) *element_manager;

	ENTER(set_FE_element_top_level);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (element_address=
					(struct FE_element **)element_address_void)
				{
					if (1==sscanf(current_token,"%d",&(cm.number)))
					{
						cm.type = CM_ELEMENT;
						if (element_manager=
							(struct MANAGER(FE_element) *)element_manager_void)
						{
							if (element=FIND_BY_IDENTIFIER_IN_MANAGER(
								FE_element,identifier)(&cm,element_manager))
							{
								REACCESS(FE_element)(element_address,element);
								return_code=shift_Parse_state(state,1);
							}
							else
							{
								display_message(ERROR_MESSAGE,"Unknown seed element: %s",
									current_token);
								display_parse_state_location(state);
								return_code=0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"set_FE_element_top_level.  Missing element_manager");
							return_code=0;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,"Invalid seed element number: %s",
							current_token);
						display_parse_state_location(state);
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_top_level.  Missing element_address");
					return_code=0;
				}
			}
			else
			{
				if ((element_address=(struct FE_element **)element_address_void)&&
					(*element_address))
				{
					display_message(INFORMATION_MESSAGE," #[%d]",
						((*element_address)->cm).number);
				}
				else
				{
					display_message(INFORMATION_MESSAGE," #[none]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"Missing seed element number");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_top_level.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_top_level */

int set_FE_element(struct Parse_state *state,
	void *element_address_void,void *element_manager_void)
/*******************************************************************************
LAST MODIFIED : 5 July 1999

DESCRIPTION :
A modifier function for specifying an element.
==============================================================================*/
{
	int element_number, face_number, line_number, return_code;
	struct FE_element *element,**element_address;
	struct CM_element_information cm;
	struct MANAGER(FE_element) *element_manager;

	ENTER(set_FE_element);
	if (state && (element_manager=
		(struct MANAGER(FE_element) *)element_manager_void))
	{
		if (state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,state->current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,state->current_token))
			{
				if (element_address=
					(struct FE_element **)element_address_void)
				{
					if ((1==sscanf(state->current_token,"%d",&(element_number)))&&
						shift_Parse_state(state,1)&&
						(1==sscanf(state->current_token,"%d",&(face_number)))&&
						shift_Parse_state(state,1)&&
						(1==sscanf(state->current_token,"%d",&(line_number))))
					{
						element=(struct FE_element *)NULL;
						if (element_number)
						{
							if ((!face_number) && (!line_number))
							{
								cm.type = CM_ELEMENT;
								cm.number = element_number;
								if (!(element=FIND_BY_IDENTIFIER_IN_MANAGER(
									FE_element,identifier)(&cm,element_manager)))
								{
									display_message(ERROR_MESSAGE,"Unknown element: %d 0 0",
										element_number);
									display_parse_state_location(state);
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,"set_FE_element.  "
									"Specify only one of element, line or face number");
								display_parse_state_location(state);
								return_code=0;
							}
						}
						else
						{
							if (face_number)
							{
								if (!line_number)
								{
									cm.type = CM_FACE;
									cm.number = face_number;
									if (!(element=FIND_BY_IDENTIFIER_IN_MANAGER(
										FE_element,identifier)(&cm,element_manager)))
									{
										display_message(ERROR_MESSAGE,"Unknown face: 0 %d 0",
											face_number);
										display_parse_state_location(state);
										return_code=0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,"set_FE_element.  "
										"Specify only one of element, line or face number");
									display_parse_state_location(state);
									return_code=0;
								}
							}
							else
							{
								if (line_number)
								{
									cm.type = CM_LINE;
									cm.number = line_number;
									if (!(element=FIND_BY_IDENTIFIER_IN_MANAGER(
										FE_element,identifier)(&cm,element_manager)))
									{
										display_message(ERROR_MESSAGE,"Unknown line: 0 0 %d",
											line_number);
										display_parse_state_location(state);
										return_code=0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"set_FE_element.  Specify an element, line or face number");
									display_parse_state_location(state);
									return_code=0;
								}
							}
						}
						if (element)
						{
							REACCESS(FE_element)(element_address,element);
							return_code=shift_Parse_state(state,1);
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,"Unable to read element number");
						display_parse_state_location(state);
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element.  Missing element_address");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," #[element face line]");
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"Missing element identifier");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element.  Invalid arguments");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element */

int ensure_FE_element_is_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 25 February 2000

DESCRIPTION :
Iterator function for adding <element> to <element_list> if not currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(ensure_FE_element_is_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if (!FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element->identifier,element_list))
		{
			return_code=ADD_OBJECT_TO_LIST(FE_element)(element,element_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_is_in_list */

int ensure_FE_element_is_in_list_conditional(struct FE_element *element,
	void *list_conditional_data_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for adding <element> to a list - if not already in it - if a
conditional function with user_data is true.
The element_list, conditional function and user_data are passed in a
struct FE_element_list_conditional_data * in the second argument.
Warning: Must not be iterating over the list being added to!
==============================================================================*/
{
	int return_code;
	struct FE_element_list_conditional_data *list_conditional_data;

	ENTER(ensure_FE_element_is_in_list_conditional);
	if (element&&(list_conditional_data=
		(struct FE_element_list_conditional_data *)list_conditional_data_void)&&
		list_conditional_data->element_list&&list_conditional_data->function)
	{
		if ((list_conditional_data->function)(element,
			list_conditional_data->user_data))
		{
			if (!IS_OBJECT_IN_LIST(FE_element)(element,
				list_conditional_data->element_list))
			{
				return_code=ADD_OBJECT_TO_LIST(FE_element)(element,
					list_conditional_data->element_list);
			}
			else
			{
				return_code=1;
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_is_in_list_conditional.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_is_in_list_conditional */

int ensure_FE_element_is_not_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 25 February 2000

DESCRIPTION :
Iterator function for removing <element> from <element_list> if currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(ensure_FE_element_is_not_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element->identifier,element_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_element)(element,element_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_is_not_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_is_not_in_list */

int toggle_FE_element_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 25 February 2000

DESCRIPTION :
If <element> is in <element_list> it is taken out, otherwise it is added.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(toggle_FE_element_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element->identifier,element_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_element)(element,element_list);
		}
		else
		{
			return_code=ADD_OBJECT_TO_LIST(FE_element)(element,element_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"toggle_FE_element_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* toggle_FE_element_in_list */

int ensure_FE_element_and_faces_are_in_group(struct FE_element *element,
	void *element_group_void)
/*******************************************************************************
LAST MODIFIED : 28 April 1999

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
adds it and all its faces to the <element_group> if not currently in it.
Note: If function is to be called several times on a group then surround by
MANAGED_GROUP_BEGIN_CACHE/END_CACHE calls for efficient manager messages.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_element) *element_group;

	ENTER(ensure_FE_element_and_faces_are_in_group);
	if (element&&(element_group=(struct GROUP(FE_element) *)element_group_void))
	{
		if (CM_ELEMENT==element->cm.type)
		{
			return_code=add_FE_element_and_faces_to_group(element,element_group);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_and_faces_are_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_and_faces_are_in_group */

int ensure_FE_element_and_faces_are_not_in_group(struct FE_element *element,
	void *element_group_void)
/*******************************************************************************
LAST MODIFIED : 21 April 1999

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
removes it and all its faces from the <element_group> if currently in it.
Note: If function is to be called several times on a group then surround by
MANAGED_GROUP_BEGIN_CACHE/END_CACHE calls for efficient manager messages.
==============================================================================*/
{
	int return_code;
	struct GROUP(FE_element) *element_group;

	ENTER(ensure_FE_element_and_faces_are_not_in_group);
	if (element&&(element_group=(struct GROUP(FE_element) *)element_group_void))
	{
		if ((CM_ELEMENT==element->cm.type)&&
			FIND_BY_IDENTIFIER_IN_GROUP(FE_element,identifier)(
				element->identifier,element_group))
		{
			return_code=remove_FE_element_and_faces_from_group(element,element_group);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_and_faces_are_not_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_and_faces_are_not_in_group */

int ensure_top_level_FE_element_is_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
adds it to the <element_list> if not currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(ensure_top_level_FE_element_is_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if ((CM_ELEMENT==element->cm.type)&&
			(!IS_OBJECT_IN_LIST(FE_element)(element,element_list)))
		{
			return_code=ADD_OBJECT_TO_LIST(FE_element)(element,element_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_top_level_FE_element_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_top_level_FE_element_is_in_list */

int ensure_top_level_FE_element_nodes_are_in_list(struct FE_element *element,
	void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
ensures all its nodes are added to the <node_list> if not currently in it.
==============================================================================*/
{
	int i,return_code;
	struct FE_node **node;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_top_level_FE_element_nodes_are_in_list);
	if (element&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code=1;
		/* only nodes in parentless elements need be added */
		/*???SAB Mark Sagar uses CM_FACE instead of CM_ELEMENT for his toplevel
		  elements in some meshes, hence we don't check for CM_ELEMENT here */
		if (element->information)
		{
			/* note that element may have no node-based fields */
			if (node=element->information->nodes)
			{
				for (i=element->information->number_of_nodes;(0<i)&&return_code;i--)
				{
					if ((*node)&&(!IS_OBJECT_IN_LIST(FE_node)(*node,node_list)))
					{
						if (!ADD_OBJECT_TO_LIST(FE_node)(*node,node_list))
						{
							display_message(ERROR_MESSAGE,
								"ensure_top_level_FE_element_nodes_are_in_list.  "
								"Could not add node to list");
							return_code=0;
						}
					}
					node++;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_top_level_FE_element_nodes_are_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_top_level_FE_element_nodes_are_in_list */

int ensure_top_level_FE_element_nodes_are_not_in_list(
	struct FE_element *element,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
ensures none of its nodes are in <node_list>.
==============================================================================*/
{
	int i,return_code;
	struct FE_node **node;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_top_level_FE_element_nodes_are_not_in_list);
	if (element&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code=1;
		/* only nodes in parentless elements need be added */
		if (CM_ELEMENT==element->cm.type)
		{
			if (element->information)
			{
				/* note that element may have no node-based fields */
				if (node=element->information->nodes)
				{
					for (i=element->information->number_of_nodes;(0<i)&&return_code;i--)
					{
						if ((*node)&&IS_OBJECT_IN_LIST(FE_node)(*node,node_list))
						{
							if (!REMOVE_OBJECT_FROM_LIST(FE_node)(*node,node_list))
							{
								display_message(ERROR_MESSAGE,
									"ensure_top_level_FE_element_nodes_are_not_in_list.  "
									"Could not remove node from list");
								return_code=0;
							}
						}
						node++;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"ensure_top_level_FE_element_nodes_are_not_in_list.  "
					"Missing node scale field information");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_top_level_FE_element_nodes_are_not_in_list.  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_top_level_FE_element_nodes_are_not_in_list */

int ensure_top_level_FE_element_nodes_are_in_group(struct FE_element *element,
	void *node_group_void)
/*******************************************************************************
LAST MODIFIED : 18 October 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
ensures all its nodes are added to the <node_group> if not currently in it.
==============================================================================*/
{
	int i,return_code;
	struct FE_node **node;
	struct GROUP(FE_node) *node_group;

	ENTER(ensure_top_level_FE_element_nodes_are_in_group);
	if (element&&(node_group=(struct GROUP(FE_node) *)node_group_void))
	{
		return_code=1;
		/* only nodes in parentless elements need be added */
		/*???SAB Mark Sagar uses CM_FACE instead of CM_ELEMENT for his toplevel
		  elements in some meshes, hence we don't check for CM_ELEMENT here */
		if (element->information)
		{
			/* note that element may have no node-based fields */
			if (node=element->information->nodes)
			{
				for (i=element->information->number_of_nodes;(0<i)&&return_code;i--)
				{
					if ((*node)&&(!IS_OBJECT_IN_GROUP(FE_node)(*node,node_group)))
					{
						if (!ADD_OBJECT_TO_GROUP(FE_node)(*node,node_group))
						{
							display_message(ERROR_MESSAGE,
								"ensure_top_level_FE_element_nodes_are_in_group.  "
								"Could not add node to list");
							return_code=0;
						}
					}
					node++;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_top_level_FE_element_nodes_are_in_group.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_top_level_FE_element_nodes_are_in_group */

int ensure_top_level_FE_element_nodes_are_not_in_group(
	struct FE_element *element,void *node_group_void)
/*******************************************************************************
LAST MODIFIED : 18 October 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
ensures none of its nodes are in <node_group>.
==============================================================================*/
{
	int i,return_code;
	struct FE_node **node;
	struct GROUP(FE_node) *node_group;

	ENTER(ensure_top_level_FE_element_nodes_are_not_in_group);
	if (element&&(node_group=(struct GROUP(FE_node) *)node_group_void))
	{
		return_code=1;
		/* only nodes in parentless elements need be added */
		if (CM_ELEMENT==element->cm.type)
		{
			if (element->information)
			{
				/* note that element may have no node-based fields */
				if (node=element->information->nodes)
				{
					for (i=element->information->number_of_nodes;(0<i)&&return_code;i--)
					{
						if ((*node)&&IS_OBJECT_IN_GROUP(FE_node)(*node,node_group))
						{
							if (!REMOVE_OBJECT_FROM_GROUP(FE_node)(*node,node_group))
							{
								display_message(ERROR_MESSAGE,
									"ensure_top_level_FE_element_nodes_are_not_in_group.  "
									"Could not remove node from list");
								return_code=0;
							}
						}
						node++;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"ensure_top_level_FE_element_nodes_are_not_in_group.  "
					"Missing node scale field information");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_top_level_FE_element_nodes_are_not_in_group.  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_top_level_FE_element_nodes_are_not_in_group */

int FE_element_or_parent_has_field(struct FE_element *element,
	struct FE_field *field,struct GROUP(FE_element) *element_group)
/*******************************************************************************
LAST MODIFIED : 1 April 1999

DESCRIPTION :
Returns true if the <element> or any of its parents has the <field> defined
over it. By supplying an <element_group> this limits the test to elements that
are also in the group.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_has_field_data element_has_field_data;

	ENTER(FE_element_or_parent_has_field);
	return_code=0;
	if (element&&field)
	{
		if (element->information)
		{
			if (element->information->fields)
			{
				if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(field,
					element->information->fields->element_field_list)&&
					((!element_group)||FIND_BY_IDENTIFIER_IN_GROUP(FE_element,identifier)(
						element->identifier,element_group)))
				{
					return_code=1;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_or_parent_has_field.  Missing fields");
			}
		}
		else
		{
			element_has_field_data.field=field;
			element_has_field_data.element_group=element_group;
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_has_field,(void *)&element_has_field_data,
				element->parent_list))
			{
				return_code=1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_has_field.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_or_parent_has_field */

#if defined (OLD_CODE)
int FE_node_get_field_components(struct FE_node *node,
	struct FE_field *field,int component_no,FE_value **components)
/*******************************************************************************
LAST MODIFIED : 25 August 1998

DESCRIPTION :
Returns the value - not derivatives - held for the given <component_no> of
<field>, or all components if <component_no> is negative. The return value of
the function is the number of components returned, while <*components> will be
set to point to an array containing the values, which the calling function must
deallocate.
???RC Does not handle multiple versions.
==============================================================================*/
{
	FE_value *node_values,*this_component;
	int first_component_no,i,number_of_components;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct FE_node_field_info *node_field_information;

	ENTER(FE_node_get_field_components);
	if (node&&(node_field_information=node->fields)&&(node_values=node->value)&&
		field&&(component_no<field->number_of_components)&&components)
	{
		if ((node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				field,node_field_information->node_field_list)))
		{
			if (component_no<0)
			{
				number_of_components=field->number_of_components;
				first_component_no=0;
			}
			else
			{
				number_of_components=1;
				first_component_no=component_no;
			}
			if (ALLOCATE(*components,FE_value,number_of_components))
			{
				this_component = *components;
				node_field_component = node_field->components + first_component_no;
				for (i=0;i<number_of_components;i++)
				{
					if (node_field_component)
					{
						*this_component = node_values[node_field_component->value];
						this_component++;
						node_field_component++;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"FE_node_get_field_components.  Missing node field component");
						DEALLOCATE(*components);
						number_of_components=0;
					}
				}
			}
			else
			{
				number_of_components=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"FE_node_get_field_components.  "
				"Field '%s' not defined for node %d",field->name,node->cm_node_identifier);
			number_of_components=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_get_field_components.  Invalid argument(s)");
		number_of_components=0;
	}
	LEAVE;

	return (number_of_components);
} /* FE_node_get_field_components */
#endif /* defined (OLD_CODE) */

struct FE_field *FE_node_get_position_cartesian(struct FE_node *node,
	struct FE_field *coordinate_field,FE_value *node_x,FE_value *node_y,
	FE_value *node_z,FE_value *coordinate_jacobian)
/*******************************************************************************
LAST MODIFIED : 12 April 1999

DESCRIPTION :
Evaluates the supplied coordinate_field (or the first one in the node if NULL).
Sets non-present components to zero (eg if only had x and y, z would be set to
zero).  Converts to rectangular Cartesian coordinates: x,y,z.  If
<coordinate_jacobian>, then its is filled with the Jacobian for the
transformation from native coordinates to rectangular Cartesian.  Returns the
field it actually calculated.
???RC Does not handle multiple versions.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;
	FE_value node_1,node_2,node_3;	
	int number_of_coordinate_components;
	struct FE_field *return_field;	
	struct FE_node_field *coordinate_node_field;
	struct FE_node_field_info *node_field_information;
	struct FE_field_component component;

	ENTER(FE_node_get_position_cartesian);
	if (node&&node_x&&node_y&&node_z&&(node_field_information=node->fields))
	{
		if (coordinate_field)
		{
			coordinate_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				coordinate_field,node_field_information->node_field_list);
		}
		else
		{
			coordinate_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
				FE_node_field_is_type_CM_coordinate,(void *)NULL,
				node_field_information->node_field_list);
		}
		if (coordinate_node_field)
		{
			if ( (coordinate_field=coordinate_node_field->field)&& 
				(coordinate_node_field->field->value_type==FE_VALUE_VALUE))
			{
				return_field=coordinate_node_field->field;
				number_of_coordinate_components=
					coordinate_node_field->field->number_of_components;

				coordinate_system=get_FE_field_coordinate_system(coordinate_node_field->field); 
				component.field = coordinate_field; 
				component.number = 0;
				get_FE_nodal_FE_value_value(node,&component,0,FE_NODAL_VALUE,&node_1);

				if (1<number_of_coordinate_components)
				{					
					component.number = 1;
					get_FE_nodal_FE_value_value(node,&component,0,FE_NODAL_VALUE,&node_2);

					if (2<number_of_coordinate_components)
					{						
						component.number = 2;
						get_FE_nodal_FE_value_value(node,&component,0,FE_NODAL_VALUE,
							&node_3);
					}
					else
					{
						node_3=0.;
					}
				}
				else
				{
					node_2=0.;
					node_3=0.;
				}
				/* transform points to cartesian coordinates */
				switch (coordinate_system->type)
				{
					case CYLINDRICAL_POLAR:
					{
						cylindrical_polar_to_cartesian(node_1,node_2,
							node_3,node_x,node_y,node_z,coordinate_jacobian);
					} break;
					case SPHERICAL_POLAR:
					{
						spherical_polar_to_cartesian(node_1,node_2,
							node_3,node_x,node_y,node_z,coordinate_jacobian);
					} break;
					case PROLATE_SPHEROIDAL:
					{

						prolate_spheroidal_to_cartesian(node_1,node_2,
							node_3,coordinate_system->parameters.focus,
							node_x,node_y,node_z,coordinate_jacobian);
					} break;
					case OBLATE_SPHEROIDAL:
					{

						oblate_spheroidal_to_cartesian(node_1,node_2,
							node_3,coordinate_system->parameters.focus,
							node_x,node_y,node_z,coordinate_jacobian);
					} break;
					default:
					{
						*node_x=node_1;
						*node_y=node_2;
						*node_z=node_3;
						if (coordinate_jacobian)
						{
							coordinate_jacobian[0]=1;
							coordinate_jacobian[1]=0;
							coordinate_jacobian[2]=0;
							coordinate_jacobian[3]=0;
							coordinate_jacobian[4]=1;
							coordinate_jacobian[5]=0;
							coordinate_jacobian[6]=0;
							coordinate_jacobian[7]=0;
							coordinate_jacobian[8]=1;
						}
					} break;
				} /* switch */
			} /* if(coordinate_field->value_type==FE_VALUE_VALUE) */
			else
			{
				display_message(ERROR_MESSAGE,"FE_node_get_position_cartesian.  "
					"Currently only does field->value_type=FE_VALUE_VALUE. Write the code!");
				return_field=(struct FE_field *)NULL;
			}
		} /* if (coordinate_node_field) */
		else
		{
			display_message(ERROR_MESSAGE,"FE_node_get_position_cartesian.  "
				"Could not find coordinate_node_field");
			return_field=(struct FE_field *)NULL;
		}
	}/* if (node& */
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_get_position_cartesian.  Invalid argument(s)");
		return_field=(struct FE_field *)NULL;
	}
	LEAVE;

	return (return_field);
} /* FE_node_get_position_cartesian */

int FE_node_set_position_cartesian(struct FE_node *node,
	struct FE_field *coordinate_field,
	FE_value node_x,FE_value node_y,FE_value node_z)
/*******************************************************************************
LAST MODIFIED : 12 April 1999

DESCRIPTION :
Sets the position of <node> in Cartesian coordinates: x[,y[,z]] using the
supplied coordinate_field (or the first one in the node if NULL). The given
Cartesian coordinates are converted into the coordinate system of the node
for the coordinate_field used.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;
	FE_value node_1,node_2,node_3;
	int number_of_coordinate_components,return_code,version;
	struct FE_field_component field_component;
	struct FE_node_field *coordinate_node_field;
	struct FE_node_field_component *coordinate_node_field_component;
	struct FE_node_field_info *node_field_information;	

	ENTER(FE_node_set_position_cartesian);
	if (node&&(node_field_information=node->fields))
	{
		if (coordinate_field)
		{
			coordinate_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				coordinate_field,node_field_information->node_field_list);
		}
		else
		{
			coordinate_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
				FE_node_field_is_type_CM_coordinate,(void *)NULL,
				node_field_information->node_field_list);
		}
		if (coordinate_node_field)
		{
			if ((coordinate_field=coordinate_node_field->field)&& 
				(coordinate_node_field->field->value_type==FE_VALUE_VALUE))
			{
				return_code=1;
				number_of_coordinate_components=
					coordinate_node_field->field->number_of_components;

				coordinate_system = get_FE_field_coordinate_system(
					coordinate_node_field->field);

				switch (coordinate_system->type)
				{
					case CYLINDRICAL_POLAR:
					{
						cartesian_to_cylindrical_polar(node_x,node_y,node_z,
							&node_1,&node_2,&node_3,(float *)NULL);
					} break;
					case PROLATE_SPHEROIDAL:
					{
						cartesian_to_prolate_spheroidal(node_x,node_y,node_z,
							coordinate_system->parameters.focus,
							&node_1,&node_2,&node_3,(float *)NULL);
					} break;
					case OBLATE_SPHEROIDAL:
					{

						/*???DB.  Haven't written geometry function yet */
						node_1=(float)node_x;
						node_2=(float)node_y;
						node_3=(float)node_z;
					} break;
					case SPHERICAL_POLAR:
					{

						/*???DB.  Haven't written geometry function yet */
						node_1=(float)node_x;
						node_2=(float)node_y;
						node_3=(float)node_z;
					} break;
					default:
					{

						node_1=(float)node_x;
						node_2=(float)node_y;
						node_3=(float)node_z;
					} break;
				}
				coordinate_node_field_component=coordinate_node_field->components;
				field_component.field=coordinate_node_field->field;
				field_component.number=0;
				for (version=0;
						 version<coordinate_node_field_component->number_of_versions;version++)
				{
					set_FE_nodal_FE_value_value(node,&field_component,version,FE_NODAL_VALUE,node_1);
				}
				if (1<number_of_coordinate_components)
				{
					coordinate_node_field_component++;
					(field_component.number)++;
					for (version=0;
							 version<coordinate_node_field_component->number_of_versions;version++)
					{
						set_FE_nodal_FE_value_value(node,&field_component,version,
							FE_NODAL_VALUE,node_2);
					}
					if (2<number_of_coordinate_components)
					{
						coordinate_node_field_component++;
						(field_component.number)++;
						for (version=0;version<
									 coordinate_node_field_component->number_of_versions;version++)
						{
							set_FE_nodal_FE_value_value(node,&field_component,version,
								FE_NODAL_VALUE,node_3);
						}
					}
				}
			} /* if(coordinate_field->value_type==FE_VALUE_VALUE) */
			else
			{
				display_message(ERROR_MESSAGE,"FE_node_set_position_cartesian.  "
					"Currently only does field->value_type=FE_VALUE_VALUE. Write the code!");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"FE_node_set_position_cartesian.  "
				"Could not find coordinate_node_field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_set_position_cartesian.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_set_position_cartesian */

int FE_field_is_1_component_integer(struct FE_field *field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 18 May 2000

DESCRIPTION :
Conditional function returning true if <field> has exactly 1 component and a
value type of integer.
This type of field is used for storing eg. grid_point_number.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_1_component_integer);
	USE_PARAMETER(dummy_void);
	if (field)
	{
		return_code=(INT_VALUE==field->value_type)&&
			(1==field->number_of_components);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_1_component_integer.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_1_component_integer */

int FE_field_is_coordinate_field(struct FE_field *field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 18 May 2000

DESCRIPTION :
Conditional function returning true if the <field> is a coodinate field, as
defined by having a CM_field_type of coordinate, a Value_type of FE_VALUE_VALUE
and from 1 to 3 components.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_coordinate_field);
	USE_PARAMETER(dummy_void);
	if (field)
	{
		return_code=
			(CM_COORDINATE_FIELD==field->cm.type)&&
			(FE_VALUE_VALUE==field->value_type)&&
			(1<=field->number_of_components)&&
			(3>=field->number_of_components);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_coordinate_field.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_coordinate_field */

int FE_field_is_anatomical_fibre_field(struct FE_field *field, void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 22 January 1999

DESCRIPTION :
Returns true if the field is of type ANATOMICAL and it has a FIBRE coordinate
system. Used with FIRST_OBJECT_IN_LIST_THAT(FE_field) to get any fibre field
that may be defined over a group of elements.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_anatomical_fibre_field);
	if (field&&!dummy_void)
	{
		return_code=(CM_ANATOMICAL_FIELD==field->cm.type)&&
			(FIBRE==field->coordinate_system.type);		
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_anatomical_fibre_field.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_anatomical_fibre_field */

int FE_field_is_defined_at_node(struct FE_field *field, struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Returns true if the <field> is defined for the <node>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_defined_at_node);
	return_code=0;
	if (field&&node&&(node->fields))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node->fields->node_field_list))
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_defined_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_defined_at_node */

int FE_node_field_is_not_defined(struct FE_node *node,void *field_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
FE_node iterator version of FE_field_is_defined_at_node.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(FE_node_field_is_not_defined);
	if (node&&(field=(struct FE_field *)field_void))
	{
		return_code = !FE_field_is_defined_at_node(field,node);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_is_not_defined.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_is_not_defined */

static int FE_element_parent_has_field_defined(struct FE_element_parent *parent,
	void *field_void)
/*******************************************************************************
LAST MODIFIED : 3 September 1999

DESCRIPTION :
Calls FE_field_is_defined_in_element for the parent element.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(FE_element_parent_has_field_defined);
	if (parent&&(field=(struct FE_field *)field_void))
	{
		return_code=FE_field_is_defined_in_element(field,parent->parent);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_field_defined.  Unknown FE_field_type");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_has_field_defined */

int FE_field_is_defined_in_element(struct FE_field *field,
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Returns true if the <field> is defined for the <element>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_defined_in_element);
	return_code=0;
	if (element&&field)
	{
		if (element->information&&element->information->fields)
		{
			if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(field,
				element->information->fields->element_field_list))
			{
				return_code=1;
			}
		}
		if (!return_code)
		{
			return_code=((struct FE_element_parent *)NULL !=
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_has_field_defined,(void *)field,
					element->parent_list));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_defined_in_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_defined_in_element */

int FE_element_field_is_grid_based(struct FE_element *element,
	struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Returns true if <field> is grid-based in <element>. Only checks the first
component since we assume all subsequent components have the same basis and
numbers of grid cells in xi.
Returns 0 with no error if <field> is not defined over element or not element-
based in it.
==============================================================================*/
{
	int return_code;
	struct FE_element_field *element_field;

	ENTER(FE_element_field_is_grid_based);
	return_code=0;
	if (element&&field&&element->information&&element->information->fields)
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field,element->information->fields->element_field_list)))
		{
			return_code=
				FE_element_field_has_element_grid_map(element_field,(void *)NULL);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_is_grid_based.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_is_grid_based */

int get_FE_element_field_grid_map_number_in_xi(struct FE_element *element,
	struct FE_field *field,int *number_in_xi)
/*******************************************************************************
LAST MODIFIED : 18 October 1999 

DESCRIPTION :
If <field> is grid-based in <element>, returns in <number_in_xi> the numbers of
finite difference cells in each xi-direction of <element>. Note that this number
is one less than the number of grid points in each direction. <number_in_xi>
should be allocated with at least as much space as the number of dimensions in
<element>, but is assumed to have no more than MAXIMUM_ELEMENT_XI_DIMENSIONS so
that int number_in_xi[MAXIMUM_ELEMENT_XI_DIMENSIONS] can be passed to this
function.
==============================================================================*/
{
	int *component_number_in_xi,dimension,i,return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;

	ENTER(get_FE_element_field_grid_map_number_in_xi);
	return_code=0;
	if (element&&element->information&&element->information->fields&&
		number_in_xi&&element->shape&&(dimension=element->shape->dimension)&&
		(MAXIMUM_ELEMENT_XI_DIMENSIONS>=element->shape->dimension))
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field,element->information->fields->element_field_list)))
		{
			/* only GENERAL_FE_FIELD has components and can be grid-based */
			if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
			{
				/* get first field component */
				if (element_field->components&&(component=*(element_field->components)))
				{
					if (ELEMENT_GRID_MAP==component->type)
					{
						if (component_number_in_xi=
							component->map.element_grid_based.number_in_xi)
						{
							return_code=1;
							for (i=0;i<dimension;i++)
							{
								number_in_xi[i]=component_number_in_xi[i];
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"get_FE_element_field_grid_map_number_in_xi.  "
								"Missing component number_in_xi");
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"get_FE_element_field_grid_map_number_in_xi.  "
							"Field is not grid-based");
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_field_grid_map_number_in_xi.  "
						"Missing element field component");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_field_grid_map_number_in_xi.  "
					"Field is not general, not grid-based");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_field_grid_map_number_in_xi.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_field_grid_map_number_in_xi.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_field_grid_map_number_in_xi */

int get_FE_element_field_number_of_grid_values(struct FE_element *element,
	struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 18 October 1999 

DESCRIPTION :
If <field> is grid-based in <element>, returns the total number of grid points
at which data is stored for <field>, equal to product of <number_in_xi>+1 in
all directions. Returns 0 without error for non grid-based fields.
==============================================================================*/
{
	int *component_number_in_xi,dimension,i,number_of_grid_values;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;

	ENTER(get_FE_element_field_number_of_grid_values);
	number_of_grid_values=0;
	if (element&&element->information&&element->information->fields&&
		element->shape&&(dimension=element->shape->dimension))
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field,element->information->fields->element_field_list)))
		{
			/* only GENERAL_FE_FIELD has components and can be grid-based */
			if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
			{
				/* get first field component */
				if (element_field->components&&(component=*(element_field->components)))
				{
					if (ELEMENT_GRID_MAP==component->type)
					{
						if (component_number_in_xi=
							component->map.element_grid_based.number_in_xi)
						{
							number_of_grid_values=1;
							for (i=0;i<dimension;i++)
							{
								number_of_grid_values *= (component_number_in_xi[i] + 1);
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"get_FE_element_field_number_of_grid_values.  "
								"Missing component number_in_xi");
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_field_number_of_grid_values.  "
						"Missing element field component");
				}
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_field_number_of_grid_values.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_field_number_of_grid_values.  Invalid argument(s)");
	}
	LEAVE;

	return (number_of_grid_values);
} /* get_FE_element_field_number_of_grid_values */

int get_FE_element_field_component_grid_FE_value_values(
	struct FE_element *element,struct FE_field *field,int component_number,
	FE_value **values)
/*******************************************************************************
LAST MODIFIED : 14 October 1999

DESCRIPTION :
If <field> is grid-based in <element>, returns an allocated array of the grid
values stored for <component_number>. To get number of values returned, call
get_FE_element_field_number_of_grid_values; Grids change in xi0 fastest.
It is up to the calling function to DEALLOCATE the returned values.
==============================================================================*/
{
	FE_value *value;
	int *component_number_in_xi,dimension,i,number_of_grid_values,return_code,
		size;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;
	Value_storage *values_storage;

	ENTER(get_FE_element_field_component_grid_FE_value_values);
	return_code=0;
	if (element&&element->information&&element->information->fields&&
		element->shape&&(dimension=element->shape->dimension)&&field&&
		(0<=component_number)&&(component_number<field->number_of_components)&&
		(FE_VALUE_VALUE==field->value_type)&&values)
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field,element->information->fields->element_field_list)))
		{
			/* get the component */
			if (element_field->components&&
				(component=element_field->components[component_number]))
			{
				if ((ELEMENT_GRID_MAP==component->type)&&
					(values_storage=element->information->values_storage))
				{
					if (component_number_in_xi=
						component->map.element_grid_based.number_in_xi)
					{
						values_storage += component->map.element_grid_based.value_index;
						size = get_Value_storage_size(FE_VALUE_VALUE);
						number_of_grid_values=1;
						for (i=0;i<dimension;i++)
						{
							number_of_grid_values *= (component_number_in_xi[i] + 1);
						}
						if (ALLOCATE(*values,FE_value,number_of_grid_values))
						{
							return_code=1;
							value= *values;
							for (i=number_of_grid_values;0<i;i--)
							{
								*value = *((FE_value *)values_storage);
								value++;
								values_storage += size;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"get_FE_element_field_component_grid_FE_value_values.  "
								"Not enough memory");
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"get_FE_element_field_component_grid_FE_value_values.  "
							"Missing component number_in_xi");
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_field_component_grid_FE_value_values.  "
						"Field is not grid-based in element");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_field_component_grid_FE_value_values.  "
					"Missing element field component");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_field_component_grid_FE_value_values.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_field_component_grid_FE_value_values.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_field_component_grid_FE_value_values */

int set_FE_element_field_component_grid_FE_value_values(
	struct FE_element *element,struct FE_field *field,int component_number,
	FE_value *values)
/*******************************************************************************
LAST MODIFIED : 14 October 1999

DESCRIPTION :
If <field> is grid-based in <element>, copies <values> into the values storage
for <component_number>. To get number of values to pass, call
get_FE_element_field_number_of_grid_values; Grids change in xi0 fastest.
==============================================================================*/
{
	FE_value *value;
	int *component_number_in_xi,dimension,i,number_of_grid_values,return_code,
		size;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;
	Value_storage *values_storage;

	ENTER(set_FE_element_field_component_grid_FE_value_values);
	return_code=0;
	if (element&&element->information&&element->information->fields&&
		element->shape&&(dimension=element->shape->dimension)&&field&&
		(0<=component_number)&&(component_number<field->number_of_components)&&
		(FE_VALUE_VALUE==field->value_type)&&values)
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field,element->information->fields->element_field_list)))
		{
			/* get the component */
			if (element_field->components&&
				(component=element_field->components[component_number]))
			{
				if ((ELEMENT_GRID_MAP==component->type)&&
					(values_storage=element->information->values_storage))
				{
					if (component_number_in_xi=
						component->map.element_grid_based.number_in_xi)
					{
						return_code=1;
						values_storage += component->map.element_grid_based.value_index;
						size = get_Value_storage_size(FE_VALUE_VALUE);
						number_of_grid_values=1;
						for (i=0;i<dimension;i++)
						{
							number_of_grid_values *= (component_number_in_xi[i] + 1);
						}
						value=values;
						for (i=number_of_grid_values;0<i;i--)
						{
							/*???RC following should be a macro */
							*((FE_value *)values_storage) = *value;
							value++;
							values_storage += size;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"set_FE_element_field_component_grid_FE_value_values.  "
							"Missing component number_in_xi");
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_field_component_grid_FE_value_values.  "
						"Field is not grid-based in element");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_element_field_component_grid_FE_value_values.  "
					"Missing element field component");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_element_field_component_grid_FE_value_values.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_field_component_grid_FE_value_values.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_field_component_grid_FE_value_values */

int get_FE_element_field_component_grid_int_values(struct FE_element *element,
	struct FE_field *field,int component_number,int **values)
/*******************************************************************************
LAST MODIFIED : 14 October 1999

DESCRIPTION :
If <field> is grid-based in <element>, returns an allocated array of the grid
values stored for <component_number>. To get number of values returned, call
get_FE_element_field_number_of_grid_values; Grids change in xi0 fastest.
It is up to the calling function to DEALLOCATE the returned values.
==============================================================================*/
{
	int *value;
	int *component_number_in_xi,dimension,i,number_of_grid_values,return_code,
		size;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;
	Value_storage *values_storage;

	ENTER(get_FE_element_field_component_grid_int_values);
	return_code=0;
	if (element&&element->information&&element->information->fields&&
		element->shape&&(dimension=element->shape->dimension)&&field&&
		(0<=component_number)&&(component_number<field->number_of_components)&&
		(INT_VALUE==field->value_type)&&values)
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field,element->information->fields->element_field_list)))
		{
			/* get the component */
			if (element_field->components&&
				(component=element_field->components[component_number]))
			{
				if ((ELEMENT_GRID_MAP==component->type)&&
					(values_storage=element->information->values_storage))
				{
					if (component_number_in_xi=
						component->map.element_grid_based.number_in_xi)
					{
						values_storage += component->map.element_grid_based.value_index;
						size = get_Value_storage_size(INT_VALUE);
						number_of_grid_values=1;
						for (i=0;i<dimension;i++)
						{
							number_of_grid_values *= (component_number_in_xi[i] + 1);
						}
						if (ALLOCATE(*values,int,number_of_grid_values))
						{
							return_code=1;
							value= *values;
							for (i=number_of_grid_values;0<i;i--)
							{
								*value = *((int *)values_storage);
								value++;
								values_storage += size;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"get_FE_element_field_component_grid_int_values.  "
								"Not enough memory");
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"get_FE_element_field_component_grid_int_values.  "
							"Missing component number_in_xi");
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_field_component_grid_int_values.  "
						"Field is not grid-based in element");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_field_component_grid_int_values.  "
					"Missing element field component");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_field_component_grid_int_values.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_field_component_grid_int_values.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_field_component_grid_int_values */

int set_FE_element_field_component_grid_int_values(struct FE_element *element,
	struct FE_field *field,int component_number,int *values)
/*******************************************************************************
LAST MODIFIED : 14 October 1999

DESCRIPTION :
If <field> is grid-based in <element>, copies <values> into the values storage
for <component_number>. To get number of values to pass, call
get_FE_element_field_number_of_grid_values; Grids change in xi0 fastest.
==============================================================================*/
{
	int *value;
	int *component_number_in_xi,dimension,i,number_of_grid_values,return_code,
		size;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;
	Value_storage *values_storage;

	ENTER(set_FE_element_field_component_grid_int_values);
	return_code=0;
	if (element&&element->information&&element->information->fields&&
		element->shape&&(dimension=element->shape->dimension)&&field&&
		(0<=component_number)&&(component_number<field->number_of_components)&&
		(INT_VALUE==field->value_type)&&values)
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field,element->information->fields->element_field_list)))
		{
			/* get the component */
			if (element_field->components&&
				(component=element_field->components[component_number]))
			{
				if ((ELEMENT_GRID_MAP==component->type)&&
					(values_storage=element->information->values_storage))
				{
					if (component_number_in_xi=
						component->map.element_grid_based.number_in_xi)
					{
						return_code=1;
						values_storage += component->map.element_grid_based.value_index;
						size = get_Value_storage_size(INT_VALUE);
						number_of_grid_values=1;
						for (i=0;i<dimension;i++)
						{
							number_of_grid_values *= (component_number_in_xi[i] + 1);
						}
						value=values;
						for (i=number_of_grid_values;0<i;i--)
						{
							/*???RC following should be a macro */
							*((int *)values_storage) = *value;
							value++;
							values_storage += size;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"set_FE_element_field_component_grid_int_values.  "
							"Missing component number_in_xi");
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_field_component_grid_int_values.  "
						"Field is not grid-based in element");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_element_field_component_grid_int_values.  "
					"Missing element field component");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_element_field_component_grid_int_values.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_field_component_grid_int_values.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_field_component_grid_int_values */

int add_node_to_smoothed_node_lists(struct FE_node *node,
	int component_number,FE_value *derivative,
	struct Smooth_field_over_element_data *smooth_field_over_element_data)
/*******************************************************************************
LAST MODIFIED : 29 October 1998

DESCRIPTION :
???DB.  Came from command.c .  Knows too much about nodes/elements to stay there
==============================================================================*/
{
	int i,j,maximum_number_of_elements_per_node,number_of_components,return_code;
	struct LIST(FE_node) **node_lists;

	ENTER(add_node_to_smoothed_node_lists);
	/* check arguments */
	if (node&&smooth_field_over_element_data&&(smooth_field_over_element_data->
		field)&&(node_lists=smooth_field_over_element_data->node_lists)&&
		(0<=component_number)&&(component_number<(number_of_components=
		smooth_field_over_element_data->field->number_of_components))&&
		derivative)
	{
		return_code=1;
		maximum_number_of_elements_per_node=smooth_field_over_element_data->
			maximum_number_of_elements_per_node;
		i=0;
		while ((i<maximum_number_of_elements_per_node)&&
			!IS_OBJECT_IN_LIST(FE_node)(node,
			node_lists[i*number_of_components+component_number]))
		{
			i++;
		}
		if (i<maximum_number_of_elements_per_node)
		{
			if (i==maximum_number_of_elements_per_node-1)
			{
				maximum_number_of_elements_per_node++;
				if (REALLOCATE(node_lists,smooth_field_over_element_data->node_lists,
					struct LIST(FE_node) *,maximum_number_of_elements_per_node*
					number_of_components))
				{
					smooth_field_over_element_data->node_lists=node_lists;
					smooth_field_over_element_data->maximum_number_of_elements_per_node=
						maximum_number_of_elements_per_node;
					j=0;
					node_lists=(smooth_field_over_element_data->node_lists)+
						(number_of_components*(maximum_number_of_elements_per_node-1));
					while ((j<number_of_components)&&return_code)
					{
						if (*node_lists=CREATE_LIST(FE_node)())
						{
							j++;
							node_lists++;
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"add_node_to_smoothed_node_lists.  Could not create node list");
							while (j>0)
							{
								node_lists--;
								DESTROY_LIST(FE_node)(node_lists);
								j--;
							}
							return_code=0;
						}
					}
					node_lists=smooth_field_over_element_data->node_lists;
				}
				else
				{
					display_message(ERROR_MESSAGE,
					"add_node_to_smoothed_node_lists.  Could not reallocate node lists");
					return_code=0;
					maximum_number_of_elements_per_node--;
				}
			}
			if (return_code)
			{
				if (return_code=REMOVE_OBJECT_FROM_LIST(FE_node)(node,
					node_lists[i*number_of_components+component_number]))
				{
					i++;
					return_code=ADD_OBJECT_TO_LIST(FE_node)(node,
						node_lists[i*number_of_components+component_number]);
				}
			}
		}
		else
		{
			*derivative=0;
			return_code=ADD_OBJECT_TO_LIST(FE_node)(node,
				node_lists[component_number]);
		}
		if (!return_code)
		{
			node_lists=smooth_field_over_element_data->node_lists;
			for (j=number_of_components*maximum_number_of_elements_per_node;j>0;j--)
			{
				DESTROY_LIST(FE_node)(node_lists);
				node_lists++;
			}
			DEALLOCATE(smooth_field_over_element_data->node_lists);
			smooth_field_over_element_data->maximum_number_of_elements_per_node=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_node_to_smoothed_node_lists.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_node_to_smoothed_node_lists */

int smooth_field_over_node(struct FE_node *node,
	void *void_smooth_field_over_node_data)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
???DB.  Came from command.c .  Knows too much about nodes/elements to stay there
==============================================================================*/
{
	FE_value *node_values;
	int return_code;
	struct FE_field_component *field_component;
	struct FE_node *node_copy;
	struct FE_node_field *node_field;
	struct Smooth_field_over_node_data *smooth_field_over_node_data;

	ENTER(smooth_field_over_node);
	/* check arguments */
	if (node&&(smooth_field_over_node_data=
		(struct Smooth_field_over_node_data *)void_smooth_field_over_node_data))
	{
		return_code = 1;

		field_component= &(smooth_field_over_node_data->field_component);
		node_field=(struct FE_node_field *)NULL;

		node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field_component->field,node->fields->node_field_list);

		if (node_field)
		{
			if(node_field->field->value_type==FE_VALUE_VALUE)
			{	
				node_copy=CREATE(FE_node)(0,(struct FE_node *)NULL);
				if (node_copy&&MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
					node_copy,node))
				{	
					Value_storage *values_storage;
					node_values = (FE_value *)NULL;

					find_FE_nodal_values_storage_dest(node_copy,field_component,0,
						FE_NODAL_VALUE,FE_VALUE_VALUE,&values_storage);
					node_values = (FE_value *)values_storage;
				
					switch (((node_field->components)[field_component->number]).
						number_of_derivatives)
					{
						case 1:
						{
							node_values[1] /=
								(FE_value)(smooth_field_over_node_data->number_of_elements);
						} break;
						case 3:
						{
							node_values[1] /= node_values[3];
							node_values[2] /= node_values[3];
							/*						node_values[3]=(node_values[1])*(node_values[2]);*/
							node_values[3]=0;
						} break;
					}
					MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
						node,node_copy,smooth_field_over_node_data->node_manager);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"smooth_field_over_node.  Could not make node_copy");
					return_code=0;
				}
				DESTROY(FE_node)(&node_copy);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"smooth_field_over_node. Currently only works with field->value_type == "
					"FE_VALUE_VALUE. Write the code!");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"smooth_field_over_node.  Field not defined for node");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"smooth_field_over_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* smooth_field_over_node */

int smooth_field_over_element(struct FE_element *element,
	void *void_smooth_field_over_element_data)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
???DB.  Needs to be extended to use get_nodal_value, but what about scale
	factors ?
???DB.  Came from command.c .  Knows too much about nodes/elements to stay there
==============================================================================*/
{
	FE_value *node_1_values,*node_2_values,*node_3_values,*node_4_values,
		*node_5_values,*node_6_values,*node_7_values,*node_8_values,*scale_factors,
		value1, value2, value3, value4, value5, value6, value7, value8, 
		xi, xivector[3];
	float smoothing;
	int element_dimension,i,*index,number_of_components,return_code;
	struct FE_element *element_copy;
	struct FE_element_field *element_field;
	struct FE_element_field_component *element_field_component;
	struct FE_field *field;
	struct FE_node *node_1,*node_1_managed,*node_2,*node_2_managed,*node_3,
		*node_3_managed,*node_4,*node_4_managed,*node_5,*node_5_managed,*node_6,
		*node_6_managed,*node_7,*node_7_managed,*node_8,*node_8_managed;
	struct FE_node_field *node_field_1,*node_field_2,*node_field_3,*node_field_4,
		*node_field_5,*node_field_6,*node_field_7,*node_field_8;
	struct LIST(FE_node) *node_list,**node_lists;
	struct Smooth_field_over_element_data *smooth_field_over_element_data;
	struct Standard_node_to_element_map **node_to_element_map;

	ENTER(smooth_field_over_element);
	/* check arguments */
	if (element&&(smooth_field_over_element_data=
		(struct Smooth_field_over_element_data *)
		void_smooth_field_over_element_data))
	{
		if ((!(element->parent_list)||
			(0==NUMBER_IN_LIST(FE_element_parent)(element->parent_list)))&&
			((1==(element_dimension=element->shape->dimension))||
			(3==element_dimension))&&(element->information)&&
			(scale_factors=element->information->scale_factors))
		{
			if (!(smooth_field_over_element_data->field))
			{
				if (element_field=FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
					FE_element_field_is_type_CM_coordinate,(void *)NULL,
					element->information->fields->element_field_list))
				{
					smooth_field_over_element_data->field=element_field->field;
				}
			}
			if (field=smooth_field_over_element_data->field)
			{
				if(field->value_type==FE_VALUE_VALUE)
				{
					number_of_components=field->number_of_components;
					if (!(smooth_field_over_element_data->node_lists))
					{
						if (ALLOCATE(smooth_field_over_element_data->node_lists,
							struct LIST(FE_node) *,number_of_components))
						{
							smooth_field_over_element_data->
								maximum_number_of_elements_per_node=1;
							i=0;
							while ((i<number_of_components)&&
								smooth_field_over_element_data->node_lists)
							{
								if ((smooth_field_over_element_data->node_lists)[i]=
									CREATE_LIST(FE_node)())
								{
									i++;
								}
								else
								{
									while (i>0)
									{
										DESTROY_LIST(FE_node)(
											(smooth_field_over_element_data->node_lists)+i);
										i--;
									}
									DEALLOCATE(smooth_field_over_element_data->node_lists);
								}
							}
						}
					}
					if (node_lists=smooth_field_over_element_data->node_lists)
					{						
						element_field=(struct FE_element_field *)NULL;

				
						element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
							field,element->information->fields->element_field_list);
		
						if (element_field)
						{
							return_code=1;
							i=0;
							while (return_code&&(i<number_of_components))
							{
								element_field_component=(element_field->components)[i];
								node_list=node_lists[i];
								switch (element_dimension)
								{
									case 1:
									{
										if ((STANDARD_NODE_TO_ELEMENT_MAP==element_field_component->
											type)&&(2==(element_field_component->map).
												standard_node_based.number_of_nodes))
										{
											node_1=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_2=CREATE(FE_node)(0,(struct FE_node *)NULL);
											if (node_1&&node_2)
											{
												node_1_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[0])->node_index];
												node_2_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[1])->node_index];
												if (MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
													node_1,node_1_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_2,node_2_managed))
												{
													node_field_1=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_1->fields->node_field_list);
													node_field_2=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_2->fields->node_field_list);										 					 
													if ((1==((node_field_1->components)[i]).
														number_of_derivatives)&&
														(1==((node_field_2->components)[i]).
															number_of_derivatives))
													{
														node_1_values=(FE_value *)((node_1->values_storage)+
															(((node_field_1->components)[i]).value));									
														node_2_values=(FE_value *)((node_2->values_storage)+
															(((node_field_2->components)[i]).value));
														if (add_node_to_smoothed_node_lists(node_1_managed,i,
															node_1_values+1,smooth_field_over_element_data)&&
															add_node_to_smoothed_node_lists(node_2_managed,i,
																node_2_values+1,smooth_field_over_element_data))
														{
															if (element_field_component->modify)
															{
																/* Need to use this function so go through the FE_calculate */
																xi = 0.0;
																calculate_FE_field(field, i, (struct FE_node *)NULL, 
																	element, &xi, &value1);
																xi = 1.0;
																calculate_FE_field(field, i, (struct FE_node *)NULL, 
																	element, &xi, &value2);
																node_1_values[1] += value2-value1;
																node_2_values[1] += value2-value1;
															}
															else
															{
																node_1_values[1] +=
																	node_2_values[0]-node_1_values[0];
																node_2_values[1] +=
																	node_2_values[0]-node_1_values[0];
															}
															MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
																node_1_managed,node_1,
																smooth_field_over_element_data->node_manager);
															MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
																node_2_managed,node_2,
																smooth_field_over_element_data->node_manager);
														}
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"smooth_field_over_element.  Invalid node field component");
														return_code=0;
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"smooth_field_over_element.  Could not copy nodes");
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"smooth_field_over_element.  Could not create nodes");
												return_code=0;
											}
											DESTROY(FE_node)(&node_1);
											DESTROY(FE_node)(&node_2);
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"smooth_field_over_element.  Invalid element_field_component");
											return_code=0;
										}
									} break;
									case 3:
									{
										if ((STANDARD_NODE_TO_ELEMENT_MAP==element_field_component->
											type)&&(8==(element_field_component->map).
												standard_node_based.number_of_nodes))
										{
											node_1=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_2=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_3=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_4=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_5=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_6=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_7=CREATE(FE_node)(0,(struct FE_node *)NULL);
											node_8=CREATE(FE_node)(0,(struct FE_node *)NULL);
											if (node_1&&node_2&&node_3&&node_4&&node_5&&node_6&&node_7&&
												node_8)
											{
												node_1_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[0])->node_index];
												node_2_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[1])->node_index];
												node_3_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[2])->node_index];
												node_4_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[3])->node_index];
												node_5_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[4])->node_index];
												node_6_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[5])->node_index];
												node_7_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[6])->node_index];
												node_8_managed=(element->information->nodes)[
													((element_field_component->map.standard_node_based.
														node_to_element_maps)[7])->node_index];
												if (MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
													node_1,node_1_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_2,node_2_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_3,node_3_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_4,node_4_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_5,node_5_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_6,node_6_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_7,node_7_managed)&&
													MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier)(
														node_8,node_8_managed))
												{
											
													node_field_1=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_1->fields->node_field_list);
													node_field_2=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_2->fields->node_field_list);
													node_field_3=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_3->fields->node_field_list);
													node_field_4=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_4->fields->node_field_list);
													node_field_5=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_5->fields->node_field_list);
													node_field_6=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_6->fields->node_field_list);
													node_field_7=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_7->fields->node_field_list);
													node_field_8=FIND_BY_IDENTIFIER_IN_LIST(
														FE_node_field,field)(field,
															node_8->fields->node_field_list);
										
													if ((3==((node_field_1->components)[i]).
														number_of_derivatives)&&
														(3==((node_field_2->components)[i]).
															number_of_derivatives)&&
														(3==((node_field_3->components)[i]).
															number_of_derivatives)&&
														(3==((node_field_4->components)[i]).
															number_of_derivatives)&&
														(3==((node_field_5->components)[i]).
															number_of_derivatives)&&
														(3==((node_field_6->components)[i]).
															number_of_derivatives)&&
														(3==((node_field_7->components)[i]).
															number_of_derivatives)&&
														(3==((node_field_8->components)[i]).
															number_of_derivatives))
													{
														node_1_values=(FE_value *)((node_1->values_storage)+
															(((node_field_1->components)[i]).value));
														node_2_values=(FE_value *)((node_2->values_storage)+
															(((node_field_2->components)[i]).value));
														node_3_values=(FE_value *)((node_3->values_storage)
															+(((node_field_3->components)[i]).value));
														node_4_values=(FE_value *)((node_4->values_storage)+
															(((node_field_4->components)[i]).value));
														node_5_values=(FE_value *)((node_5->values_storage)+
															(((node_field_5->components)[i]).value));
														node_6_values=(FE_value *)((node_6->values_storage)+
															(((node_field_6->components)[i]).value));
														node_7_values=(FE_value *)((node_7->values_storage)+
															(((node_field_7->components)[i]).value));
														node_8_values=(FE_value *)((node_8->values_storage)+
															(((node_field_8->components)[i]).value));
														if (IS_OBJECT_IN_LIST(FE_node)(node_1_managed,
															node_list))
														{
															node_1_values[3] += 1;
														}
														else
														{
															node_1_values[1]=0;
															node_1_values[2]=0;
															node_1_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_1_managed,
																node_list);
														}
														if (IS_OBJECT_IN_LIST(FE_node)(node_2_managed,
															node_list))
														{
															node_2_values[3] += 1;
														}
														else
														{
															node_2_values[1]=0;
															node_2_values[2]=0;
															node_2_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_2_managed,
																node_list);
														}
														if (IS_OBJECT_IN_LIST(FE_node)(node_3_managed,
															node_list))
														{
															node_3_values[3] += 1;
														}
														else
														{
															node_3_values[1]=0;
															node_3_values[2]=0;
															node_3_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_3_managed,
																node_list);
														}
														if (IS_OBJECT_IN_LIST(FE_node)(node_4_managed,
															node_list))
														{
															node_4_values[3] += 1;
														}
														else
														{
															node_4_values[1]=0;
															node_4_values[2]=0;
															node_4_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_4_managed,
																node_list);
														}
														if (IS_OBJECT_IN_LIST(FE_node)(node_5_managed,
															node_list))
														{
															node_5_values[3] += 1;
														}
														else
														{
															node_5_values[1]=0;
															node_5_values[2]=0;
															node_5_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_5_managed,
																node_list);
														}
														if (IS_OBJECT_IN_LIST(FE_node)(node_6_managed,
															node_list))
														{
															node_6_values[3] += 1;
														}
														else
														{
															node_6_values[1]=0;
															node_6_values[2]=0;
															node_6_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_6_managed,
																node_list);
														}
														if (IS_OBJECT_IN_LIST(FE_node)(node_7_managed,
															node_list))
														{
															node_7_values[3] += 1;
														}
														else
														{
															node_7_values[1]=0;
															node_7_values[2]=0;
															node_7_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_7_managed,
																node_list);
														}
														if (IS_OBJECT_IN_LIST(FE_node)(node_8_managed,
															node_list))
														{
															node_8_values[3] += 1;
														}
														else
														{
															node_8_values[1]=0;
															node_8_values[2]=0;
															node_8_values[3]=1;
															ADD_OBJECT_TO_LIST(FE_node)(node_8_managed,
																node_list);
														}

														if (element_field_component->modify)
														{
															/* Need to use this function so go through the FE_calculate */
															xivector[0] = 0.0;
															xivector[1] = 0.0;
															xivector[2] = 0.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value1);
															xivector[0] = 1.0;
															xivector[1] = 0.0;
															xivector[2] = 0.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value2);
															xivector[0] = 0.0;
															xivector[1] = 1.0;
															xivector[2] = 0.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value3);
															xivector[0] = 1.0;
															xivector[1] = 1.0;
															xivector[2] = 0.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value4);
															xivector[0] = 0.0;
															xivector[1] = 0.0;
															xivector[2] = 1.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value5);
															xivector[0] = 1.0;
															xivector[1] = 0.0;
															xivector[2] = 1.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value6);
															xivector[0] = 0.0;
															xivector[1] = 1.0;
															xivector[2] = 1.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value7);
															xivector[0] = 1.0;
															xivector[1] = 1.0;
															xivector[2] = 1.0;
															calculate_FE_field(field, i, (struct FE_node *)NULL, 
																element, xivector, &value8);
															node_1_values[1] += value2-value1;
															node_1_values[2] += value3-value1;
															node_2_values[1] += value2-value1;
															node_2_values[2] += value4-value2;
															node_3_values[1] += value4-value3;
															node_3_values[2] += value3-value1;
															node_4_values[1] += value4-value3;
															node_4_values[2] += value4-value2;
															node_5_values[1] += value6-value5;
															node_5_values[2] += value7-value5;
															node_6_values[1] += value6-value5;
															node_6_values[2] += value8-value6;
															node_7_values[1] += value8-value7;
															node_7_values[2] += value7-value5;
															node_8_values[1] += value8-value7;
															node_8_values[2] += value8-value6;
														}
														else
														{
															node_1_values[1] += node_2_values[0]-node_1_values[0];
															node_1_values[2] += node_3_values[0]-node_1_values[0];
															node_2_values[1] += node_2_values[0]-node_1_values[0];
															node_2_values[2] += node_4_values[0]-node_2_values[0];
															node_3_values[1] += node_4_values[0]-node_3_values[0];
															node_3_values[2] += node_3_values[0]-node_1_values[0];
															node_4_values[1] += node_4_values[0]-node_3_values[0];
															node_4_values[2] += node_4_values[0]-node_2_values[0];
															node_5_values[1] += node_6_values[0]-node_5_values[0];
															node_5_values[2] += node_7_values[0]-node_5_values[0];
															node_6_values[1] += node_6_values[0]-node_5_values[0];
															node_6_values[2] += node_8_values[0]-node_6_values[0];
															node_7_values[1] += node_8_values[0]-node_7_values[0];
															node_7_values[2] += node_7_values[0]-node_5_values[0];
															node_8_values[1] += node_8_values[0]-node_7_values[0];
															node_8_values[2] += node_8_values[0]-node_6_values[0];
														}

														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_1_managed,node_1,
															smooth_field_over_element_data->node_manager);
														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_2_managed,node_2,
															smooth_field_over_element_data->node_manager);
														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_3_managed,node_3,
															smooth_field_over_element_data->node_manager);
														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_4_managed,node_4,
															smooth_field_over_element_data->node_manager);
														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_5_managed,node_5,
															smooth_field_over_element_data->node_manager);
														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_6_managed,node_6,
															smooth_field_over_element_data->node_manager);
														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_7_managed,node_7,
															smooth_field_over_element_data->node_manager);
														MANAGER_MODIFY_NOT_IDENTIFIER(FE_node,cm_node_identifier)(
															node_8_managed,node_8,
															smooth_field_over_element_data->node_manager);
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"smooth_field_over_element.  Invalid node field component");
														return_code=0;
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"smooth_field_over_element.  Could not copy nodes");
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"smooth_field_over_element.  Could not create nodes");
												return_code=0;
											}
											DESTROY(FE_node)(&node_1);
											DESTROY(FE_node)(&node_2);
											DESTROY(FE_node)(&node_3);
											DESTROY(FE_node)(&node_4);
											DESTROY(FE_node)(&node_5);
											DESTROY(FE_node)(&node_6);
											DESTROY(FE_node)(&node_7);
											DESTROY(FE_node)(&node_8);
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"smooth_field_over_element.  Invalid element_field_component");
											return_code=0;
										}
									} break;
								}
								i++;
							}
							if (return_code)
							{
								element_copy=CREATE(FE_element)(element->identifier,
									(struct FE_element *)NULL);
								if (element_copy&&MANAGER_COPY_WITH_IDENTIFIER(FE_element,
									identifier)(element_copy,element)&&
									(element_copy->information)&&
									(scale_factors=element_copy->information->scale_factors))
								{
									/* set scale factors to implement "smoothing" */
									/*???DB.  Very specific */
									node_to_element_map=(((element_field->components)[0])->map).
										standard_node_based.node_to_element_maps;
									smoothing=smooth_field_over_element_data->smoothing;
									switch (element_dimension)
									{
										case 1:
										{
											for (i=2;i>0;i--)
											{
												index=(*node_to_element_map)->scale_factor_indices;
												scale_factors[*index]=1;
												index++;
												scale_factors[*index]=smoothing;
												node_to_element_map++;
											}
										} break;
										case 3:
										{
											for (i=8;i>0;i--)
											{
												index=(*node_to_element_map)->scale_factor_indices;
												scale_factors[*index]=1;
												index++;
												scale_factors[*index]=smoothing;
												index++;
												scale_factors[*index]=smoothing;
												index++;
												scale_factors[*index]=smoothing*smoothing;
												node_to_element_map++;
											}
										} break;
									}
									MANAGER_MODIFY_NOT_IDENTIFIER(FE_element,identifier)(
										element,element_copy,
										smooth_field_over_element_data->element_manager);
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"smooth_field_over_element.  Could not make element_copy");
									return_code=0;
								}
								DESTROY(FE_element)(&element_copy);
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"smooth_field_over_element.  Field not defined for element");
							return_code=0;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"smooth_field_over_element.  Could not create node lists");
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"smooth_field_over_element."
						" Only works for field->value_type == FE_VALUE_VALUE "
						" Write the code!");
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"smooth_field_over_element.  No field to smooth");
				return_code=0;
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"smooth_field_over_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* smooth_field_over_element */

PROTOTYPE_COPY_OBJECT_FUNCTION(CM_field_information)
/*******************************************************************************
LAST MODIFIED: 4 February 1999

DESCRIPTION:
Copies the CM_Field_information from source to destination
==============================================================================*/
{
	int return_code;
	ENTER(COPY(CM_field_information));
	if(destination&&source)
	{
		destination->type = source->type;
		switch(source->type)
		{
			case CM_DEPENDENT_FIELD:
			{
				destination->indices.dependent.nc = source->indices.dependent.nc;
				destination->indices.dependent.niy = source->indices.dependent.niy;
				destination->indices.dependent.nr = source->indices.dependent.nr;
				destination->indices.dependent.nxc = source->indices.dependent.nxc;
				destination->indices.dependent.nxt = source->indices.dependent.nxt;			
			}break;
			default: /* everything else is independent*/
			{
				destination->indices.independent.nr = source->indices.independent.nr;;
			}break;
		}
		return_code =1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"COPY(CM_field_informatio). Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);

}/* PROTOTYPE_COPY_OBJECT_FUNCTION(CM_field_information) */

enum CM_field_type get_CM_field_information_type(struct CM_field_information *field_info)
/*******************************************************************************
LAST MODIFIED : 4 February 1999

DESCRIPTION :
gets the name type and indice of field_info.
==============================================================================*/
{
	enum CM_field_type cm_field_type;

	ENTER(get_CM_field_information_type);
	if (field_info)
	{
		cm_field_type = field_info->type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_CM_field_information_type.  Invalid CM_field_information ");
		cm_field_type = CM_UNKNOWN_FIELD;	
	}
	LEAVE;

	return (cm_field_type);
} /* get_CM_field_information_type */

int set_CM_field_information(struct CM_field_information *field_info,
	enum CM_field_type type, int *indices)
/*******************************************************************************
LAST MODIFIED : 4 February 1999

DESCRIPTION :
Sets the  type and indices (if any) of field_info. Any indices passed as a 
pointer to an array.
==============================================================================*/
{
	int return_code;

	ENTER(set_CM_field_information);
	if (field_info)
	{
		field_info->type = type;

		switch(type)
		{
			case CM_DEPENDENT_FIELD:
			{
				if(indices)/* have some data */
				{
					field_info->indices.dependent.nc = *indices;
					indices++;
					field_info->indices.dependent.niy = *indices;
					indices++;
					field_info->indices.dependent.nr = *indices;
					indices++;
					field_info->indices.dependent.nxc = *indices;
					indices++;
					field_info->indices.dependent.nxt = *indices;
				}
				else /* no data, assume all zero */
				{
					field_info->indices.dependent.nc = 0;
					field_info->indices.dependent.niy = 0;
					field_info->indices.dependent.nr = 0;
					field_info->indices.dependent.nxc = 0;
					field_info->indices.dependent.nxt = 0;
				}					
			}break;
			default: /* everything else is independent*/
			{
				if(indices)/* have some data */
				{
					field_info->indices.independent.nr = *indices;
				}
				else /* no data, assume all zero */
				{
					field_info->indices.independent.nr = 0;
				}		
			}break;
		}

		return_code =1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_CM_field_information. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /*set_CM_field_information */

int compare_CM_field_information(struct CM_field_information *field_info1,
	struct CM_field_information *field_info2)
/************************************************************************
LAST MODIFIED: 4 February 1999

DESCRIPTION:
Compares the CM_Field_information structures, field_info1 and field_info2.
=======================================================================*/
{
	int return_code;
	ENTER(compare_CM_field_information);

	if(field_info1&&field_info2)
	{
		if(field_info1->type != field_info2->type )/* do the types match? */
			return_code =0;
		else
		{
			if(field_info1->type == CM_UNKNOWN_FIELD)
				return_code = 1; /*if both CM_UNKNOWN_FIELD don't have to match anything else */
			else /* do the indices match?*/
				{
					switch(field_info1->type)
					{
						case CM_DEPENDENT_FIELD:
						{
							return_code = (
							  (field_info1->indices.dependent.nc == 
									field_info2->indices.dependent.nc)&&
								(field_info1->indices.dependent.niy == 
									field_info2->indices.dependent.niy)&&
								(field_info1->indices.dependent.nr ==
									field_info2->indices.dependent.nr)&&
								(field_info1->indices.dependent.nxc ==
									field_info2->indices.dependent.nxc)&&
								(field_info1->indices.dependent.nxt == 
									field_info2->indices.dependent.nxt)
									);
						}break;
						default: /* everything else is independent*/
						{
							return_code = (field_info1->indices.independent.nr == 
								field_info2->indices.independent.nr);
						}break;
					} /* switch*/
				}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE," compare_CM_field_information. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
}/*compare_CM_field_information */

int FE_element_field_is_type_CM_coordinate(
	struct FE_element_field *element_field, void *dummy)
/*******************************************************************************
LAST MODIFIED: 11 February 1999

DESCRIPTION:
returns true if <element_field> has a field of type CM_coordinate
Not static as used in command/cmiss.c
==============================================================================*/
{
	int return_code;
	ENTER(FE_element_field_is_type_CM_coordinate);

	if(element_field&&!dummy)
	{
		return_code = (element_field->field->cm.type == CM_COORDINATE_FIELD); 	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_element_is_type_CM_coordinate. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
}/* FE_node_element_is_type_CM_coordinate */

int FE_element_field_is_type_CM_anatomical(
	struct FE_element_field *element_field, void *dummy)
/*******************************************************************************
LAST MODIFIED: 11 February 1999

DESCRIPTION:
returns true if <element_field> has a field of type CM_anatomical
Not static as used in projection/projection.c
==============================================================================*/
{
	int return_code;
	ENTER(FE_element_field_is_type_CM_anatomical);

	if(element_field&&!dummy)
	{
		return_code = (element_field->field->cm.type == CM_ANATOMICAL_FIELD); 	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_element_is_type_CM_anatomical. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return(return_code);
}/* FE_node_element_is_type_CM_anatomical */

int FE_element_shape_find_face_number_for_xi(struct FE_element_shape *shape, 
	FE_value *xi, int *face_number)
/*******************************************************************************
LAST MODIFIED : 11 June 1999

DESCRIPTION :
This function checks to see if the given <xi> location (of dimension 
<shape>->dimension) specifys a location on a face.  If it does then the function
returns 1 and <face_number> is set.  Otherwise the function returns 0.
SAB Doesn't work for polygons at the moment.
==============================================================================*/
{
	int bit, i, j, return_code;
	float sum;

	ENTER(FE_element_shape_find_face_number_for_xi);

	if (shape&&face_number)
	{
		return_code = 0;
		for (i = 0 ; (!return_code) && (i < shape->number_of_faces) ; i++)
		{
			sum = 0.0;
			bit = 2;
			for (j = 0 ; j < shape->dimension ; j++)
			{
				if (shape->faces[i] & bit)
				{
					sum += xi[j];
				}
				bit *= 2;
			}
			if (shape->faces[i] & 1)
			{
				if (sum >= 1.0)
				{
					*face_number = i;
					return_code = 1;
				}
			}
			else
			{
				if (sum <= 0.0)
				{
					*face_number = i;
					return_code = 1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"find_face_number_of_face_type.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_shape_find_face_number_for_xi */

struct GROUP(FE_node) *make_node_and_element_and_data_groups(
	struct MANAGER(GROUP(FE_node)) *node_group_manager,
	struct MANAGER(FE_node) *node_manager,
	struct MANAGER(FE_element) *element_manager,
	struct MANAGER(GROUP(FE_element))	*element_group_manager,
	struct MANAGER(GROUP(FE_node)) *data_group_manager,char *group_name)
/*******************************************************************************
LAST MODIFIED : 18 May 1999

DESCRIPTION :
Makes a node group ,and a corresponding element group and data group using the 
supplied group_name. If a group exists, it will be cleaned out.
This function is used for creating node group such that the nodes will be visible 
in the 3D window/graphical element editor.
The node group is returned. The node group is cached, 
with MANAGED_GROUP_BEGIN_CACHE(FE_node).
The caching must be ended by the calling function.
==============================================================================*/
{
	struct FE_element *element_to_destroy;
	struct FE_node *node_to_destroy;
	struct GROUP(FE_node) *existing_group,*node_group,*same_name_data_group;
	struct GROUP(FE_element) *same_name_element_group;	
	int success;

	ENTER(make_node_and_element_and_data_groups);
	if(node_group_manager&&node_manager&&element_group_manager&&data_group_manager&&
		group_name)
	{
		node_group = (struct GROUP(FE_node) *)NULL;
		success = 1;
		existing_group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_node),name)(
			group_name,node_group_manager);	
		if(existing_group)	
		{
			node_group = existing_group;
			if(!(NUMBER_IN_GROUP(FE_node)(node_group)))
			{							
				success = 1;/* group exists and is empty */						
			}
			else
			{	
				/* now need to clean out the group */
				while(success&&(node_to_destroy=FIRST_OBJECT_IN_GROUP_THAT(FE_node)
					((GROUP_CONDITIONAL_FUNCTION(FE_node) *)NULL, NULL, node_group)))
				{
					success = REMOVE_OBJECT_FROM_GROUP(FE_node)(
						node_to_destroy, node_group);				
					if (FE_node_can_be_destroyed(node_to_destroy))
					{				
						success = REMOVE_OBJECT_FROM_MANAGER(FE_node)(node_to_destroy,
							node_manager);					
					}					
				}	/* while(success */
			}/* else */
		}/* if(existing_group) */
		else
		{
			/* create the group*/
			node_group = CREATE_GROUP(FE_node)(group_name);
			/* now need to add the group to manager */
			if (!(success=ADD_OBJECT_TO_MANAGER(GROUP(FE_node))(
				node_group,node_group_manager)))
			{
				DEACCESS(GROUP(FE_node))(&node_group);
				success = 0;
			}	
		}
		same_name_data_group=
			FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_node),name)(group_name,data_group_manager);
		/* do we have a same_name_data_group? */	
		if(same_name_data_group&&success)
		{
			if(!(NUMBER_IN_GROUP(FE_node)(same_name_data_group)))
			{							
				success = 1;/* group exists and is empty */							
			}
			else
			{	
				/* now need to clean out the group */
				while(success&&(node_to_destroy=FIRST_OBJECT_IN_GROUP_THAT(FE_node)
					((GROUP_CONDITIONAL_FUNCTION(FE_node) *)NULL, NULL,same_name_data_group)))
				{
					success = REMOVE_OBJECT_FROM_GROUP(FE_node)(
						node_to_destroy, same_name_data_group);				
					if (FE_node_can_be_destroyed(node_to_destroy))
					{				
						success = REMOVE_OBJECT_FROM_MANAGER(FE_node)(node_to_destroy,
							node_manager);					
					}					
				}	/* while */
			} /* else */
		}/* if(same_name_data_group&&success) */
		else
		{
			/* create the group,add it to the manager*/
			same_name_data_group=CREATE(GROUP(FE_node))(group_name);
			if (!ADD_OBJECT_TO_MANAGER(GROUP(FE_node))(same_name_data_group,
				data_group_manager))
			{
				DEACCESS(GROUP(FE_node))(&same_name_data_group);
				success = 0;
			}
		}
		same_name_element_group=
			FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_element),name)(group_name,element_group_manager);
		/* do we have a same_name_element_group? */	
		if(same_name_element_group&&success)
		{
			if(!(NUMBER_IN_GROUP(FE_element)(same_name_element_group)))
			{								
				success = 1; /* group exists and is empty */	
			}
			else
			{		/* now need to clean out the group */
				while(success&&(element_to_destroy=FIRST_OBJECT_IN_GROUP_THAT(FE_element)
					((GROUP_CONDITIONAL_FUNCTION(FE_element) *)NULL, NULL,same_name_element_group)))
				{
					success = REMOVE_OBJECT_FROM_GROUP(FE_element)(
						element_to_destroy, same_name_element_group);				
					if (FE_element_can_be_destroyed(element_to_destroy))
					{				
						success = REMOVE_OBJECT_FROM_MANAGER(FE_element)(element_to_destroy,
							element_manager);					
					}					
				}	/* while */			
			}/* else */
		}/* if(same_name_element_group&&success) */
		else
		{
			/* create the group,add it to the manager*/
			same_name_element_group=CREATE(GROUP(FE_element))(group_name);
			if (!ADD_OBJECT_TO_MANAGER(GROUP(FE_element))(
				same_name_element_group,element_group_manager))
			{
				DEACCESS(GROUP(FE_element))(&same_name_element_group);
				success = 0;
			}
		}
		if(success)
		{					
			MANAGED_GROUP_BEGIN_CACHE(FE_node)(node_group);
		}	
		else
		{	
			display_message(ERROR_MESSAGE,"make_node_and_element_and_data_groups."
				" Failed to create or free groups");
			node_group = (struct GROUP(FE_node) *)NULL;	 
		}									 	
	}
	else
	{	
		display_message(ERROR_MESSAGE,"make_node_and_element_and_data_groups. Invalid arguments");	
		node_group = (struct GROUP(FE_node) *)NULL;
	}					
	LEAVE;

	return (node_group);
} /* make_node_and_element_and_data_groups */

struct FE_field_order_info *CREATE(FE_field_order_info)(int number_of_fields)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION
Allocate space for an array of pointers to fields of length number_of_field, 
set these to NULL, copy the number-of_fields. 
==============================================================================*/
{
	int i;
	struct FE_field_order_info *field_order_info;

	ENTER(CREATE(FE_field_order_info));
	if (number_of_fields>=0)
	{
		if (ALLOCATE(field_order_info,struct FE_field_order_info,1))
		{
			if (number_of_fields)
			{
				if (ALLOCATE(field_order_info->fields,struct FE_field *,
					number_of_fields))
				{
					field_order_info->number_of_fields = number_of_fields; 
					for (i=0;i<number_of_fields;i++)
					{				
						field_order_info->fields[i] = (struct FE_field *)NULL;
					}		
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_field_order_info). "
						"Could not allocate memory for fields pointer");
					DEALLOCATE(field_order_info);	
				}
			}
			else
			{
				field_order_info->number_of_fields = number_of_fields; 
				field_order_info->fields = (struct FE_field **)NULL;
				field_order_info->access_count=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
"CREATE(FE_field_order_info).  Could not allocate memory for node field info");
			DEALLOCATE(field_order_info);	
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_field_order_info).  Invalid argument(s)");
		DEALLOCATE(field_order_info);	
	}
	LEAVE;

	return (field_order_info);
} /* CREATE(FE_field_order_info) */

int DESTROY(FE_field_order_info)(
	struct FE_field_order_info **field_order_info_address)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION
Frees them memory used by field_order_info.
==============================================================================*/
{
	int return_code,i;
	struct FE_field_order_info *field_order_info;

	ENTER(DESTROY(FE_field_order_info));
	if ((field_order_info_address)&&
		(field_order_info= *field_order_info_address))
	{			
		/* free the components */
		if (field_order_info->fields)
		{		
			/* free the components */		
			for (i=0;i<field_order_info->number_of_fields;i++)
			{				
				DEACCESS(FE_field)(&(field_order_info->fields[i]));
			}		
			DEALLOCATE(field_order_info->fields);	
		}
		DEALLOCATE(*field_order_info_address);	
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_field_order_info) */

int define_node_field_and_field_order_info(struct FE_node *node,
	struct FE_field *field,int *number_of_derivatives,int *number_of_versions,
	int *field_number,int number_of_fields,
	enum FE_nodal_value_type **nodal_value_types,
	struct FE_field_order_info *field_order_info)
/*******************************************************************************
LAST MODIFIED : 21 May 1999

DESCRIPTION :
Helper function for create_config_template_node() and
create_mapping_template_node() that,  given the node,field and
field_order_info, defines the field at the node, and places it in the
field_order_info
==============================================================================*/
{
	int return_code;

	ENTER(define_node_field_and_field_order_info);
	return_code=0;
	if (node&&field&&field_order_info&&nodal_value_types&&
		number_of_derivatives&&number_of_versions)
	{
		return_code=1;
		if (define_FE_field_at_node(node,field,number_of_derivatives,
			number_of_versions,nodal_value_types))
		{	
			if (*field_number<number_of_fields)
			{			
				set_FE_field_order_info_field(field_order_info,*field_number,
					field);
				(*field_number)++;
			}
			else
			{
				display_message(ERROR_MESSAGE,
"define_node_field_and_field_order_info.  Too many fields for sock the_field_order_info");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
"define_node_field_and_field_order_info.  Could not define  field at node");
			DESTROY(FE_field)(&field);				
			return_code=0;
		}	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"define_node_field_and_field_order_info. Invalid arguments");
		return_code=0;	
	}		 
	LEAVE;

	return (return_code);
} /* define_node_field_and_field_order_info */

int iterative_define_FE_field_at_node(struct FE_node *node,
	void *define_FE_field_at_node_data_void)
/*******************************************************************************
LAST MODIFIED : 8 November 2000

DESCRIPTION :
iterative wrapper for define_FE_field_at_node.
first checks if field is already defined with FE_field_is_defined_at_node
===============================================================================*/
{
	int *number_of_derivatives,*number_of_versions,return_code;
	enum FE_nodal_value_type **nodal_value_types;
	struct FE_field *field;
	struct Define_FE_field_at_node_data  *define_FE_field_at_node_data;
	
	ENTER(iterative_define_FE_field_at_node);	
	field=(struct FE_field *)NULL;
	define_FE_field_at_node_data=(struct Define_FE_field_at_node_data  *)NULL;
	if(node&&define_FE_field_at_node_data_void&&(define_FE_field_at_node_data=
		(struct Define_FE_field_at_node_data  *)define_FE_field_at_node_data_void))
	{	
		field=define_FE_field_at_node_data->field;
		number_of_derivatives=define_FE_field_at_node_data->number_of_derivatives;
		number_of_versions=define_FE_field_at_node_data->number_of_versions;
		nodal_value_types=define_FE_field_at_node_data->nodal_value_types;
		if(!FE_field_is_defined_at_node(field,node))
		{
			if(!(return_code=define_FE_field_at_node(node,field,number_of_derivatives,
				number_of_versions,nodal_value_types)))
			{
				display_message(ERROR_MESSAGE,"iterative_define_FE_field_at_node. define failed");
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"iterative_define_FE_field_at_node."
			" Invalid argument(s)");
		return_code=0;
	}
	LEAVE;
	return(return_code);
} /*iterative_define_FE_field_at_node */

int get_FE_field_order_info_number_of_fields(
	struct FE_field_order_info *field_order_info)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Gets the <field_order_info> number_of_fields
==============================================================================*/
{
	int number_of_fields;

	ENTER(get_FE_field_order_info_number_of_fields);
	if (field_order_info)
	{
		number_of_fields=field_order_info->number_of_fields;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_order_info_number_of_fields.  Invalid argument");		
		number_of_fields=0;
	}
	LEAVE;

	return (number_of_fields);
} /* get_FE_field_order_info_number_of_fields */

struct FE_field *get_FE_field_order_info_field(
	struct FE_field_order_info *field_order_info,int field_number)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Gets the <field_order_info> field at the specified field_number
==============================================================================*/
{
	struct FE_field *field;

	ENTER(get_FE_field_order_info_field);
	if ((field_order_info)&&
		(field_number<=field_order_info->number_of_fields))
	{		
		field=field_order_info->fields[field_number];
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_order_info_field.  Invalid argument");		
		field=(struct FE_field *)NULL;
	}
	LEAVE;

	return(field);
} /* get_FE_node_field_order_field */

int set_FE_field_order_info_field(
	struct FE_field_order_info *field_order_info,int field_number,
	struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Sets the <field_order_info> field at the specified field_number
==============================================================================*/
{
	int return_code

	ENTER(set_FE_field_order_info_field);
	return_code=0;
	if((field_order_info)&&
		(field_number<=field_order_info->number_of_fields)&&(field))
	{		
		REACCESS(FE_field)(&(field_order_info->fields[field_number]),field);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_order_info_field.  Invalid argument");		
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_field_order_field */

struct FE_node_order_info *CREATE(FE_node_order_info)(
	int number_of_nodes)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Allocate space for an array of pointers to nodes of length number_of_nodes, 
set these to NULL, copy the number_of_nodes. 
==============================================================================*/
{
	int i;
	struct FE_node_order_info *node_order_info;

	ENTER(CREATE(FE_node_order_info));				
	if (ALLOCATE(node_order_info,struct FE_node_order_info,1))
	{
		if (number_of_nodes>0)
		{	
			if (ALLOCATE(node_order_info->nodes,struct FE_node *,
				number_of_nodes))
			{
				node_order_info->number_of_nodes = number_of_nodes; 
				for (i=0;i<number_of_nodes;i++)
				{				
					node_order_info->nodes[i]=(struct FE_node *)NULL;
				}	
				node_order_info->access_count=0;
			}
			else
			{
				display_message(ERROR_MESSAGE,
"CREATE(FE_node_order_info).  Could not allocate memory for node_field_info->nodes");
				DEALLOCATE(node_order_info->nodes);		
				DEALLOCATE(node_order_info);
			}
		}
		else
		{	
			node_order_info->number_of_nodes=0;
			node_order_info->nodes=(struct FE_node **)NULL;	
			node_order_info->access_count=0;
		}
		node_order_info->current_node_number=0;
	}
	else
	{
		display_message(ERROR_MESSAGE,
"CREATE(FE_node_order_info).  Could not allocate memory for node field info");	
		DEALLOCATE(node_order_info);	
	}
	LEAVE;

	return (node_order_info);
} /* CREATE(FE_node_order_info) */

int DESTROY(FE_node_order_info)(
	struct FE_node_order_info **node_order_info_address)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Frees them memory used by node_order_info.
==============================================================================*/
{
	int i,return_code;
	struct FE_node_order_info *node_order_info;
	struct FE_node *node;

	ENTER(DESTROY(FE_node_order_info));
	return_code=0;
	if ((node_order_info_address)&&
		(node_order_info= *node_order_info_address))
	{					
		/* free the components */		
		for (i=0;i<node_order_info->number_of_nodes;i++)
		{				
			node=node_order_info->nodes[i];
			DEACCESS(FE_node)(&node);
		}			
		DEALLOCATE(node_order_info->nodes);	
		DEALLOCATE(*node_order_info_address);	
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node_order_info) */

DECLARE_OBJECT_FUNCTIONS(FE_node_order_info)

PROTOTYPE_COPY_OBJECT_FUNCTION(FE_node_order_info)
/*******************************************************************************
LAST MODIFIED : 11 August 1999

DESCRIPTION :
Makes an exacy copy of the FE_node_order_info
==============================================================================*/
{
	int return_code,i;
	
	ENTER(COPY(FE_node_order_info));
	return_code=0;
	/* check the arguments */
	if (source&&destination)
	{
		/* free any existing the destination things */
		if(destination->number_of_nodes)
		{
			for (i=0;i<destination->number_of_nodes;i++)
			{				
				DEACCESS(FE_node)(&(destination->nodes[i]));
			}		
			DEALLOCATE(destination->nodes);
			destination->number_of_nodes=0;
		}
		if (ALLOCATE(destination->nodes,struct FE_node*,source->number_of_nodes))
		{
			/* copy the new */
			destination->number_of_nodes=source->number_of_nodes;
			for (i=0;i<destination->number_of_nodes;i++)
			{				
				destination->nodes[i]=ACCESS(FE_node)(source->nodes[i]);
			}	
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"COPY(FE_node_order_info).  Out of memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"COPY(FE_node_order_info).  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* COPY(FE_node_order_info) */

int get_FE_node_order_info_number_of_nodes(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Gets the <node_order_info> number_of_nodes
==============================================================================*/
{
	int number_of_nodes;

	ENTER(get_FE_node_order_info_number_of_nodes);
	if (node_order_info)
	{
		number_of_nodes=node_order_info->number_of_nodes;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_number_of_nodes.  Invalid argument");		
		number_of_nodes=0;
	}
	LEAVE;

	return (number_of_nodes);
} /* get_FE_node_order_info_number_of_nodes */

struct FE_node *get_FE_node_order_info_node(
	struct FE_node_order_info *node_order_info,int node_number)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Gets the <node_order_info> node at the specified node_number
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_node);
	if ((node_order_info)&&
		(node_number<=node_order_info->number_of_nodes))
	{		
		node=node_order_info->nodes[node_number];
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /* get_FE_node_order_info_node */

int set_FE_node_order_info_node(
	struct FE_node_order_info *node_order_info,int node_number,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 16 August 1999

DESCRIPTION : 
Sets the <node_order_info> node at the specified node_number.
Also sets the current_node_number to <the node_number>
==============================================================================*/
{
	int return_code

	ENTER(set_FE_node_order_info_node);
	return_code=0;
	if ((node_order_info)&&
		(node_number<=node_order_info->number_of_nodes)&&(node))
	{	
		REACCESS(FE_node)(&(node_order_info->nodes[node_number]),node);
		node_order_info->current_node_number=node_number;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_node_order_info_node.  Invalid argument");		
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_group_order_node */

int get_FE_node_order_info_current_node_number(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
gets the <node_order_info> <current_node_number>
==============================================================================*/
{
	int current_node_number;

	ENTER(get_FE_node_order_info_current_node_number);	
	if (node_order_info&&(node_order_info->number_of_nodes>0))
	{			
		current_node_number=node_order_info->current_node_number;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_node_order_info_current_node_number.  Invalid argument");		
		current_node_number=-1;
	}
	LEAVE;

	return (current_node_number);
} /* set_FE_node_order_info_current_node_number */

int set_FE_node_order_info_current_node_number(
	struct FE_node_order_info *node_order_info,int current_node_number)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Sets the <node_order_info> <current_node_number>
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_node_order_info_current_node_number);
	return_code=0;
	if ((node_order_info)&&(current_node_number>-1)&&
		(current_node_number<=node_order_info->number_of_nodes))
	{			
		node_order_info->current_node_number=current_node_number;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_node_order_info_current_node_number.  Invalid argument");		
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_order_info_current_node_number */

struct FE_node *get_FE_node_order_info_current_node(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Gets the <node_order_info> node at the current_node_number
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_current_node);
	if (node_order_info)
	{		
		if(node_order_info->number_of_nodes)
		{
			node=node_order_info->nodes[node_order_info->current_node_number];
		}
		else
		{
			node=(struct FE_node *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_current_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /*get_FE_node_order_info_current_node  */

struct FE_node *get_FE_node_order_info_next_node(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Gets the <node_order_info> next node by incrementing the current_node_number,
and returning the new current node. If at the end of the array, return null.
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_next_node);
	if (node_order_info)
	{		
		if((node_order_info->number_of_nodes)&&
			(node_order_info->current_node_number<(node_order_info->number_of_nodes-1)))
		{			
			node_order_info->current_node_number++;
			node=node_order_info->nodes[node_order_info->current_node_number];		
		}
		else
		{
			node=(struct FE_node *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_next_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /*get_FE_node_order_info_next_node  */

struct FE_node *get_FE_node_order_info_prev_node(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Gets the <node_order_info> next node by incrementing the current_node_number,
and returning the new current node. If at the start of the array, return null.
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_prev_node);
	if (node_order_info)
	{		
		if((node_order_info->number_of_nodes)&&
			(node_order_info->current_node_number>0))
		{			
			node_order_info->current_node_number--;
			node=node_order_info->nodes[node_order_info->current_node_number];		
		}
		else
		{
			node=(struct FE_node *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_prev_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /*get_FE_node_order_info_prev_node  */

int add_nodes_FE_node_order_info(int number_of_nodes_to_add,
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 6 July 1999

DESCRIPTION :
Reallocates space for more  nodes in a previously created
FE_node_order_info.  Use set_FE_node_order_info to set up the nodes.
==============================================================================*/
{
	int i,return_code,old_number_of_nodes;
	struct FE_node **nodes;

	ENTER(add_nodes_FE_node_order_info)
	return_code=0;
	if (node_order_info)
	{		
		old_number_of_nodes=node_order_info->number_of_nodes;
		node_order_info->number_of_nodes += number_of_nodes_to_add;				
		if (REALLOCATE(nodes,node_order_info->nodes,struct FE_node *,
			node_order_info->number_of_nodes))
		{
			node_order_info->nodes=nodes;
			/*set the new nodes to null*/
			for(i=old_number_of_nodes;i<node_order_info->number_of_nodes;i++)
			{
				node_order_info->nodes[i]=(struct FE_node *)NULL;
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_order_info_add_node.  Out of memory ");	
			return_code=0;
		}
	}	
	else
	{	
		display_message(ERROR_MESSAGE,
			"FE_node_order_info_add_node.  Invalid arguments");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_order_info_add_node */

int fill_FE_node_order_info(struct FE_node *node,void *dummy)
/*******************************************************************************
LAST MODIFIED : 6 July 1999

DESCRIPTION :
Allocate space for and add an FE_node to previously created 
FE_node_order_info (passed in dummy).
Called iteratively.
==============================================================================*/
{
	int return_code;
	struct FE_node **nodes;
	struct FE_node_order_info *node_order_info;

	ENTER(fill_FE_node_order_info)
	return_code=0;
	if (node&&dummy)
	{
		node_order_info=(struct FE_node_order_info *)dummy;
		node_order_info->number_of_nodes++;
		/* reallocate space for pointer to the node */
		if (REALLOCATE(nodes,node_order_info->nodes,struct FE_node *,
			node_order_info->number_of_nodes))
		{
			node_order_info->nodes=nodes;
			/* set the pointer to the node */
			node_order_info->nodes[node_order_info->number_of_nodes-1]=
				ACCESS(FE_node)(node);
			node_order_info->current_node_number=node_order_info->number_of_nodes-1;
			return_code=1;	
		}		
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"fill_FE_node_order_info. Invalid arguments");
		return_code=0;	
	}
	LEAVE;

	return (return_code);
} /* fill_FE_node_order_info */

int get_FE_node_group_access_count(struct GROUP(FE_node) *node_group)
/*******************************************************************************
LAST MODIFIED : 17 August 1999

DESCRIPTION :Debug function. May be naughty.
==============================================================================*/
{
	int access_count;
	if(node_group)
	{
		access_count=node_group->access_count;
	}
	else
	{
		access_count=-1;
	}
	return(access_count);
}

int get_FE_field_access_count(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 17 August 1999

DESCRIPTION :Debug function. May be naughty.
==============================================================================*/
{
	int access_count;
	if(field)
	{
		access_count=field->access_count;
	}
	else
	{
		access_count=-1;
	}
	return(access_count);
}

int free_node_and_element_and_data_groups(struct GROUP(FE_node) **a_node_group,
	struct MANAGER(FE_element) *element_manager,
	struct MANAGER(GROUP(FE_element))	*element_group_manager,
	struct MANAGER(FE_node) *data_manager,
	struct MANAGER(GROUP(FE_node)) *data_group_manager,
	struct MANAGER(FE_node) *node_manager,
	struct MANAGER(GROUP(FE_node)) *node_group_manager )
/*******************************************************************************
LAST MODIFIED : 2 October 2000

DESCRIPTION :
Given a <node_group>, frees it's asscoiated element and data groups
Deaccesses the <node_group> and attempts to remove it from the manager.
(i.e assumes the <node_group> has been accessed somewhere)
==============================================================================*/
{
	int return_code;	
	char *group_name;
	struct GROUP(FE_node) *data_group=(struct GROUP(FE_node) *)NULL;
	struct GROUP(FE_node) *temp_node_group=(struct GROUP(FE_node) *)NULL;
	struct GROUP(FE_node) *node_group=(struct GROUP(FE_node) *)NULL;
	struct GROUP(FE_element) *element_group=(struct GROUP(FE_element) *)NULL;
	struct FE_node *node_to_destroy=(struct FE_node *)NULL;
	struct FE_element *element_to_destroy=(struct FE_element *)NULL;

	ENTER(free_node_and_element_and_data_groups);
	if(node_group=*a_node_group)
	{
		return_code=1;		
		GET_NAME(GROUP(FE_node))(node_group,&group_name);	 
		if ((element_group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_element),name)
			(group_name,element_group_manager)))
		{					
			while(return_code&&(element_to_destroy=FIRST_OBJECT_IN_GROUP_THAT(FE_element)
				((GROUP_CONDITIONAL_FUNCTION(FE_element) *)NULL, NULL,element_group)))
			{
				return_code = REMOVE_OBJECT_FROM_GROUP(FE_element)(
					element_to_destroy,element_group);				
				if (FE_element_can_be_destroyed(element_to_destroy))
				{				
					return_code = REMOVE_OBJECT_FROM_MANAGER(FE_element)(element_to_destroy,
						element_manager);					
				}					
			}	
			if(MANAGED_GROUP_CAN_BE_DESTROYED(FE_element)(element_group))
			{
			REMOVE_OBJECT_FROM_MANAGER(GROUP(FE_element))(element_group,
				element_group_manager);	
			}
		}	
	
		if ((data_group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_node),name)
			(group_name,data_group_manager)))
		{					
			while(return_code&&(node_to_destroy=FIRST_OBJECT_IN_GROUP_THAT(FE_node)
				((GROUP_CONDITIONAL_FUNCTION(FE_node) *)NULL, NULL, data_group)))
			{
				return_code = REMOVE_OBJECT_FROM_GROUP(FE_node)(
					node_to_destroy,data_group);				
				if (FE_node_can_be_destroyed(node_to_destroy))
				{				
					return_code = REMOVE_OBJECT_FROM_MANAGER(FE_node)(node_to_destroy,
						data_manager);					
				}					
			}		
			if(MANAGED_GROUP_CAN_BE_DESTROYED(FE_node)(data_group))
			{
				REMOVE_OBJECT_FROM_MANAGER(GROUP(FE_node))(data_group,
					data_group_manager);
			}
		}	
		while(return_code&&(node_to_destroy=FIRST_OBJECT_IN_GROUP_THAT(FE_node)
			((GROUP_CONDITIONAL_FUNCTION(FE_node) *)NULL, NULL, node_group)))
		{
			return_code = REMOVE_OBJECT_FROM_GROUP(FE_node)(
				node_to_destroy,node_group);				
			if (FE_node_can_be_destroyed(node_to_destroy))
			{				
				return_code = REMOVE_OBJECT_FROM_MANAGER(FE_node)(node_to_destroy,
					node_manager);					
			}					
		}		
		if(!return_code)
		{
			display_message(ERROR_MESSAGE,"free_node_and_element_and_data_groups."
			" Failed to free groups");
		}
		
		temp_node_group=node_group;
		DEACCESS(GROUP(FE_node))(&temp_node_group);
		
		if(MANAGED_GROUP_CAN_BE_DESTROYED(FE_node)(node_group))
		{
			if(REMOVE_OBJECT_FROM_MANAGER(GROUP(FE_node))(node_group,
				node_group_manager))
			{
				node_group=(struct GROUP(FE_node) *)NULL;
				return_code=1;
			}
			else
			{
				return_code=0;
			}
		}
		*a_node_group=node_group;
		DEALLOCATE(group_name);				
	}
	else
	{	
		display_message(ERROR_MESSAGE,"free_node_and_element_and_data_groups."
			" invalid arguments");
		return_code =0;		
	}
	LEAVE;
	return(return_code);
} /* free_node_and_element_and_data_groups */


int FE_element_get_scale_factor_for_nodal_value(
	struct FE_element *element, struct FE_node *node, struct FE_field *field,
	int component_number,	enum FE_nodal_value_type nodal_value_type,
	FE_value *scale_factor)
/*******************************************************************************
LAST MODIFIED : 26 October 2000

DESCRIPTION :
Given  <component_number>  and <nodal_value_type> of <field> at a 
<node> in an <element>, find the  corresponding <scale_factor>.
===============================================================================*/
{
	int i, nodal_value_index, nodal_value_number, number_of_nodes, 
		number_of_versions, return_code,	scale_factor_index;
	struct FE_element_field *element_field;
	struct FE_element_field_component *element_field_component;
	struct FE_node **nodes;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct Standard_node_to_element_map *node_to_element_map,
		**node_to_element_maps;

	ENTER(FE_element_get_scale_factor_for_nodal_value);
	return_code = 0;
	if (element && node && field && (0 <= component_number) &&
		(component_number < field->number_of_components) && scale_factor)
	{
		/* get the element field*/
		if (element->information && element->information->fields &&
			(element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				field, element->information->fields->element_field_list)) &&
			(element_field_component = element_field->components[component_number]))
		{
			/* ensure element has nodes*/
			if (nodes = element->information->nodes)
			{
				switch (element_field_component->type)
				{
					case STANDARD_NODE_TO_ELEMENT_MAP:
					{
						/* get the node_to_element map*/
						node_to_element_maps = element_field_component->
							map.standard_node_based.node_to_element_maps;
						node_to_element_map = (struct Standard_node_to_element_map *)NULL;
						number_of_nodes =
							element_field_component->map.standard_node_based.number_of_nodes;
						for (i = 0; (!node_to_element_map) && (i < number_of_nodes); i++)
						{
							if (node_to_element_maps[i] &&
								(node == nodes[node_to_element_maps[i]->node_index]))
							{
								node_to_element_map = node_to_element_maps[i];
							}
						}
						if (node_to_element_map &&
							node_to_element_map->nodal_value_indices &&
							node_to_element_map->scale_factor_indices)
						{
							/* ensure element field is defined in node */
							if (node->fields && (node_field =
								FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
									field, node->fields->node_field_list)) &&
								(node_field_component =
									&(node_field->components[component_number])))
							{
								/* ensure node field has nodal value types */
								if (node_field_component->nodal_value_types &&
									(number_of_versions=node_field_component->number_of_versions))
								{
									/* find the nodal value in the field*/
									nodal_value_number = -1;
									for (i = 0; (0 > nodal_value_number) &&
										(i < node_to_element_map->number_of_nodal_values); i++)
									{
										nodal_value_index =
											node_to_element_map->nodal_value_indices[i];
										if (nodal_value_type == node_field_component->
											nodal_value_types[nodal_value_index /	number_of_versions])
										{
											nodal_value_number = i;
										}
									}
									/* find the scale factor corresponding to the nodal value */
									if (0 <= nodal_value_number)
									{
										scale_factor_index = node_to_element_map->
											scale_factor_indices[nodal_value_number];
										if (-1 == scale_factor_index)
										{
											*scale_factor = 1.0;
											return_code = 1;
										}
										else if ((0 <= scale_factor_index) && (scale_factor_index <
											element->information->number_of_scale_factors))
										{
											*scale_factor =
												element->information->scale_factors[scale_factor_index];
											return_code = 1;
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"FE_element_get_scale_factor_for_nodal_value.  "
												"Scale factor index out of range");
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"FE_element_get_scale_factor_for_nodal_value.  "
											"Nodal value type not used for field");
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"FE_element_get_scale_factor_for_nodal_value.  "
										"Node field has no nodal value types");
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"FE_element_get_scale_factor_for_nodal_value.  "
									"Element field is corrupt as not defined in node it uses");
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"FE_element_get_scale_factor_for_nodal_value.  "
								"Node not used by field in element");
						}
					} break;
					default:
					{
						display_message(ERROR_MESSAGE,
							"FE_element_get_scale_factor_for_nodal_value.  "
							"Currently Only supports STANDARD_NODE_TO_ELEMENT_MAP"
							" Write the code");
					} break;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_get_scale_factor_for_nodal_value.  Element has no nodes");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_get_scale_factor_for_nodal_value.  "
				"Field is not defined in this element");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"FE_element_get_scale_factor_for_nodal_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_get_scale_factor_for_nodal_value */

int node_is_in_list(struct FE_node *node,
	void *node_is_in_list_data_void)
/*******************************************************************************
LAST MODIFIED : 16 October 2000

DESCRIPTION :
returns 1 if <node> is in <node_is_in_list_data>'s node list.
Called iteratively.
==============================================================================*/
{	
	int return_code;
	struct Node_is_in_list_data *node_is_in_list_data;
	
	ENTER(node_is_in_list);
	return_code=1;
	node_is_in_list_data=(struct Node_is_in_list_data *)NULL;
	if(node&&node_is_in_list_data_void&&(node_is_in_list_data
		=(struct Node_is_in_list_data *)node_is_in_list_data_void))
	{
		return_code=IS_OBJECT_IN_LIST(FE_node)(node,node_is_in_list_data->node_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,"node_not_in_list. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;
	return(return_code);
}/* node_is_in_list */

int offset_FE_node_and_element_identifiers_in_group(char *name,int last_identifier,
	struct MANAGER(FE_node) *node_manager,
	struct MANAGER(FE_element) *element_manager,
	struct MANAGER(GROUP(FE_node))*node_group_manager,
	struct MANAGER(GROUP(FE_element)) *element_group_manager)
/*******************************************************************************
LAST MODIFIED :3 November 2000

DESCRIPTION :
Finds the node and element groups matching  <name>, and shifts the contained nodes 
and elements  identifier numbers so that the groups identifiers end at 
<last_identifier>. Eg if you wanted to shift the groups to the end of 
the legal integer range, <last_identifier> would be INT_MAX.
Currently, there must be NO other node and elemnt groups in the manager when
this function is called.
==============================================================================*/
{
	int number_of_elements,number_of_nodes,offset,return_code;
	struct Change_identifier_data data;
	struct GROUP(FE_element) *element_group;
	struct GROUP(FE_node) *node_group;

	ENTER(offset_FE_node_and_element_identifiers_in_group);	
	node_group=(struct GROUP(FE_node) *)NULL;
	element_group = (struct GROUP(FE_element) *) NULL;
	if(name)
	{
		return_code=1;
		/* shift the nodes and elements */
		if((node_group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_node),name)
			(name,node_group_manager))&&				
			(number_of_nodes=NUMBER_IN_GROUP(FE_node)(node_group))&&
			(element_group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_element),name)
				(name,element_group_manager))&&
			(number_of_elements=NUMBER_IN_GROUP(FE_element)(element_group)))
		{	
			/* for now, can only change identifiers of nodes/elements if there's only ONE*/	
			/* node/element group */
			if((1==NUMBER_IN_MANAGER(GROUP(FE_element))(element_group_manager))&&
				(1==NUMBER_IN_MANAGER(GROUP(FE_node))(node_group_manager)))
			{				
				/* offset the nodes and elements to 
					 last_identifier-max(number_of_nodes,number_of_elements)*/			
				if(number_of_nodes>=number_of_elements)
				{
					offset=number_of_nodes;
				}
				else
				{
					offset=number_of_elements;
				}
				offset=last_identifier-offset;			
				data.element_offset = offset;
				data.face_offset = 0;
				data.line_offset = 0;
				data.node_offset = offset;
				/* shift nodes */
				if (node_group)
				{
					data.count = 0;
					data.node_manager = node_manager;
					MANAGER_BEGIN_CACHE(FE_node)(node_manager);
					FOR_EACH_OBJECT_IN_GROUP(FE_node)(FE_node_change_identifier_sub,
						(void *)&data, node_group);
					MANAGER_END_CACHE(FE_node)(node_manager);
					if (data.count != NUMBER_IN_GROUP(FE_node)(node_group))
					{
						return_code=0;
						display_message(ERROR_MESSAGE,
							"offset_FE_node_and_element_identifiers_in_group."
							"  Only able to update node numbers for %d nodes out of %d\n",
							data.count, NUMBER_IN_GROUP(FE_node)(node_group));
					}
				}	
				/* shift elements */		
				if (element_group)
				{
					data.count = 0;
					data.element_manager = element_manager;
					MANAGER_BEGIN_CACHE(FE_element)(element_manager);
					FOR_EACH_OBJECT_IN_GROUP(FE_element)(
						FE_element_change_identifier_sub,
						(void *)&data, element_group);
					MANAGER_END_CACHE(FE_element)(element_manager);
					if (data.count != NUMBER_IN_GROUP(FE_element)(element_group))
					{
						return_code=0;
						display_message(ERROR_MESSAGE,
							"offset_FE_node_and_element_identifiers_in_group."
							"  Only able to update element numbers for %d elements out of %d\n",
							data.count, NUMBER_IN_GROUP(FE_element)(element_group));
					}
				}
			}
			else
			{
				return_code=0;
				display_message(ERROR_MESSAGE,"offset_FE_node_and_element_identifiers_in_group."
					" Must be NO pre exisitng node and element groups when call this function");
			}
		}
		else
		{
			return_code=0;
			display_message(ERROR_MESSAGE,"offset_FE_node_and_element_identifiers_in_group."
				" node or element groups empty");
		}
	}
	else
	{
		return_code=0;
		display_message(ERROR_MESSAGE,"offset_FE_node_and_element_identifiers_in_group."
			" invalid arguments");
	}
	LEAVE;
	return(return_code);
}/* offset_FE_node_and_element_identifiers_in_group*/

#if !defined (WINDOWS_DEV_FLAG)
int FE_element_change_identifier_sub(struct FE_element *element,
	void *data_void)
/*******************************************************************************
LAST MODIFIED : 7 October 1999

DESCRIPTION :
==============================================================================*/
{
	int return_code;
	struct CM_element_information cm_id;
	struct Change_identifier_data *data;

	ENTER(FE_element_change_identifier_sub);
	if (element && 
		(data=(struct Change_identifier_data *)data_void)
		&& data->element_manager)
	{
		return_code = 1;
		cm_id.type = element->cm.type;
		cm_id.number = element->cm.number;
		switch( cm_id.type )
		{
			case CM_ELEMENT:
			{
				cm_id.number += data->element_offset;
			} break;
			case CM_FACE:
			{
				cm_id.number += data->element_offset;
			} break;
			case CM_LINE:
			{
				cm_id.number += data->element_offset;
			} break;
		}
		if (MANAGER_MODIFY_IDENTIFIER(FE_element, identifier)(element,
			&cm_id, data->element_manager))
		{
			data->count++;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_change_identifier_sub.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_change_identifier_sub */
#endif /* !defined (WINDOWS_DEV_FLAG) */

#if !defined (WINDOWS_DEV_FLAG)
int FE_node_change_identifier_sub(struct FE_node *node, void *data_void)
/*******************************************************************************
LAST MODIFIED : 7 October 1999

DESCRIPTION :
==============================================================================*/
{
	int return_code;
	struct Change_identifier_data *data;

	ENTER(FE_node_change_identifier_sub);
	if (node && 
		(data=(struct Change_identifier_data *)data_void)
		&& data->node_manager)
	{
		return_code = 1;
		if (MANAGER_MODIFY_IDENTIFIER(FE_node, cm_node_identifier)(node,
			get_FE_node_cm_node_identifier(node) + data->node_offset,
			data->node_manager))
		{
			data->count++;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_change_identifier_sub.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_change_identifier_sub */
#endif /* !defined (WINDOWS_DEV_FLAG) */
