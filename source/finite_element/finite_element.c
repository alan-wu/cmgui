/*******************************************************************************
FILE : finite_element.c

LAST MODIFIED : 20 December 2005

DESCRIPTION :
Functions for manipulating finite element structures.
???DB.  Can FE_node_field_info become a module type ?  (create_FE_node would be
	given the element field lists)
???DB.  Get rid of the find_FE_ and replace with FIRST_OBJECT_IN_/FIND_BY_IDEN ?
???DB.  enum FE_basis_type ?
???DB.  calculate_FE_node_field ?
???DB.  change FE_nodes so that request a particular value for a particular
	field (see merge_FE_node)
???DB.  Should the list_ routines be in their own module ?
==============================================================================*/
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is cmgui.
 *
 * The Initial Developer of the Original Code is
 * Auckland Uniservices Ltd, Auckland, New Zealand.
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/*???DB.  Testing */
#define DOUBLE_FOR_DOT_PRODUCT

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "command/parser.h"
#include "finite_element/finite_element.h"
#include "finite_element/finite_element_private.h"
#include "finite_element/finite_element_region_private.h"
#include "general/change_log_private.h"
#include "general/compare.h"
#include "general/debug.h"
#include "general/enumerator_private.h"
#include "general/heapsort.h"
#include "general/indexed_list_private.h"
#include "general/list_private.h"
#include "general/manager_private.h"
#include "general/matrix_vector.h"
#include "general/multi_range.h"
#include "general/mystring.h"
#include "general/object.h"
#include "general/value.h"
#include "user_interface/message.h"

/*
Module Constants
----------------
*/

/* need following to handle 64-bit alignment problems of 64-bit quantities in
   64-bit version */
#if defined (O64)
#define VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE 8
#define ADJUST_VALUE_STORAGE_SIZE( new_values_storage_size ) \
/* round size up to nearest 64-bit boundary */ \
if (new_values_storage_size % 8) \
{ \
	new_values_storage_size += (8 - (new_values_storage_size % 8)); \
}
#else /* defined (O64) */
#define VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE sizeof(int)
#define ADJUST_VALUE_STORAGE_SIZE( new_values_storage_size )
/* do nothing */
#endif /* defined (O64) */

#define VALUE_STORAGE_NUMBER_OF_TIMES_BLOCK (30)
/*
Module types
------------
*/

struct FE_field_info
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Information common to a set of FE_fields.
Currently only maintains a non-ACCESSed pointer to the owning FE_region.
==============================================================================*/
{
	/* the FE_region this FE_field_info and all FE_fields using it belong to */
  struct FE_region *fe_region;

	/* the number of structures that point to this field information.  The
		 field information cannot be destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_field_info */

struct FE_field
/*******************************************************************************
LAST MODIFIED : 18 February 2003

DESCRIPTION :
Stores the information for calculating the value of a field at a point.  The
position of the point should be specified by giving the element that contains
the point and the Xi coordinates of the point within the element.
==============================================================================*/
{
	/* the name of the field, which is its identifier */
	char *name;
	/* shared info for this FE_field including the FE_region it belongs to */
	struct FE_field_info *info;
	/* CMISS field type and number */
	enum CM_field_type cm_field_type;
	struct FE_field_external_information *external;
	enum FE_field_type fe_field_type;
	/* following two for INDEXED_FE_FIELD only */
	struct FE_field *indexer_field;
	int number_of_indexed_values; 
	/* the number of components (allows vector valued fields) */
	int number_of_components;
	/* the names of the different vector components */
	char **component_names;
	/* the coordinate system for the vector */
	struct Coordinate_system coordinate_system;
	/* the number of global values/derivatives that are stored with the field */
	int number_of_values;
 /* the type of the values returned by the field */
  enum Value_type value_type;
  /* array of global values/derivatives that are stored with the field.  The
    actual values can be extracted using the <value_type> */
  Value_storage *values_storage;
    /*???DB.  Have something like enum FE_nodal_value_type ? */
    /*???DB.  Needs to be clarified for constant fields */
  /* time series information.  If <number_of_times> is zero then constant in
    time */
  enum Value_type time_value_type;
  int number_of_times;
  Value_storage *times;
	/* the number of structures that point to this field.  The field cannot be
		destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_field */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_field);

FULL_DECLARE_CHANGE_LOG_TYPES(FE_field);

struct FE_node_field_component
/*******************************************************************************
LAST MODIFIED : 19 January 1998

DESCRIPTION :
Specifies how to find the value and derivatives for a field component at a node.
This only appears as part of a FE_node_field.
==============================================================================*/
{
	/* the offset for the global value within the list of all global values and
		derivatives at the node */
	int value;
	/* the number of global derivatives.  NB The global derivatives are assumed to
		follow directly after the global value in the list of all global values and
		derivatives at the node */
	int number_of_derivatives;
	/* the number of versions at the node.  Different fields may use different
		versions eg if the node is on the axis in prolate spheroidal coordinates
		(mu=0 or mu=pi).  NB The different versions are assumed to follow directly
		after each other (only need one starting <value>) and to have the same
		<number_of derivatives> */
	int number_of_versions;
	/* the types the nodal values */
	enum FE_nodal_value_type *nodal_value_types;
}; /* struct FE_node_field_component */

struct FE_node_field
/*******************************************************************************
LAST MODIFIED : 6 December 1993

DESCRIPTION :
How to access the the global values and derivatives for a field at a node.
???DB.  More information needed ?  FE_node_basis ?
==============================================================================*/
{
	/* the field which this accesses values and derivatives for */
	struct FE_field *field;
	/* an array with <number_of_components> node field components */
	struct FE_node_field_component *components;
	/* the time dependence of all components below this point,
	   if it is non-NULL then every value storage must be an array of 
	   values that matches this fe_time_sequence */
	struct FE_time_sequence *time_sequence;
	/* the number of structures that point to this node field.  The node field
		cannot be destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_node_field */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_node_field);

struct FE_node_field_info
/*******************************************************************************
LAST MODIFIED : 19 February 2003

DESCRIPTION :
The fields defined for a node and how to access the values and derivatives.
==============================================================================*/
{
	/* the total number of values and derivatives */
	/*???RC not convinced number_of_values needs to be in this structure */
	int number_of_values; 

	/* the size of the data in node->values->storage */
	int values_storage_size;

  /* list of the node fields */
  struct LIST(FE_node_field) *node_field_list;

	/* the FE_region this FE_node_field_info and all nodes using it belong to */
  struct FE_region *fe_region;

	/* the number of structures that point to this node field information.  The
		node field information cannot be destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_node_field_info */

FULL_DECLARE_LIST_TYPE(FE_node_field_info);

struct FE_node_field_creator
/*******************************************************************************
LAST MODIFIED : 16 November 2001

DESCRIPTION :
==============================================================================*/
{
	int number_of_components;
	int *numbers_of_versions;
	int *numbers_of_derivatives;
	enum FE_nodal_value_type **nodal_value_types;
}; /* struct FE_node_field_creator */

struct FE_node
/*******************************************************************************
LAST MODIFIED : 11 February 2003

DESCRIPTION :
==============================================================================*/
{
	/* the unique number that identifies the node in CMISS */
	int cm_node_identifier;
	/* the fields defined at the node */
	struct FE_node_field_info *fields;
	/* the global values and derivatives for the fields defined at the node */
	Value_storage *values_storage;

	/* the number of structures that point to this node.  The node cannot be
		destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_node */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_node);

FULL_DECLARE_CHANGE_LOG_TYPES(FE_node);

struct FE_basis
/*******************************************************************************
LAST MODIFIED : 9 October 2002

DESCRIPTION :
Stores the information for calculating basis function values from xi
coordinates.  For each of basis there will be only one copy stored in a global
list.
==============================================================================*/
{
	/* an integer array that specifies the basis as a "product" of the bases for
		the different coordinates.  The first entry is the number_of_xi_coordinates.
		The other entries are the upper triangle of a <number_of_xi_coordinates> by
		<number_of_xi_coordinates> matrix.  The entries on the diagonal specify the
		basis type for each coordinate and entries in the same row/column indicate
		associated coordinates eg.
		1.  CUBIC_HERMITE       0              0
											CUBIC_HERMITE        0
																		LINEAR_LAGRANGE
			has cubic variation in xi1 and xi2 and linear variation in xi3 (8 nodes).
		2.  SERENDIPITY       0            1
										CUBIC_HERMITE      0
																	SERENDIPITY
			has cubic variation in xi2 and 2-D serendipity variation for xi1 and
			xi3 (16 nodes).
		3.  CUBIC_HERMITE        0               0
											LINEAR_SIMPLEX         1
																			LINEAR_SIMPLEX
			has cubic variation in xi1 and 2-D linear simplex variation for xi2 and
			xi3 (6 nodes)
		4.  POLYGON        0           5
								LINEAR_LAGRANGE    0
																POLYGON
			has linear variation in xi2 and a 2-D 5-gon for xi1 and xi3 (12 nodes,
			5-gon has 5 peripheral nodes and a centre node) */
	int *type;
	/* the number of basis functions */
	int number_of_basis_functions;
	/* the names for the basis values eg. "0", "dXi1 1,1" */
	char **value_names;
	/* the blending matrix is a linear mapping from the basis used (eg. cubic
		Hermite) to the standard basis (eg. Chebyshev polynomials).  In some cases,
		for example a non-polynomial basis, this may be NULL, which indicates the
		identity matrix */
	FE_value *blending_matrix;
	/* to calculate the values of the "standard" basis functions */
	int number_of_standard_basis_functions;
	void *arguments;
	Standard_basis_function *standard_basis;
	/* the number of structures that point to this basis.  The basis cannot be
		destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_basis */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_basis);

FULL_DECLARE_MANAGER_TYPE(FE_basis);

struct Linear_combination_of_global_values
/*******************************************************************************
LAST MODIFIED : 9 October 2002

DESCRIPTION :
Stores the information for calculating an element value as a linear combination
of global values.  The application of scale factors is one of the uses for this
linear combination.
==============================================================================*/
{
	/* the number of global values */
	int number_of_global_values;
	/* array of indices for the global values (stored with the field) */
	/*???RC I think the above comment should say the following is an array of
		indices into the nodal values, within the list of all values at the node.
		In any case the index is an offset in whole FE_values relative to the
		absolute value offset in the FE_node_field_component for the associated
		node (which is a values storage/unsigned char).
		See: global_to_element_map_values() */
	int *global_value_indices;
	/* array of indices for the coefficients multiplying the global values
		(stored with the element as scale factors) */
	int *coefficient_indices;
}; /* struct Linear_combination_of_global_values */

struct Standard_node_to_element_map
/*******************************************************************************
LAST MODIFIED : 12 March 2003

DESCRIPTION :
Stores the information for calculating element values by choosing nodal values
and applying a diagonal scale factor matrix.  The <nodal_values> and
<scale_factors> are stored as offsets so that the arrays stored with the nodes
and elements can be reallocated.
==============================================================================*/
{
	/* the index, within the list of nodes for the element, of the node at which
		the values are stored */
	int node_index;
	/* the number of nodal values used (which is also the number of element values
		calculated) */
	int number_of_nodal_values;
	/* array of indices for the nodal values, within the list of all values at
		the node - index is an offset in whole FE_values relative to the absolute
		value offset in the FE_node_field_component for the associated node (which
		is a values storage/unsigned char). See: global_to_element_map_values() */
	int *nodal_value_indices;
	/* array of indices for the scale factors.
		 Note a negative index indicates a unit scale factor */
	int *scale_factor_indices;
}; /* struct Standard_node_to_element_map */

struct General_node_to_element_map
/*******************************************************************************
LAST MODIFIED : 9 October 2002

DESCRIPTION :
Stores the information for calculating element values by choosing nodal values
and applying a general scale factor matrix.  The <nodal_values> and
<scale_factors> are stored as offsets so that the arrays stored with the nodes
and elements can be reallocated.
==============================================================================*/
{
	/* the index, within the list of nodes for the element, of the node at which
		the values are stored */
	int node_index;
	/* the number of nodal values used (which is also the number of element values
		calculated) */
	int number_of_nodal_values;
	/* how to calculate each element values from the nodal values */
	struct Linear_combination_of_global_values **element_values;
}; /* struct General_node_to_element_map */

struct FE_element_field_component
/*******************************************************************************
LAST MODIFIED : 9 October 2002

DESCRIPTION :
Stores the information for calculating element values, with respect to the
<basis>, from global values (this calculation includes the application of scale
factors).  There are two types - <NODE_BASED_MAP> and <GENERAL_LINEAR_MAP>.  For
a node based map, the global values are associated with nodes.  For a general
linear map, the global values do not have to be associated with nodes.  The node
based maps could be specified as general linear maps, but the node based
specification (required by CMISS) cannot be recovered from the general linear
map specification (important when the front end is being used to create meshs).
The <modify> function is called after the element values have been calculated
with respect to the <basis> and before the element values are blended to be with
respect to the standard basis.  The <modify> function is to allow for special
cases, such as CMISS nodes that have multiple theta values in cylindrical polar,
spherical polar, prolate spheroidal or oblate spheroidal coordinate systems -
either lying on the z-axis or being the first and last node in a circle. 
==============================================================================*/
{
	/* the type of the global to element map */
	enum Global_to_element_map_type type;
	union
	{
		/* for a standard node based map */
		struct
		{
			/* the number of nodes */
			int number_of_nodes;
			/* how to get the element values from the nodal values */
			struct Standard_node_to_element_map **node_to_element_maps;
		} standard_node_based;
		/* for a general node based map */
		struct
		{
			/* the number of nodes */
			int number_of_nodes;
			/* how to get the element values from the nodal values */
			struct General_node_to_element_map **node_to_element_maps;
		} general_node_based;
		/* for a field map */
		struct
		{
			/* the number of element values */
			int number_of_element_values;
			/* how to calculate each element value from the global values */
			struct Linear_combination_of_global_values **element_values;
		} field_based;
		/* for an element grid */
		struct
		{
			/* the element is covered by a regular grid with <number_in_xi>
				sub-elements in each direction */
			int *number_in_xi;
			/* the component is linear over each sub-element and the grid point values
				are stored with the element starting at <value_index> */
				/*???DB.  Other bases for the sub-elements are possible, but are not
					currently used and would add to the complexity/compute time */
			int value_index;
		} element_grid_based;
	} map;
	/* the basis that the element values are with respect to */
	struct FE_basis *basis;
	/* the function for modifying element values */
	FE_element_field_component_modify modify;
}; /* struct FE_element_field_component */

struct FE_element_field
/*******************************************************************************
LAST MODIFIED : 9 October 2002

DESCRIPTION :
Stores the information for calculating the value of a field at a point within a
element.  The position of the point should be specified by Xi coordinates of the
point within the element.
==============================================================================*/
{
	/* the field which this is part of */
	struct FE_field *field;
	/* an array with <field->number_of_components> pointers to element field
		components */
	struct FE_element_field_component **components;
	/* the number of structures that point to this element field.  The element
		field cannot be destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_element_field */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_element_field);

struct FE_element_field_values
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
The values need to calculate a field on an element.  These structures are
calculated from the element field as required and are then destroyed.
==============================================================================*/
{
	/* the field these values are for */
	struct FE_field *field;
	/* the element these values are for */
	struct FE_element *element;
	/* the element the field was inherited from */
	struct FE_element *field_element;
	/* whether or not these values depend on time */
	int time_dependent;
	/* if the values are time dependent, the time at which they were calculated */
	FE_value time;
	/* number of sub-elements in each xi-direction of element. If NULL then field
		 is not	grid based.  Notes
		1.  struct FE_element_field allows some components to be grid-based and
			some not with different discretisations for the grid-based components.
			This structure only supports - all grid-based components with the same
			discretisation, or no grid-based components.  This restriction could be
			removed by having a <number_in_xi> for each component
		2.  the sub-elements are linear in each direction.  This means that
			<component_number_of_values> is not used
		3.  the grid-point values are not blended (to monomial) and so
			<component_standard_basis_functions> and
			<component_standard_basis_function_arguments> are not used
		4.  for grid-based <destroy_standard_basis_arguments> is used to specify
			if the <component_values> should be destroyed (element field has been
			inherited) */
	int *number_in_xi;
	/* a flag to specify whether or not values have also been calculated for the
		derivatives of the field with respect to the xi coordinates */
	char derivatives_calculated;
	/* a flag added to specify if the element field component modify function is
		ignored */
		/*???DB.  Added for calculating derivatives with respect to nodal values.
			See FE_element_field_values_set_no_modify */
	char no_modify;
	/* specify whether the standard basis arguments should be destroyed (element
		field has been inherited) or not be destroyed (element field is defined for
		the element and the basis arguments are being used) */
	char destroy_standard_basis_arguments;
	/* the number of field components */
	int number_of_components;
	/* the number of values for each component */
	int *component_number_of_values;
	/* the values_storage for each component if grid-based */
	Value_storage **component_grid_values_storage;
	/* grid_offset_in_xi is allocated with 2^number_of_xi_coordinates integers
		 giving the increment in index into the values stored with the top_level
		 element for the grid. For top_level_elements the first value is 1, the
		 second is (number_in_xi[0]+1), the third is
		 (number_in_xi[0]+1)*(number_in_xi[1]+1) etc. The base_grid_offset is 0 for
		 top_level_elements. For faces and lines these values are adjusted to get
		 the correct index for the top_level_element */
	int base_grid_offset,*grid_offset_in_xi;
	/* following allocated with 2^number_of_xi for grid-based fields for use in
		 calculate_FE_element_field */
	int *element_value_offsets;
	/* the values for each component */
	FE_value **component_values;
	/* the standard basis function for each component */
	Standard_basis_function **component_standard_basis_functions;
	/* the arguments for the standard basis function for each component */
	void *component_standard_basis_function_arguments;
	/* working space for evaluating basis */
	FE_value *basis_function_values;

	int access_count;
}; /* struct FE_element_field_values */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_element_field_values);

struct FE_element_field_info
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
The element fields defined on an element and how to calculate them.
==============================================================================*/
{
	/* list of the  element fields */
	struct LIST(FE_element_field) *element_field_list;

	/* the FE_region this FE_element_field_info and all elements using it
		 belong to */
  struct FE_region *fe_region;

	/* the number of structures that point to this information.  The information
		cannot be destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_element_field_info */

FULL_DECLARE_LIST_TYPE(FE_element_field_info);

struct FE_element_node_scale_field_info
/*******************************************************************************
LAST MODIFIED : 10 October 2002

DESCRIPTION :
The field values, nodes and scale factors for an element.
The element stores its FE_element_field_info, and optionally this structure
if fields are defined and need this supplemental information.
==============================================================================*/
{
	/* values_storage.  Element based maps have indices into this array */
	int values_storage_size;
	Value_storage *values_storage;

	/* nodes.  Node to element maps have indices into this array */
	int number_of_nodes;
	struct FE_node **nodes;
	/* there may be a number of sets of scale factors (CMISS has one for each
		basis) */
	int number_of_scale_factor_sets;
	/*???RC following void * pointers generally point at FE_basis. However, if it
		were used for anything else it would stuff up export_finite_element, since
		then we'd have no idea what to output. Move to more involved structure
		instead? */
	void **scale_factor_set_identifiers;
	int *numbers_in_scale_factor_sets;
	/* all scale factors are stored in this array.  Global to element maps have
		indices into this array */
	int number_of_scale_factors;
	FE_value *scale_factors;
}; /* struct FE_element_node_scale_field_info */

struct FE_element_shape
/*******************************************************************************
LAST MODIFIED : 9 October 2002

DESCRIPTION :
A description of the shape of an element in Xi space.  It includes how to
calculate face coordinates from element coordinates and how to calculate element
coordinates from face coordinates.
==============================================================================*/
{
	/* the number of xi coordinates */
	int dimension;
	/* the structure description.  Similar to type for a FE_basis
		- doesn't have the dimension in the first position (type[0])
		- the diagonal entry is the shape type
		- non-zero off-diagonal entries indicate that the dimensions are linked.
			For a polygon, it is the number of vertices
		eg. a 5-gon in dimensions 1 and 2 and linear in the third dimension
			POLYGON_SHAPE 5             0
										POLYGON_SHAPE 0
																	LINE_SHAPE
		eg. tetrahedron
			SIMPLEX_SHAPE 1             1
										SIMPLEX_SHAPE 1
																	SIMPLEX_SHAPE */
	int *type;
	/* the number of faces */
	int number_of_faces;
	/* the equations for the faces of the element.  This is a linear system
		b = A xi, where A is <number_of_faces> by <dimension> matrix whose entries
		are either 0 or 1 and b is a vector whose entries are
		0,...number_of_faces_in_this_dimension-1.  For a cube the system would be
			0   1 0 0  xi1       2
			1   1 0 0  xi2       3
			0 = 0 1 0  xi3       4
			1   0 1 0            5
			0   0 0 1            8
			1   0 0 1            9
		For a 5-gon by linear above the system would be
			0   1 0 0  xi1       5
			1   1 0 0  xi2       6
			2   1 0 0  xi3       7
			3 = 1 0 0            8
			4   1 0 0            9
			0   0 0 1           10
			1   0 0 1           11
			The "equations" for the polygon faces, don't actually describe the faces,
				but are in 1 to 1 correspondence - first represents 0<=xi1<=1/5 and
				xi2=1.
		For a tetrahedron the system would be
			0   1 0 0  xi1       2
			0 = 0 1 0  xi2       4
			0   0 0 1  xi3       8
			1   1 1 1           15
		A unique number is calculated for each number as follows
		- a value is calculated for each column by multiplying the number for the
			previous column (start with 1, left to right) by
			- the number_of_vertices for the first polygon column
			- 1 for the second polygon column
			- 2 otherwise
		- a value for each row by doing the dot product of the row and the column
			values
		- the entry of b for that row is added to the row value to give the unique
			number
		These numbers are stored in <faces>.
		The values for the above examples are given on the right */
	int *faces;
	/* for each face an outwards pointing normal stored as a vector of size <dimension> */
	FE_value *face_normals;
	/* for each face an affine transformation, b + A xi for calculating the
		element xi coordinates from the face xi coordinates.  For each face there is
		a <number_of_xi_coordinates> by <number_of_xi_coordinates> array with the
		translation b in the first column.  For a cube the translations could be
		(not unique)
		face 2 :  0 0 0 ,  face 3 : 1 0 0 ,  face 4 : 0 0 1 , 1(face) goes to 3 and
							0 1 0             0 1 0             0 0 0   2(face) goes to 1 to
							0 0 1             0 0 1             0 1 0   maintain right-
																													handedness (3x1=2)
		face 5 :  0 0 1 ,  face 8 : 0 1 0 ,  face 9 : 0 1 0
							1 0 0             0 0 1             0 0 1
							0 1 0             0 0 0             1 0 0
		For the 5-gon by linear the faces would be
		face 5 :  0 1/5 0 ,  face 6 : 1/5 1/5 0 ,  face 7 : 2/5 1/5 0
							1 0   0             1   0   0             1   0   0
							0 0   1             0   0   1             0   0   1
		face 8 :  3/5 1/5 0 ,  face 9 : 4/5 1/5 0
							1   0   0             1   0   0
							0   0   1             0   0   1
		face 10 : 0 1 0 ,  face 11 : 0 1 0
							0 0 1              0 0 1
							0 0 0              1 0 0
		For the tetrahedron the faces would be
		face 2 :  0 0 0 ,  face 4 : 1 -1 -1 ,  face 8 : 0  0  1
							0 1 0             0  0  0             1 -1 -1
							0 0 1             0  1  0             0  0  0
		face 15 : 0  1  0
							0  0  1
							1 -1 -1
		The transformations are stored by row (ie. column number varying fastest) */
	FE_value *face_to_element;
	/* the number of structures that point to this shape.  The shape cannot be
		destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_element_shape */

FULL_DECLARE_LIST_TYPE(FE_element_shape);

#if defined (OLD_CODE)
/*???DB.  Some ideas, but best to keep it simple at present */
	/* the structure description.  Similar to type for a FE_basis, but doesn't
		have the dimension in the first position (type[0]).  There are two versions,
		the "external" which is passed to CREATE(FE_element_shape) and the
		"internal" which is calculated by CREATE(FE_element_shape) and stored here.
		external
		- the diagonal entry is the shape type
		- non-zero off-diagonal entries indicate that the dimensions are linked.
			For a polygon, it is the number of vertices
		internal
		- diagonal entries
			- zero.  Then linear in this dimension
			- negative.  Then the last in a sub-shape of linked dimensions.  This is
				the offset to the previous linked dimension
			- positive.  Then not the last in a sub-shape of linked dimensions.  This
				is the offset to the next linked dimension
		- off-diagonal entries
			- zero.  Then the dimensions are not linked
			- negative.  Then the dimensions are linked and there is another linked
				dimension before the row dimension.  This is the offset to the previous
				linked dimension
			- positive.  Then the dimensions are linked and the row dimension is the
				first dimension in the linked sub-shape.
				- 1 simplex
				- 2 reserved for future developments
				- >=3 polygon.  This is the number of vertices
				is the offset to the next linked dimension
		eg. linear in xi1 and a 5-gon in xi2 and xi3
			external
				LINE_SHAPE  0             0
										POLYGON_SHAPE 5
																	POLYGON_SHAPE
			internal
				0 0  0
					1  5
						-1
		eg. tetrahedron
			external
			SIMPLEX_SHAPE 1             1
										SIMPLEX_SHAPE 1
																	SIMPLEX_SHAPE
			internal
				1 1  1
					1 -1
						-1 */
#endif /* defined (OLD_CODE) */

struct FE_element_parent
/*******************************************************************************
LAST MODIFIED : 8 January 1994

DESCRIPTION :
Information for going from an element to a parent element.
==============================================================================*/
{
	/* access_FE_element and deaccess_FE_element are NOT used for this so that
		an element can be destroyed when it has children */
	struct FE_element *parent;
	int face_number;
	/* the number of structures that point to this element parent.  The element
		parent cannot be destroyed while this is greater than 0.  Needed so that can
		have lists */
	int access_count;
}; /* struct FE_element_parent */

DECLARE_LIST_TYPES(FE_element_parent);

FULL_DECLARE_LIST_TYPE(FE_element_parent);

struct FE_element
/*******************************************************************************
LAST MODIFIED : 10 October 2002

DESCRIPTION :
A region in space with functions defined on the region.  The region is
parameterized and the functions are known in terms of the parameterized
variables.
==============================================================================*/
{
	/* identifier points to <cm> and is used for the <find_by_identifier>
		function */
	struct CM_element_information cm,*identifier;

	/* a description of the shape/geometry of the element in Xi space */
	struct FE_element_shape *shape;
	/* the faces (finite elements of dimension 1 less) of the element.  The number
		of faces is known from the <shape> */
	struct FE_element **faces;

	/* the field information for the element */
	struct FE_element_field_info *fields;
	/* the nodes, scale factors and valuess for the element.  This is only set if
		 the element has fields that require this supplemental information */
	struct FE_element_node_scale_field_info *information;

	/* the parent elements are of dimension 1 greater and are the elements for
		which this element is a face */
	struct LIST(FE_element_parent) *parent_list;
	/* the number of structures that point to this element.  The element cannot be
		destroyed while this is greater than 0 */
	int access_count;
}; /* struct FE_element */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_element);

FULL_DECLARE_CHANGE_LOG_TYPES(FE_element);

struct FE_element_type_node_sequence_identifier
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
See struct FE_element_type_node_sequence.
==============================================================================*/
{
	enum CM_element_type cm_type;
	/* node_numbers must be ordered from lowest to highest to work! */
	int *node_numbers,number_of_nodes;
}; /* struct FE_element_type_node_sequence_identifier */

struct FE_element_type_node_sequence
/*******************************************************************************
LAST MODIFIED : 30 April 1999

DESCRIPTION :
Structure for storing an element with its identifier being its cm_type and the
number and list - in ascending order - of the nodes referred to by the default
coordinate field of the element. Indexed lists, indexed using function
compare_FE_element_type_node_sequence_identifier ensure that recalling a line or
face with the same nodes is extremely rapid. add_FE_element_and_faces_to_manager
uses them to find faces and lines for elements without them, if they exist.

???RC Can only match faces correctly for coordinate fields with standard node
to element maps and no versions. A grid-based coordinate field would fail
utterly since it has no nodes. A possible future solution for all cases is to
match the geometry exactly either by using the FE_element_field_values
(coefficients of the monomial basis functions), although there is a problem with
xi-directions not matching up, or actual centre positions of the face being a
trivial rejection, narrowing down to a single face or list of faces to compare
against.
==============================================================================*/
{
	struct FE_element_type_node_sequence_identifier *identifier;
	struct FE_element *element;
	int access_count;
}; /* struct FE_element_line_face_node_sequence */

FULL_DECLARE_INDEXED_LIST_TYPE(FE_element_type_node_sequence);

struct FE_node_field_iterator_and_data
{
	FE_node_field_iterator_function *iterator;
	struct FE_node *node;
	void *user_data;
}; /* struct FE_node_field_iterator_and_data */

struct FE_node_field_priority_iterator_and_data
{
	FE_node_field_iterator_function *iterator;
	struct FE_node *node;
	void *user_data;
	int priority_on;
	struct LIST(FE_field) *priority_field_list;
}; /* struct FE_node_field_iterator_and_data */

struct FE_element_field_iterator_and_data
{
	FE_element_field_iterator_function *iterator;
	struct FE_element *element;
	void *user_data;
}; /* struct FE_element_field_iterator_and_data */

struct FE_element_field_priority_iterator_and_data
{
	FE_element_field_iterator_function *iterator;
	struct FE_element *element;
	void *user_data;
	int priority_on;
	struct LIST(FE_field) *priority_field_list;
}; /* struct FE_element_field_iterator_and_data */

struct FE_field_order_info
/*******************************************************************************
LAST MODIFIED : 4 September 2001

DESCRIPTION :
Stores a list of fields in the order they are added.
???RC move up in file.
==============================================================================*/
{
	int allocated_number_of_fields, number_of_fields;
	struct FE_field **fields;
}; /* FE_field_order_info */

/*
Module variables
----------------
*/

/* blending matricies for the monomial basis */

static FE_value linear_lagrange_blending_matrix[]=
{
	1,-1, /* phi1 = 1 - x */
	0, 1  /* phi2 = x     */
};

static FE_value quadratic_lagrange_blending_matrix[]=
{
	1,-3, 2, /* phi1 = 1 - 3x + 2xx */
	0, 4,-4,
	0,-1, 2
};

static FE_value cubic_lagrange_blending_matrix[]=
{
	1,-5.5,  9  , -4.5,
	0, 9  ,-22.5, 13.5,
	0,-4.5, 18  ,-13.5,
	0, 1  , -4.5,  4.5
};

static FE_value cubic_hermite_blending_matrix[]=
{
	1,0,-3, 2,
	0,1,-2, 1,
	0,0, 3,-2,
	0,0,-1, 1
};

static FE_value lagrange_hermite_blending_matrix[]=
{
	1,-2, 1,
	0, 2,-1,
	0,-1, 1
};

static FE_value hermite_lagrange_blending_matrix[]=
{
	1,0,-1,
	0,1,-1,
	0,0, 1
};

/*???DB.  Start by blending to full monomial.  Think about reduced later */
static FE_value linear_simplex_2d_blending_matrix[]=
{
	/* coefficients of 1 x y xy; all cooefficients of xy are zero, so can be "reduced" */
	1,-1,-1, 0, /* phi1 = 1 - x - y */
	0, 1, 0, 0,
	0, 0, 1, 0
};

static FE_value quadratic_simplex_2d_blending_matrix[]=
{
	/* coefficients of 1 x  xx y xy xxy yy xyy xxyy; starting to be wasteful with lots of zero terms */
	1,-3, 2,-3, 4, 0, 2, 0, 0, /* phi1 = 1 - 3x + 2xx - 3y + 4xy + 2yy */
	0, 4,-4, 0,-4, 0, 0, 0, 0,
	0,-1, 2, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 4,-4, 0,-4, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0, 0,
	0, 0, 0,-1, 0, 0, 2, 0, 0
};

static FE_value linear_simplex_3d_blending_matrix[]=
{
	1,-1,-1, 0,-1, 0, 0, 0, /* i.e. phi(0) = 1 - xi1 - xi2 - xi3; no quadratic or cubic (xi1*xi2*xi3) terms */
	0, 1, 0, 0, 0, 0, 0, 0,
	0, 0, 1, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 0, 0
};

static FE_value quadratic_simplex_3d_blending_matrix[]=
{
	/* Very wasteful! 27 standard basis functions with as few as 1 non-zero coefficient!
	   Intend to use simplex basis functions directly once testing examples running.
	   coefficients of monomial set, with x=xi1 y=xi2 z=xi3
		 1  x   xx   y   xy   xxy   yy   xyy   xxyy
	 	 z  xz  xxz  yz  xyz  xxyz  yyz  xyyz  xxyyz
	 	 zz xzz xxzz yzz xyzz xxyzz yyzz xyyzz xxyyzz */
	1,-3, 2,-3, 4,  0,  2,  0,0, -3, 4,  0,  4,  0,0,0,0,0,  2,  0,0,0,0,0,0,0,0,
	0, 4,-4, 0,-4,  0,  0,  0,0,  0,-4,  0,  0,  0,0,0,0,0,  0,  0,0,0,0,0,0,0,0,
	0,-1, 2, 0, 0,  0,  0,  0,0,  0, 0,  0,  0,  0,0,0,0,0,  0,  0,0,0,0,0,0,0,0,
	0, 0, 0, 4,-4,  0, -4,  0,0,  0, 0,  0, -4,  0,0,0,0,0,  0,  0,0,0,0,0,0,0,0,
	0, 0, 0, 0, 4,  0,  0,  0,0,  0, 0,  0,  0,  0,0,0,0,0,  0,  0,0,0,0,0,0,0,0,
	0, 0, 0,-1, 0,  0,  2,  0,0,  0, 0,  0,  0,  0,0,0,0,0,  0,  0,0,0,0,0,0,0,0,
	0, 0, 0, 0, 0,  0,  0,  0,0,  4,-4,  0, -4,  0,0,0,0,0, -4,  0,0,0,0,0,0,0,0,
	0, 0, 0, 0, 0,  0,  0,  0,0,  0, 4,  0,  0,  0,0,0,0,0,  0,  0,0,0,0,0,0,0,0,
	0, 0, 0, 0, 0,  0,  0,  0,0,  0, 0,  0,  4,  0,0,0,0,0,  0,  0,0,0,0,0,0,0,0,
	0, 0, 0, 0, 0,  0,  0,  0,0, -1, 0,  0,  0,  0,0,0,0,0,  2,  0,0,0,0,0,0,0,0
};



#if defined (NEW_NEW_CODE)
/*???DB.  For reduced monomial */
/* simplex elements have zero coefficients for most/all higher order monomial terms, e.g. xi1*xi1 or xi1*xi2*xi2, so
 * in theory these could be removed from the monomial basis. Similarly for serendipity element bases which
 * are like Lagrangian elements but omitting certain interior or midface nodes associated with higher order monomial terms */ 
static FE_value linear_simplex_2d_blending_matrix[]=
{
	1,-1,-1,
	0, 1, 0,
	0, 0, 1
};

static FE_value quadratic_simplex_2d_blending_matrix[]=
{
	1,-3, 2,-3,-4, 2,
	0, 4,-4, 0,-4, 0,
	0,-1, 2, 0, 0, 0,
	0, 0, 0, 4,-4,-4,
	0, 0, 0, 0, 4, 0,
	0, 0, 0,-1, 0, 2
};

static FE_value linear_simplex_3d_blending_matrix[]=
{
	1,-1,-1,-1,
	0, 1, 0, 0,
	0, 0, 1, 0,
	0, 0, 0, 1
};
#endif /* defined (NEW_NEW_CODE) */

struct Add_FE_element_and_faces_to_manager_data
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
User data for function add_FE_element_and_faces_to_manager - created by
CREATE(Add_FE_element_and_faces_to_manager_data).
==============================================================================*/
{
	/* this flag should initially be set; if add_FE_element_and_faces_to_manager
		 needs to find an existing face for the first time (ie. this flag is set),
		 it does the lengthy job of taking all existing faces and lines and making
		 an element_type_node_sequence item in the list for them so it can be found
		 easily again. Any new faces automatically have an entry put in the list,
		 hence this flag is then immediately cleared. */
	int first_time_called;
	/* keep next free identifiers so don't have expensive search to get them
		 each time we call add_FE_element_and_faces_to_manager */
	struct CM_element_information next_free_face_identifier,
		next_free_line_identifier;
	struct LIST(FE_element_type_node_sequence) *element_type_node_sequence_list;
	struct MANAGER(FE_element) *element_manager;
}; /* struct Add_FE_element_and_faces_to_manager_data */

/*
Module functions
----------------
*/

static int get_Value_storage_size(enum Value_type value_type,
	struct FE_time_sequence *time_sequence)
/*******************************************************************************
LAST MODIFIED : 20 November 2001

DESCRIPTION :
Given the value type, returns the size in bytes of the memory required to store 
the following:
For non-array type, the actual data.
For array types, an integer storing the number of array values, and a pointer to
the array values.
for time depedant types, a pointer to the values.
==============================================================================*/
{		
	int size;

	ENTER(get_Value_storage_size);
	if (time_sequence)
	{
		switch (value_type)
		{
			case DOUBLE_VALUE:
			{
				size = sizeof(double *);
			} break; 
			case FE_VALUE_VALUE:				
			{
				size = sizeof(FE_value *);
			} break;
			case FLT_VALUE:
			{
				size = sizeof(float *);
			} break;	
			case SHORT_VALUE:
			{
				size = sizeof(short *);
			} break;
			case INT_VALUE:
			{
				size = sizeof(int *);
			} break;
			case UNSIGNED_VALUE:
			{
				size = sizeof(unsigned *);
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_Value_storage_size.  Not implemented time array value type.");
				size =0;
			} break;
		}
	}
	else
	{
		switch (value_type)
		{
			case DOUBLE_VALUE:
			{
				size = sizeof(double);
			} break;
			case ELEMENT_XI_VALUE:
			{
				/* need this to handle 64-bit alignment problems of 64-bit quantities in
					64-bit version */
#if defined (O64)
				size = (sizeof(struct FE_element *) + sizeof(FE_value) * 
					MAXIMUM_ELEMENT_XI_DIMENSIONS) -
					((sizeof(struct FE_element *) + sizeof(FE_value) * 
						MAXIMUM_ELEMENT_XI_DIMENSIONS)%8) + 8;
#else /* defined (O64) */
				size = sizeof(struct FE_element *) + sizeof(FE_value) * 
					MAXIMUM_ELEMENT_XI_DIMENSIONS;
#endif /* defined (O64) */
			} break;
			case FE_VALUE_VALUE:
			{
				size = sizeof(FE_value);
			} break;
			case FLT_VALUE:
			{
				size = sizeof(float);
			} break;
			case SHORT_VALUE:
			{
				size = sizeof(short);
			} break;
			case INT_VALUE:
			{
				size = sizeof(int);
			} break;	
			case UNSIGNED_VALUE:
			{
				size = sizeof(unsigned);
			} break;
			case DOUBLE_ARRAY_VALUE:
			{
				/* VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE space for number of array values */
				/* (*double) to store pointer to data*/
				size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(double *);
			} break; 
			case FE_VALUE_ARRAY_VALUE:				
			{
				size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(FE_value *);
			} break;
			case FLT_ARRAY_VALUE:
			{
				size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(float *);
			} break;	
			case SHORT_ARRAY_VALUE:
			{
				size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(short *);
			} break;
			case INT_ARRAY_VALUE:
			{
				size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(int *);
			} break;
			case UNSIGNED_ARRAY_VALUE:
			{
				size = VALUE_STORAGE_ARRAY_LENGTH_INT_SIZE+sizeof(unsigned *);
			} break;
			case STRING_VALUE:
			{
				size = sizeof(char *);
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_Value_storage_size.  Unknown value_type");
				size =0;
			} break;
		}
	}
	LEAVE;

	return (size);	
} /* get_Value_storage_size */

static int free_value_storage_array(Value_storage *values_storage,
	enum Value_type value_type, struct FE_time_sequence *time_sequence,
	int number_of_values)
/*******************************************************************************
LAST MODIFIED: 20 November 2001

DESCRIPTION:
DEACCESSes objects and DEALLOCATEs dynamic storage in use by <values_storage>,
which is assumed to have <number_of_values> of the given <value_type> and
whether <time_sequence> is set.
Note that the values_storage array itself is not DEALLOCATED - up to the
calling function to do this.
Only certain value types, eg. arrays, strings, element_xi require this.
==============================================================================*/
{
	Value_storage *the_values_storage;
	int i,return_code,size;

	ENTER(free_value_storage_array);
	if (values_storage&&(size=get_Value_storage_size(value_type, time_sequence))&&
		(0<number_of_values))
	{
		return_code=1;
		the_values_storage = values_storage;
		if (time_sequence)
		{
			switch (value_type)
			{
				case DOUBLE_VALUE:
				{
					double **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (double **)the_values_storage;
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case FE_VALUE_VALUE:
				{
					FE_value **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (FE_value **)the_values_storage;
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case FLT_VALUE:
				{
					float **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (float **)the_values_storage;
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case INT_VALUE:
				{
					int **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (int **)the_values_storage;
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case UNSIGNED_VALUE:
				{
					unsigned **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (unsigned **)the_values_storage;
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
			}
		}
		else
		{
			switch (value_type)
			{
				case DOUBLE_ARRAY_VALUE:
				{
					double **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (double **)(the_values_storage+sizeof(int));
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case ELEMENT_XI_VALUE:
				{
					struct FE_element **element_address;

					for (i=0;i<number_of_values;i++)
					{
						element_address = (struct FE_element **)the_values_storage;
						if (*element_address)
						{
							DEACCESS(FE_element)(element_address);
						}
						the_values_storage += size;
					}
				} break;
				case FE_VALUE_ARRAY_VALUE:
				{
					FE_value **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (FE_value **)(the_values_storage+sizeof(int));
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case FLT_ARRAY_VALUE:
				{
					float **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (float **)(the_values_storage+sizeof(int));
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case INT_ARRAY_VALUE:
				{
					int **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (int **)(the_values_storage+sizeof(int));
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case UNSIGNED_ARRAY_VALUE:
				{
					unsigned **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (unsigned **)(the_values_storage+sizeof(int));
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
				case STRING_VALUE:
				{
					char **array_address;

					for (i=0;i<number_of_values;i++)
					{
						array_address = (char **)(the_values_storage);
						DEALLOCATE(*array_address);
						the_values_storage += size;
					}
				} break;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"free_value_storage_array. Invalid arguments");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* free_value_storage_array */

static int allocate_and_copy_values_storage_array(Value_storage *source, 
	enum Value_type value_type, Value_storage *dest)
/************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION
Allocate an array of type value_type, of the length stored in source.
Copy the data from the array referenced by the pointer in source to the
alocated array. Copy the number of array values and the pointer to the 
allocated array into dest.

Therefore must must free dest in calling function, and dest must be 
an unallocated pointer when this function is called.

NOTE:
For array types, the contents of values_storage is:
 | int (number of array values) | pointer to array (eg double *) | 
  x number_of_values 
Assumes that sizeof(int) = 1 DWORD, so that the pointers are a DWORD aligned
in memory. If pointers weren't DWORD aligned get bus errors on SGIs.
=======================================================================*/
{
	int number_of_array_values,array_size,return_code;
 
	
	ENTER(allocate_and_copy_values_storage_array);	
	if (source)
	{	
		return_code = 1;
		switch (value_type)
		{				
			case DOUBLE_ARRAY_VALUE:			
			{
				double *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if (number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (double **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(double))*(number_of_array_values);
					/* allocate the dest array */
					if (ALLOCATE(dest_array,double,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (double **)(dest+sizeof(int));
						*array_address = dest_array;					
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}
				}
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest
						values_storage*/	
					array_address = (double **)(dest+sizeof(int));
					*array_address = (double *)NULL;		
				}
			} break; 
			case FE_VALUE_ARRAY_VALUE:				
			{
				FE_value *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if (number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (FE_value **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(FE_value))*(number_of_array_values);
					/* allocate the dest array */
					if (ALLOCATE(dest_array,FE_value,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (FE_value **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (FE_value **)(dest+sizeof(int));
					*array_address = (FE_value *)NULL;		
				}
			} break;
			case FLT_ARRAY_VALUE:		
			{
				float *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if (number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (float **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(float))*(number_of_array_values);
					/* allocate the dest array */
					if (ALLOCATE(dest_array,float,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (float **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}		
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (float **)(dest+sizeof(int));
					*array_address = (float *)NULL;		
				}	
			} break;
			case SHORT_ARRAY_VALUE:		
			{
				short *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if (number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (short **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(short))*(number_of_array_values);
					/* allocate the dest array */
					if (ALLOCATE(dest_array,short,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (short **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}		
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (short **)(dest+sizeof(int));
					*array_address = (short *)NULL;		
				}	
			} break;	
			case INT_ARRAY_VALUE:			
			{
				int *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if (number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (int **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(int))*(number_of_array_values);
					/* allocate the dest array */
					if (ALLOCATE(dest_array,int,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (int **)(dest+sizeof(int));
						*array_address = dest_array;									
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}							
				}		
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (int **)(dest+sizeof(int));
					*array_address = (int *)NULL;		
				}	
			} break;
			case UNSIGNED_ARRAY_VALUE:
			{
				unsigned *dest_array,*source_array,**array_address;				
				/* get number of array values from source */		 
				number_of_array_values = *((int *)source);
				if (number_of_array_values) /* no array values, source array is NULL*/
				{
					/* get address of array from source */			
					array_address = (unsigned **)(source+sizeof(int));
					source_array = *array_address;
					array_size = (sizeof(unsigned))*(number_of_array_values);
					/* allocate the dest array */
					if (ALLOCATE(dest_array,unsigned,number_of_array_values))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);
						/* copy the number of array values into the dest values_storage */			 
						*((int *)dest) = number_of_array_values;
						/* copy the address of the new array into the dest values_storage*/	
						array_address = (unsigned **)(dest+sizeof(int));
						*array_address = dest_array;
					}				
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}
				}	
				else
				{
					/* copy the number of array values = 0 into the dest values_storage */			 
					*((int *)dest) = 0;
					/* copy the  NULL address of the new array into the dest values_storage*/	
					array_address = (unsigned **)(dest+sizeof(int));
					*array_address = (unsigned *)NULL;		
				}		
			} break;
			case STRING_VALUE:
			{
				char *dest_array,*source_array,**array_address;			
				/* get address of array from source */				
				array_address = (char **)(source);
				if (*array_address)/* if we have a source array*/
				{
					source_array = *array_address;
					array_size = strlen(source_array)+1; /* +1 for null termination */
					/* allocate the dest array */
					if (ALLOCATE(dest_array,char,array_size))
					{
						/* copy values into the dest array */
						memcpy(dest_array,source_array,array_size);				
						/* copy the address of the new array into the dest values_storage*/		
						array_address = (char **)(dest);
						*array_address = dest_array;
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"allocate_and_copy_values_storage_array. Out of memory");
						return_code = 0;
					}					
				}
				else	/* copy NULL into the dest values_storage*/	
				{
					array_address = (char **)(dest);
					*array_address = (char *)NULL;
				}
			} break;		
			default:
			{	
				display_message(ERROR_MESSAGE,
					"allocate_and_copy_values_storage_array. Invalid type");
				return_code = 0;
			} break;
		} /*switch (the_value_type) */
	}
	else
	{
		display_message(ERROR_MESSAGE,"allocate_and_copy_values_storage_array."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
} /* allocate_and_copy_values_storage_array */

static int copy_time_sequence_values_storage_array(Value_storage *source, 
	enum Value_type value_type, struct FE_time_sequence *source_time_sequence,
	struct FE_time_sequence *destination_time_sequence, Value_storage *dest)
/************************************************************************
LAST MODIFIED : 21 November 2001

DESCRIPTION
Copy the data from the array referenced by the pointer in <source> to the
array referenced by the pointer in <dest>.

The destination must already have arrays allocated corresponding to the
<destination_time_sequence>.

NOTE:
For array types, the contents of values_storage is:
 | pointer to array (eg double *) | 
  x number_of_values 
Assumes that sizeof(int) = 1 DWORD, so that the pointers are a DWORD aligned
in memory. If pointers weren't DWORD aligned get bus errors on SGIs.
=======================================================================*/
{
	int destination_time_index, source_number_of_times,
		source_time_index, return_code;
	FE_value time;
	
	ENTER(copy_time_sequence_values_storage_array);	
	if (source)
	{	
		return_code = 1;
		source_number_of_times = FE_time_sequence_get_number_of_times(
			source_time_sequence);
		/* Copy the values into the correct places */
		for (source_time_index = 0 ; source_time_index < source_number_of_times
			 ; source_time_index++)
		{
			if (FE_time_sequence_get_time_for_index(source_time_sequence,
					 source_time_index, &time) &&
				FE_time_sequence_get_index_for_time(destination_time_sequence,
					time, &destination_time_index))
			{
				switch (value_type)
				{				
					case DOUBLE_VALUE:
					{
						double *dest_array,*source_array,**array_address;				
						/* get address of array from source */			
						array_address = (double **)source;
						source_array = *array_address;
						array_address = (double **)dest;
						dest_array = *array_address;
						dest_array[destination_time_index] = 
							source_array[source_time_index];
					} break; 
					case FE_VALUE_VALUE:
					{
						FE_value *dest_array,*source_array,**array_address;
						/* get address of array from source */
						array_address = (FE_value **)source;
						source_array = *array_address;
						array_address = (FE_value **)dest;
						dest_array = *array_address;
						dest_array[destination_time_index] = 
							source_array[source_time_index];
					} break;
					case FLT_VALUE:		
					{
						float *dest_array,*source_array,**array_address;				
						/* get address of array from source */			
						array_address = (float **)source;
						source_array = *array_address;
						array_address = (float **)dest;
						dest_array = *array_address;
						dest_array[destination_time_index] = 
							source_array[source_time_index];
					} break;
					case SHORT_VALUE:		
					{
						short *dest_array,*source_array,**array_address;				
						/* get address of array from source */			
						array_address = (short **)source;
						source_array = *array_address;
						array_address = (short **)dest;
						dest_array = *array_address;
						dest_array[destination_time_index] = 
							source_array[source_time_index];
					} break;	
					case INT_VALUE:			
					{
						int *dest_array,*source_array,**array_address;				
						/* get address of array from source */			
						array_address = (int **)source;
						source_array = *array_address;
						array_address = (int **)dest;
						dest_array = *array_address;
						dest_array[destination_time_index] = 
							source_array[source_time_index];
					} break;
					case UNSIGNED_ARRAY_VALUE:
					{
						unsigned *dest_array,*source_array,**array_address;				
						/* get address of array from source */			
						array_address = (unsigned **)source;
						source_array = *array_address;
						array_address = (unsigned **)dest;
						dest_array = *array_address;
						dest_array[destination_time_index] = 
							source_array[source_time_index];
					} break;
					case STRING_VALUE:
					{
						display_message(ERROR_MESSAGE,
							"copy_time_sequence_values_storage_array.  "
							"String type not implemented for multiple times yet.");
						return_code = 0;				
					} break;		
					default:
					{	
						display_message(ERROR_MESSAGE,
							"copy_time_sequence_values_storage_array.  Invalid type");
						return_code = 0;
					} break;
				} /*switch (the_value_type) */
					
			}
			else
			{
				display_message(ERROR_MESSAGE,"copy_time_sequence_values_storage_array.  "
					"Unable to find destination space for source time index %d",
					source_time_index);
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"copy_time_sequence_values_storage_array."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
} /* copy_time_sequence_values_storage_array */

int copy_time_sequence_values_storage_arrays(Value_storage *destination, 
	enum Value_type value_type, struct FE_time_sequence *destination_time_sequence,
	struct FE_time_sequence *source_time_sequence, int number_of_values,
	Value_storage *source)
/*******************************************************************************
LAST MODIFIED : 1 November 2002

DESCRIPTION :
Calls copy_time_sequence_values_storage for all <number_of_values> items of
the appropriate value size to transfer time value arrays from <source> with
<source_time_sequence> to <destination> with <destination_time_sequence>.
==============================================================================*/
{
	int i, return_code, value_size;
	Value_storage *src,*dest;

	ENTER(copy_time_sequence_values_storage_arrays);
	if (destination && destination_time_sequence && source_time_sequence &&
		(0 < number_of_values) && source)
	{
		return_code = 1;
		dest = destination;
		src = source;
		value_size = get_Value_storage_size(value_type, destination_time_sequence);
		for (i = 0; (i < number_of_values) && return_code; i++)
		{
			if (!copy_time_sequence_values_storage_array(src, value_type,
				source_time_sequence, destination_time_sequence, dest))
			{
				display_message(ERROR_MESSAGE,
					"copy_time_sequence_values_storage_arrays.  Failed to copy array");
				return_code = 0;
			}
			dest += value_size;
			src += value_size;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_time_sequence_values_storage_arrays.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* copy_time_sequence_values_storage_arrays */

static int allocate_time_values_storage_array(enum Value_type value_type, 
	struct FE_time_sequence *destination_time_sequence, Value_storage *dest,
	int initialise_storage)
/************************************************************************
LAST MODIFIED : 21 November 2001

DESCRIPTION
Allocate an array of type value_type with size determined by the 
destination_time_sequence.  If <initialise_storage> is true then the
values in the array are set to the zero.

NOTE:
For time types, the contents of values_storage is:
 | pointer to array (eg double *) | 
  x number_of_values 
Assumes that sizeof(int) = 1 DWORD, so that the pointers are a DWORD aligned
in memory. If pointers weren't DWORD aligned get bus errors on SGIs.
=======================================================================*/
{
	int number_of_times,j,return_code;
	
	ENTER(allocate_time_values_storage_array);	
	if (dest)
	{	
		return_code = 1;
		number_of_times = FE_time_sequence_get_number_of_times(
			destination_time_sequence);
		/* Allocate the array */
		switch (value_type)
		{				
			case DOUBLE_VALUE:
			{
				double *dest_array,**array_address;				
				/* allocate the dest array */
				if (ALLOCATE(dest_array,double,number_of_times))
				{
					if (initialise_storage)
					{
						for (j = 0 ; j < number_of_times ; j++)
						{
							dest_array[j] = 0.0;
						}
					}
					/* copy the address of the new array into the dest values_storage*/	
					array_address = (double **)dest;
					*array_address = dest_array;					
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break; 
			case FE_VALUE_VALUE:
			{
				FE_value *dest_array,**array_address;
				/* allocate the dest array */
				if (ALLOCATE(dest_array,FE_value,number_of_times))
				{
					if (initialise_storage)
					{
						for (j = 0 ; j < number_of_times ; j++)
						{
							dest_array[j] = FE_VALUE_INITIALIZER;
						}
					}
					/* copy the address of the new array into the dest values_storage*/	
					array_address = (FE_value **)dest;
					*array_address = dest_array;					
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break;
			case FLT_VALUE:		
			{
				float *dest_array,**array_address;
				/* allocate the dest array */
				if (ALLOCATE(dest_array,float,number_of_times))
				{
					if (initialise_storage)
					{
						for (j = 0 ; j < number_of_times ; j++)
						{
							dest_array[j] = 0.0f;
						}
					}
					/* copy the address of the new array into the dest values_storage*/	
					array_address = (float **)dest;
					*array_address = dest_array;					
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break;
			case SHORT_VALUE:		
			{
				short *dest_array,**array_address;
				/* allocate the dest array */
				if (ALLOCATE(dest_array,short,number_of_times))
				{
					if (initialise_storage)
					{
						for (j = 0 ; j < number_of_times ; j++)
						{
							dest_array[j] = 0;
						}
					}
					/* copy the address of the new array into the dest values_storage*/	
					array_address = (short **)dest;
					*array_address = dest_array;					
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break;	
			case INT_VALUE:			
			{
				int *dest_array,**array_address;
				/* allocate the dest array */
				if (ALLOCATE(dest_array,int,number_of_times))
				{
					if (initialise_storage)
					{
						for (j = 0 ; j < number_of_times ; j++)
						{
							dest_array[j] = 0;
						}
					}
					/* copy the address of the new array into the dest values_storage*/	
					array_address = (int **)dest;
					*array_address = dest_array;					
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break;
			case STRING_VALUE:
			{
				display_message(ERROR_MESSAGE,
					"allocate_time_values_storage_array. String type not implemented for multiple times yet.");
				return_code = 0;				
			} break;		
			default:
			{	
				display_message(ERROR_MESSAGE,
					"allocate_time_values_storage_array. Invalid type");
				return_code = 0;
			} break;
		} /*switch (the_value_type) */
	}
	else
	{
		display_message(ERROR_MESSAGE,"allocate_time_values_storage_array."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
} /* allocate_time_values_storage_array */

static int reallocate_time_values_storage_array(enum Value_type value_type, 
	int new_number_of_values, Value_storage *new_array,
	Value_storage *previous_array, 
	int initialise_storage, int previous_number_of_values)
/************************************************************************
LAST MODIFIED : 20 December 2005

DESCRIPTION
Reallocate an array of type value_type with number_of_values.  If 
<initialise_storage> is true then the values from
<previous_number_of_values> + 1 to <new_number_of_values> are set to zero.
The routine will potentially overallocate the array to accelerate when
these arrays are expanded out one value at a time, many times over.
=======================================================================*/
{
	int allocate_number_of_values, j, return_code;
	
	ENTER(allocate_time_values_storage_array);	
	if (new_array && previous_array)
	{	
		return_code = 1;

		allocate_number_of_values = (new_number_of_values + VALUE_STORAGE_NUMBER_OF_TIMES_BLOCK) - 
			(new_number_of_values % VALUE_STORAGE_NUMBER_OF_TIMES_BLOCK);		
		switch (value_type)
		{
			case DOUBLE_VALUE:
			{
				double *array;
				if (REALLOCATE(array,*(double **)previous_array,double,allocate_number_of_values))
				{
					if (initialise_storage)
					{
						for (j = previous_number_of_values ; j < new_number_of_values ; j++)
						{
							array[j] = 0.0;
						}
					}
					*(double **)new_array = array;
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break; 
			case FE_VALUE_VALUE:
			{
				FE_value *array;
				if (REALLOCATE(array,*(FE_value **)previous_array,FE_value,allocate_number_of_values))
				{
					if (initialise_storage)
					{
						for (j = previous_number_of_values ; j < new_number_of_values ; j++)
						{
							array[j] = FE_VALUE_INITIALIZER;
						}
					}
					*(FE_value **)new_array = array;
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break;
			case FLT_VALUE:
			{
				float *array;
				if (REALLOCATE(array,*(float **)previous_array,float,allocate_number_of_values))
				{
					if (initialise_storage)
					{
						for (j = previous_number_of_values ; j < new_number_of_values ; j++)
						{
							array[j] = 0.0f;
						}
					}
					*(float **)new_array = array;
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break;
			case SHORT_VALUE:
			{
				short *array;
				if (REALLOCATE(array,*(short **)previous_array,short,allocate_number_of_values))
				{
					if (initialise_storage)
					{
						for (j = previous_number_of_values ; j < new_number_of_values ; j++)
						{
							array[j] = 0;
						}
					}
					*(short **)new_array = array;
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break; 
			case INT_VALUE:
			{
				int *array;
				if (REALLOCATE(array,*(int **)previous_array,int,allocate_number_of_values))
				{
					if (initialise_storage)
					{
						for (j = previous_number_of_values ; j < new_number_of_values ; j++)
						{
							array[j] = 0;
						}
					}
					*(int **)new_array = array;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"allocate_time_values_storage_array. Out of memory");
					return_code = 0;
				}
			} break;
			case STRING_VALUE:
			{
				display_message(ERROR_MESSAGE,
					"allocate_time_values_storage_array. String type not implemented for multiple times yet.");
				return_code = 0;				
			} break;		
			default:
			{	
				display_message(ERROR_MESSAGE,
					"allocate_time_values_storage_array. Invalid type");
				return_code = 0;
			} break;
		} /*switch (the_value_type) */
	}
	else
	{
		display_message(ERROR_MESSAGE,"allocate_time_values_storage_array."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
} /* allocate_time_values_storage_array */

static int copy_value_storage_array(Value_storage *destination,
	enum Value_type value_type, struct FE_time_sequence *destination_time_sequence,
	struct FE_time_sequence *source_time_sequence,int number_of_values,
	Value_storage *source)
/*******************************************************************************
LAST MODIFIED : 21 November 2001

DESCRIPTION :
Copies the <number_of_values> of <value_type> stored in <source> into
<destination>. Arrays, strings and other dynamic values are allocated afresh
for <destination>. <destination> is assumed to be blank and large enough to
contain such values.  If <source_time_sequence> and <destination_time_sequence>
are non NULL then the value storage correspond to an arrays of values at those
times.
==============================================================================*/
{
	enum FE_time_sequence_mapping time_sequence_mapping;
	int destination_number_of_times, i, return_code;

	ENTER(copy_value_storage_array);
	if (destination&&(0<number_of_values)&&source)
	{
		return_code=1;
		if (source_time_sequence || destination_time_sequence)
		{
			if (source_time_sequence && destination_time_sequence)
			{
				int value_size;
				Value_storage *src,*dest;
				
				dest = destination;
				src = source;
				value_size=get_Value_storage_size(value_type,
					destination_time_sequence);
				time_sequence_mapping = 
					FE_time_sequences_mapping(source_time_sequence, destination_time_sequence);
				switch (time_sequence_mapping)
				{
					case FE_TIME_SEQUENCE_MAPPING_IDENTICAL:
					case FE_TIME_SEQUENCE_MAPPING_APPEND:
					{
						destination_number_of_times = FE_time_sequence_get_number_of_times(destination_time_sequence);
						for (i=0;(i<number_of_values)&&return_code;i++)
						{
							reallocate_time_values_storage_array(value_type, 
								destination_number_of_times, dest, src,
								/*initialise_storage*/0, /*previous_number_of_values*/0);
							*(void **)src = 0x0;
							dest += value_size;
							src += value_size;
						}
					} break;
					default:
					{
						/* Fallback default implementation */
						for (i=0;(i<number_of_values)&&return_code;i++)
						{
							if (!(allocate_time_values_storage_array(value_type,
										destination_time_sequence,dest,/*initialise_storage*/0)&&
									copy_time_sequence_values_storage_array(src,value_type,
										source_time_sequence,destination_time_sequence,dest)))
							{
								display_message(ERROR_MESSAGE,
									"copy_value_storage_array.  Failed to copy array");
								if (0<i)
								{
									/* free any arrays allocated to date */
									free_value_storage_array(destination,value_type,
										destination_time_sequence,i);
								}
									return_code = 0;
							}
							dest += value_size;
							src += value_size;
						}
					} break;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"copy_value_storage_array.  Copying time values to or from non"
					"non time based values not implemented");
			}
		}
		else
		{
			switch (value_type)
			{			
				case DOUBLE_VALUE:
				{
					double *src,*dest;

					src = (double *)source;
					dest = (double *)destination;
					for (i=0;i<number_of_values;i++)
					{
						*dest = *src;
						dest++;
						src++;
					}
				} break;
				case ELEMENT_XI_VALUE:
				{
					int i,j;
					Value_storage *src,*dest;

					src = source;
					dest = destination;
					for (i=0;i<number_of_values;i++)
					{
						/* copy accessed element pointer */
						if (*((struct FE_element **)src))
						{
							(*(struct FE_element **)dest)
								= ACCESS(FE_element)(*((struct FE_element **)src));
						}
						else
						{
							(*(struct FE_element **)dest) = (struct FE_element *)NULL;
						}
						dest += sizeof(struct FE_element *);
						src += sizeof(struct FE_element *);
						/* copy the xi location */
						for (j=0;j<MAXIMUM_ELEMENT_XI_DIMENSIONS;j++)
						{
							*((FE_value *)dest) = *((FE_value *)src);
							dest += sizeof(FE_value);
							src += sizeof(FE_value);
						}
					}
				} break;
				case FE_VALUE_VALUE:
				{
					FE_value *src,*dest;

					src = (FE_value *)source;
					dest = (FE_value *)destination;
					for (i=0;i<number_of_values;i++)
					{
						*dest = *src;
						dest++;
						src++;
					}
				} break;
				case FLT_VALUE:
				{
					float *src,*dest;

					src = (float *)source;
					dest = (float *)destination;
					for (i=0;i<number_of_values;i++)
					{
						*dest = *src;
						dest++;
						src++;
					}
				} break;	
				case SHORT_VALUE:
				{
					display_message(ERROR_MESSAGE,"copy_value_storage_array.  "
						"SHORT_VALUE: Haven't written code yet. Beware pointer alignment problems!");
					return_code = 0;
				} break;
				case INT_VALUE:
				{
					int *src,*dest;

					src = (int *)source;
					dest = (int *)destination;
					for (i=0;i<number_of_values;i++)
					{
						*dest = *src;
						dest++;
						src++;
					}
				} break;	
				case UNSIGNED_VALUE:
				{
					unsigned *src,*dest;

					src = (unsigned *)source;
					dest = (unsigned *)destination;
					for (i=0;i<number_of_values;i++)
					{
						*dest = *src;
						dest++;
						src++;
					}
				} break;	
				case DOUBLE_ARRAY_VALUE:
				case FE_VALUE_ARRAY_VALUE:
				case FLT_ARRAY_VALUE:	
				case SHORT_ARRAY_VALUE:
				case INT_ARRAY_VALUE:
				case UNSIGNED_ARRAY_VALUE:
				case STRING_VALUE:
				{
					int value_size;
					Value_storage *src,*dest;

					dest = destination;
					src = source;
					value_size=get_Value_storage_size(value_type,
						(struct FE_time_sequence *)NULL);
					for (i=0;(i<number_of_values)&&return_code;i++)
					{
						if (!allocate_and_copy_values_storage_array(src,value_type,dest))
						{
							display_message(ERROR_MESSAGE,
								"copy_value_storage_array.  Failed to copy array");
							if (0<i)
							{
								/* free any arrays allocated to date */
								free_value_storage_array(destination,value_type,
									(struct FE_time_sequence *)NULL,i);
							}
							return_code = 0;
						}
						dest += value_size;
						src += value_size;
					}
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"copy_value_storage_array.  Unknown value_type");
					return_code = 0;
				} break;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_value_storage_array.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* copy_value_storage_array */

static int initialise_value_storage_array(Value_storage *values_storage,
	enum Value_type value_type, struct FE_time_sequence *time_sequence,
	int number_of_values)
/*******************************************************************************
LAST MODIFIED : 6 May 2003

DESCRIPTION :
Clears values_storage array to suitable defaults for the <value_type> and
<time_sequence>.
<number_of_values> of the given <value_type>.
For non-array types, the contents of field->values_storage is:
   | data type (eg FE_value) | x number_of_values
For array types, the contents of field->values_storage is:
   ( | int (number of array values) | pointer to array (eg double *) |
   x number_of_values )
For time types where the <time_sequence> is nonNULL then then values_storage is:
   ( | pointer to array (eg double *) | x number_of_values )
Sets data in this memory to 0, pointers to NULL.
==============================================================================*/
{
	int i, j, return_code, size;
	Value_storage *new_value, *temp_values_storage;

	ENTER(initialise_value_storage_array);
	if (values_storage &&
		(size = get_Value_storage_size(value_type, time_sequence)) &&
		(0 < number_of_values))
	{
		return_code = 1;
		temp_values_storage = values_storage;
		if (time_sequence)
		{
			/* set pointers to NULL */
			switch (value_type) 
			{
				case DOUBLE_VALUE: 
				{						
					for (i = number_of_values; 0 < i; i--)
					{
						*((double **)temp_values_storage) = (double *)NULL;
						temp_values_storage += size;	
					}
				}	break;
				case FE_VALUE_VALUE:
				{
					for (i = number_of_values; 0 < i; i--)
					{
						*((FE_value **)temp_values_storage) = (FE_value *)NULL;
						temp_values_storage += size;	
					}
				}	break;
				case FLT_VALUE: 
				{
					for (i = number_of_values; 0 < i; i--)
					{
						*((float **)temp_values_storage) = (float *)NULL;
						temp_values_storage += size;	
					}
				} break;
				case SHORT_VALUE: 
				{							
					for (i = number_of_values; 0 < i; i--)
					{
						*((short **)temp_values_storage) = (short *)NULL;
						temp_values_storage += size;	
					}
				} break;
				case INT_VALUE: 
				{						
					for (i = number_of_values; 0 < i; i--)
					{
						*((int **)temp_values_storage) = (int *)NULL;
						temp_values_storage += size;	
					}
				}	break;
				case UNSIGNED_VALUE: 
				{							
					for (i = number_of_values; 0 < i; i--)
					{
						*((unsigned **)temp_values_storage) = (unsigned *)NULL;
						temp_values_storage += size;	
					}
				}	break;
				default:
				{
					display_message(ERROR_MESSAGE, "initialise_value_storage_array.  "
						"Value type does not support time_sequences");
					return_code = 0;
				} break;
			}
		}
		else
		{
			/* set values to zero */
			switch (value_type) 
			{
				case DOUBLE_VALUE: 
				{						
					for (i = number_of_values; 0 < i; i--)
					{
						*((double *)temp_values_storage) = 0.0;
						temp_values_storage += size;	
					}
				}	break;
				case ELEMENT_XI_VALUE:
				{
					for (i = number_of_values; 0 < i; i--)
					{
						new_value = temp_values_storage;
						*((struct FE_element **)new_value) = (struct FE_element *)NULL;
						new_value += sizeof(struct FE_element *);
						for (j = 0; j < MAXIMUM_ELEMENT_XI_DIMENSIONS; j++)
						{
							*((FE_value *)new_value) = 0;
							new_value += sizeof(FE_value);
						}
						temp_values_storage += size;	
					}
				}	break;
				case FE_VALUE_VALUE:
				{
					for (i = number_of_values; 0 < i; i--)
					{
						*((FE_value *)temp_values_storage) = 0.0;
						temp_values_storage += size;	
					}
				}	break;
				case FLT_VALUE: 
				{
					for (i = number_of_values; 0 < i; i--)
					{
						*((float *)temp_values_storage) = 0.0;
						temp_values_storage += size;	
					}
				} break;
				case SHORT_VALUE: 
				{							
					display_message(ERROR_MESSAGE," initialise_value_storage_array." 
						"SHORT_VALUE. Code not written yet. Beware alignment problems ");
					return_code = 0;
				} break;
				case INT_VALUE: 
				{						
					for (i = number_of_values; 0 < i; i--)
					{
						*((int *)temp_values_storage) = 0;
						temp_values_storage += size;	
					}
				}	break;
				case UNSIGNED_VALUE: 
				{							
					for (i = number_of_values; 0 < i; i--)
					{
						*((unsigned *)temp_values_storage) = 0;
						temp_values_storage += size;	
					}
				}	break;
				case STRING_VALUE:
				{
					for (i = number_of_values; 0 < i; i--)
					{
						*((char **)temp_values_storage) = (char *)NULL;	
						temp_values_storage += size;	
					}
				} break;
				/* set number of array values to 0, array pointers to NULL */
				case DOUBLE_ARRAY_VALUE:
				{ 						
					double **array_address;

					for (i = number_of_values; 0 < i; i--)
					{
						/* copy the number of array values (0!) to temp_values_storage */
						*((int *)temp_values_storage) = 0;
						/* copy the pointer to the array values (currently NULL), to
							 temp_values_storage*/
						array_address = (double **)(temp_values_storage + sizeof(int));
						*array_address = (double *)NULL;
						temp_values_storage += size;	
					}
				} break;
				case FE_VALUE_ARRAY_VALUE:				
				{
					FE_value **array_address;

					for (i = number_of_values; 0 < i; i--)
					{
						*((int *)temp_values_storage) = 0;
						array_address = (FE_value **)(temp_values_storage + sizeof(int));
						*array_address = (FE_value *)NULL;
						temp_values_storage += size;	
					}
				} break;
				case FLT_ARRAY_VALUE:			
				{
					float **array_address;

					for (i = number_of_values; 0 < i; i--)
					{
						*((int *)temp_values_storage) = 0;
						array_address = (float **)(temp_values_storage + sizeof(int));
						*array_address = (float *)NULL;
						temp_values_storage += size;	
					}
				} break;	
				case SHORT_ARRAY_VALUE:			
				{
					short **array_address;

					for (i = number_of_values; 0 < i; i--)
					{
						*((int *)temp_values_storage) = 0;
						array_address = (short **)(temp_values_storage + sizeof(int));
						*array_address = (short *)NULL;
						temp_values_storage += size;	
					}
				} break;			
				case INT_ARRAY_VALUE:								
				{
					int **array_address;

					for (i = number_of_values; 0 < i; i--)
					{
						*((int *)temp_values_storage) = 0;
						array_address = (int **)(temp_values_storage + sizeof(int));
						*array_address = (int *)NULL;
						temp_values_storage += size;	
					}
				} break;	
				case UNSIGNED_ARRAY_VALUE:			
				{
					unsigned **array_address;

					for (i = number_of_values; 0 < i; i--)
					{
						*((int *)temp_values_storage) = 0;
						array_address = (unsigned **)(temp_values_storage + sizeof(int));
						*array_address = (unsigned *)NULL;
						temp_values_storage += size;	
					}
				} break;	
				default:
				{
					display_message(ERROR_MESSAGE,
						"initialise_value_storage_array.  Unknown value_type");
					return_code = 0;
				} break;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"initialise_value_storage_array.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* initialise_value_storage_array */

static Value_storage *make_value_storage_array(enum Value_type value_type,
	struct FE_time_sequence *time_sequence, int number_of_values)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Allocates space large enough to contain <number_of_values> of the given
<value_type>.
For non-array types, the contents of field->values_storage is:
   | data type (eg FE_value) | x number_of_values
For array types, the contents of field->values_storage is:
   ( | int (number of array values) | pointer to array (eg double *) |
   x number_of_values )
For time types where the <time_sequence> is nonNULL then then values_storage is:
   ( | pointer to array (eg double *) | x number_of_values )
Initialises the contents to be zero for values, NULL for pointers.
==============================================================================*/
{
	int size, values_storage_size;
	Value_storage *values_storage;

	ENTER(make_value_storage_array);
	values_storage = (Value_storage *)NULL;
	if ((size = get_Value_storage_size(value_type ,time_sequence)) &&
		(0 < number_of_values))
	{
		values_storage_size = size*number_of_values;
		ADJUST_VALUE_STORAGE_SIZE(values_storage_size);
		if (ALLOCATE(values_storage, Value_storage, values_storage_size))
		{
			if (!initialise_value_storage_array(values_storage, value_type,
				time_sequence, number_of_values))
			{
				DEALLOCATE(values_storage);
				values_storage = (Value_storage *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"make_value_storage_array.  Not enough memory");
		}	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"make_value_storage_array.  Invalid argument(s)");
	}
	LEAVE;

	return (values_storage);
} /* make_value_storage_array */

#if defined (DEBUG)
int show_FE_nodal_FE_values(struct FE_node *node)
/************************************************************************
LAST MODIFIED : 19 April 1999

DESCRIPTION
A debug function to print a node's value storage (to stdout)
=======================================================================*/
{
	int return_code,limit,i;
	FE_value *values;
	ENTER(show_FE_nodal_FE_values);
	if (node)
	{
		if (node->values_storage)
		{
			limit = get_FE_node_number_of_values(node);
			return_code = 1;
			values = (FE_value*)(node->values_storage);
			for (i=0;i<limit;i++)
			{
				printf("Nodal value[%d], = %f \n",i,*values);
				values++;	
			}
		}
		else
		{
			printf("Node->values_storage = NULL \n");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"show_FE_nodal_values."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
} /* show_FE_nodal_field_FE_values */

static int show_node_field(struct FE_node_field *node_field,void *count)
/************************************************************************
LAST MODIFIED : 19 April 1999

DESCRIPTION
A debug function to print a node fields (to stdout)
=======================================================================*/
{
	int return_code,i;
	struct FE_node_field_component *component;

	int *the_count;

	ENTER(show_node_field);		
	the_count = (int *)count;
	printf("count = %d\n",*the_count);
	if (node_field)
	{	
		printf("node_field = %x \n",node_field);
		if (node_field->field)
		{	
			printf("   node_field->field = %x \n",node_field->field);
			printf("   name = %s \n",node_field->field->name);
			printf("   number of values = %d \n",node_field->field->number_of_values);
			printf("   number of components = %d \n",node_field->field->number_of_components);		
			for (i=0;i<node_field->field->number_of_components;i++)
			{	
				printf("      component %d: \n",i);
				component = &(node_field->components[i]);
				printf("      number of versions = %d \n",component->number_of_versions);
				printf("      number of derivatives = %d \n",component->number_of_derivatives);
			}
		}
		else
		{
			printf("node_field->field = NULL \n");
		}
		return_code =1;	
	}
	else
	{
		printf("node_field = NULL \n");
		return_code = 1;
	}
	(*the_count)++;	
	printf("\n");
	LEAVE;
	return (return_code);
}

int show_FE_nodal_node_fields(struct FE_node *node)
/************************************************************************
LAST MODIFIED : 19 April 1999

DESCRIPTION
A debug function to print all a node's node fields (to stdout)
=======================================================================*/
{
	int return_code,count;
	FE_value *values;
	ENTER(show_FE_nodal_node_fields);
	if (node)
	{
		if (node->fields)
		{
			count =0;
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)
				(show_node_field,(void *)(&count),node->fields->node_field_list);
		}
		else
		{
			printf("Node->fields = NULL \n");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"show_FE_nodal_values."
			"Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
} /* show_FE_nodal_node_fields */
#endif /* defined (DEBUG) */

static int FE_node_fields_match(struct FE_node_field *node_field_1,
	struct FE_node_field *node_field_2, int ignore_field_and_time_sequence,
	int ignore_component_value)
/*******************************************************************************
LAST MODIFIED : 6 May 2003

DESCRIPTION :
Returns true if <node_field_1> and <node_field_2> are equivalent.
Note that the component value pointers do not have to match since the position
of the data in the values_storage can be different.
No comparison of field and time_sequence members will be made if
<ignore_field_and_time_sequence> is set.
No comparison of the component value, the offset into the nodal values_storage
where the data is kept it <ignore_component_value> is set.
Use with caution!
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type_1, *nodal_value_type_2;
	int i, j, number_of_components, return_code;
	struct FE_node_field_component *component_1, *component_2;

	ENTER(FE_node_fields_match);
	if (node_field_1 && node_field_2)
	{
		if (ignore_field_and_time_sequence ||
			((node_field_1->field == node_field_2->field) &&
				(node_field_1->time_sequence == node_field_2->time_sequence)))
		{
			if (((number_of_components =
				get_FE_field_number_of_components(node_field_1->field)) ==
				get_FE_field_number_of_components(node_field_2->field)) &&
				(component_1 = node_field_1->components) &&
				(component_2 = node_field_2->components))
			{
				return_code = 1;
				for (i = number_of_components; (return_code) && (0 < i); i--)
				{
					if ((ignore_component_value ||
						(component_1->value == component_2->value)) &&
						(component_1->number_of_derivatives ==
							component_2->number_of_derivatives) &&
						(component_1->number_of_versions ==
							component_2->number_of_versions))
					{
						nodal_value_type_1 = component_1->nodal_value_types;
						nodal_value_type_2 = component_2->nodal_value_types;
						if (nodal_value_type_1 && nodal_value_type_2)
						{
							j = 1 + component_1->number_of_derivatives;
							while (return_code && (j > 0))
							{
								if (*nodal_value_type_1 != *nodal_value_type_2)
								{
									return_code = 0;
								}
								nodal_value_type_1++;
								nodal_value_type_2++;
								j--;
							}
						}
						else if (nodal_value_type_1 || nodal_value_type_2)
						{
							return_code = 0;
						}
					}
					else
					{
						return_code = 0;
					}
					component_1++;
					component_2++;
				}
			}
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_fields_match.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_fields_match */

static int FE_node_field_is_in_list(struct FE_node_field *node_field,
	void *node_field_list_void)
/*******************************************************************************
LAST MODIFIED : 6 May 2003

DESCRIPTION :
Returns true if a node field exactly matching <node_field> is found in
<node_field_list>.
==============================================================================*/
{
	int return_code;
	struct FE_node_field *node_field_2;
	struct LIST(FE_node_field) *node_field_list;

	ENTER(FE_node_field_is_in_list);
	return_code = 0;
	if (node_field && (node_field->field) &&
		(node_field_list = (struct LIST(FE_node_field) *)node_field_list_void))
	{
		if ((node_field_2 = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			node_field->field, node_field_list)) &&
			FE_node_fields_match(node_field, node_field_2,
				/*ignore_field_and_time_sequence*/0, /*ignore_component_value*/0))
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_is_in_list.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_is_in_list */

static int FE_node_field_get_number_of_values(struct FE_node_field *node_field)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
Returns the number of values sum of (1+number_of_derivatives)*number_of_versions
for all components.
==============================================================================*/
{
	int i,number_of_values;
	struct FE_node_field_component *component;
	
	ENTER(FE_node_field_get_number_of_values);
	number_of_values=0;
	if (node_field)
	{
		component = node_field->components;
		for (i=node_field->field->number_of_components;0<i;i--)
		{
			number_of_values +=
				(1+component->number_of_derivatives) * component->number_of_versions;
			component++;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_get_number_of_values.  Invalid argument");
	}
	LEAVE;

	return (number_of_values);
} /* FE_node_field_get_number_of_values */

static int FE_node_field_set_FE_time_sequence(struct FE_node_field *node_field,
	struct FE_time_sequence *time_sequence)
/*******************************************************************************
LAST MODIFIED : 13 December 2005

DESCRIPTION :
Sets the fe_time_sequence for this object.  If this FE_node_field is being
accessed more than once it will fail as there will be other Node_field_infos
and therefore nodes that would then have mismatched node_fields and values_storage.
Should only be doing this if the Node_field_info that this belongs to is only
being used by one node otherwise you would have to update the values_storage
for all nodes using the Node_field_info.
==============================================================================*/
{
	int return_code;
	
	ENTER(FE_node_field_set_FE_time_sequence);
	if (node_field && (node_field->access_count < 2))
	{
		REACCESS(FE_time_sequence)(&(node_field->time_sequence), time_sequence);
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_set_FE_time_sequence.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_set_FE_time_sequence */

static int FE_node_field_add_values_storage_size(
	struct FE_node_field *node_field, void *values_storage_size_void)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
If <node_field> represents a GENERAL_FE_FIELD then its required values_storage
in the node, adjusted for word alignment, is added on to <*values_storage_size>.
==============================================================================*/
{
	int return_code,this_values_storage_size,*values_storage_size;
	struct FE_field *field;

	ENTER(FE_node_field_add_values_storage_size);
	if (node_field&&(field=node_field->field)&&
		(values_storage_size = (int *)values_storage_size_void))
	{
		if (GENERAL_FE_FIELD==field->fe_field_type)
		{
			this_values_storage_size =
				FE_node_field_get_number_of_values(node_field) *
				get_Value_storage_size(field->value_type, node_field->time_sequence);
			ADJUST_VALUE_STORAGE_SIZE(this_values_storage_size);
			(*values_storage_size) += this_values_storage_size;
		}
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_add_values_storage_size.  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_add_values_storage_size */

#if defined (OLD_CODE)
static int FE_node_field_initialise_value_storage(
	struct FE_node_field *new_node_field, void *values_storage_void)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Initialise the time arrays in FE_node_field's values_storage.
Assumes values_storage has already been allocated.
==============================================================================*/
{
 	enum Value_type value_type;
	int i, number_of_values,offset,return_code,size;
	struct FE_field *field;
	struct FE_node_field_component *component;
	Value_storage *destination, *values_storage;

	ENTER(FE_node_field_initialise_value_storage);
	if (new_node_field && (field = new_node_field->field) &&
		(values_storage = (Value_storage *)values_storage_void))
	{
		/* only GENERAL_FE_FIELD has values stored with node and only
		   time based fields need initialising */
		if ((GENERAL_FE_FIELD == field->fe_field_type) &&
			(new_node_field->time_sequence))
		{
			value_type = field->value_type;
			size=get_Value_storage_size(value_type,new_node_field->time_sequence);
			number_of_values = FE_node_field_get_number_of_values(new_node_field);
			/* start at first component->value */
			component = new_node_field->components;
			offset = component->value;
			destination = values_storage + offset;
			for (i = 0 ; i < number_of_values ; i++)
			{
				allocate_time_values_storage_array(value_type,
					new_node_field->time_sequence, destination);
				destination += size;
			}
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_initialise_value_storage.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_initialise_value_storage */
#endif /* defined (OLD_CODE) */

static int FE_node_field_free_values_storage_arrays(
	struct FE_node_field *node_field, void *start_of_values_storage_void)
/*******************************************************************************
LAST MODIFIED: 9 March 2005

DESCRIPTION:
Frees accesses and dynamically allocated memory in <start_of_values_storage> 
for the FE_node_field.
The <start_of_the_values_storage> address is passed so that the this function
can be called from an interator, the <node> is not passed so this function can
be used to deallocate parts of any values_storage.  The <values_storage> can
be NULL if there are no GENERAL_FE_FIELDs defined on the node.
Only certain value types, eg. arrays, strings, element_xi require this.
==============================================================================*/
{
	enum Value_type value_type;
	int i,number_of_components,number_of_values,return_code;
	struct FE_node_field_component *component;
	Value_storage *start_of_values_storage, *values_storage;

	ENTER(FE_node_field_free_values_storage_arrays);
	if (node_field&&node_field->field)
	{
		return_code = 1;
		/* only general fields have node_field_components and can have
			 values_storage at the node */
		if (GENERAL_FE_FIELD==node_field->field->fe_field_type)
		{
			value_type = node_field->field->value_type;
			number_of_components = node_field->field->number_of_components;
			component = node_field->components;
			for (i=0;i<number_of_components;i++)
			{
				if (start_of_values_storage=(Value_storage *)start_of_values_storage_void)
				{
					values_storage = start_of_values_storage + component->value;	
					number_of_values=
						(1+component->number_of_derivatives)*component->number_of_versions;
					free_value_storage_array(values_storage,value_type,
						node_field->time_sequence,number_of_values);
					component++;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_node_field_free_values_storage_arrays. Invalid values storage");
					return_code = 0;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_free_values_storage_arrays. Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_free_values_storage_arrays */

struct FE_node_field_merge_values_storage_data
{
	Value_storage *new_values_storage;
	struct LIST(FE_node_field) *old_node_field_list;
	Value_storage *old_values_storage;
	struct LIST(FE_node_field) *add_node_field_list;
	Value_storage *add_values_storage;
}; /* FE_node_field_merge_values_storage_data */

static int FE_node_field_merge_values_storage(
	struct FE_node_field *new_node_field,	void *copy_data_void)
/*******************************************************************************
LAST MODIFIED: 4 March 2005

DESCRIPTION:
If <new_node_field> uses values storage then:

... when <add_node_field_list> and <add_values_storage> provided:
Finds the equivalent node field in the <old_node_field_list> or
<add_node_field_list>, and copies values giving precedence to the latter.
If the node fields have times, the time arrays are allocated once, then the
old values are copied followed by the add values to correctly merge the times.

... when <add_node_field_list> and <add_values_storage> not provided:
Copies the values for <new_node_field> into <new_values_storage> from the
<old_values_storage> with the equivalent node field in <old_node_field_list>.

... when <new_values_storage> is not provided then the values described by
<add_node_field_list> are copied from the <add_values_storage> into the 
corresponding places in the <old_values_storage>.

Notes:
Assumes <new_values_storage> is already allocated to the appropriate size.
Assumes the only differences between equivalent node fields are in time version;
no checks on this are made here.
Assumes component nodal values are consecutive and start at first component.
<copy_data_void> points at a struct FE_node_field_merge_values_storage_data.
==============================================================================*/
{	
 	enum Value_type value_type;
	int number_of_values, return_code;
	struct FE_field *field;
	struct FE_node_field *add_node_field, *old_node_field;
	struct FE_node_field_merge_values_storage_data *copy_data;
	Value_storage *destination, *source;

	ENTER(FE_node_field_merge_values_storage);
	if (new_node_field && (field = new_node_field->field) && (copy_data =
		(struct FE_node_field_merge_values_storage_data *)copy_data_void))
	{
		return_code = 1;
		/* only GENERAL_FE_FIELD has values stored with node */
		if (GENERAL_FE_FIELD == field->fe_field_type)
		{
			old_node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				field, copy_data->old_node_field_list);
			if (copy_data->add_node_field_list)
			{
				add_node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
					field, copy_data->add_node_field_list);
			}
			else
			{
				add_node_field = (struct FE_node_field *)NULL;
			}
			if (copy_data->new_values_storage)
			{
				/* Merging into a new values storage */
				if (old_node_field || add_node_field)
				{
					/* destination in new_values_storage according to new_node_field */
					destination =
						copy_data->new_values_storage + new_node_field->components->value;
					value_type = field->value_type;
					number_of_values = FE_node_field_get_number_of_values(new_node_field);
					if ((!add_node_field) ||
						(old_node_field && new_node_field->time_sequence))
					{
						/* source in old_values_storage according to old_node_field */
						if (copy_data->old_values_storage && old_node_field->components)
						{
							source = copy_data->old_values_storage +
								old_node_field->components->value;
							return_code = copy_value_storage_array(destination, value_type,
								new_node_field->time_sequence, old_node_field->time_sequence,
								number_of_values, source);
						}
						else
						{
							return_code = 0;
						}
					}
					if (return_code && add_node_field)
					{
						/* source in add_values_storage according to add_node_field */
						if (copy_data->add_values_storage && add_node_field->components)
						{
							source = copy_data->add_values_storage +
								add_node_field->components->value;
							if (old_node_field && new_node_field->time_sequence)
							{
								return_code = copy_time_sequence_values_storage_arrays(
									destination, value_type, new_node_field->time_sequence,
									add_node_field->time_sequence, number_of_values, source);
							}
							else
							{
								return_code = copy_value_storage_array(destination, value_type,
									new_node_field->time_sequence, add_node_field->time_sequence,
									number_of_values, source);
							}
						}
						else
						{
							return_code = 0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE, "FE_node_field_merge_values_storage.  "
						"Could not find equivalent existing node field");
					return_code = 0;
				}
				if (!return_code)
				{
					display_message(ERROR_MESSAGE,
						"FE_node_field_merge_values_storage.  Unable to copy values");
					return_code = 0;
				}
			}
			else
			{
				/* Replacing values in the existing values storage by copying
					them from the add_node_storage to the old_node_storage.
					(old_node_field and new_node_field should be the same) */
				if (old_node_field && (old_node_field == new_node_field))
				{
					if (add_node_field)
					{
						destination =
							copy_data->old_values_storage + old_node_field->components->value;
						value_type = field->value_type;
						number_of_values = FE_node_field_get_number_of_values(new_node_field);
						if (copy_data->add_values_storage && add_node_field->components)
						{
							source = copy_data->add_values_storage +
								add_node_field->components->value;
							if (old_node_field->time_sequence)
							{
								return_code = copy_time_sequence_values_storage_arrays(
									destination, value_type, old_node_field->time_sequence,
									add_node_field->time_sequence, number_of_values, source);
							}
							else
							{
								/* Release the storage of the old values.  The pointer is from the 
									start of the values storage to make it work as a node_field iterator. */
								FE_node_field_free_values_storage_arrays(old_node_field,
									(void *)copy_data->old_values_storage);
								return_code = copy_value_storage_array(destination, value_type,
									old_node_field->time_sequence, add_node_field->time_sequence,
									number_of_values, source);
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"FE_node_field_merge_values_storage.  Unable to merge values");
							return_code = 0;
						}
					}
					/* else do nothing as we are leaving this field alone */
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_node_field_merge_values_storage.  "
						"Unable to find corresponding node fields when updating values.");
					return_code = 0;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_merge_values_storage.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_merge_values_storage */

static int merge_FE_node_values_storage(struct FE_node *node,
	Value_storage *values_storage,
	struct LIST(FE_node_field) *new_node_field_list,
	struct FE_node *add_node)
/*******************************************************************************
LAST MODIFIED: 4 March 2005

DESCRIPTION:
For each field in <new_node_field_list> requiring values storage, finds the
equivalent node field in either <node>, <add_node> or both. If only one of
<node> or <add_node> contains an equivalent node field, those values are
copied. If there is an equivalent node field in both, behaviour depends on
whether the node fields have times:
* if the node fields have no times, values are taken from <add_node>.
* if the node fields have times, the times arrays are allocated, then the
values at times in <node> are copied, followed by those in <add_node>.
Hence, the values in <add_node> take preference over those in <node>.
If <values_storage> is not provided then the fields described in the 
<new_node_field_list> are looked for in the <add_node> and if found the
values are copied into the existing values storage in <node>.
Notes:
* there must be an equivalent node field at either <node> or <add_node>;
* <add_node> is optional and used only by merge_FE_node. If NULL then a node
field must be found in <node>;
* Values_storage, when provided, must already be allocated to the appropriate
size but is not assumed to contain any information prior to being filled here;
* Any objects or arrays referenced in the values_storage are accessed or
allocated in the new <values_storage> so <node> and <add_node> are unchanged.
* It is up to the calling function to have checked that the node fields in
<node>, <add_node> and <new_node_field_list> are compatible.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_merge_values_storage_data copy_data;

	ENTER(merge_FE_node_values_storage);
	if (node && node->fields && new_node_field_list &&
		((!add_node) || add_node->fields))
	{
		copy_data.new_values_storage = values_storage;
		copy_data.old_node_field_list = node->fields->node_field_list;
		copy_data.old_values_storage = node->values_storage;
		if (add_node)
		{
			copy_data.add_node_field_list = add_node->fields->node_field_list;
			copy_data.add_values_storage = add_node->values_storage;
		}
		else
		{
			copy_data.add_node_field_list = (struct LIST(FE_node_field) *)NULL;
			copy_data.add_values_storage = (Value_storage *)NULL;
		}
		return_code = FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			FE_node_field_merge_values_storage, (void *)(&copy_data),
			new_node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_node_values_storage.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;
	
	return (return_code);
} /* merge_FE_node_values_storage */

static int get_FE_node_field_list_values_storage_size(
	struct LIST(FE_node_field) *node_field_list)
/*******************************************************************************
LAST MODIFIED : 13 September 2000

DESCRIPTION :
Returns the size, in bytes, of the data in the nodal values storage owned
by the all the node_fields in node_field_list.
==============================================================================*/
{
	int values_storage_size;
	
	ENTER(get_FE_node_field_list_values_storage_size);
	values_storage_size=0;
	if (node_field_list)
	{
		FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			FE_node_field_add_values_storage_size,
			(void *)&values_storage_size,node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_list_values_storage_size.  Invalid argument");
	}
	LEAVE;

	return (values_storage_size);
} /* get_FE_node_field_list_values_storage_size */

static int allocate_and_copy_FE_node_values_storage(struct FE_node *node, 
	Value_storage **values_storage)
/******************************************************************************
LAST MODIFIED: 1 November 2002

DESCRIPTION:
Allocates values_storage to the same size as node->values_storage.
Copies the node->values_storage to values_storage. Also allocates and copies
any arrays in node->values_storage.

Note that values_storage contains no information about the value_type(s) or the
number of values of the data in it. You must refer to the FE_node/FE_field to 
get this.

The the calling function is responsible for deallocating values_storage,
and any arrays in values_storage.
==============================================================================*/
{
	int return_code,size;
	Value_storage *dest_values_storage;

	ENTER(allocate_and_copy_FE_node_values_storage);
	if (node)
	{
		return_code = 1;
	
		if (node->fields)
		{
			size = get_FE_node_field_list_values_storage_size(
				node->fields->node_field_list);
			if (size)
			{
				if (ALLOCATE(dest_values_storage,Value_storage,size))
				{
					return_code = merge_FE_node_values_storage(node, dest_values_storage,
						node->fields->node_field_list, (struct FE_node *)NULL);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"allocate_and_copy_FE_node_values_storage.  Not enough memory");
					dest_values_storage = (Value_storage *)NULL;
					return_code = 0;
				}
			}
			else /* no fields, nothing to copy */
			{
				dest_values_storage = (Value_storage *)NULL;	
			}	
		}	
		else /* no fields, nothing to copy */
		{
		 dest_values_storage = (Value_storage *)NULL;	
		}	
		*values_storage = dest_values_storage;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"allocate_and_copy_FE_node_values_storage.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* allocate_and_copy_FE_node_values_storage */

static int FE_node_field_is_coordinate_field(struct FE_node_field 
	*node_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 29 August 2001

DESCRIPTION:
Returns true if <node_field> has a field of type CM_coordinate, returns
FE_values and has up to 3 components.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(FE_node_field_is_coordinate_field);
	USE_PARAMETER(dummy);
	if (node_field && (field = node_field->field))
	{
		return_code=FE_field_is_coordinate_field(field,dummy);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_is_coordinate_field.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
}/* FE_node_field_is_coordinate_field */

static int FE_node_field_has_time(struct FE_node_field *node_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 16 June 1999

DESCRIPTION:
returns true if <node_field> has time information defined
==============================================================================*/
{
	int return_code;
	ENTER(FE_node_field_has_time);

	if (node_field&&!dummy)
	{
		return_code = (node_field->field->number_of_times > 0); 	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_has_time. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
}/* FE_node_field_has_time */

static int assign_FE_node_field_component(
	struct FE_node_field_component *component,
	int value,int number_of_derivatives,int number_of_versions,
	enum FE_nodal_value_type *nodal_value_types)
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
Assigns the fields for the component
???DB.  Do nodal_value_types better ?
==============================================================================*/
{
	int i,return_code;

	ENTER(assign_FE_node_field_component);

	return_code = 1;
	if (component && (0 <= value) && (0 <= number_of_derivatives) &&
		(1 <= number_of_versions) && nodal_value_types)
	{
		if (!(component->nodal_value_types))
		{
			i=number_of_derivatives+1;
			if (ALLOCATE(component->nodal_value_types,enum FE_nodal_value_type,i))
			{
				while (i>0)
				{
					i--;
					(component->nodal_value_types)[i]=nodal_value_types[i];
				}
				component->value = value;
				component->number_of_derivatives=number_of_derivatives;
				component->number_of_versions=number_of_versions;
			}
			else
			{
				display_message(ERROR_MESSAGE, "assign_FE_node_field_component.  "
					"Could not allocate memory for nodal value types");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"assign_FE_node_field_component.  Component already assigned");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"assign_FE_node_field_component.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* assign_FE_node_field_component */

static int compare_FE_field(struct FE_field *field_1,struct FE_field *field_2)
/*******************************************************************************
LAST MODIFIED : 18 May 1998

DESCRIPTION :
Returns -1 if field_1 < field_2, 0 if field_1 = field_2 and 1 if
field_1 > field_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_FE_field);
	/*???DB.  Alphabetical ordering */
	return_code=strcmp(field_1->name,field_2->name);
#if defined (OLD_CODE)
	if (field_1<field_2)
	{
		return_code= -1;
	}
	else
	{
		if (field_1>field_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
#endif /* defined (OLD_CODE) */
	LEAVE;

	return (return_code);
} /* compare_FE_field */

static struct FE_node_field *CREATE(FE_node_field)(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 19 January 1998

DESCRIPTION :
Allocates memory and assigns fields for a node field.  The components are
allocated and set to "zero".
???DB.  Not allocating any nodal value names.
==============================================================================*/
{
	int number_of_components;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;

	ENTER(CREATE(FE_node_field));
	if (field)
	{
		number_of_components=field->number_of_components;
		if (ALLOCATE(node_field,struct FE_node_field,1)&&
			ALLOCATE(component,struct FE_node_field_component,number_of_components))
		{
			node_field->field=ACCESS(FE_field)(field);
			node_field->time_sequence=(struct FE_time_sequence *)NULL;
			node_field->components=component;
			while (number_of_components>0)
			{
				component->value=0;
				component->number_of_derivatives=0;
				component->number_of_versions=0;
				component->nodal_value_types=(enum FE_nodal_value_type *)NULL;
				component++;
				number_of_components--;
			}
			node_field->access_count=0;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_node_field).  Could not allocate memory for node field");
			DEALLOCATE(node_field);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_node_field).  Invalid argument(s)");
		node_field=(struct FE_node_field *)NULL;
	}
	LEAVE;

	return (node_field);
} /* CREATE(FE_node_field) */

static int DESTROY(FE_node_field)(struct FE_node_field **node_field_address)
/*******************************************************************************
LAST MODIFIED : 19 January 1998

DESCRIPTION :
Frees the memory for the node field and sets <*node_field_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;

	ENTER(DESTROY(FE_node_field));
	if ((node_field_address)&&(node_field= *node_field_address))
	{
		if (0==node_field->access_count)
		{
			component=node_field->components;
			for (i=node_field->field->number_of_components;i>0;i--)
			{
				DEALLOCATE(component->nodal_value_types);
				component++;
			}
			/* free the components */
			DEALLOCATE(node_field->components);
			if (node_field->time_sequence)
			{
				DEACCESS(FE_time_sequence)(&(node_field->time_sequence));
			}
			(void)DEACCESS(FE_field)(&(node_field->field));
			DEALLOCATE(*node_field_address);
		}
		else
		{
			*node_field_address=(struct FE_node_field *)NULL;
		}
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node_field) */

DECLARE_OBJECT_FUNCTIONS(FE_node_field)

static struct FE_node_field *copy_create_FE_node_field_with_offset(
	struct FE_node_field *source_node_field,int value_offset)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
Creates an FE_node_field that is identical to <source_node_field> except that
the <value_offset> is added to the value member of the components (which is
an offset into the values_storage array at the node). For non-GENERAL_FE_FIELD
types, the value is not changed.
==============================================================================*/
{
	int i,number_of_components;
	struct FE_field *field;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component,*source_component;

	ENTER(copy_create_FE_node_field_with_offset);
	if (source_node_field&&(field=source_node_field->field))
	{
		if (node_field=CREATE(FE_node_field)(field))
		{
			if (source_node_field->time_sequence)
			{
				node_field->time_sequence = ACCESS(FE_time_sequence)
					(source_node_field->time_sequence);
			}
			if (GENERAL_FE_FIELD != field->fe_field_type)
			{
				/* though component->value is currently irrelevant for these fields,
					 keep it unchanged for future use */
				value_offset=0;
			}
			number_of_components=get_FE_field_number_of_components(field);
			component=node_field->components;
			source_component=source_node_field->components;
			for (i=number_of_components;(0<i)&&node_field;i--)
			{
				if (!assign_FE_node_field_component(component,
					source_component->value+value_offset,
					source_component->number_of_derivatives,
					source_component->number_of_versions,
					source_component->nodal_value_types))
				{
					display_message(ERROR_MESSAGE,
						"copy_create_FE_node_field_with_offset.  "
						"Could not assign node field component");
					DESTROY(FE_node_field)(&node_field);
				}
				component++;
				source_component++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"copy_create_FE_node_field_with_offset.  Could not create node field");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_create_FE_node_field_with_offset.  Invalid argument(s)");
		node_field=(struct FE_node_field *)NULL;
	}
	LEAVE;

	return (node_field);
} /* copy_create_FE_node_field_with_offset */

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_node_field, field, \
	struct FE_field *, compare_FE_field)

DECLARE_INDEXED_LIST_FUNCTIONS(FE_node_field)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_node_field, field, \
	struct FE_field *, compare_FE_field)

struct FE_node_field_copy_with_equivalent_field_data
/*******************************************************************************
LAST MODIFIED : 27 November 2002

DESCRIPTION :
Data for passing to FE_node_field_copy_with_equivalent_field.
==============================================================================*/
{
	struct FE_time_sequence_package *fe_time;
	struct LIST(FE_field) *fe_field_list;
	struct LIST(FE_node_field) *node_field_list;
};

static int FE_node_field_copy_with_equivalent_field(
	struct FE_node_field *node_field, void *data_void)
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
Creates a copy of <node_field> using the same named field in <fe_field_list>
and adds it to <node_field_list>. Checks fields are equivalent.
Also creates an equivalent FE_time_sequence in the new <fe_time> for this
node field.
<data_void> points at a struct FE_node_field_copy_with_equivalent_field_data.
==============================================================================*/
{
	int i, number_of_components, return_code;
	struct FE_field *equivalent_field;
	struct FE_node_field *copy_node_field;
	struct FE_node_field_copy_with_equivalent_field_data *data;
	struct FE_node_field_component *component, *copy_component;

	ENTER(FE_node_field_copy_with_equivalent_field);
	if (node_field && node_field->field &&
		(data = (struct FE_node_field_copy_with_equivalent_field_data *)data_void))
	{
		return_code = 1;
		if (equivalent_field = FIND_BY_IDENTIFIER_IN_LIST(FE_field,name)(
			node_field->field->name, data->fe_field_list))
		{
			if (FE_fields_match_exact(node_field->field, equivalent_field))
			{
				if (copy_node_field = CREATE(FE_node_field)(equivalent_field))
				{
					if (node_field->time_sequence)
					{
						if (!(copy_node_field->time_sequence = ACCESS(FE_time_sequence)(
							get_FE_time_sequence_matching_FE_time_sequence(data->fe_time,
								node_field->time_sequence))))
						{
							return_code = 0;
						}
					}
					if (GENERAL_FE_FIELD == equivalent_field->fe_field_type)
					{
						number_of_components =
							get_FE_field_number_of_components(equivalent_field);
						component = node_field->components;
						copy_component = copy_node_field->components;
						for (i = number_of_components; (0 < i) && return_code; i--)
						{
							if (!assign_FE_node_field_component(copy_component,
								component->value,
								component->number_of_derivatives,
								component->number_of_versions,
								component->nodal_value_types))
							{
								return_code = 0;
							}
							component++;
							copy_component++;
						}
					}
					if (return_code)
					{
						if (!ADD_OBJECT_TO_LIST(FE_node_field)(copy_node_field,
							data->node_field_list))
						{
							return_code = 0;
						}
					}
					if (!return_code)
					{
						display_message(ERROR_MESSAGE,
							"FE_node_field_copy_with_equivalent_field.  "
							"Could not copy node field component");
						DESTROY(FE_node_field)(&copy_node_field);
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_node_field_copy_with_equivalent_field.  "
						"Could not create node field");
					return_code = 0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_node_field_copy_with_equivalent_field.  Fields not equivalent");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_field_copy_with_equivalent_field.  No equivalent field");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_copy_with_equivalent_field.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_copy_with_equivalent_field */

struct LIST(FE_node_field) *
	FE_node_field_list_clone_with_FE_field_list(
		struct LIST(FE_node_field) *node_field_list,
		struct LIST(FE_field) *fe_field_list, struct FE_time_sequence_package *fe_time)
/*******************************************************************************
LAST MODIFIED : 6 May 2003

DESCRIPTION :
Returns a new FE_node_field list that is identical to <node_field_list>
except that it references equivalent same-name fields from <fe_field_list> and
uses FE_time_sequences in <fe_time>.
It is an error if an equivalent FE_field is not found.
==============================================================================*/
{
	struct LIST(FE_node_field) *return_node_field_list;
	struct FE_node_field_copy_with_equivalent_field_data data;

	ENTER(FE_node_field_list_clone_with_FE_field_list);
	return_node_field_list = (struct LIST(FE_node_field) *)NULL;
	if (node_field_list && fe_field_list && fe_time)
	{
		data.fe_time = fe_time;
		data.fe_field_list = fe_field_list;
		data.node_field_list = CREATE(LIST(FE_node_field))();
		if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			FE_node_field_copy_with_equivalent_field, (void *)&data,
			node_field_list))
		{
			return_node_field_list = data.node_field_list;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_field_list_clone_with_FE_field_list.  Failed");
			DESTROY(LIST(FE_node_field))(&data.node_field_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_list_clone_with_FE_field_list.  Invalid argument(s)");
	}
	LEAVE;

	return (return_node_field_list);
} /* FE_node_field_list_clone_with_FE_field_list */

struct FE_node_field_info *CREATE(FE_node_field_info)(
	struct FE_region *fe_region, struct LIST(FE_node_field) *fe_node_field_list,
	int number_of_values)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Creates a struct FE_node_field_info with a pointer to <fe_region> and a copy of
the <fe_node_field_list>.
Fails if more than one FE_node_field in the list references the same field.
If <fe_node_field_list> is omitted, an empty list is assumed.
Note:
This should only be called by FE_region functions, and the FE_region must be
its own master. The returned object is added to the list of
FE_node_field_info in the FE_region and is therefore owned by the FE_region.
It maintains a non-ACCESSed pointer to its owning FE_region which the FE_region
will clear before it is destroyed. If it becomes necessary to have other owners
of these objects, the common parts of it and FE_region should be extracted to a
common object.
==============================================================================*/
{
	struct FE_node_field_info *fe_node_field_info;

	ENTER(CREATE(FE_node_field_info));
	fe_node_field_info = (struct FE_node_field_info *)NULL;
	if (fe_region)
	{
		if (ALLOCATE(fe_node_field_info, struct FE_node_field_info, 1))
		{
			/*???RC not convinced number_of_values needs to be in this structure */
			fe_node_field_info->number_of_values = number_of_values;
			fe_node_field_info->values_storage_size = 0;
			fe_node_field_info->node_field_list = CREATE_LIST(FE_node_field)();
			/* maintain pointer to the the FE_region this information belongs to.
				 It is not ACCESSed since FE_region is the owning object and it
				 would prevent the FE_region from being destroyed. */
			fe_node_field_info->fe_region = fe_region;
			fe_node_field_info->access_count = 0;
			if (fe_node_field_info->node_field_list && ((!fe_node_field_list) ||
					COPY_LIST(FE_node_field)(fe_node_field_info->node_field_list,
							fe_node_field_list)))
			{
				fe_node_field_info->values_storage_size =
					get_FE_node_field_list_values_storage_size(
						fe_node_field_info->node_field_list);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_node_field_info).  Unable to build node field list");
				DESTROY(FE_node_field_info)(&fe_node_field_info);
				fe_node_field_info = (struct FE_node_field_info *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_node_field_info).  Not enough memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_node_field_info).  Invalid argument(s)");
	}
	LEAVE;

	return (fe_node_field_info);
} /* CREATE(FE_node_field_info) */

int DESTROY(FE_node_field_info)(
	struct FE_node_field_info **node_field_info_address)
/*******************************************************************************
LAST MODIFIED : 19 February 2003

DESCRIPTION :
Destroys the FE_node_field_info at *<node_field_info_address>. Frees the memory
for the information and sets <*node_field_info_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_info *node_field_info;

	ENTER(DESTROY(FE_node_field_info));
	if (node_field_info_address && (node_field_info = *node_field_info_address))
	{
		if (0 == node_field_info->access_count)
		{
			DESTROY(LIST(FE_node_field))(&(node_field_info->node_field_list));
			DEALLOCATE(*node_field_info_address);
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_node_field_info).  Non-zero access count");
			return_code = 0;
		}
		*node_field_info_address = (struct FE_node_field_info *)NULL;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(FE_node_field_info).  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node_field_info) */

DECLARE_ACCESS_OBJECT_FUNCTION(FE_node_field_info)

PROTOTYPE_DEACCESS_OBJECT_FUNCTION(FE_node_field_info)
/*******************************************************************************
LAST MODIFIED : 29 January 2003

DESCRIPTION :
Special version of DEACCESS which if the FE_node_field_info access_count reaches
1 and it has an fe_region member, calls FE_region_remove_FE_node_field_info.
Since the FE_region accesses the info once, this indicates no other object is
using it so it should be flushed from the FE_region. When the owning FE_region
deaccesses the info, it is destroyed in this function.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_info *object;

	ENTER(DEACCESS(FE_node_field_info));
	if (object_address && (object = *object_address))
	{
		(object->access_count)--;
		return_code = 1;
		if (object->access_count <= 1)
		{
			if (1 == object->access_count)
			{
				if (object->fe_region)
				{
					return_code =
						FE_region_remove_FE_node_field_info(object->fe_region, object);
				}
			}
			else
			{
				return_code = DESTROY(FE_node_field_info)(object_address);
			}
		}
		*object_address = (struct FE_node_field_info *)NULL;
	}
	else
	{
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DEACCESS(FE_node_field_info) */

PROTOTYPE_REACCESS_OBJECT_FUNCTION(FE_node_field_info)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Special version of REACCESS which if the FE_node_field_info access_count reaches
1 and it has an fe_region member, calls FE_region_remove_FE_node_field_info.
Since the FE_region accesses the info once, this indicates no other object is
using it so it should be flushed from the FE_region. When the owning FE_region
deaccesses the info, it is destroyed in this function.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_info *current_object;

	ENTER(REACCESS(FE_node_field_info));
	if (object_address)
	{
		return_code = 1;
		if (new_object)
		{
			/* access the new object */
			(new_object->access_count)++;
		}
		if (current_object = *object_address)
		{
			/* deaccess the current object */
			(current_object->access_count)--;
			if (current_object->access_count <= 1)
			{
				if (1 == current_object->access_count)
				{
					if (current_object->fe_region)
					{
						return_code = FE_region_remove_FE_node_field_info(
							current_object->fe_region, current_object);
					}
				}
				else
				{
					return_code = DESTROY(FE_node_field_info)(object_address);
				}
			}
		}
		/* point to the new object */
		*object_address = new_object;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"REACCESS(FE_node_field_info).  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* REACCESS(FE_node_field_info) */

DECLARE_LIST_FUNCTIONS(FE_node_field_info)

int FE_node_field_info_clear_FE_region(
	struct FE_node_field_info *node_field_info, void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Clears the pointer to FE_region in <node_field_info>.
Private function only to be called by destroy_FE_region.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_info_clear_FE_region);
	USE_PARAMETER(dummy_void);
	if (node_field_info)
	{
		node_field_info->fe_region = (struct FE_region *)NULL;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_clear_FE_region.  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_info_clear_FE_region */

int FE_node_field_info_has_FE_field(
	struct FE_node_field_info *node_field_info, void *fe_field_void)
/*******************************************************************************
LAST MODIFIED : 4 March 2003

DESCRIPTION :
Returns true if <node_field_info> has an node field for <fe_field>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_info_has_FE_field);
	if (FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
		(struct FE_field *)fe_field_void, node_field_info->node_field_list))
	{
		return_code = 1;
	}
	else
	{
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_info_has_FE_field */

int FE_node_field_info_has_empty_FE_node_field_list(
	struct FE_node_field_info *node_field_info, void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 14 October 2002

DESCRIPTION :
Returns true if <node_field_info> has no node fields.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_info_has_empty_FE_node_field_list);
	USE_PARAMETER(dummy_void);
	if (node_field_info)
	{
		if (0 == NUMBER_IN_LIST(FE_node_field)(node_field_info->node_field_list))
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_has_empty_FE_node_field_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_info_has_empty_FE_node_field_list */

int FE_node_field_info_has_FE_field_with_multiple_times(
	struct FE_node_field_info *node_field_info, void *fe_field_void)
/*******************************************************************************
LAST MODIFIED: 26 February 2003

DESCRIPTION:
Returns true if <node_field_info> has a node_field that references
<fe_field_void> and that node_field has multiple times.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;
	struct FE_node_field *node_field;

	ENTER(FE_node_field_info_has_FE_field_with_multiple_times);
	if (node_field_info && (field = (struct FE_field *)fe_field_void))
	{
		if (node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field, field)(field,
			node_field_info->node_field_list))
		{
			if (node_field->time_sequence)
			{
				return_code = 1;
			}
			else
			{
				return_code = 0;
			}
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_has_FE_field_with_multiple_times.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
}/* FE_node_field_info_has_FE_field_with_multiple_times */

int FE_node_field_info_has_matching_FE_node_field_list(
	struct FE_node_field_info *node_field_info, void *node_field_list_void)
/*******************************************************************************
LAST MODIFIED : 14 November 2002

DESCRIPTION :
Returns true if <node_field_info> has a FE_node_field_list containing all the
same FE_node_fields as <node_field_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node_field) *node_field_list;

	ENTER(FE_node_field_info_has_matching_FE_node_field_list);
	return_code = 0;
	if (node_field_info &&
		(node_field_list = (struct LIST(FE_node_field) *)node_field_list_void))
	{
		if ((NUMBER_IN_LIST(FE_node_field)(node_field_list) ==
			NUMBER_IN_LIST(FE_node_field)(node_field_info->node_field_list)))
		{
			if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(FE_node_field_is_in_list,
				(void *)(node_field_info->node_field_list), node_field_list))
			{
				return_code = 1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_has_matching_FE_node_field_list.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_info_has_matching_FE_node_field_list */

struct LIST(FE_node_field) *FE_node_field_info_get_node_field_list(
	struct FE_node_field_info *fe_node_field_info)
/*******************************************************************************
LAST MODIFIED : 24 February 2003

DESCRIPTION :
Returns the node field list contained in the <node_field_info>.
==============================================================================*/
{
	struct LIST(FE_node_field) *node_field_list;

	ENTER(FE_node_field_info_get_node_field_list);
	if (fe_node_field_info)
	{
		node_field_list = fe_node_field_info->node_field_list;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_get_node_field_list.  Invalid argument(s)");
		node_field_list = (struct LIST(FE_node_field) *)NULL;
	}
	LEAVE;

	return (node_field_list);
} /* FE_node_field_info_get_node_field_list */

int FE_node_field_info_get_number_of_values(
	struct FE_node_field_info *fe_node_field_info)
/*******************************************************************************
LAST MODIFIED : 24 February 2003

DESCRIPTION :
Returns the number of values expected for the <node_field_info>.
==============================================================================*/
{
	int number_of_values;

	ENTER(FE_node_field_info_get_number_of_values);
	if (fe_node_field_info)
	{
		number_of_values = fe_node_field_info->number_of_values;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_get_number_of_values.  Invalid argument(s)");
		number_of_values = 0;
	}
	LEAVE;

	return (number_of_values);
} /* FE_node_field_info_get_number_of_values */

int FE_node_field_info_add_node_field(
	struct FE_node_field_info *fe_node_field_info, 
	struct FE_node_field *new_node_field, int new_number_of_values)
/*******************************************************************************
LAST MODIFIED : 24 August 2005

DESCRIPTION :
Adds the <new_node_field> to the list in the <fe_node_field_info> and updates the
<new_number_of_values>.  This should only be done if object requesting the change
is known to be the only object using this field info.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_info_add_node_field);
	if (fe_node_field_info)
	{
		if (ADD_OBJECT_TO_LIST(FE_node_field)(new_node_field, 
				fe_node_field_info->node_field_list))
		{
			fe_node_field_info->number_of_values = new_number_of_values;
			FE_node_field_add_values_storage_size(
				new_node_field, (void *)&fe_node_field_info->values_storage_size);
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_field_info_add_node_field.  Unable to add field to list");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_add_node_field.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_info_add_node_field */

int FE_node_field_info_used_only_once(
	struct FE_node_field_info *fe_node_field_info)
/*******************************************************************************
LAST MODIFIED : 24 August 2005

DESCRIPTION :
Returns 1 if the <node_field_info> access count indicates that it is being used
by only one external object.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_info_used_only_once);
	if (fe_node_field_info)
	{
		/* Once plus the access by the FE_region into its list == 2 */
		if (fe_node_field_info->access_count <= 2)
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_used_only_once.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_info_used_only_once */

int FE_node_field_log_FE_field_change(
	struct FE_node_field *node_field, void *fe_field_change_log_void)
/*******************************************************************************
LAST MODIFIED : 14 February 2003

DESCRIPTION :
Logs the field in <node_field> as RELATED_OBJECT_CHANGED
in <fe_field_change_log>.
==============================================================================*/
{
	int return_code;
	struct CHANGE_LOG(FE_field) *fe_field_change_log;

	ENTER(FE_node_field_log_FE_field_change);
	if (node_field && (fe_field_change_log =
		(struct CHANGE_LOG(FE_field) *)fe_field_change_log_void))
	{
		return_code = CHANGE_LOG_OBJECT_CHANGE(FE_field)(fe_field_change_log,
			node_field->field, CHANGE_LOG_RELATED_OBJECT_CHANGED(FE_field));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_log_FE_field_change.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_log_FE_field_change */

int FE_node_field_info_log_FE_field_changes(
	struct FE_node_field_info *fe_node_field_info,
	struct CHANGE_LOG(FE_field) *fe_field_change_log)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Marks each FE_field in <fe_node_field_info> as RELATED_OBJECT_CHANGED
in <fe_field_change_log>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_info_log_FE_field_changes);
	if (fe_node_field_info && fe_field_change_log)
	{
		return_code = FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			FE_node_field_log_FE_field_change, (void *)fe_field_change_log,
			fe_node_field_info->node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_info_log_FE_field_changes.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_info_log_FE_field_changes */

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_node,cm_node_identifier,int,compare_int)

DECLARE_CHANGE_LOG_MODULE_FUNCTIONS(FE_node)

static int compare_FE_basis_type(int *basis_type_1,int *basis_type_2)
/*******************************************************************************
LAST MODIFIED : 2 November 1995

DESCRIPTION :
Returns -1 if basis_type_1 < basis_type_2, 0 if basis_type_1 = basis_type_2 and
1 if basis_type_1 > basis_type_2.
==============================================================================*/
{
	int return_code,*type_1,*type_2;
	int i;

	ENTER(compare_FE_basis_type);
	if (type_1=basis_type_1)
	{
		if (type_2=basis_type_2)
		{
			if ((i= *type_1)== *type_2)
			{
				if (i>0)
				{
					i *= i+1;
					i /= 2;
					do
					{
						type_1++;
						type_2++;
						i--;
					} while ((i>0)&&(*type_1== *type_2));
					if (*type_1< *type_2)
					{
						return_code= -1;
					}
					else
					{
						if (*type_1> *type_2)
						{
							return_code=1;
						}
						else
						{
							return_code=0;
						}
					}
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				if (*type_1< *type_2)
				{
					return_code= -1;
				}
				else
				{
					return_code=1;
				}
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		if (basis_type_2)
		{
			return_code= -1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* compare_FE_basis_type */

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_basis,type,int *,compare_FE_basis_type)

static int compare_CM_element_information(
	struct CM_element_information *cmiss_1,
	struct CM_element_information *cmiss_2)
/*******************************************************************************
LAST MODIFIED : 17 April 1999

DESCRIPTION :
Returns -1 if cmiss_1 < cmiss_2, 0 if cmiss_1 = cmiss_2 and 1 if cmiss_1 >
cmiss_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_CM_element_information);
	if (cmiss_1&&cmiss_2)
	{		
		if (cmiss_1->type==cmiss_2->type )
		{		
			if (cmiss_1->number==cmiss_2->number)
				return_code=0;
			else if (cmiss_1->number < cmiss_2->number)
				return_code=-1;
			else					 
				return_code =1;		
		}
		else
		{
			if (cmiss_1->type<cmiss_2->type )
				return_code=-1;
			else					 
				return_code =1;		
		}
		
	}
	else
	{
		return_code=1;
	}
	LEAVE;

	return (return_code);
} /* compare_CM_element_information */

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_element,identifier, \
	struct CM_element_information *, compare_CM_element_information)

DECLARE_CHANGE_LOG_MODULE_FUNCTIONS(FE_element)

static int compare_FE_element_type_node_sequence_identifier(
	struct FE_element_type_node_sequence_identifier *identifier1,
	struct FE_element_type_node_sequence_identifier *identifier2)
/*******************************************************************************
LAST MODIFIED : 29 April 1999

DESCRIPTION :
Compare functions for listing struct FE_element_type_node_sequence in order:
- cm_type changing slowest;
- number_of_nodes changing next slowest;
- node numbers in numerical order (nodes must be in ascending order).
Returns values like strcmp:
-1 = identifier 1 < identifier 2
 0 = identifier 1 = identifier 2
 1 = identifier 1 > identifier 2
==============================================================================*/
{
	int i,number_of_nodes,return_code;

	ENTER(compare_FE_element_type_node_sequence_identifier);
	if (identifier1&&identifier2)
	{
		/* 1. compare cm_type */
		if (identifier1->cm_type < identifier2->cm_type)
		{
			return_code=-1;
		}
		else if (identifier1->cm_type > identifier2->cm_type)
		{
			return_code=1;
		}
		else
		{
			/* 2. compare number_of_nodes */
			number_of_nodes=identifier1->number_of_nodes;
			if (number_of_nodes < identifier2->number_of_nodes)
			{
				return_code=-1;
			}
			else if (number_of_nodes > identifier2->number_of_nodes)
			{
				return_code=1;
			}
			else
			{
				/* 3. compare node_numbers - assumed in ascending order */
				return_code=0;
				/*???RC.  Assumes the identifiers have nodes - as required by
					CREATE(FE_element_type_node_sequence */
				for (i=0;(!return_code)&&(i<number_of_nodes);i++)
				{
					if (identifier1->node_numbers[i]<identifier2->node_numbers[i])
					{
						return_code=-1;
					}
					else if (identifier1->node_numbers[i]>identifier2->node_numbers[i])
					{
						return_code=1;
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"compare_FE_element_type_node_sequence_identifier.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* compare_FE_element_type_node_sequence_identifier */

struct FE_element_type_node_sequence
	*CREATE(FE_element_type_node_sequence)(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Structure for storing an element with its identifier being its cm_type and the
number and list - in ascending order - of the nodes referred to by the default
coordinate field of the element. Indexed lists, indexed using function
compare_FE_element_type_node_sequence_identifier ensure that recalling a line or
face with the same nodes is extremely rapid. add_FE_element_and_faces_to_manager
uses them to find faces and lines for elements without them, if they exist.
==============================================================================*/
{
	int i,node_number,*node_numbers,number_of_nodes,placed,j,k;
	struct FE_element_type_node_sequence *element_type_node_sequence;
	struct FE_node **nodes_in_element;

	ENTER(CREATE(FE_element_type_node_sequence));
	if (element)
	{
		/* get list of nodes used by default coordinate field in element */
		if (calculate_FE_element_field_nodes(element, (struct FE_field *)NULL,
			&number_of_nodes, &nodes_in_element,
			/*top_level_element*/(struct FE_element *)NULL) && (0 < number_of_nodes))
		{
			if (ALLOCATE(element_type_node_sequence,
				struct FE_element_type_node_sequence,1)&&
				ALLOCATE(element_type_node_sequence->identifier,
				struct FE_element_type_node_sequence_identifier,1)&&
				ALLOCATE(node_numbers,int,number_of_nodes))
			{
				element_type_node_sequence->identifier->cm_type=element->cm.type;
				element_type_node_sequence->identifier->number_of_nodes=number_of_nodes;
				element_type_node_sequence->identifier->node_numbers=node_numbers;
				element_type_node_sequence->element=ACCESS(FE_element)(element);
				element_type_node_sequence->access_count=0;
				/* put the nodes in the identifier in ascending order */
				for (i=0;element_type_node_sequence&&(i<number_of_nodes);i++)
				{
					node_number=(nodes_in_element[i])->cm_node_identifier;
					node_numbers[i]=node_number;
					/* SAB Reenabled the matching of differently ordered faces as 
						detecting the continuity correctly is more important than the 
						problems with lines matching to different nodes when 
						inheriting from different parents.
						OLDCOMMENT 
						We do not want to sort these node numbers as the order of the nodes
						determines which ordering the faces are in and if these do not match
						we will get the lines matched to different pairs of the nodes. */
					placed=0;
					for (j=0;(!placed)&&(j<i);j++)
					{
						if (node_number<node_numbers[j])
						{
							/* make space for the new number */
							for (k=i;j<k;k--)
							{
								node_numbers[k]=node_numbers[k-1];
							}
							node_numbers[j]=node_number;
							placed=1;
						}
					}
					if (!placed)
					{
						node_numbers[i]=node_number;
					}
				}
#if defined (DEBUG)
				/*???debug*/
				printf("FE_element_type_node_sequence  %s %d has nodes: ",
					CM_element_type_string(element->cm.type), element->cm.number);
				for (i=0;i<number_of_nodes;i++)
				{
					printf(" %d",node_numbers[i]);
				}
				printf("\n");
#endif /* defined (DEBUG) */
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_element_type_node_sequence).  Not enough memory");
				if (element_type_node_sequence)
				{
					if (element_type_node_sequence->identifier)
					{
						DEALLOCATE(element_type_node_sequence->identifier);
					}
					DEALLOCATE(element_type_node_sequence);
				}
			}
			for (i=0;i<number_of_nodes;i++)
			{
				DEACCESS(FE_node)(nodes_in_element+i);
			}
			DEALLOCATE(nodes_in_element);
		}
		else
		{
			display_message(ERROR_MESSAGE,"CREATE(FE_element_type_node_sequence).  "
				"Could not get nodes in element");
			element_type_node_sequence=(struct FE_element_type_node_sequence *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_type_node_sequence).  Invalid argument(s)");
		element_type_node_sequence=(struct FE_element_type_node_sequence *)NULL;
	}
	LEAVE;

	return (element_type_node_sequence);
} /* CREATE(FE_element_type_node_sequence) */

int DESTROY(FE_element_type_node_sequence)(
	struct FE_element_type_node_sequence **element_type_node_sequence_address)
/*******************************************************************************
LAST MODIFIED : 13 February 2003

DESCRIPTION :
Cleans up memory used by the FE_element_type_node_sequence.
==============================================================================*/
{
	int return_code;
	struct FE_element_type_node_sequence *element_type_node_sequence;

	ENTER(DESTROY(FE_element_type_node_sequence));
	if (element_type_node_sequence_address&&
		(element_type_node_sequence= *element_type_node_sequence_address))
	{
		if (0==element_type_node_sequence->access_count)
		{
			/* must deaccess element */
			DEACCESS(FE_element)(&(element_type_node_sequence->element));
			if (element_type_node_sequence->identifier)
			{
				DEALLOCATE(element_type_node_sequence->identifier->node_numbers);
				DEALLOCATE(element_type_node_sequence->identifier);
			}
			DEALLOCATE(*element_type_node_sequence_address);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_element_type_node_sequence).  Non-zero access count of %d",
				element_type_node_sequence->access_count);
			*element_type_node_sequence_address=
				(struct FE_element_type_node_sequence *)NULL;
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(FE_element_type_node_sequence).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_type_node_sequence) */

DECLARE_OBJECT_FUNCTIONS(FE_element_type_node_sequence)

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_element_type_node_sequence, \
	identifier, struct FE_element_type_node_sequence_identifier *, \
	compare_FE_element_type_node_sequence_identifier)

DECLARE_INDEXED_LIST_FUNCTIONS(FE_element_type_node_sequence)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION( \
	FE_element_type_node_sequence,identifier, \
	struct FE_element_type_node_sequence_identifier *, \
	compare_FE_element_type_node_sequence_identifier)

int FE_element_type_node_sequence_is_collapsed(
	struct FE_element_type_node_sequence *element_type_node_sequence)
/*******************************************************************************
LAST MODIFIED : 13 February 2003

DESCRIPTION :
Returns true if the <element_type_node_sequence> represents an element that
has collapsed, ie, is a face with <= 2 unique nodes, or a line with 1 unique
node.
???RC Note that repeated nodes in the face/line are not put in the node_numbers
array twice, facilitating the simple logic in this function. If they were, then
this function would have to be modified extensively.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_type_node_sequence_is_collapsed);
	if (element_type_node_sequence&&element_type_node_sequence->identifier)
	{
		return_code=((CM_FACE == element_type_node_sequence->identifier->cm_type)&&
			(2 >= element_type_node_sequence->identifier->number_of_nodes))||
			((CM_LINE == element_type_node_sequence->identifier->cm_type)&&
				(1 == element_type_node_sequence->identifier->number_of_nodes));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_type_node_sequence_is_collapsed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_type_node_sequence_is_collapsed */

struct FE_element *FE_element_type_node_sequence_get_FE_element(
	struct FE_element_type_node_sequence *element_type_node_sequence)
/*******************************************************************************
LAST MODIFIED : 13 February 2003

DESCRIPTION :
Returns the FE_element from the <element_type_node_sequence>.
==============================================================================*/
{
	struct FE_element *element;

	ENTER(FE_element_type_node_sequence_get_FE_element);
	if (element_type_node_sequence)
	{
		element = element_type_node_sequence->element;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_type_node_sequence_get_FE_element.  Invalid argument(s)");
		element = (struct FE_element *)NULL;
	}
	LEAVE;

	return (element);
} /* FE_element_type_node_sequence_get_FE_element */

struct FE_element_type_node_sequence_identifier
	*FE_element_type_node_sequence_get_identifier(
		struct FE_element_type_node_sequence *element_type_node_sequence)
/*******************************************************************************
LAST MODIFIED : 13 February 2003

DESCRIPTION :
Returns a pointer to the identifier of the <element_type_node_sequence>.
==============================================================================*/
{
	struct FE_element_type_node_sequence_identifier *identifier;

	ENTER(FE_element_type_node_sequence_get_identifier);
	if (element_type_node_sequence)
	{
		identifier = element_type_node_sequence->identifier;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_type_node_sequence_get_identifier.  Invalid argument(s)");
		identifier = (struct FE_element_type_node_sequence_identifier *)NULL;
	}
	LEAVE;

	return (identifier);
} /* FE_element_type_node_sequence_get_identifier */

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_field,name,char *,strcmp)

DECLARE_CHANGE_LOG_MODULE_FUNCTIONS(FE_field)

static FE_value *tensor_product(int row_dimension_1,int column_dimension_1,
	FE_value *matrix_1,int row_dimension_2,int column_dimension_2,
	FE_value *matrix_2)
/*******************************************************************************
LAST MODIFIED : 17 June 1994

DESCRIPTION :
This function returns the tensor product (memory allocated within the function)
of <matrix_1> and <matrix_2>.  All matricies are assumed to be stored row-wise.
==============================================================================*/
{
	FE_value *product,*row_start_1,*row_start_2,*value,*value_1,*value_2;
	int i,j,k,l;

	ENTER(tensor_product);
	if ((row_dimension_1>0)&&(column_dimension_1>0)&&matrix_1&&
		(row_dimension_2>0)&&(column_dimension_2>0)&&matrix_2)
	{
		if (ALLOCATE(product,FE_value,
			row_dimension_1*column_dimension_1*row_dimension_2*column_dimension_2))
		{
			value=product;
			row_start_1=matrix_1;
			for (i=row_dimension_1;i>0;i--)
			{
				row_start_2=matrix_2;
				for (j=row_dimension_2;j>0;j--)
				{
					value_1=row_start_1;
					for (k=column_dimension_1;k>0;k--)
					{
						value_2=row_start_2;
						for (l=column_dimension_2;l>0;l--)
						{
							*value=(*value_2)*(*value_1);
							value++;
							value_2++;
						}
						value_1++;
					}
					row_start_2=value_2;
				}
				row_start_1=value_1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"tensor_product.  Could not allocate memory for product");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE, "tensor_product.  Invalid argument(s)");
		product=(FE_value *)NULL;
	}
	LEAVE;

	return (product);
} /* tensor_product */

static int sort_integers(const void *number_1_address, const void *number_2_address)
/*******************************************************************************
LAST MODIFIED : 10 May 2001

DESCRIPTION :
==============================================================================*/
{
	int number_1,number_2,return_code;

	ENTER(sort_integers);
	number_1= *((int *)number_1_address);
	number_2= *((int *)number_2_address);
	if (number_1<number_2)
	{
		return_code= -1;
	}
	else
	{
		if (number_1>number_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* sort_integers */

static int sort_basis_functions(const void *tuple_1_void,const void *tuple_2_void)
/*******************************************************************************
LAST MODIFIED : 13 May 2001

DESCRIPTION :
==============================================================================*/
{
	int i,number_of_xi_coordinates,return_code,*tuple_1,*tuple_2;

	ENTER(sort_basis_functions);
	tuple_1=(int *)tuple_1_void;
	tuple_2=(int *)tuple_2_void;
	number_of_xi_coordinates=tuple_1[1];
	i=number_of_xi_coordinates-1;
	tuple_1 += 2*number_of_xi_coordinates;
	tuple_2 += 2*number_of_xi_coordinates;
	while ((i>0)&&(*tuple_1== *tuple_2))
	{
		tuple_1 -= 2;
		tuple_2 -= 2;
	}
	if (*tuple_1< *tuple_2)
	{
		return_code= -1;
	}
	else
	{
		if (*tuple_1> *tuple_2)
		{
			return_code=1;
		}
		else
		{
			tuple_1=(int *)tuple_1_void;
			tuple_2=(int *)tuple_2_void;
			i=number_of_xi_coordinates-1;
			tuple_1 += 2*number_of_xi_coordinates+1;
			tuple_2 += 2*number_of_xi_coordinates+1;
			while ((i>0)&&(*tuple_1== *tuple_2))
			{
				tuple_1 -= 2;
				tuple_2 -= 2;
			}
			if (*tuple_1< *tuple_2)
			{
				return_code= -1;
			}
			else
			{
				if (*tuple_1> *tuple_2)
				{
					return_code=1;
				}
				else
				{
					return_code=0;
				}
			}
		}
	}
	LEAVE;

	return (return_code);
} /* sort_basis_functions */

static int monomial_basis_functions(void *type_arguments,
	FE_value *xi_coordinates,FE_value *function_values)
/*******************************************************************************
LAST MODIFIED : 29 January 1994

DESCRIPTION :
Calculates the monomial basis function values.  Expects the memory to already be
allocated for the <function_values>.  The first entry of the <type_arguments> is
the number of xi coordinates and the other entries are the orders of the
monomials for each xi coordinate.
NB.  xi_1 is varying slowest (xi_n fastest)
==============================================================================*/
{
	FE_value *temp_value,*value,xi,*xi_coordinate,xi_power;
	int *argument,i,j,k,order,number_of_values,number_of_xi_coordinates,
		return_code;

	ENTER(monomial_basis_functions);
	if ((argument=(int *)type_arguments)&&(xi_coordinate=xi_coordinates)&&
		function_values)
	{
		number_of_xi_coordinates= *argument;
		value=function_values;
		*value=1;
		number_of_values=1;
		for (i=number_of_xi_coordinates;i>0;i--)
		{
			xi= *xi_coordinate;
			xi_coordinate++;
			xi_power=xi;
			argument++;
			order= *argument;
			for (j=order;j>0;j--)
			{
				temp_value=function_values;
				for (k=number_of_values;k>0;k--)
				{
					value++;
					*value=(*temp_value)*xi_power;
					temp_value++;
				}
				xi_power *= xi;
			}
			number_of_values *= (order+1);
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"monomial_basis_functions.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* monomial_basis_functions */

static int polygon_basis_functions(void *type_arguments,
	FE_value *xi_coordinates,FE_value *function_values)
/*******************************************************************************
LAST MODIFIED : 23 November 2001

SCRIPTION :
For a polygon
a) xi1 is circumferential and xi2 is radial.
b) the nodal basis functions are
	phi0 = 1 - xi2,  centre node
				/ xi2 * (1 - n*xi1), 0<=n*xi1<1
	phi1 = | xi2 * (n*xi1 - (n-1)), n-1<n*xi1<n
				\ 0, otherwise
				/ xi2 * (i - n*xi1), i-1<=n*xi1<i
	phii = | xi2 * (n*xi1 - (i-2)), i-2<n*xi1<i-1 ,  1<i<=n
				\ 0, otherwise
	where n is the number of polygon verticies/sides.
c) the standard basis functions are
				/ 1, xi1=1
	s001 = | 1, 0<=n*xi1<1
				\ 0, otherwise
	s00i = / 1, i-1<=n*xi1<i ,  2<=i<=n
				\ 0, otherwise
	s10i = / n*xi1-i+1, i-1<=n*xi1<i ,  1<=i<=n
				\ 0, otherwise
	s01i = xi2 * s00i ,  1<=i<=n
	s11i = xi2 * s10i ,  1<=i<=n
???DB.  Should this be
				/ 0.5, xi1=0 or xi1=1 or n*xi1=1
	s001 = | 1, 0<n*xi1<1
				\ 0, otherwise
				/ 0.5, n*xi1=i-1 or n*xi1=i
	s00i = | 1, i-1<n*xi1<i           ,  2<=i<=n
				\ 0, otherwise
				/ 0.5, n*xi1=i
	s10i = | n*xi1-i+1, i-1<n*xi1<i ,  1<=i<=n
				\ 0, otherwise
	s01i = xi2 * s00i ,  1<=i<=n
	s11i = xi2 * s10i ,  1<=i<=n
	to get derivatives right (better) at vertices ?
d) the blending matrix is
	1 1 1 . . . 1 0 0 0 . . . 0 -1 -1 -1 . . . -1  0  0  0 . . .  0
	0 0 0 . . . 0 0 0 0 . . . 0  1  0  0 . . .  0 -1  0  0 . . .  1
	0 0 0 . . . 0 0 0 0 . . . 0  0  1  0 . . .  0  1 -1  0 . . .  0
	0 0 0 . . . 0 0 0 0 . . . 0  0  0  1 . . .  0  0  1 -1 . . .  0
	.             .              .              .              .
	.             .              .              .              .
	.             .              .              .              .
	0 0 0 . . . 0 0 0 0 . . . 0  0  0  0 . . .  1  0  0  0 . 0 1 -1
==============================================================================*/
{
	FE_value basis_function10, basis_function11, save_value, *temp_value, *value,
		xi, xi_circumferential, *xi_coordinate, xi_power, xi_radial;
	int *argument, i, j, k, number_of_polygon_verticies,
		number_of_values, number_of_xi_coordinates, offset00, offset01, offset10,
		offset11, order, polygon_offset, polygon_vertex, return_code;

	ENTER(polygon_basis_functions);
	if ((argument=(int *)type_arguments)&&(xi_coordinate=xi_coordinates)&&
		function_values)
	{
		number_of_xi_coordinates= *argument;
		value=function_values;
		*value=1;
		number_of_values=1;
		for (i=number_of_xi_coordinates;i>0;i--)
		{
			xi= *xi_coordinate;
			argument++;
			order= *argument;
			if (order<0)
			{
				/* polygon */
				order= -order;
				/* need to distinguish between first and second polygon coordinates */
				if (order%2)
				{
					/* first polygon coordinate */
					order /= 2;
					polygon_offset=order%number_of_xi_coordinates;
					order /= number_of_xi_coordinates;
					/* first polygon coordinate is circumferential */
					xi_circumferential=xi;
					/* second polygon coordinate is radial */
					xi_radial=xi_coordinate[polygon_offset];
					/* may be called with xi outside the element (eg. during streamline
						tracking).  Wrap the circumferential coordinate */
					xi_circumferential -= floor(xi_circumferential);
					number_of_polygon_verticies=(-argument[polygon_offset])/2;
					/*???DB.  Need to do higher order polygons */
					basis_function10=
						xi_circumferential*(FE_value)number_of_polygon_verticies;
					polygon_vertex=(int)(basis_function10);
					basis_function10 -= (FE_value)polygon_vertex;
					if (number_of_polygon_verticies==polygon_vertex)
					{
						polygon_vertex=0;
					}
					basis_function11=xi_radial*basis_function10;
					temp_value=function_values;
					offset00=polygon_vertex*number_of_values;
					offset11=number_of_polygon_verticies*number_of_values;
					offset10=offset00+offset11;
					offset01=offset10+offset11;
					offset11=offset01+offset11;
					for (j=number_of_values;j>0;j--)
					{
						save_value= *temp_value;
						temp_value[offset00]=save_value;
						temp_value[offset10]=basis_function10*save_value;
						temp_value[offset01]=xi_radial*save_value;
						temp_value[offset11]=basis_function11*save_value;
						temp_value++;
					}
					temp_value=function_values;
					offset10=number_of_polygon_verticies*number_of_values;
					offset01=2*offset10;
					offset11=3*offset10;
					for (j=offset00;j>0;j--)
					{
						*temp_value=0;
						temp_value[offset10]=0;
						temp_value[offset01]=0;
						temp_value[offset11]=0;
						temp_value++;
					}
					temp_value += number_of_values;
					for (j=(number_of_polygon_verticies-polygon_vertex-1)*
						number_of_values;j>0;j--)
					{
						*temp_value=0;
						temp_value[offset10]=0;
						temp_value[offset01]=0;
						temp_value[offset11]=0;
						temp_value++;
					}
					number_of_values *= 4*number_of_polygon_verticies;
					value=function_values+(number_of_values-1);
				}
			}
			else
			{
				/* not polygon */
				xi_power=xi;
				for (j=order;j>0;j--)
				{
					temp_value=function_values;
					for (k=number_of_values;k>0;k--)
					{
						value++;
						*value=(*temp_value)*xi_power;
						temp_value++;
					}
					xi_power *= xi;
				}
				number_of_values *= (order+1);
			}
			xi_coordinate++;
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"polygon_basis_functions.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* polygon_basis_functions */

static int count_nodal_values(struct FE_node_field *node_field,
	void *number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 12 April 1996

DESCRIPTION :
Increases the <number_of_nodal_values> by the number of values for <node_field>.
==============================================================================*/
{
	int i,*number_of_values,return_code;
	struct FE_node_field_component *component;

	ENTER(count_nodal_values);
	if (node_field&&(node_field->field)&&(component=node_field->components)&&
		(number_of_values=(int *)number_of_nodal_values))
	{
		i=node_field->field->number_of_components;
		while (i>0)
		{
			*number_of_values += (component->number_of_versions)*
				((component->number_of_derivatives)+1);
			component++;
			i--;
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"count_nodal_values.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* count_nodal_values */

static int count_nodal_size(struct FE_node_field *node_field,
	void *number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 26 October 1999

DESCRIPTION :
Increases the <number_of_nodal_values> by the number of values for <node_field>
times the size of <node_field->field->value_type> .
==============================================================================*/
{
	int i,*number_of_values,return_code,size,this_values_storage_size;
	struct FE_node_field_component *component;

	ENTER(count_nodal_values);
	if (node_field&&(node_field->field)&&(component=node_field->components)&&
		(number_of_values=(int *)number_of_nodal_values))
	{
		size=get_Value_storage_size(node_field->field->value_type,
			node_field->time_sequence);
		this_values_storage_size=0;
		for (i=node_field->field->number_of_components;0<i;i--)
		{
			this_values_storage_size += ((component->number_of_versions)*
				((component->number_of_derivatives)+1))*size;
			component++;
		}
		ADJUST_VALUE_STORAGE_SIZE(this_values_storage_size);
		*number_of_values += this_values_storage_size;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"count_nodal_size.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* count_nodal_size */

struct Merge_FE_node_field_into_list_data
{
	int requires_merged_storage;
	int values_storage_size; 
	int number_of_values;
	struct LIST(FE_node_field) *list;
}; /* struct Merge_FE_node_field_into_list_data */

static int merge_FE_node_field_into_list(struct FE_node_field *node_field,
	void *merge_FE_node_field_into_list_data)
/*******************************************************************************
LAST MODIFIED : 23 October 2002

DESCRIPTION :
Merges the <node_field> into the list.
If there is already a node_field for the field in <node_field>, checks the two
are compatible and adds any new times that may be in the new field.
If <node_field> introduces a new field to the list, it is added to the list
with value offset to the <value_size> which it subsequently increases to fit
the new data added for this node field. <number_of_values> is also increased
appropriately.
==============================================================================*/
{
	int i, j, new_values_storage_size, return_code, size, this_number_of_values;
	struct FE_field *field;
	struct FE_node_field *existing_node_field, *new_node_field;
	struct FE_node_field_component *component, *existing_component,
		*new_component;
	struct FE_time_sequence *merged_time_sequence;
	struct Merge_FE_node_field_into_list_data *merge_data;

	ENTER(merge_FE_node_field_into_list);
	if (node_field&&(field=node_field->field) &&
		(merge_data = (struct Merge_FE_node_field_into_list_data *)
		merge_FE_node_field_into_list_data))
	{
		/* check if the node field is in the list */
		if (existing_node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field, merge_data->list))
		{
			/* the node field is already in the list */
			/* check that the components agree */
			/*???DB.  Check names ? */
			if ((component = node_field->components) &&
				(existing_component = existing_node_field->components))
			{
				i = field->number_of_components;
				return_code = 1;
				while (return_code && (i > 0))
				{
					if ((component->number_of_derivatives ==
						existing_component->number_of_derivatives) &&
						(component->number_of_versions ==
							existing_component->number_of_versions))
					{
						component++;
						existing_component++;
						i--;
					}
					else
					{
						return_code = 0;
					}
				}
			}
			else
			{
				return_code = 0;
			}
			if (return_code)
			{
				/* if the new node_field is a time based node field merge it in */
				if (node_field->time_sequence)
				{
					if (existing_node_field->time_sequence)
					{
						/* Merging two time fields.  Make a node_field with the 
							 combined list */
						if (merged_time_sequence =
							FE_region_get_FE_time_sequence_merging_two_time_series(
								FE_field_get_FE_region(field), node_field->time_sequence,
								existing_node_field->time_sequence))
						{
							if (compare_FE_time_sequence(merged_time_sequence,
									existing_node_field->time_sequence))
							{
								/* Time sequences are different */
								merge_data->requires_merged_storage = 1;
								new_node_field = copy_create_FE_node_field_with_offset(
									existing_node_field, /*offset*/0);
								REACCESS(FE_time_sequence)(&(new_node_field->time_sequence),
									merged_time_sequence);
								if (REMOVE_OBJECT_FROM_LIST(FE_node_field)(
									existing_node_field, merge_data->list) &&
									ADD_OBJECT_TO_LIST(FE_node_field)(new_node_field,
									merge_data->list))
								{
									/* Finished */
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"merge_FE_node_field_into_list.  "
										"Unable to replace node_field in merged list.");
									return_code = 0;
								}
							}
							else
							{
								/* Can continue with the existing time_sequence */
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_node_field_into_list.  Unable to merge time arrays.");
							return_code = 0;
						}
					}
					else
					{
						/* Overwriting a single valued field with a time based
							 field, the values storage size will change, need to 
							 write the code */
						display_message(ERROR_MESSAGE,
							"merge_FE_node_field_into_list.  "
							"Need to write code to overwrite non time field with "
							"time based field");
						return_code = 0;
					}
				}
				else
				{
					if (existing_node_field->time_sequence)
					{
						/* Overwriting a time based field with a single valued
							 field, the values storage size will change, need to 
							 write the code */
						display_message(ERROR_MESSAGE,
							"merge_FE_node_field_into_list.  "
							"Need to write code to overwrite time field with "
							"non time based field");
						return_code = 0;
					}
				}
			}
		}
		else
		{
			/* the node field is not already in the list */
			/* create a new node field with modified offsets */
			merge_data->requires_merged_storage = 1;
			if ((component = node_field->components) &&
				(new_node_field = CREATE(FE_node_field)(field)))
			{
				FE_node_field_set_FE_time_sequence(new_node_field,
					node_field->time_sequence);
				size = get_Value_storage_size(field->value_type,
					node_field->time_sequence);
				new_component = new_node_field->components;
				i = field->number_of_components;
				return_code = 1;
				new_values_storage_size = 0;
				while (return_code && (i > 0))
				{
					new_component->value =
						merge_data->values_storage_size + new_values_storage_size;
					new_component->number_of_derivatives =
						component->number_of_derivatives;
					new_component->number_of_versions =
						component->number_of_versions;
					this_number_of_values = ((component->number_of_versions)*
						((component->number_of_derivatives) + 1));
					new_values_storage_size += this_number_of_values*size;
					merge_data->number_of_values += this_number_of_values;
					if (component->nodal_value_types)
					{
						/* assign nodal value names */
						if (ALLOCATE(new_component->nodal_value_types,
							enum FE_nodal_value_type,
							new_component->number_of_derivatives + 1))
						{
							for (j = new_component->number_of_derivatives; j >= 0; j--)
							{
								(new_component->nodal_value_types)[j] =
									(component->nodal_value_types)[j];
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_node_field_into_list.  "
								"Could not allocate memory for nodal value types");
						}
					}
					component++;
					new_component++;
					i--;
				}
				if (return_code)
				{
					ADJUST_VALUE_STORAGE_SIZE(new_values_storage_size);
					merge_data->values_storage_size += new_values_storage_size;
					/* add the new node field to the list */
					if (!ADD_OBJECT_TO_LIST(FE_node_field)(new_node_field,
						merge_data->list))
					{
						DESTROY(FE_node_field)(&new_node_field);
						return_code = 0;
					}
				}
				else
				{
					DESTROY(FE_node_field)(&new_node_field);
				}
			}
			else
			{
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_node_field_into_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_node_field_into_list */

#if !defined (WINDOWS_DEV_FLAG)
static int list_FE_node_field(struct FE_node_field *node_field,void *node_void)
/*******************************************************************************
LAST MODIFIED : 14 February 2008

DESCRIPTION :
Outputs the information contained by the node field.
==============================================================================*/
{
	char *component_name, *string_value, *type_string;
	enum FE_nodal_value_type *type;
	FE_value time;
	int i,version,k,number_of_components,number_of_times,number_of_versions,
		return_code,time_index,xi_dimension,xi_index;
	struct FE_element *embedding_element;
	struct FE_field *field;
	struct FE_node *node;
	struct FE_node_field_component *node_field_component;
	Value_storage *values_storage, *value;

	ENTER(list_FE_node_field);
	if (node_field&&(node=(struct FE_node *)node_void))
	{
		if ((field=node_field->field)&&node_field->components)
		{	 
			return_code=1;
			display_message(INFORMATION_MESSAGE,"  %s",field->name);
			if (type_string=ENUMERATOR_STRING(CM_field_type)(field->cm_field_type))
			{
				display_message(INFORMATION_MESSAGE,", %s",type_string);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"list_FE_node_field.  Invalid CM field type");
				return_code=0;
			}
			if (type_string=ENUMERATOR_STRING(Coordinate_system_type)(
				field->coordinate_system.type))
			{
				display_message(INFORMATION_MESSAGE,", %s",type_string);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"list_FE_node_field.  Invalid field coordinate system");
				return_code=0;
			}
			number_of_components=field->number_of_components;
			display_message(INFORMATION_MESSAGE,", #Components=%d\n",
				number_of_components);
			if (node_field->time_sequence)
			{
				number_of_times = FE_time_sequence_get_number_of_times(
					node_field->time_sequence);
			}
			else
			{
				number_of_times = 1;
			}
			for (time_index = 0 ; return_code && (time_index < number_of_times) ;
				  time_index++)
			{
				if (node_field->time_sequence)
				{
					FE_time_sequence_get_time_for_index(node_field->time_sequence,
						time_index, &time);
					display_message(INFORMATION_MESSAGE,"   Time: %g\n", time);
				}
				i=0;
				node_field_component = node_field->components;
				while (return_code&&(i<number_of_components))
				{
					if (component_name=get_FE_field_component_name(field,i))
					{
						display_message(INFORMATION_MESSAGE,"    %s",component_name);
						DEALLOCATE(component_name);
					}
					number_of_versions=node_field_component->number_of_versions;
					if (1<number_of_versions)
					{
						display_message(INFORMATION_MESSAGE,", #Versions=%d",
							number_of_versions);
					}
					display_message(INFORMATION_MESSAGE,".  ");
					/* display field based information */
					if (field->number_of_values)
					{	
						int count;

						display_message(INFORMATION_MESSAGE,"field based values: ");
						switch (field->value_type)
						{
							case FE_VALUE_VALUE:
							{
								display_message(INFORMATION_MESSAGE,"\n");
								display_message(INFORMATION_MESSAGE,"    "); 
								/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
								for (count=0;count<field->number_of_values;count++)
								{	
									display_message(INFORMATION_MESSAGE," %" FE_VALUE_STRING,
										*((FE_value *)(field->values_storage+
											  count*sizeof(FE_value))));
									if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
										(0==((count+1)%DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
									{
										display_message(INFORMATION_MESSAGE,"\n");
									}											
								}	
								display_message(INFORMATION_MESSAGE,"\n");
							} break;
							case STRING_VALUE:
							{
								display_message(INFORMATION_MESSAGE, "\n");
								display_message(INFORMATION_MESSAGE, "    ");
								for (count = 0; count < field->number_of_values; count++)
								{
									if (get_FE_field_string_value(field, count, &string_value))
									{
										make_valid_token(&string_value);
										display_message(INFORMATION_MESSAGE, " %s", string_value);
										DEALLOCATE(string_value);
									}
								}	
								display_message(INFORMATION_MESSAGE, "\n");
							} break;
							default:
							{
								display_message(INFORMATION_MESSAGE, "list_FE_node_field.  "
									"Can't display that field value_type yet.  Write the code!");
							} break;
						}
					}
					/* display node based information*/
					if ((values_storage=node->values_storage)&&(type=node_field_component->
							 nodal_value_types))
					{					
						values_storage += node_field_component->value;
						version=0;
						while (return_code&&(version<number_of_versions))
						{
							if (1<number_of_versions)
							{
								display_message(INFORMATION_MESSAGE,"\n      Version %d.  ",version+1);
								type=node_field_component->nodal_value_types;
							}
							k=1+(node_field_component->number_of_derivatives);
							while (return_code&&(k>0))
							{
								display_message(INFORMATION_MESSAGE,"%s=",
									ENUMERATOR_STRING(FE_nodal_value_type)(*type));
#if defined (NEW_CODE)
								/*???JW.ot sure how we're going to display these yet */
								/* display field time information*/
								if (field->number_of_times)
								{
									int count;

									display_message(INFORMATION_MESSAGE,"times: ");							
									switch (field->time_value_type)
									{
										case FE_VALUE_VALUE:
										{
											display_message(INFORMATION_MESSAGE,"\n");
											/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
											for (count=0;count<field->number_of_times;count++)
											{
												display_message(INFORMATION_MESSAGE," %"FE_VALUE_STRING,
													*((FE_value*)(field->times + count*sizeof(FE_value)) ));
												if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
													(0==((count+1) % DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
												{
													display_message(INFORMATION_MESSAGE,"\n");
												}											
											}																							
										} break;
										default:
										{
											display_message(INFORMATION_MESSAGE,"list_FE_node_field.  "
												"Can't display that time_value_type yet.  "
												"Write the code!");
										} break;
									}
								}
#endif /* defined (NEW_CODE) */				
								/* display node based field information */
								if (field->number_of_times)
								{
									/* for the moment don't display the (generally massive) time
										based */
									/* field information */
									display_message(INFORMATION_MESSAGE," Time based field ");
								}
								else
								{							
									if (node_field->time_sequence)
									{
										switch (field->value_type)
										{
											case FE_VALUE_VALUE:
											{
												display_message(INFORMATION_MESSAGE,"%g",
													*(*((FE_value**)values_storage) + time_index));
											} break;
											case INT_VALUE:
											{
												display_message(INFORMATION_MESSAGE,"%d",
													*(*((int **)values_storage) + time_index));
											} break;	
											default:
											{
												display_message(INFORMATION_MESSAGE,"list_FE_node_field: "
													"Can't display times for this value type");
											} break;
										}/* switch*/
									}
									else /* (node_field->time_sequence) */
									{
										switch (field->value_type)
										{
											case FE_VALUE_VALUE:
											{
												display_message(INFORMATION_MESSAGE,"%g",
													*((FE_value*)values_storage));
											} break;
											case ELEMENT_XI_VALUE:
											{
												embedding_element = *((struct FE_element **)values_storage);
												if (embedding_element)
												{
													display_message(INFORMATION_MESSAGE,"%s %d xi",
															CM_element_type_string(embedding_element->cm.type),
															embedding_element->cm.number);
													xi_dimension=embedding_element->shape->dimension;
													value=values_storage+sizeof(struct FE_element *);
													for (xi_index=0;xi_index<xi_dimension;xi_index++)
													{
														display_message(INFORMATION_MESSAGE," %g",
															*((FE_value *)value));
														value += sizeof(FE_value);
													}
												}
												else
												{
													display_message(INFORMATION_MESSAGE,"UNDEFINED");
												}
											} break;	
											case INT_VALUE:
											{
												display_message(INFORMATION_MESSAGE,"%d",
													*((int *)values_storage));
											} break;	
											case STRING_VALUE:
											{
												char *name;

												if (get_FE_nodal_string_value(node,field,
														 /*component_number*/i,version,*type,&name))
												{
													display_message(INFORMATION_MESSAGE,name);
													DEALLOCATE(name);
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"list_FE_node_field.  Could not get string value");
													return_code=0;
												}
											} break;
#if defined (UNEMAP_USE_NODES)
											case DOUBLE_ARRAY_VALUE:
											{
												double *array;
												int number_of_values,count;
									
												number_of_values=get_FE_nodal_array_number_of_elements(node,
													field,/*component_number*/i,version,*type);
												if (number_of_values>0)
												{									
													if (ALLOCATE(array,double,number_of_values))
													{
														get_FE_nodal_double_array_value(node,field,
															/*component_number*/i,version,
															*type,array,number_of_values);
														display_message(INFORMATION_MESSAGE,"\n");
														/* output in columns if
															DOUBLE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
														for (count=0;count<number_of_values;count++)
														{
															display_message(INFORMATION_MESSAGE," %"
																DOUBLE_VALUE_STRING,array[count]);
															if ((0<DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)&&
																(0==((count+1)%DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
															{
																display_message(INFORMATION_MESSAGE,"\n");
															}											
														}										
														DEALLOCATE(array);
													}
													else
													{
														display_message(ERROR_MESSAGE,"list_FE_node_field."
															"  Could not allocate double array");
														return_code =0;
													}	
												}
												else
												{
													/* this is NOT an error */
													display_message(INFORMATION_MESSAGE,"array length 0");
												}
											} break;	
											case FE_VALUE_ARRAY_VALUE:
											{
												FE_value *array;
												int number_of_values,count;
									
												number_of_values=get_FE_nodal_array_number_of_elements(node,
													field,/*component_number*/i,version,*type);
												if (number_of_values>0)
												{																			
													if (ALLOCATE(array,FE_value,number_of_values))
													{
														get_FE_nodal_FE_value_array(node,field,
															/*component_number*/i,version,
															*type,array,number_of_values);	
														display_message(INFORMATION_MESSAGE,"\n");
														/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS>0 */
														for (count=0;count<number_of_values;count++)
														{
															display_message(INFORMATION_MESSAGE," %"
																FE_VALUE_STRING,array[count]);
															if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
																(0==((count+1) % FE_VALUE_MAX_OUTPUT_COLUMNS)))
															{
																display_message(INFORMATION_MESSAGE,"\n");
															}											
														}									
														DEALLOCATE(array);
													}
													else
													{
														display_message(ERROR_MESSAGE,"list_FE_node_field."
															"  Could not allocate FE_value array");
														return_code=0;
													}
												}
												else
												{
													/* this is NOT an error */
													display_message(INFORMATION_MESSAGE,"array length 0");
												}										
											} break;	
											case SHORT_ARRAY_VALUE:
											{
												short *array;
												int number_of_values,count;									

												number_of_values=get_FE_nodal_array_number_of_elements(node,
													field,/*component_number*/i,version,*type);
												if (number_of_values>0)
												{								
													if (ALLOCATE(array,short,number_of_values))
													{
														get_FE_nodal_short_array(node,field,
															/*component_number*/i,version,
															*type,array,number_of_values);
														display_message(INFORMATION_MESSAGE,"\n");
														/* output in columns if
															SHORT_VALUE_MAX_OUTPUT_COLUMNS > 0 */
														for (count=0;count<number_of_values;count++)
														{
															display_message(INFORMATION_MESSAGE," %4d",
																array[count]);
															if ((0<SHORT_VALUE_MAX_OUTPUT_COLUMNS)&&
																(0==((count+1) % SHORT_VALUE_MAX_OUTPUT_COLUMNS)))
															{
																display_message(INFORMATION_MESSAGE,"\n");
															}											
														}										
														DEALLOCATE(array);
													}
													else
													{
														display_message(ERROR_MESSAGE,"list_FE_node_field."
															"  Could not allocate short array");
														return_code=0;
													}
												}																		
												else
												{
													/* this is NOT an error */
													display_message(INFORMATION_MESSAGE,"array length 0");
												}
											} break;									
#endif /* defined (UNEMAP_USE_NODES) */
											default:
											{
												display_message(INFORMATION_MESSAGE,"list_FE_node_field: "
													"Can't display that Value_type yet. Write the code!");
											} break;
										}/* switch*/
									} /* (node_field->time_sequence) */
								} /* if (field->number_of_times) */
								values_storage += get_Value_storage_size(field->value_type,
									node_field->time_sequence); 
								type++;
								k--;
								if (k>0)
								{
									display_message(INFORMATION_MESSAGE,", ");
								}
							}
							version++;
						} /* while (return_code&&(version<number_of_versions)) */
						display_message(INFORMATION_MESSAGE,"\n");
					}
					else
					{
						/* missing nodal values only an error if no field based values
							either */
						if (!(field->number_of_values))
						{
							display_message(ERROR_MESSAGE,
								"list_FE_node_field.  Missing nodal values");
							return_code=0;
						}
					}
					node_field_component++;
					i++;
				}
			} /* time_index */
		}
		else
		{
			display_message(ERROR_MESSAGE,"list_FE_node_field.  Missing field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_node_field.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_node_field */
#endif /* !defined (WINDOWS_DEV_FLAG) */

struct Match_FE_element_shape_data
{
	int dimension;
	int *type;
}; /* struct Match_FE_element_shape_data */

static int match_FE_element_shape(struct FE_element_shape *shape,
	void *match_FE_element_shape_data)
/*******************************************************************************
LAST MODIFIED : 30 April 2003

DESCRIPTION :
Checks if the <match_FE_element_shape_data> matchs the <shape>.
Note a NULL shape type means an unspecified shape of that dimension.
==============================================================================*/
{
	int *find_type, i, return_code, *shape_type;
	struct Match_FE_element_shape_data *match_data;

	ENTER(match_FE_element_shape);
	if (shape && (match_data =
		(struct Match_FE_element_shape_data *)match_FE_element_shape_data))
	{
		if (match_data->dimension == shape->dimension)
		{
			find_type = match_data->type;
			shape_type = shape->type;
			if (find_type && shape_type)
			{
				i = (match_data->dimension)*((match_data->dimension)+1)/2;
				while ((i>0)&&(*find_type== *shape_type))
				{
					find_type++;
					shape_type++;
					i--;
				}
				if (i>0)
				{
					return_code=0;
				}
				else
				{
					return_code=1;
				}
			}
			else if ((!find_type) && (!shape_type))
			{
				/* no type array: unspecified shape */
				return_code = 1;
			}
			else
			{
				return_code = 0;
			}
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"match_FE_element_shape.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* match_FE_element_shape */

static struct FE_element_shape *find_FE_element_shape_in_list(int dimension,
	int *type,struct LIST(FE_element_shape) *list)
/*******************************************************************************
LAST MODIFIED : 18 November 2002

DESCRIPTION :
Searchs the <list> for the element shape with the specified <dimension> and
<type> and returns the address of the element_shape.
A NULL <type> means an unspecified shape of <dimension>.
==============================================================================*/
{
	struct Match_FE_element_shape_data match_data;
	struct FE_element_shape *shape;

	ENTER(find_FE_element_shape_in_list);
	if ((dimension > 0) && list)
	{
		match_data.dimension = dimension;
		match_data.type = type;
		shape = FIRST_OBJECT_IN_LIST_THAT(FE_element_shape)(match_FE_element_shape,
			(void *)(&match_data),list);
	}
	else
	{
		shape = (struct FE_element_shape *)NULL;
	}
	LEAVE;

	return (shape);
} /* find_FE_element_shape_in_list */

static int compare_FE_element_parent_parent(struct FE_element *parent_1,
	struct FE_element *parent_2)
/*******************************************************************************
LAST MODIFIED : 30 July 1995

DESCRIPTION :
Returns -1 if parent_1 < parent_2, 0 if parent_1 = parent_2 and 1 if
parent_1 > parent_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_FE_element_parent_parent);
	if (parent_1<parent_2)
	{
		return_code= -1;
	}
	else
	{
		if (parent_1>parent_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* compare_FE_element_parent_parent */

static int compare_FE_element_parent_face_number(int face_number_1,
	int face_number_2)
/*******************************************************************************
LAST MODIFIED : 30 July 1995

DESCRIPTION :
Returns -1 if face_number_1 < face_number_2, 0 if face_number_1 = face_number_2
and 1 if face_number_1 > face_number_2.
==============================================================================*/
{
	int return_code;

	ENTER(compare_FE_element_parent_face_number);
	if (face_number_1<face_number_2)
	{
		return_code= -1;
	}
	else
	{
		if (face_number_1>face_number_2)
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	LEAVE;

	return (return_code);
} /* compare_FE_element_parent_face_number */

#if !defined (WINDOWS_DEV_FLAG)
static int list_FE_element_parent(struct FE_element_parent *element_parent,
	void *void_line)
/*******************************************************************************
LAST MODIFIED : 15 February 1999

DESCRIPTION :
Outputs the information contained at the element.
==============================================================================*/
{
	char *line;
	int return_code;
	struct FE_element *parent;

	ENTER(list_FE_element_parent);
	if (element_parent&&(parent=element_parent->parent)&&(line=(char *)void_line))
	{
		sprintf(line+strlen(line)," (%d)",
			parent->cm.number);
		if (70<=strlen(line))
		{
			display_message(INFORMATION_MESSAGE,line);
			display_message(INFORMATION_MESSAGE,"\n");
			*line='\0';
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"list_FE_element_parent.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element_parent */
#endif /* !defined (WINDOWS_DEV_FLAG) */

DECLARE_LOCAL_MANAGER_FUNCTIONS(FE_basis)

static int global_to_element_map_values(struct FE_element *element,
	struct FE_element_field *element_field, FE_value time, int component_number,
	int *number_of_values,FE_value **values)
/*******************************************************************************
LAST MODIFIED : 3 December 2001

DESCRIPTION :
The standard function for calculating the <element> <values> for the given
<component_number> of <element_field>. Calculates the <number_of_values> and
the <values> for the component.  The storage for the <values> is allocated by
the function.
???RC Changed to use relative offsets into nodal values array in standard and
general node to element maps. Absolute offset for start of field component is
obtained from the node_field_component for the field at the node.
==============================================================================*/
{
	FE_value *array,*blended_element_value,*blended_element_values,
		*blending_matrix,*element_value,*element_values,
		*scale_factors,temp_value,xi;
	int *coefficient_index,*global_value_index,i,j,k,l,
		number_of_blended_element_values,number_of_element_nodes,
		number_of_element_values,number_of_global_values,number_of_map_values,
		number_of_scale_factors,return_code,*scale_factor_index,scale_index,
		time_index_one, time_index_two, value_index;
	short *short_array;
	struct FE_basis *basis;
	struct FE_element_field_component *component;
	struct FE_field *field;
	struct FE_node *node,**nodes;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct FE_node_field_info *node_field_info;
	struct FE_time_sequence *time_sequence;
	struct General_node_to_element_map *general_node_map,
		**general_node_map_address;
	struct Linear_combination_of_global_values *linear_combination,
		**linear_combination_address;
	struct Standard_node_to_element_map *standard_node_map,
		**standard_node_map_address;
#if defined (DOUBLE_FOR_DOT_PRODUCT)
	double sum;
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
	FE_value sum;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
	void *global_values;

	ENTER(global_to_element_map_values);
/*???debug */
/*printf("enter global_to_element_map_values\n");*/
	/* check the arguments */
	if (element&&element_field&&(field=element_field->field)&&number_of_values&&
		values&&(0<=component_number)&&
		(component_number<field->number_of_components)&&
		(component=element_field->components[component_number]))
	{
		/* retrieve the element values */
		switch (component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
				/* global values are associated with nodes */
			{
				/* check information */
				/*???RC 18 Nov 1999 allowed having no scale factors */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->number_of_nodes)>0)&&
					((0==(number_of_scale_factors=
						  element->information->number_of_scale_factors))||
						((0<number_of_scale_factors)&&
							(scale_factors=element->information->scale_factors))))
				{
					/* calculate the number of element values by summing the numbers of
						values retrieved from each node */
					number_of_element_values=0;
					standard_node_map_address=
						component->map.standard_node_based.node_to_element_maps;
					j=component->map.standard_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((standard_node_map= *standard_node_map_address)&&
							((number_of_map_values=
								standard_node_map->number_of_nodal_values)>0)&&
							(0<=standard_node_map->node_index)&&
							(standard_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[standard_node_map->node_index])&&
							(node->values_storage)&&(node->fields)&&
							(standard_node_map->nodal_value_indices)&&
							(standard_node_map->scale_factor_indices))
						{
							number_of_element_values += number_of_map_values;
							standard_node_map_address++;
							j--;
						}
						else
						{
							return_code = 0;
							display_message(ERROR_MESSAGE,"global_to_element_map_values.  "
								"Invalid standard node to element map");
							if (standard_node_map)
							{
								if (number_of_map_values>0)
								{
									if ((0<=standard_node_map->node_index)&&
										(standard_node_map->node_index<number_of_element_nodes))
									{
										if (node)
										{
											if (node->values_storage)
											{
											}
											else
											{
												display_message(ERROR_MESSAGE,"global_to_element_map_values.  "
													"Node %d used in element %d has no fields defined.",
													node->cm_node_identifier, element->cm.number);
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,"global_to_element_map_values.  "
												"Node reference missing for element %d.",
												element->cm.number);
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,"global_to_element_map_values.  "
											"Node element map specifies a node index out of range for element %d.",
											element->cm.number);
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,"global_to_element_map_values.  "
										"No map values for element %d.",
										element->cm.number);
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,"global_to_element_map_values.  "
									"No standard node map for element %d.",
									element->cm.number);
							}
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&
							(ALLOCATE(element_values,FE_value,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							standard_node_map_address=
								component->map.standard_node_based.node_to_element_maps;
							j=component->map.standard_node_based.number_of_nodes;
							/* Need node_field_component to get absolute offset into nodal
								values array. Also store node_field_info so we don't have to
								get node_field_component each time if it is not changing */
							node_field_info=(struct FE_node_field_info *)NULL;
							node_field_component=(struct FE_node_field_component *)NULL;
							time_sequence = (struct FE_time_sequence *)NULL;
							while (return_code&&(j>0))
							{
								/* retrieve the scaled nodal values */
								standard_node_map= *standard_node_map_address;
								node=nodes[standard_node_map->node_index];
#if defined (OLD_CODE)
								global_values=node->values;
#endif /* defined (OLD_CODE) */
								number_of_global_values=node->fields->number_of_values;
								global_value_index=standard_node_map->nodal_value_indices;
								scale_factor_index=standard_node_map->scale_factor_indices;
								/* get node_field_component for absolute offsets into nodes */
								if (node_field_info != node->fields)
								{
									if (node->fields&&(node_field=FIND_BY_IDENTIFIER_IN_LIST(
										FE_node_field,field)(field,node->fields->node_field_list))&&
										node_field->components)
									{
										node_field_component=
											node_field->components + component_number;
										
										node_field_info=node->fields;
										time_sequence = node_field->time_sequence;
										if (time_sequence)
										{
											FE_time_sequence_get_interpolation_for_time(
												time_sequence, time, &time_index_one, &time_index_two,
												&xi);
										}
									}
									else
									{
										/* field not defined at this node */
										node_field_component=(struct FE_node_field_component *)NULL;
									}
								}
								if (node_field_component)
								{
									/* add absolute value offset from node_field_component and
										cast address into FE_value type */
									global_values=
										node->values_storage+node_field_component->value;
									k=standard_node_map->number_of_nodal_values;
									while (k>0)
									{
										/* if there is not a nodal value use 0 */
										if ((0<=(value_index= *global_value_index))&&
											(value_index<number_of_global_values))
										{
											switch (field->value_type)
											{
												case FE_VALUE_VALUE:
												{
													if (time_sequence)
													{
														array = *(((FE_value **)global_values+value_index));
														/* if there is not a scale factor use 1 as the scale
															factor */
														if ((0<=(scale_index= *scale_factor_index))&&
															(scale_index<number_of_scale_factors))
														{
															*element_value=((1.0 - xi)*array[time_index_one]
																+xi*array[time_index_two])*
																scale_factors[scale_index];
														}
														else
														{
															*element_value=((1.0 - xi)*array[time_index_one]
																+xi*array[time_index_two]);
														}												
													}
													else
													{
														/* if there is not a scale factor use 1 as the scale
															factor */
														if ((0<=(scale_index= *scale_factor_index))&&
															(scale_index<number_of_scale_factors))
														{
															*element_value=((FE_value *)global_values)[value_index]*
																scale_factors[scale_index];
														}
														else
														{
															*element_value=((FE_value *)global_values)[value_index];
														}
													}
												} break;
												case SHORT_VALUE:
												{
													if (time_sequence)
													{
														short_array = *(((short **)global_values+value_index));
														/* if there is not a scale factor use 1 as the scale
															factor */
														if ((0<=(scale_index= *scale_factor_index))&&
															(scale_index<number_of_scale_factors))
														{
															*element_value=((1.0 - xi)*(FE_value)short_array[time_index_one]
																+xi*(FE_value)short_array[time_index_two])*
																scale_factors[scale_index];
														}
														else
														{
															*element_value=((1.0 - xi)*(FE_value)short_array[time_index_one]
																+xi*(FE_value)short_array[time_index_two]);
														}												
													}
													else
													{
														/* if there is not a scale factor use 1 as the scale
															factor */
														if ((0<=(scale_index= *scale_factor_index))&&
															(scale_index<number_of_scale_factors))
														{
															*element_value=(FE_value)(((short *)global_values)[value_index])*
																scale_factors[scale_index];
														}
														else
														{
															*element_value=(FE_value)(((short *)global_values)[value_index]);
														}
													}
												} break;
												default:
												{
													display_message(ERROR_MESSAGE,
														"global_to_element_map_values.  "
														"Unsupported value type %s in finite_element field",
														Value_type_string(field->value_type));
													return_code=0;
												}
											}
										
										}
										else
										{
											*element_value=0;
										}
										element_value++;
										global_value_index++;
										scale_factor_index++;
										k--;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"global_to_element_map_values.  Cannot evaluate field %s "
										"in element %d because it is not defined at node %d",
										field->name,element->cm.number,node->cm_node_identifier);
									return_code=0;
								}
								standard_node_map_address++;
								j--;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"global_to_element_map_values.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Missing element information");
					return_code=0;
				}
			} break;
			case GENERAL_NODE_TO_ELEMENT_MAP:
				/* global values are associated with nodes */
			{
				/* check information */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->number_of_nodes)>0)&&
					(scale_factors=element->information->scale_factors)&&
					((number_of_scale_factors=element->information->
						number_of_scale_factors)>0))
				{
					/* calculate the number of element values by summing the numbers of
						values retrieved from each node */
					number_of_element_values=0;
					general_node_map_address=
						component->map.general_node_based.node_to_element_maps;
					j=component->map.general_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((general_node_map= *general_node_map_address)&&
							((number_of_map_values=
								general_node_map->number_of_nodal_values)>0)&&
							(0<=general_node_map->node_index)&&
							(general_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[general_node_map->node_index])&&
							(node->values_storage)&&(node->fields)&&
							(general_node_map->element_values))
						{
							number_of_element_values += number_of_map_values;
							general_node_map_address++;
							j--;
						}
						else
						{
							display_message(ERROR_MESSAGE,"global_to_element_map_values.  "
								"Invalid general node to element map");
							return_code=0;
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&
							(ALLOCATE(element_values,FE_value,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							general_node_map_address=
								component->map.general_node_based.node_to_element_maps;
							j=component->map.general_node_based.number_of_nodes;
							/* Need node_field_component to get absolute offset into nodal
								values array. Also store node_field_info so we don't have to
								get node_field_component each time if it is not changing */
							node_field_info=(struct FE_node_field_info *)NULL;
							node_field_component=(struct FE_node_field_component *)NULL;
							while (return_code&&(j>0))
							{
								/* retrieve the scaled nodal values */
								general_node_map= *general_node_map_address;
								node=nodes[general_node_map->node_index];
#if defined (OLD_CODE)
								global_values=node->values;
#endif /* defined (OLD_CODE) */
								number_of_global_values=node->fields->number_of_values;
								linear_combination_address=general_node_map->element_values;
								/* get node_field_component for absolute offsets into nodes */
								if (node_field_info != node->fields)
								{
									if (node->fields&&(node_field=FIND_BY_IDENTIFIER_IN_LIST(
																 FE_node_field,field)(field,node->fields->node_field_list))&&
										node_field->components)
									{
										node_field_component=
											node_field->components + component_number;
									}
									node_field_info=node->fields;
								}
								if (node_field_component)
								{
									/* add absolute value offset from node_field_component and
										cast address into FE_value type */
									global_values=(node->values_storage+
										node_field_component->value);
									k=general_node_map->number_of_nodal_values;
									while (return_code&&(k>0))
									{
										sum=0;
										if ((linear_combination= *linear_combination_address)&&
											((l=linear_combination->number_of_global_values)>0)&&
											(global_value_index=
												linear_combination->global_value_indices)&&
											(coefficient_index=
												linear_combination->coefficient_indices))
										{
											while (return_code&&(l>0))
											{
												/* if there is not a global value use 0 */
												if ((0<=(value_index= *global_value_index))&&
													(value_index<number_of_global_values))
												{
													/* if there is not a coefficient use 1 as the
														coefficient */
													if ((0<=(scale_index= *coefficient_index))&&
														(scale_index<number_of_scale_factors))
													{
														/* ???RC Change to relative. */
#if defined (DOUBLE_FOR_DOT_PRODUCT)
														sum += (double)(((FE_value *)global_values)[value_index])*
															(double)(scale_factors[scale_index]);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
														sum += ((FE_value *)global_values)[value_index]*
															scale_factors[scale_index];
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
													}
													else
													{
														/* ???RC Change to relative. */
#if defined (DOUBLE_FOR_DOT_PRODUCT)
														sum += (double)((FE_value *)global_values)[value_index];
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
														sum += ((FE_value *)global_values)[value_index];
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
													}
												}
												global_value_index++;
												coefficient_index++;
												l--;
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"global_to_element_map_values.  Missing linear combination");
											DEALLOCATE(element_values);
											return_code=0;
										}
										*element_value=(FE_value)sum;
										element_value++;
										k--;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"global_to_element_map_values.  Invalid node field component");
									return_code=0;
								}
								general_node_map_address++;
								j--;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"global_to_element_map_values.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Missing element information");
					return_code=0;
				}
			} break;
			case FIELD_TO_ELEMENT_MAP:
				/* global values are associated with the field */
			{
				/* check information */
				if ((element->information)&&
					(scale_factors=element->information->scale_factors)&&
					((number_of_scale_factors=element->information->
						number_of_scale_factors)>0)&&					 						
					(field->value_type==FE_VALUE_VALUE)&&
					((number_of_global_values=field->number_of_values)>0))
				{
					/* allocate storage for storing the element values */
					if ((linear_combination_address=component->map.field_based.
							 element_values)&&((number_of_element_values=
														 component->map.field_based.number_of_element_values)>0)&&
						(ALLOCATE(element_values,FE_value,number_of_element_values)))
					{
						element_value=element_values;
						/* calculate each element value as a linear combination of global
							values */
						j=number_of_element_values;
						return_code=1;
						while (return_code&&(j>0))
						{
							sum=0;
							if ((linear_combination= *linear_combination_address)&&
								((k=linear_combination->number_of_global_values)>0)&&
								(global_value_index=linear_combination->global_value_indices)&&
								(coefficient_index=linear_combination->coefficient_indices))
							{
								while (return_code&&(k>0))
								{
									/* if there is not a global value use 0 */
									if ((0<=(value_index= *global_value_index))&&
										(value_index<number_of_global_values))
									{
										get_FE_field_FE_value_value(field,value_index,&temp_value);
										/* if there is not a coefficient use 1 as the coefficient */
										if ((0<=(scale_index= *coefficient_index))&&
											(scale_index<number_of_scale_factors))
										{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
											sum += (double)(temp_value)*
												(double)(scale_factors[scale_index]);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
											sum += temp_value*scale_factors[scale_index];
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
										}
										else
										{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
											sum += (double)temp_value;
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
											sum += temp_value;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
										}
									}
									global_value_index++;
									coefficient_index++;
									k--;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"global_to_element_map_values.  Missing linear combination");
								DEALLOCATE(element_values);
								return_code=0;
							}
							*element_value=(FE_value)sum;
							element_value++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"global_to_element_map_values.  Could not allocate memory for values");
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Missing element/field information");
					return_code=0;
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"global_to_element_map_values.  Invalid map type");
				return_code=0;
			} break;
		}
		if (return_code)
		{
			/* if necessary, modify the calculated element values */
			if (component->modify)
			{
/*???debug */
/*printf("Element %d %d %d\n",element->cmiss.element_number,
	element->cmiss.face_number,element->cmiss.line_number);
printf("unmodified values :");
for (i=0;i<number_of_element_values;i++)
{
	printf(" %g",element_values[i]);
}
printf("\n");*/
				return_code=(component->modify)(component,element,field,
					time,number_of_element_values,element_values);
/*???debug */
/*printf("modified values :");
for (i=0;i<number_of_element_values;i++)
{
	printf(" %g",element_values[i]);
}
printf("\n");*/
			}
			if (return_code)
			{
				/* check that there is a valid basis */
				if ((basis=component->basis)&&
					(number_of_element_values==basis->number_of_basis_functions)&&
					(basis->standard_basis)&&((number_of_blended_element_values=
					basis->number_of_standard_basis_functions)>0))
				{
					/* if there is a blending matrix then the element values are the
						product of the element values and the blending matrix */
					if (blending_matrix=basis->blending_matrix)
					{
						/* allocate storage for the blended element values */
						if (ALLOCATE(blended_element_values,FE_value,
							number_of_blended_element_values))
						{
							/* calculate the blended element values */
							blended_element_value=blended_element_values;
							for (i=0;i<number_of_blended_element_values;i++)
							{
								sum=0;
								element_value=element_values;
								blending_matrix=(basis->blending_matrix)+i;
								for (j=number_of_element_values;j>0;j--)
								{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
									sum += (double)(*blending_matrix)*(double)(*element_value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									sum += (*blending_matrix)*(*element_value);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									element_value++;
									blending_matrix += number_of_blended_element_values;
								}
								*blended_element_value=(FE_value)sum;
								blended_element_value++;
							}
							*values=blended_element_values;
							*number_of_values=number_of_blended_element_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
"global_to_element_map_values.  Could not allocate memory for blended values");
							return_code=0;
						}
						DEALLOCATE(element_values);
#if defined (OLD_CODE)
#if defined (DOUBLE_FOR_DOT_PRODUCT)
						double *blended_element_value_double,*blended_element_values_double,
							blending_double,element_double;

						/* allocate storage for the blended element values */
						if (ALLOCATE(blended_element_values_double,double,
							number_of_blended_element_values))
						{
							/* calculate the blended element values */
							blended_element_value_double=blended_element_values_double;
							for (i=number_of_blended_element_values;i>0;i--)
							{
								*blended_element_value_double=0;
								blended_element_value_double++;
							}
							element_value=element_values;
							for (j=number_of_element_values;j>0;j--)
							{
								element_double=(double)(*element_value);
								blended_element_value_double=blended_element_values_double;
								for (i=number_of_blended_element_values;i>0;i--)
								{
									blending_double=(double)(*blending_matrix);
									*blended_element_value_double +=
										blending_double*element_double;
									blended_element_value_double++;
									blending_matrix++;
								}
								element_value++;
							}
							if (REALLOCATE(element_value,element_values,FE_value,
								number_of_blended_element_values))
							{
								element_values=element_value;
								blended_element_value_double=blended_element_values_double;
								for (i=number_of_blended_element_values;i>0;i--)
								{
									*element_value=(float)(*blended_element_value_double);
									element_value++;
									blended_element_value_double++;
								}
								*values=element_values;
								*number_of_values=number_of_blended_element_values;
							}
							else
							{
								display_message(ERROR_MESSAGE,
"global_to_element_map_values.  Could not allocate memory for blended values 2");
								DEALLOCATE(element_values);
								return_code=0;
							}
							DEALLOCATE(blended_element_values_double);
						}
						else
						{
							display_message(ERROR_MESSAGE,
"global_to_element_map_values.  Could not allocate memory for blended values");
							DEALLOCATE(element_values);
							return_code=0;
						}
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
						/* allocate storage for the blended element values */
						if (ALLOCATE(blended_element_values,FE_value,
							number_of_blended_element_values))
						{
/*???debug */
/*{
	FE_value *value;
	int i;

	printf("unblended values :");
	value=element_values;
	i=number_of_element_values;
	while (i>0)
	{
		printf(" %.10g",*value);
		value++;
		i--;
	}
	printf("\n");
}*/
							/* calculate the blended element values */
							blended_element_value=blended_element_values;
							for (i=number_of_blended_element_values;i>0;i--)
							{
								*blended_element_value=0;
								blended_element_value++;
							}
							element_value=element_values;
							for (j=number_of_element_values;j>0;j--)
							{
								temp_value= *element_value;
								blended_element_value=blended_element_values;
								for (i=number_of_blended_element_values;i>0;i--)
								{
									*blended_element_value += (*blending_matrix)*temp_value;
									blended_element_value++;
									blending_matrix++;
								}
								element_value++;
							}
/*???debug */
/*{
	FE_value *value;
	int i;

	printf("blended values :");
	value=blended_element_values;
	i=number_of_blended_element_values;
	while (i>0)
	{
		printf(" %.10g",*value);
		value++;
		i--;
	}
	printf("\n");
}*/
							*values=blended_element_values;
							*number_of_values=number_of_blended_element_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
"global_to_element_map_values.  Could not allocate memory for blended values");
							return_code=0;
						}
						DEALLOCATE(element_values);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
#endif /* defined (OLD_CODE) */
					}
					else
					{
						*values=element_values;
						*number_of_values=number_of_element_values;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_values.  Invalid basis");
					DEALLOCATE(element_values);
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"global_to_element_map_values.  Error modifying element values");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"global_to_element_map_values.  Invalid argument(s)");
		return_code=0;
	}
/*???debug */
/*printf("leave global_to_element_map_values\n");*/
	LEAVE;

	return (return_code);
} /* global_to_element_map_values */

static int global_to_element_map_nodes(
	struct FE_element_field_component *component,struct FE_element *element,
	struct FE_field *field,int *number_of_values,
	struct FE_node ***element_values_address)
/*******************************************************************************
LAST MODIFIED : 9 February 1998

DESCRIPTION :
The standard function for calculating the nodes used for a <component>.
Calculates the <number_of_values> and the node used to calculate each element
value for a <component>.  The storage for the nodes array
(<*element_values_address>) is allocated by the function.
==============================================================================*/
{
	int j,k,number_of_element_nodes,number_of_element_values,number_of_map_values,
	 return_code;
	struct FE_node **element_value,**element_values,*node,**nodes;
	struct General_node_to_element_map *general_node_map,
		**general_node_map_address;
	struct Standard_node_to_element_map *standard_node_map,
		**standard_node_map_address;

	ENTER(global_to_element_map_nodes);
/*???debug */
/*printf("enter global_to_element_map_nodes\n");*/
	/* check the arguments */
	if (component&&element&&field&&number_of_values&&element_values_address)
	{
		/* retrieve the element values */
		switch (component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
			{
				/* check information */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->number_of_nodes)>0))
				{
					/* calculate the number of element values by summing the numbers
						of values retrieved from each node */
					number_of_element_values=0;
					standard_node_map_address=
						component->map.standard_node_based.node_to_element_maps;
					j=component->map.standard_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((standard_node_map= *standard_node_map_address)&&
							((number_of_map_values=
							standard_node_map->number_of_nodal_values)>0)&&
							(0<=standard_node_map->node_index)&&
							(standard_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[standard_node_map->node_index])&&
							(node->values_storage)&&(node->fields)&&
							(standard_node_map->nodal_value_indices)&&
							(standard_node_map->scale_factor_indices))
						{
							number_of_element_values += number_of_map_values;
							standard_node_map_address++;
							j--;
						}
						else
						{
							display_message(ERROR_MESSAGE,"global_to_element_map_nodes.  "
								"Invalid standard node to element map");
							return_code=0;
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&(ALLOCATE(element_values,
							struct FE_node *,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							standard_node_map_address=
								component->map.standard_node_based.node_to_element_maps;
							for (j=component->map.standard_node_based.number_of_nodes;j>0;
								j--)
							{
								/* retrieve the scaled nodal values */
								standard_node_map= *standard_node_map_address;
								node=nodes[standard_node_map->node_index];
								for (k=standard_node_map->number_of_nodal_values;k>0;k--)
								{
									*element_value=node;
									element_value++;
								}
								standard_node_map_address++;
							}
							*element_values_address=element_values;
							*number_of_values=number_of_element_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_nodes.  Missing element information");
					return_code=0;
				}
			} break;
			case GENERAL_NODE_TO_ELEMENT_MAP:
			/* global values are associated with nodes */
			{
				/* check information */
				if ((element->information)&&(nodes=element->information->nodes)&&
					((number_of_element_nodes=element->information->
					 number_of_nodes)>0))
				{
					/* calculate the number of element values by summing the numbers
						of values retrieved from each node */
					number_of_element_values=0;
					general_node_map_address=
						component->map.general_node_based.node_to_element_maps;
					j=component->map.general_node_based.number_of_nodes;
					return_code=1;
					while (return_code&&(j>0))
					{
						if ((general_node_map= *general_node_map_address)&&
							((number_of_map_values=
							general_node_map->number_of_nodal_values)>0)&&
							(0<=general_node_map->node_index)&&
							(general_node_map->node_index<number_of_element_nodes)&&
							(node=nodes[general_node_map->node_index])&&
							(node->values_storage)&&(node->fields)&&
							(general_node_map->element_values))
						{
							number_of_element_values += number_of_map_values;
							general_node_map_address++;
							j--;
						}
						else
						{
							display_message(ERROR_MESSAGE,"global_to_element_map_nodes.  "
								"Invalid general node to element map");
							return_code=0;
						}
					}
					if (return_code)
					{
						/* allocate storage for storing the element values */
						if ((number_of_element_values>0)&&(ALLOCATE(element_values,
							struct FE_node *,number_of_element_values)))
						{
							element_value=element_values;
							/* for each node retrieve the scaled nodal values */
							general_node_map_address=
								component->map.general_node_based.node_to_element_maps;
							for (j=component->map.general_node_based.number_of_nodes;j>0;
								j--)
							{
								/* retrieve the scaled nodal values */
								general_node_map= *general_node_map_address;
								node=nodes[general_node_map->node_index];
								for (k=general_node_map->number_of_nodal_values;k>0;k--)
								{
									*element_value=node;
									element_value++;
								}
								general_node_map_address++;
							}
							*element_values_address=element_values;
							*number_of_values=number_of_element_values;
						}
						else
						{
							display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Could not allocate memory for values");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"global_to_element_map_nodes.  Missing element information");
					return_code=0;
				}
			} break;
			case FIELD_TO_ELEMENT_MAP:
			/* global values are associated with the field */
			{
				/*???DB.  What to do ? */
				return_code=0;
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"global_to_element_map_nodes.  Invalid map type");
				return_code=0;
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"global_to_element_map_nodes.  Invalid argument(s)");
		return_code=0;
	}
/*???debug */
/*printf("leave global_to_element_map_nodes\n");*/
	LEAVE;

	return (return_code);
} /* global_to_element_map_nodes */

static int calculate_standard_basis_transformation(struct FE_basis *basis,
	FE_value *coordinate_transformation,int inherited_dimension,
	int **inherited_arguments_address,int *number_of_inherited_values_address,
	Standard_basis_function **inherited_standard_basis_function_address,
	FE_value **blending_matrix_address)
/*******************************************************************************
LAST MODIFIED : 5 August 2001

DESCRIPTION :
==============================================================================*/
{
	FE_value *blending_matrix,*expanded_coordinate_transformation,
		*inherited_value,*reorder_blending_matrix,scalar,*sumand,*transformation,
		*value;
	int basis_dimension,*field_to_element,i,inherited_polygon_offset,
		*inherited_standard_basis_argument,*inherited_standard_basis_arguments,j,k,
		l,m,need_reordering,number_of_inherited_values,number_of_polygon_verticies,
		number_of_values,offset,order,p,polygon_offset,polygon_vertex,
		*reorder_coordinate,*reorder_value,*reorder_values,return_code,row_size,
		*standard_basis_argument,*standard_basis_arguments;
	Standard_basis_function *standard_basis_function;
#if defined (DOUBLE_FOR_DOT_PRODUCT)
	double sum;
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
	FE_value sum;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */

	ENTER(calculate_standard_basis_transformation);
#if defined (DEBUG)
	/*???debug */
	printf("enter calculate_standard_basis_transformation\n");
#endif /* defined (DEBUG) */
	return_code=0;
	if (basis&&(inherited_dimension>0)&&inherited_arguments_address&&
		inherited_standard_basis_function_address&&blending_matrix_address)
	{
		standard_basis_arguments=(int *)(basis->arguments);
		standard_basis_function=basis->standard_basis;
		basis_dimension=(basis->type)[0];
		if (monomial_basis_functions==standard_basis_function)
		{
			/* calculate the blending matrix from the monomial basis for the full
				<basis> to the inherited monomial basis */
			ALLOCATE(inherited_standard_basis_arguments,int,inherited_dimension+1);
			ALLOCATE(expanded_coordinate_transformation,FE_value,
				(basis_dimension+1)*(inherited_dimension+1));
			if (inherited_standard_basis_arguments&&
				expanded_coordinate_transformation)
			{
				inherited_standard_basis_argument=
					inherited_standard_basis_arguments;
				*inherited_standard_basis_argument=inherited_dimension;
				for (i=inherited_dimension;i>0;i--)
				{
					inherited_standard_basis_argument++;
					*inherited_standard_basis_argument=0;
				}
				standard_basis_argument=standard_basis_arguments;
				expanded_coordinate_transformation[0]=1;
				transformation=expanded_coordinate_transformation;
				for (j=inherited_dimension;j>0;j--)
				{
					transformation++;
					*transformation=0;
				}
				if (value=coordinate_transformation)
				{
					for (i=basis_dimension;i>0;i--)
					{
						standard_basis_argument++;
						order= *standard_basis_argument;
						inherited_standard_basis_argument=
							inherited_standard_basis_arguments;
						for (j=inherited_dimension;j>=0;j--)
						{
							transformation++;
							*transformation= *value;
							value++;
							if (j>0)
							{
								inherited_standard_basis_argument++;
								if ((0!= *value)&&(order> *inherited_standard_basis_argument))
								{
									*inherited_standard_basis_argument=order;
								}
							}
						}
					}
				}
				else
				{
					for (i=basis_dimension*(inherited_dimension+1);i>0;i--)
					{
						transformation++;
						*transformation=0;
					}
					transformation=expanded_coordinate_transformation+
						(inherited_dimension+1);
					inherited_standard_basis_argument=
						inherited_standard_basis_arguments;
					i=1;
					while (i<=basis_dimension)
					{
						standard_basis_argument++;
						inherited_standard_basis_argument++;
						transformation[i]=1;
						i++;
						transformation += inherited_dimension+1;
						*inherited_standard_basis_argument= *standard_basis_argument;
					}
				}
				row_size=basis->number_of_standard_basis_functions;
				number_of_inherited_values=1;
				inherited_standard_basis_argument=
					inherited_standard_basis_arguments;
				for (j=inherited_dimension;j>0;j--)
				{
					inherited_standard_basis_argument++;
					number_of_inherited_values *= (*inherited_standard_basis_argument)+1;
				}
				if (ALLOCATE(blending_matrix,FE_value,
					row_size*number_of_inherited_values))
				{
					value=blending_matrix;
					*value=1;
					for (i=row_size*number_of_inherited_values-1;i>0;i--)
					{
						value++;
						*value=0;
					}
					standard_basis_argument=standard_basis_arguments;
					row_size=1;
					transformation=expanded_coordinate_transformation+
						(inherited_dimension+1);
					for (i=basis_dimension;i>0;i--)
					{
						standard_basis_argument++;
						order= *standard_basis_argument;
						for (j=0;j<order;j++)
						{
							offset=0;
							for (k=0;k<=inherited_dimension;k++)
							{
								if (0!= *transformation)
								{
									/* loop over blending matrix rows */
									value=blending_matrix+(j*row_size*number_of_inherited_values);
									for (l=0;l<row_size;l++)
									{
										for (p=number_of_inherited_values-offset;p>0;p--)
										{
											if (0!= *value)
											{
												value[row_size*number_of_inherited_values+offset] +=
													(*value)*(*transformation);
											}
											value++;
										}
										value += offset;
									}
								}
								if (k>0)
								{
									offset *= (1+inherited_standard_basis_arguments[k]);
								}
								else
								{
									offset=1;
								}
								transformation++;
							}
							transformation -= inherited_dimension+1;
						}
						transformation += inherited_dimension+1;
						row_size *= (order+1);
					}
					*inherited_arguments_address=inherited_standard_basis_arguments;
					*blending_matrix_address=blending_matrix;
					*number_of_inherited_values_address=number_of_inherited_values;
					*inherited_standard_basis_function_address=monomial_basis_functions;
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"calculate_standard_basis_transformation.  "
						"Insufficient memory for blending_matrix");
					DEALLOCATE(inherited_standard_basis_arguments);
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_standard_basis_transformation.  Insufficient memory 1");
				DEALLOCATE(inherited_standard_basis_arguments);
				return_code=0;
			}
			DEALLOCATE(expanded_coordinate_transformation);
		}
		else
		{
			if (polygon_basis_functions==standard_basis_function)
			{
				/* calculate the blending matrix from the standard basis for the full
					<basis> to the inherited standard basis */
				ALLOCATE(inherited_standard_basis_arguments,int,inherited_dimension+1);
				ALLOCATE(field_to_element,int,basis_dimension);
				ALLOCATE(reorder_coordinate,int,inherited_dimension);
				row_size=basis->number_of_standard_basis_functions;
				ALLOCATE(blending_matrix,FE_value,row_size*row_size);
				if (inherited_standard_basis_arguments&&field_to_element&&
					reorder_coordinate&&blending_matrix)
				{
					return_code=1;
					/* determine the correspondence between the xi coordinates for the
						element field and the xi coordinates for the element */
					/*???DB.  At present only able to do transformations that are one to
						one in the xi coordinates.  This is equivalent to one non-zero in
						each column of A and at most one non-zero in each row of A */
					if (value=coordinate_transformation)
					{
						i=0;
						k=0;
						need_reordering=0;
						standard_basis_argument=standard_basis_arguments;
						while (return_code&&(i<basis_dimension))
						{
							field_to_element[i]=0;
							standard_basis_argument++;
							order= *standard_basis_argument;
							/* skip translate b */
							value++;
							/* examine matrix A */
							j=0;
							while (return_code&&(j<inherited_dimension))
							{
								if (0!= *value)
								{
									if (0==field_to_element[i])
									{
										field_to_element[i]=j+1;
										reorder_coordinate[k]=j;
										if (j!=k)
										{
											need_reordering=1;
										}
										k++;
									}
									else
									{
										display_message(ERROR_MESSAGE,
"calculate_standard_basis_transformation.  Coordinate transformation not 1 to 1");
										return_code=0;
									}
								}
								value++;
								j++;
							}
							i++;
						}
						if (return_code)
						{
							if (!need_reordering)
							{
								/* coordinate reordering is not needed */
								DEALLOCATE(reorder_coordinate);
							}
						}
					}
					else
					{
						need_reordering=0;
						DEALLOCATE(reorder_coordinate);
						for (i=inherited_dimension;i>0;i--)
						{
							field_to_element[i-1]=i;
						}
					}
					if (return_code)
					{
						/* calculate the arguments for the standard basis function */
						number_of_inherited_values=1;
						*inherited_standard_basis_arguments=inherited_dimension;
						standard_basis_argument=standard_basis_arguments;
						standard_basis_function=monomial_basis_functions;
						i=0;
						while (return_code&&(i<basis_dimension))
						{
							standard_basis_argument++;
							order= *standard_basis_argument;
							if (order<0)
							{
								/* polygon */
								order= -order;
								if (order%2)
								{
									/* first polygon coordinate */
									order /= 2;
									polygon_offset=order%basis_dimension;
									order /= basis_dimension;
									number_of_polygon_verticies=
										(-standard_basis_argument[polygon_offset])/2;
									if (field_to_element[i])
									{
										if (field_to_element[i+polygon_offset])
										{
											/* radial and circumferential coordinates inherited */
											standard_basis_function=polygon_basis_functions;
											inherited_polygon_offset=
												field_to_element[i+polygon_offset]-field_to_element[i];
											if (inherited_polygon_offset<0)
											{
												display_message(ERROR_MESSAGE,
													"calculate_standard_basis_transformation.  "
													"Reordering of polygon coordinates is not supported");
												return_code=0;
											}
											else
											{
												inherited_standard_basis_arguments[field_to_element[i]]=
													-(1+2*(inherited_polygon_offset+
													order*inherited_dimension));
												inherited_standard_basis_arguments[field_to_element[
													i+polygon_offset]]= -2*number_of_polygon_verticies;
											}
											number_of_inherited_values *=
												4*number_of_polygon_verticies;
										}
										else
										{
											/* circumferential coordinate inherited */
											inherited_standard_basis_arguments[field_to_element[i]]=
												order;
											number_of_inherited_values *= order+1;
										}
									}
									else
									{
										if (field_to_element[i+polygon_offset])
										{
											display_message(ERROR_MESSAGE,
												"calculate_standard_basis_transformation.  "
												"Cannot inherit polygon radial coordinate by itself");
											return_code=0;
										}
									}
								}
								else
								{
									/* second polygon coordinate.  Validity checked and argument
										assigned with first coordinate */
								}
							}
							else
							{
								/* not polygon */
								if (field_to_element[i])
								{
									inherited_standard_basis_arguments[field_to_element[i]]=order;
									number_of_inherited_values *= order+1;
								}
							}
							i++;
						}
						if (return_code)
						{
							/* calculate the blending matrix */
							/* start with the identity */
							value=blending_matrix;
							*value=1;
							for (i=row_size-1;i>0;i--)
							{
								for (j=row_size;j>0;j--)
								{
									value++;
									*value=0;
								}
								value++;
								*value=1;
							}
							if (transformation=coordinate_transformation)
							{
								number_of_inherited_values=1;
								standard_basis_argument=standard_basis_arguments;
								number_of_values=basis->number_of_standard_basis_functions;
								offset=1;
								for (i=0;i<basis_dimension;i++)
								{
									standard_basis_argument++;
									order= *standard_basis_argument;
									if (order<0)
									{
										/* polygon */
										order= -order;
										if (order%2)
										{
											/* first polygon component */
											order /= 2;
											polygon_offset=order%basis_dimension;
											order /= basis_dimension;
											number_of_polygon_verticies=
												(-standard_basis_argument[polygon_offset])/2;
											/* NB.  Have already checked validity when calculating
												inherited arguments */
											if (field_to_element[i])
											{
												if (field_to_element[i+polygon_offset])
												{
													/* polygon is in projection */
													number_of_inherited_values *=
														4*number_of_polygon_verticies;
												}
												else
												{
													/* edge of polygon in projection */
													polygon_vertex=(int)(0.1+(*transformation)*
														(FE_value)number_of_polygon_verticies);
													value=blending_matrix;
													inherited_value=value;
													if (number_of_polygon_verticies-1==polygon_vertex)
													{
														for (j=number_of_values/
															(4*number_of_polygon_verticies*
															number_of_inherited_values);j>0;j--)
														{
															for (k=number_of_inherited_values;k>0;k--)
															{
																for (l=row_size;l>0;l--)
																{
																	scalar=value[polygon_vertex*
																		number_of_inherited_values*row_size]+
																		value[(polygon_vertex+
																		2*number_of_polygon_verticies)*
																		number_of_inherited_values*row_size];
																	inherited_value[
																		number_of_inherited_values*row_size]=
																		(*value)+
																		value[2*number_of_polygon_verticies*
																		number_of_inherited_values*row_size]-scalar;
																	*inherited_value=scalar;
																	inherited_value++;
																	value++;
																}
															}
															inherited_value +=
																number_of_inherited_values*row_size;
															value +=
																(4*number_of_polygon_verticies-1)*
																number_of_inherited_values*row_size;
														}
													}
													else
													{
														if (number_of_polygon_verticies==polygon_vertex)
														{
															polygon_vertex=0;
														}
														value += polygon_vertex*number_of_inherited_values*
															row_size;
														for (j=number_of_values/
															(4*number_of_polygon_verticies*
															number_of_inherited_values);j>0;j--)
														{
															for (k=number_of_inherited_values;k>0;k--)
															{
																for (l=row_size;l>0;l--)
																{
																	scalar= (*value)+
																		value[2*number_of_polygon_verticies*
																		number_of_inherited_values*row_size];
																	inherited_value[
																		number_of_inherited_values*row_size]=
																		value[number_of_inherited_values*row_size]+
																		value[(2*number_of_polygon_verticies+1)*
																		number_of_inherited_values*row_size]-
																		scalar;
																	*inherited_value=scalar;
																	inherited_value++;
																	value++;
																}
															}
															inherited_value +=
																number_of_inherited_values*row_size;
															value += (4*number_of_polygon_verticies-1)*
																number_of_inherited_values*row_size;
														}
													}
													number_of_values /= 4*number_of_polygon_verticies;
													number_of_values *= 2;
													number_of_inherited_values *= 2;
												}
											}
											else
											{
												/* polygon is not in projection */
												polygon_vertex=(int)(0.1+(*transformation)*
													(FE_value)number_of_polygon_verticies);
												if (number_of_polygon_verticies==polygon_vertex)
												{
													polygon_vertex=0;
												}
												value=blending_matrix;
												inherited_value=value;
												value +=
													polygon_vertex*number_of_inherited_values*row_size;
												for (j=number_of_values/(4*number_of_polygon_verticies*
													number_of_inherited_values);j>0;j--)
												{
													for (k=number_of_inherited_values;k>0;k--)
													{
														for (l=row_size;l>0;l--)
														{
															*inherited_value= *value+
																value[2*number_of_polygon_verticies*
																number_of_inherited_values*row_size];
															inherited_value++;
															value++;
														}
													}
													value += (4*number_of_polygon_verticies-1)*
														number_of_inherited_values*row_size;
												}
												number_of_values /=
													4*number_of_polygon_verticies;
											}
										}
									}
									else
									{
										/* not polygon */
										if (field_to_element[i])
										{
											/* in projection */
											number_of_inherited_values *= order+1;
										}
										else
										{
											/* not in projection */
											if (*transformation)
											{
												/* assume *transformation (b) is 1 */
												value=blending_matrix;
												inherited_value=value;
												for (j=number_of_values/
													((order+1)*number_of_inherited_values);j>0;j--)
												{
													for (k=number_of_inherited_values;k>0;k--)
													{
														for (l=row_size;l>0;l--)
														{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
															sum=(double)(*value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
															sum= *value;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
															sumand=value;
															for (m=order;m>0;m--)
															{
																sumand += number_of_inherited_values*row_size;
#if defined (DOUBLE_FOR_DOT_PRODUCT)
																sum += (double)(*sumand);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
																sum += *sumand;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
															}
															*inherited_value=(FE_value)sum;
															inherited_value++;
															value++;
														}
													}
													value += order*number_of_inherited_values*row_size;
												}
												number_of_values /= order+1;
											}
											else
											{
												/* *transformation (b) is 0 */
												value=blending_matrix;
												inherited_value=value;
												for (j=number_of_values/
													((order+1)*number_of_inherited_values);j>0;j--)
												{
													for (k=number_of_inherited_values*row_size;k>0;k--)
													{
														*inherited_value= *value;
														inherited_value++;
														value++;
													}
													value += order*number_of_inherited_values*row_size;
												}
												number_of_values /= order+1;
											}
										}
									}
									transformation += inherited_dimension+1;
								}
								/* transpose so that stored by columns */
								value=blending_matrix;
								for (i=0;i<row_size;i++)
								{
									inherited_value=blending_matrix+i;
									for (j=0;j<i;j++)
									{
										scalar= *inherited_value;
										*inherited_value= *value;
										*value=scalar;
										value++;
										inherited_value += row_size;
									}
									value += row_size-i;
								}
								/* compress by reducing the column length */
								value=blending_matrix;
								inherited_value=blending_matrix;
								for (j=row_size;j>0;j--)
								{
									for (i=number_of_inherited_values;i>0;i--)
									{
										*inherited_value= *value;
										inherited_value++;
										value++;
									}
									value += row_size-number_of_inherited_values;
								}
								if (reorder_coordinate)
								{
									ALLOCATE(reorder_blending_matrix,FE_value,
										number_of_inherited_values*row_size);
									ALLOCATE(reorder_values,int,number_of_inherited_values);
									if (reorder_blending_matrix&&reorder_values)
									{
										value=blending_matrix;
										blending_matrix=reorder_blending_matrix;
										reorder_blending_matrix=value;
										inherited_value=blending_matrix;
										for (l=row_size;l>0;l--)
										{
											*inherited_value= *value;
											value += number_of_inherited_values;
											inherited_value += number_of_inherited_values;
										}
										reorder_value=reorder_values;
										*reorder_value=0;
										k=1;
										for (i=0;i<inherited_dimension;i++)
										{
											offset=1;
											inherited_standard_basis_argument=
												inherited_standard_basis_arguments;
											for (j=reorder_coordinate[i];j>0;j--)
											{
												inherited_standard_basis_argument++;
												order= *inherited_standard_basis_argument;
												if (order<0)
												{
													/* polygon */
													order= -order;
													if (order%2)
													{
														/* first polygon coordinate */
														order /= 2;
														polygon_offset=order%inherited_dimension;
														number_of_polygon_verticies=
															(-inherited_standard_basis_argument[
															polygon_offset])/2;
														offset *= 4*number_of_polygon_verticies;
													}
												}
												else
												{
													/* not polygon */
													offset *= order+1;
												}
											}
											inherited_standard_basis_argument++;
											order= *inherited_standard_basis_argument;
											if (order<0)
											{
												/* polygon */
												order= -order;
												if (order%2)
												{
													/* first polygon coordinate */
													order /= 2;
													polygon_offset=order%inherited_dimension;
													order=4*(-inherited_standard_basis_argument[
														polygon_offset])/2;
												}
												else
												{
													order=0;
												}
											}
											reorder_value=reorder_values;
											for (j=0;j<k*order;j++)
											{
												reorder_value[k]=(*reorder_value)+offset;
												inherited_value=blending_matrix+reorder_value[k];
												value=reorder_blending_matrix+(j+k);
												for (l=row_size;l>0;l--)
												{
													*inherited_value= *value;
													value += number_of_inherited_values;
													inherited_value += number_of_inherited_values;
												}
												reorder_value++;
											}
											k *= (order+1);
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"calculate_standard_basis_transformation.  "
											"Insufficient memory 2");
										return_code=0;
									}
									DEALLOCATE(reorder_values);
									DEALLOCATE(reorder_blending_matrix);
								}
							}
							if (return_code)
							{
								*number_of_inherited_values_address=number_of_inherited_values;
								*inherited_standard_basis_function_address=
									standard_basis_function;
								*inherited_arguments_address=inherited_standard_basis_arguments;
								*blending_matrix_address=blending_matrix;
							}
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"calculate_standard_basis_transformation.  Insufficient memory 1");
					return_code=0;
				}
				if (!return_code)
				{
					DEALLOCATE(blending_matrix);
					DEALLOCATE(inherited_standard_basis_arguments);
				}
				DEALLOCATE(field_to_element);
				DEALLOCATE(reorder_coordinate);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_standard_basis_transformation.  Invalid basis");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(WARNING_MESSAGE,
			"calculate_standard_basis_transformation.  Invalid argument(s)");
		return_code=0;
	}
#if defined (DEBUG)
	/*???debug */
	printf("leave calculate_standard_basis_transformation %d\n",return_code);
#endif /* defined (DEBUG) */
	LEAVE;

	return (return_code);
} /* calculate_standard_basis_transformation */

static int FE_element_parent_contains_node(
	struct FE_element_parent *element_parent, void *node_void)
/*******************************************************************************
LAST MODIFIED : 25 May 2001

DESCRIPTION :
Calls FE_element_or_parent_contains_node for the element in the
FE_element_parent.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_parent_contains_node);
	if (element_parent)
	{
		return_code =
			FE_element_or_parent_contains_node(element_parent->parent, node_void);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_contains_node.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_contains_node */

static int FE_element_parent_contains_node_in_list(
	struct FE_element_parent *element_parent, void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 25 May 2001

DESCRIPTION :
Calls FE_element_or_parent_contains_node_in_list for the element in
<element_parent>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_parent_contains_node_in_list);
	if (element_parent)
	{
		return_code = FE_element_or_parent_contains_node_in_list(
			element_parent->parent, node_list_void);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_contains_node_in_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_contains_node_in_list */

struct Check_element_grid_map_values_storage_data
{
	int check_sum,values_storage_size;
}; /* struct Check_element_grid_map_values_storage_data */

static int check_element_grid_map_values_storage(
	struct FE_element_field *element_field,
	void *check_element_grid_map_values_storage_data_void)
/*******************************************************************************
LAST MODIFIED : 14 December 2000

DESCRIPTION :
If the <element_field> is grid based, check that the index range is within the
values_storage array and add the values_storage size it requires to the
check_sum.
==============================================================================*/
{
	int i,j,*number_in_xi,number_of_values,return_code,size,value_index,
		values_storage_size;
	struct Check_element_grid_map_values_storage_data *check_grid_data;
	struct FE_element_field_component **component;

	ENTER(check_element_grid_map_values_storage);
	return_code=0;
	if (element_field&&element_field->field&&(check_grid_data=
		(struct Check_element_grid_map_values_storage_data *)
		check_element_grid_map_values_storage_data_void))
	{
		return_code=1;
		/* only GENERAL_FE_FIELD has components and can be grid-based */
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			size=get_Value_storage_size(element_field->field->value_type,
				(struct FE_time_sequence *)NULL);
			component=element_field->components;
			for (i=element_field->field->number_of_components;(0<i)&&return_code;i--)
			{
				if (ELEMENT_GRID_MAP==(*component)->type)
				{
					number_in_xi=((*component)->map).element_grid_based.number_in_xi;
					number_of_values=1;
					for (j=((*component)->basis->type)[0];j>0;j--)
					{
						number_of_values *= (*number_in_xi)+1;
						number_in_xi++;
					}
					value_index=((*component)->map).element_grid_based.value_index;
					values_storage_size = number_of_values*size;
					/* make sure values storage is word aligned for machine */
					ADJUST_VALUE_STORAGE_SIZE(values_storage_size);
					if ((value_index<check_grid_data->values_storage_size)&&
						(value_index+values_storage_size <=
							check_grid_data->values_storage_size))
					{
						check_grid_data->check_sum += values_storage_size;
					}
					else
					{
						return_code=0;
					}
				}
				component++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"check_element_grid_map_values_storage.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* check_element_grid_map_values_storage */

static int for_FE_field_at_node_iterator(struct FE_node_field *node_field,
	void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
FE_node_field iterator for for_each_FE_field_at_node.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_node_iterator);
	if (node_field&&(iterator_and_data=
		(struct FE_node_field_iterator_and_data *)iterator_and_data_void)&&
		iterator_and_data->iterator)
	{
		return_code=(iterator_and_data->iterator)(iterator_and_data->node,
			node_field->field,iterator_and_data->user_data);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_node_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_node_iterator */

static int FE_node_field_add_indexer_field_to_list(
	struct FE_node_field *node_field,void *field_list_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
If the field in the <node_field> is of type INDEXED_FE_FIELD, function ensures
its indexer_field is put in the <field_list>.
Used by for_each_FE_field_at_node_indexer_first to put indexer_fields into a
priority list for iterating through first.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;
	struct LIST(FE_field) *field_list;

	ENTER(FE_node_field_add_indexer_field_to_list);
	if (node_field&&(field=node_field->field)&&
		(field_list=(struct LIST(FE_field) *)field_list_void))
	{
		return_code=1;
		if (INDEXED_FE_FIELD==field->fe_field_type)
		{
			if (!IS_OBJECT_IN_LIST(FE_field)(field->indexer_field,field_list))
			{
				return_code=
					ADD_OBJECT_TO_LIST(FE_field)(field->indexer_field,field_list);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_add_indexer_field_to_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_add_indexer_field_to_list */

static int for_FE_field_at_node_priority_iterator(
	struct FE_node_field *node_field,void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
FE_node_field iterator for for_each_FE_field_at_node. Only calls the iterator
function if the priority_on flag matches the field status in priority_list.
==============================================================================*/
{
	int priority_field,return_code;
	struct FE_node_field_priority_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_node_iterator);
	if (node_field&&(iterator_and_data=
		(struct FE_node_field_priority_iterator_and_data *)iterator_and_data_void)&&
		iterator_and_data->iterator)
	{
		priority_field=IS_OBJECT_IN_LIST(FE_field)(node_field->field,
			iterator_and_data->priority_field_list);
		if ((iterator_and_data->priority_on&&priority_field)||
			((!iterator_and_data->priority_on)&&(!priority_field)))
		{
			return_code=(iterator_and_data->iterator)(iterator_and_data->node,
				node_field->field,iterator_and_data->user_data);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_node_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_node_iterator */

static struct FE_node_field *FE_node_get_FE_node_field(struct FE_node *node,
	struct FE_field *fe_field)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Returns the FE_node_field structure describing how <fe_field> is defined at
<node>. Returns NULL with no error if <fe_field> is not defined at <node>.
==============================================================================*/
{
	struct FE_node_field *node_field;

	ENTER(FE_node_get_FE_node_field);
	if (node && node->fields && fe_field)
	{
		node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(fe_field,
			node->fields->node_field_list);
	}
	else
	{
		display_message(WARNING_MESSAGE,
			"FE_node_get_FE_node_field.  Invalid argument(s)");
		node_field = (struct FE_node_field *)NULL;
	}
	LEAVE;

	return (node_field);
} /* FE_node_get_FE_node_field */

static int find_FE_nodal_values_storage_dest(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,enum Value_type value_type,
	Value_storage **values_storage, struct FE_time_sequence **time_sequence)
/*******************************************************************************
LAST MODIFIED : 19 February 2003

DESCRIPTION :
Returns a pointer to the nodal values_storage and the matching time_sequence
for the given node, component, version, type and value_type.
Returns 0 with no error in cases where the version or type is not stored, hence
can use this function to determing if either are defined.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type;
	int i,length,return_code,size;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	Value_storage *the_values_storage = (Value_storage *)NULL;

	ENTER(find_FE_nodal_values_storage_dest);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		if (node_field = FE_node_get_FE_node_field(node, field))
		{
			if (node_field_component=node_field->components)
			{
				if (node_field->field->value_type == value_type)
				{					
					node_field_component += component_number;
					if (version < node_field_component->number_of_versions)
					{
						if (nodal_value_type=node_field_component->nodal_value_types)
						{
							length=1+(node_field_component->number_of_derivatives);
							i=0;
							while ((i<length) && (type != nodal_value_type[i]))
							{
								i++;
							}
							if (i<length)
							{
								size = get_Value_storage_size(value_type,
									node_field->time_sequence);
								the_values_storage = node->values_storage +
									(node_field_component->value) + ((version*length+i)*size);
								*values_storage = the_values_storage;
								*time_sequence = node_field->time_sequence;
								return_code=1;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"find_FE_nodal_values_storage_dest.  "
								"Missing nodal_value_type array");
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"find_FE_nodal_values_storage_dest.  value_type mismatch");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"find_FE_nodal_values_storage_dest.  Invalid node/field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"find_FE_nodal_values_storage_dest.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* find_FE_nodal_values_storage_dest */

static int FE_node_field_is_embedded_in_changed_element(
	struct FE_node_field *node_field, void *data_void)
/*******************************************************************************
LAST MODIFIED : 25 May 2001

DESCRIPTION :
Returns true if <node_field> is an element:xi field embedded in an element from
the <changed_element_list> or using a node in the <changed_node_list> from
<data_void>.
For efficiency, function returns true for some faces and lines only their
top-level elements away from the face have been affected. This is because it is
very expensive to compute the nodes on faces and lines.
==============================================================================*/
{
	FE_value xi[MAXIMUM_ELEMENT_XI_DIMENSIONS];
	int component_number_of_versions, i, j, number_of_components, return_code;
	struct FE_element *element;
	struct FE_node_is_embedded_in_changed_element_data *data;

	ENTER(FE_node_field_is_embedded_in_changed_element);
	return_code = 0;
	if (node_field &&
		(data = (struct FE_node_is_embedded_in_changed_element_data *)data_void))
	{
		if (ELEMENT_XI_VALUE == get_FE_field_value_type(node_field->field))
		{
			/* generally 1 component 1 version for this type of field */
			number_of_components =
				get_FE_field_number_of_components(node_field->field);
			for (i = 0; (i < number_of_components) && (!return_code); i++)
			{
				component_number_of_versions =
					get_FE_node_field_component_number_of_versions(
						data->node, node_field->field, i);
				for (j = 0; (j < component_number_of_versions) && (!return_code); j++)
				{
					if (get_FE_nodal_element_xi_value(data->node, node_field->field,
						i, j, FE_NODAL_VALUE, &element, xi))
					{
						if (data->changed_element_list)
						{
							return_code = IS_OBJECT_IN_LIST(FE_element)(element,
								data->changed_element_list);
						}
						if (data->changed_node_list)
						{
							return_code = FE_element_or_parent_contains_node_in_list(element,
								data->changed_node_list);
						}
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_is_embedded_in_changed_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_is_embedded_in_changed_element */

#if defined (OLD_CODE)
static int FE_element_parent_remove_face(
	struct FE_element_parent *element_parent,void *face_element_void)
/*******************************************************************************
LAST MODIFIED : 14 April 1999

DESCRIPTION :
Takes the <face_element> out of the faces array of the parent element referred
to by the <element_parent>.
==============================================================================*/
{
	int return_code;
	struct FE_element **parent_faces,*face_element;

	ENTER(FE_element_parent_remove_face);
	if (element_parent&&(face_element=(struct FE_element *)face_element_void))
	{
		if (element_parent->parent&&(parent_faces=element_parent->parent->faces)&&
			(parent_faces[element_parent->face_number] == face_element))
		{
			DEACCESS(FE_element)(&(parent_faces[element_parent->face_number]));
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_parent_remove_face.  Invalid element_parent or faces");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_remove_face.  Invalid argument(s)");
		return_code=0;
	}

	return (return_code);
} /* FE_element_parent_remove_face */
#endif /* defined (OLD_CODE) */

static char *get_automatic_component_name(char **component_names,
	int component_no)
/*******************************************************************************
LAST MODIFIED : 28 January 1999

DESCRIPTION :
Used internally by some FE_field functions. Returns an allocated string
containing the component name for <component_no> (starting at 0 for the first).
If <component_names> or component_names[component_no] are NULL a name consisting
of the value component_no+1 is created and returned.
If <component_names> is not NULL, the function assumes that component_no is
less than the number of names in this array.
It is up to the calling function to deallocate the returned string.
==============================================================================*/
{
	char *component_name,*source_name,temp_string[20];

	ENTER(get_automatic_component_name);
	if (0<=component_no)
	{
		if (component_names&&component_names[component_no])
		{
			source_name=component_names[component_no];
		}
		else
		{
			sprintf(temp_string,"%i",component_no+1);
			source_name=temp_string;
		}
		component_name = duplicate_string(source_name);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_automatic_component_name.  Invalid component_no");
		component_name=(char *)NULL;
	}
	LEAVE;

	return (component_name);
} /* get_automatic_component_name */

int FE_element_face_line_to_element_type_node_sequence_list(
	struct FE_element *element,void *element_type_node_sequence_list_void)
/*******************************************************************************
LAST MODIFIED : 13 February 2003

DESCRIPTION :
Iterator function; if <element> is type CM_LINE or CM_FACE, creates a struct
FE_element_type_node_sequence for it and adds it to the given list. Note that
function fails if two faces have the same shape and share the same nodes.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element_type_node_sequence) *element_type_node_sequence_list;
	struct FE_element_type_node_sequence *element_type_node_sequence;

	ENTER(FE_element_face_line_to_element_type_node_sequence_list);
	if (element&&(element_type_node_sequence_list=
		(struct LIST(FE_element_type_node_sequence) *)
		element_type_node_sequence_list_void))
	{
		return_code=1;
		if ((element->cm.type==CM_LINE)||(element->cm.type==CM_FACE))
		{
			if (element_type_node_sequence=
				CREATE(FE_element_type_node_sequence)(element))
			{
				if (!ADD_OBJECT_TO_LIST(FE_element_type_node_sequence)(
					element_type_node_sequence,element_type_node_sequence_list))
				{
					display_message(ERROR_MESSAGE,
						"FE_element_face_line_to_element_type_node_sequence_list.  "
						"Could not add FE_element_type_node_sequence to list for element %s %d",
						CM_element_type_string(element->cm.type), element->cm.number);
					DESTROY(FE_element_type_node_sequence)(&element_type_node_sequence);
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_face_line_to_element_type_node_sequence_list.  "
					"Could not create FE_element_type_node_sequence");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_face_line_to_element_type_node_sequence_list.  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_face_line_to_element_type_node_sequence_list */

static int node_on_axis(struct FE_node *node,struct FE_field *field,
	FE_value time, enum Coordinate_system_type coordinate_system_type)
/*******************************************************************************
LAST MODIFIED : 26 December 2000

DESCRIPTION :
Returns non-zero if the <node> is on the axis for the <field>/
<coordinate_system_type> and zero otherwise.
==============================================================================*/
{
	FE_value node_value;
	int return_code;

	ENTER(node_on_axis);
	return_code=0;
	switch (coordinate_system_type)
	{
		case CYLINDRICAL_POLAR:
		{
			calculate_FE_field(field,0,node,(struct FE_element *)NULL,
				(FE_value *)NULL,time,&node_value);
			if (0==node_value)
			{
				return_code=1;
			}
		} break;
		case PROLATE_SPHEROIDAL:
		case OBLATE_SPHEROIDAL:
		{
			calculate_FE_field(field,1,node,(struct FE_element *)NULL,
				(FE_value *)NULL,time,&node_value);
			if ((0==node_value)||(PI==node_value))
			{
				return_code=1;
			}
		} break;
		case SPHERICAL_POLAR:
		{
			calculate_FE_field(field,2,node,(struct FE_element *)NULL,
				(FE_value *)NULL,time,&node_value);
			if ((-PI/2==node_value)||(PI/2==node_value))
			{
				return_code=1;
			}
		} break;
	}
	LEAVE;

	return (return_code);
} /* node_on_axis */

static int face_calculate_xi_normal(struct FE_element_shape *shape,
	int face_number,FE_value *normal)
/*******************************************************************************
LAST MODIFIED : 3 August 2003

DESCRIPTION :
Calculates the <normal>, in xi space, of the specified face.

Cannot guarantee that <normal> is inward.
==============================================================================*/
{
	double determinant,*matrix_double,norm;
	FE_value *face_to_element,sign;
	int dimension,i,j,k,*pivot_index,return_code;

	ENTER(face_calculate_xi_normal);
	if (shape&&get_FE_element_shape_dimension(shape,&dimension)&&(0<dimension)&&
		(0<=face_number)&&(face_number<shape->number_of_faces)&&normal)
	{
		return_code = 1;
		if (1==dimension)
		{
			normal[0]=(FE_value)1;
		}
		else
		{
			/* working storage */
			ALLOCATE(matrix_double,double,(dimension-1)*(dimension-1));
			ALLOCATE(pivot_index,int,dimension-1);
			if (matrix_double&&pivot_index)
			{
				sign=(FE_value)1;
				face_to_element=(shape->face_to_element)+
					(face_number*dimension*dimension);
				i=0;
				while (return_code&&(i<dimension))
				{
					/* calculate the determinant of face_to_element excluding column 1 and
						row i+1 */
					for (j=0;j<i;j++)
					{
						for (k=1;k<dimension;k++)
						{
							matrix_double[j*(dimension-1)+(k-1)]=
								(double)face_to_element[j*dimension+k];
						}
					}
					for (j=i+1;j<dimension;j++)
					{
						for (k=1;k<dimension;k++)
						{
							matrix_double[(j-1)*(dimension-1)+(k-1)]=
								(double)face_to_element[j*dimension+k];
						}
					}
					if (LU_decompose(dimension-1,matrix_double,pivot_index,
						&determinant,/*singular_tolerance*/1.0e-12))
					{
						for (j=0;j<dimension-1;j++)
						{
							determinant *= matrix_double[j*(dimension-1)+j];
						}
						normal[i]=sign*(FE_value)determinant;
						sign= -sign;
					}
					else
					{
						normal[i] = 0.0;
						sign = -sign;
					}
					i++;
				}
				if (return_code)
				{
					/* normalize face_normal */
					norm=(double)0;
					for (i=0;i<dimension;i++)
					{
						norm += (double)(normal[i])*(double)(normal[i]);
					}
					if (0<norm)
					{
						norm=sqrt(norm);
						for (i=0;i<dimension;i++)
						{
							normal[i] /= (FE_value)norm;
						}
					}
					else
					{
						return_code=0;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,"face_calculate_xi_normal.  "
					"Could not allocate matrix_double (%p) or pivot_index (%p)",
					matrix_double,pivot_index);
				return_code=0;
			}
			DEALLOCATE(pivot_index);
			DEALLOCATE(matrix_double);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"face_calculate_xi_normal.  "
			"Invalid argument(s).  %p %d %d %p",shape,dimension,face_number,normal);
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* face_calculate_xi_normal */

static int FE_element_shape_xi_increment(struct FE_element_shape *shape,
	FE_value *xi,FE_value *increment, FE_value *step_size,
	int *face_number_address, FE_value *xi_face)
/*******************************************************************************
LAST MODIFIED : 16 June 2006

DESCRIPTION :
Adds the <increment> to <xi>.  If this moves <xi> outside of the shape, then
the step is limited to take <xi> to the boundary, <face_number> is set to be
the limiting face, <fraction> is updated with the fraction of the <increment>
actually used, the <increment> is updated to contain the part not used,
the <xi_face> are calculated for that face and the <xi> are changed to be
on the boundary of the shape.

???DB.  Assumes that <xi> is inside
???DB.  Needs reordering inside finite_element
==============================================================================*/
{
	double determinant,*face_matrix,*face_rhs,*face_rhsB,step_size_local;
	FE_value *face_to_element;
	int dimension,face_number,i,j,k,*pivot_index,return_code;
	/* While we are calculating this in doubles all the xi locations are 
		stored in floats and so when we change_element and are numerically just
		outside it can be a value as large as this */
#define SMALL_STEP (1e-4)

	ENTER(FE_element_shape_xi_increment);
	return_code=0;
	if (shape&&xi&&increment&&face_number_address&&
		get_FE_element_shape_dimension(shape,&dimension)&&(0<dimension))
	{
		/* working space */
		ALLOCATE(face_matrix,double,dimension*dimension);
		ALLOCATE(face_rhs,double,dimension);
		ALLOCATE(face_rhsB,double,dimension);
		ALLOCATE(pivot_index,int,dimension);
		if (xi_face&&face_matrix&&face_rhs&&pivot_index&&face_rhsB)
		{
			return_code=1;
			/* check if it is in the shape */
			face_number= -1;
			*step_size=(FE_value)1;
			face_to_element=shape->face_to_element;
			for (i=0;i<shape->number_of_faces;i++)
			{
				for (j=0;j<dimension;j++)
				{
					face_matrix[j*dimension]=(double)(-increment[j]);
					face_rhs[j]=(double)(xi[j]-(*face_to_element));
					face_to_element++;
					for (k=1;k<dimension;k++)
					{
						face_matrix[j*dimension+k]=(double)(*face_to_element);
						face_to_element++;
					}
				}
				/* Don't terminate if the LU_decompose fails as the matrix is 
					probably singular, just implying that we are travelling parallel
					to the face */
				if (LU_decompose(dimension,face_matrix,pivot_index,
					&determinant,/*singular_tolerance*/1.0e-12)&&
					LU_backsubstitute(dimension,face_matrix,
					pivot_index,face_rhs))
				{
					step_size_local=face_rhs[0];
					if ((step_size_local > -SMALL_STEP) && (step_size_local < SMALL_STEP) && ((FE_value)step_size_local<*step_size))
					{
						determinant = 0.0;
						for (j = 0 ; j < dimension ; j++)
						{
							determinant += shape->face_normals[i * dimension + j] *
								increment[j];
						}
						if (determinant > -SMALL_STEP)
						{
							/* We are stepping out of the element so this is a boundary */
							for (j=1;j<dimension;j++)
							{
								xi_face[j-1]=(FE_value)(face_rhs[j]);
							}
							face_number=i;
							*step_size=(FE_value)step_size_local; /* or set to zero exactly?? */
						}
					}
					else
					{
						if ((0 < step_size_local) && ((FE_value)step_size_local<*step_size))
						{
							for (j=1;j<dimension;j++)
							{
								xi_face[j-1]=(FE_value)(face_rhs[j]);
							}
							face_number=i;
							*step_size=(FE_value)step_size_local;
						}
					}
				}
			}
			*face_number_address=face_number;
			if (-1==face_number)
			{
				/* inside */
				for (i=0;i<dimension;i++)
				{
					xi[i] += increment[i];
					increment[i]=(FE_value)0;
				}
			}
			else
			{
				/* not inside */
				for (i=0;i<dimension;i++)
				{
					/* SAB Could use use face_to_element and face_xi to calculate
						updated xi location instead */
					xi[i] = xi[i] + *step_size * increment[i];
					increment[i] *= (1. - *step_size);
				}
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"FE_element_shape_xi_increment.  "
				"Could not allocate xi_face (%p), face_matrix (%p), face_rhs (%p), "
				"pivot_index (%p), face_rhsB (%p)",xi_face,face_matrix,face_rhs,
				pivot_index,face_rhsB);
			return_code=0;
		}
		DEALLOCATE(pivot_index);
		DEALLOCATE(face_rhs);
		DEALLOCATE(face_rhsB);
		DEALLOCATE(face_matrix);
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_shape_xi_increment.  "
			"Invalid argument(s).  %p %p %p %p %d",shape,xi,increment,
			face_number_address,dimension);
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_shape_xi_increment */

/*
Global functions
----------------
*/

PROTOTYPE_ENUMERATOR_STRING_FUNCTION(CM_field_type)
{
	char *enumerator_string;

	ENTER(ENUMERATOR_STRING(CM_field_type));
	switch (enumerator_value)
	{
		case CM_ANATOMICAL_FIELD:
		{
			enumerator_string = "anatomical";
		} break;
		case CM_COORDINATE_FIELD:
		{
			enumerator_string = "coordinate";
		} break;
		case CM_GENERAL_FIELD:
		{
			enumerator_string = "field";
		} break;
		default:
		{
			enumerator_string = (char *)NULL;
		} break;
	}
	LEAVE;

	return (enumerator_string);
} /* ENUMERATOR_STRING(CM_field_type) */

DEFINE_DEFAULT_ENUMERATOR_FUNCTIONS(CM_field_type)

struct FE_field_info *CREATE(FE_field_info)(struct FE_region *fe_region)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Creates a struct FE_field_info with a pointer to <fe_region>.
Note:
This should only be called by FE_region functions, and the FE_region must be
its own master. The returned object is owned by the FE_region.
It maintains a non-ACCESSed pointer to its owning FE_region which the FE_region
will clear before it is destroyed. If it becomes necessary to have other owners
of these objects, the common parts of it and FE_region should be extracted to a
common object.
==============================================================================*/
{
	struct FE_field_info *fe_field_info;

	ENTER(CREATE(FE_field_info));
	fe_field_info = (struct FE_field_info *)NULL;
	if (fe_region)
	{
		if (ALLOCATE(fe_field_info, struct FE_field_info, 1))
		{						
			/* maintain pointer to the the FE_region this information belongs to.
				 It is not ACCESSed since FE_region is the owning object and it
				 would prevent the FE_region from being destroyed. */
			fe_field_info->fe_region = fe_region;
			fe_field_info->access_count = 0;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_field_info).  Not enough memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_field_info).  Invalid argument(s)");
	}
	LEAVE;

	return (fe_field_info);
} /* CREATE(FE_field_info) */

int DESTROY(FE_field_info)(
	struct FE_field_info **fe_field_info_address)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Destroys the FE_field_info at *<field_info_address>. Frees the
memory for the information and sets <*field_info_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_field_info *fe_field_info;

	ENTER(DESTROY(FE_field_info));
	if ((fe_field_info_address) &&
		(fe_field_info = *fe_field_info_address))
	{
		if (0 == fe_field_info->access_count)
		{	
			DEALLOCATE(*fe_field_info_address);
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_field_info).  Non-zero access count");
			return_code = 0;
		}
		*fe_field_info_address = (struct FE_field_info *)NULL;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(FE_field_info).  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_field_info) */

DECLARE_OBJECT_FUNCTIONS(FE_field_info)

int FE_field_info_clear_FE_region(struct FE_field_info *field_info)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Clears the pointer to FE_region in <field_info>.
Private function only to be called by destroy_FE_region.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_info_clear_FE_region);
	if (field_info)
	{
		field_info->fe_region = (struct FE_region *)NULL;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_info_clear_FE_region.  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_info_clear_FE_region */

int get_FE_field_external_information(struct FE_field *field,
	struct FE_field_external_information **external_information)
/*******************************************************************************
LAST MODIFIED : 2 September 2001

DESCRIPTION :
Creates a copy of the <external_information> of the <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_external_information);
	return_code=0;
	if (field&&external_information)
	{
		if (field->external)
		{
			if (field->external->duplicate)
			{
				*external_information=(field->external->duplicate)(field->external);
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,"get_FE_field_external_information.  "
					"Invalid external field information");
			}
		}
		else
		{
			*external_information=(struct FE_field_external_information *)NULL;
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_external_information.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_external_information */

int set_FE_field_external_information(struct FE_field *field,
	struct FE_field_external_information *external_information)
/*******************************************************************************
LAST MODIFIED : 3 September 2001

DESCRIPTION :
Copies the <external_information> into the <field>.

Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_external_information);
	return_code=0;
	if (field)
	{
		return_code=1;
		if (field->external)
		{
			if (field->external->destroy)
			{
				(field->external->destroy)(&(field->external));
			}
			else
			{
				display_message(ERROR_MESSAGE,"set_FE_field_external_information.  "
					"Invalid external field information");
				return_code=0;
			}
		}
		if (external_information)
		{
			if (external_information->duplicate)
			{
				field->external=(external_information->duplicate)(external_information);
			}
			else
			{
				display_message(ERROR_MESSAGE,"set_FE_field_external_information.  "
					"Invalid external_information");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_external_information.  Invalid argument");
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_external_information */

struct FE_field *CREATE(FE_field)(char *name, struct FE_region *fe_region)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Creates and returns a struct FE_field of <name> belonging to the ultimate
master FE_region of <fe_region>. The new field has no name/identifier, zero
components, field_type FIELD, NOT_APPLICABLE coordinate system, no field values.
???RC Used to pass <fe_time> in here and store in FE_field; can now get it from
FE_region.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(CREATE(FE_field));
	field = (struct FE_field *)NULL;
	if (name && fe_region)
	{
		if (ALLOCATE(field, struct FE_field, 1))
		{
			return_code = 1;
			if (!(field->name = duplicate_string(name)))
			{
				return_code = 0;
			}
			/* get and ACCESS FE_field_info relating this field back to fe_region */
			if (!(field->info =
				ACCESS(FE_field_info)(FE_region_get_FE_field_info(fe_region))))
			{
				return_code = 0;
			}
			field->fe_field_type = GENERAL_FE_FIELD;
			field->indexer_field = (struct FE_field *)NULL;
			field->number_of_indexed_values = 0;
			field->cm_field_type = CM_GENERAL_FIELD;
			field->external = (struct FE_field_external_information *)NULL;
			field->number_of_components = 0;
			/* don't allocate component names until we have custom names */
			field->component_names = (char **)NULL;
			field->coordinate_system.type = NOT_APPLICABLE;
			field->number_of_values = 0;
			field->values_storage = (Value_storage *)NULL;
			field->value_type = UNKNOWN_VALUE;
			field->number_of_times = 0;
			field->time_value_type = UNKNOWN_VALUE;
			field->times = (Value_storage *)NULL;
			field->access_count = 0;
			if (!return_code)
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_field).  Could not construct contents");
				DEALLOCATE(field);
				field = (struct FE_field *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"CREATE(FE_field).  Not enough memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE, "CREATE(FE_field).  Invalid argument(s)");
	}
	LEAVE;

	return (field);
} /* CREATE(FE_field) */

int DESTROY(FE_field)(struct FE_field **field_address)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Frees the memory for the field and sets <*field_address> to NULL.
==============================================================================*/
{
	char **component_name;
	int i,return_code;
	struct FE_field *field;

	ENTER(DESTROY(FE_field));
	if ((field_address)&&(field= *field_address))
	{
		if (0==field->access_count)
		{
			/* free the field name */
			if (field->name)
			{
				DEALLOCATE(field->name);
			}
			DEACCESS(FE_field_info)(&field->info);
			REACCESS(FE_field)(&(field->indexer_field),(struct FE_field *)NULL);
			if (field->values_storage)
			{
				/* free any arrays pointed to by field->values_storage */
				free_value_storage_array(field->values_storage,field->value_type,
					(struct FE_time_sequence *)NULL,field->number_of_values);		
				/* free the global values */
				DEALLOCATE(field->values_storage);
			}

			/* free the component names */
			if (component_name=field->component_names)
			{
				for (i=field->number_of_components;i>0;i--)
				{
					DEALLOCATE(*component_name);
					component_name++;
				}
				DEALLOCATE(field->component_names);
			}
			DEALLOCATE(*field_address);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_field).  Non-zero access_count (%d)",field->access_count);
			return_code=0;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_field) */

int list_FE_field(struct FE_field *field,void *dummy)
/*******************************************************************************
LAST MODIFIED : 15 May 2003

DESCRIPTION :
Outputs the information contained in <field>.
==============================================================================*/
{
	char *component_name;
	int i, number_of_components, return_code;

	ENTER(list_FE_field);
	USE_PARAMETER(dummy);
	if (field)
	{
		return_code=1;
		/* write the identifier */
		display_message(INFORMATION_MESSAGE, "field : %s\n", field->name);
		display_message(INFORMATION_MESSAGE,
			"  access count = %d\n", field->access_count);
		display_message(INFORMATION_MESSAGE,"  type = %s",
			ENUMERATOR_STRING(CM_field_type)(field->cm_field_type));
		display_message(INFORMATION_MESSAGE,"  coordinate system = %s",
			ENUMERATOR_STRING(Coordinate_system_type)(field->coordinate_system.type));
		number_of_components=field->number_of_components;
		display_message(INFORMATION_MESSAGE,", #Components = %d\n",
			number_of_components);
		i=0;
		while (return_code&&(i<number_of_components))
		{
			if (component_name = get_FE_field_component_name(field, i))
			{
				display_message(INFORMATION_MESSAGE,"    %s", component_name);
				DEALLOCATE(component_name);
			}
			/* display field based information*/
			if (field->number_of_values)
			{	
				int count;

				display_message(INFORMATION_MESSAGE,"field based values: ");
				switch (field->value_type)
				{
					case FE_VALUE_VALUE:
					{
						display_message(INFORMATION_MESSAGE,"\n");
						/* output in columns if FE_VALUE_MAX_OUTPUT_COLUMNS > 0 */
						for (count=0;count<field->number_of_values;count++)
						{
							display_message(INFORMATION_MESSAGE," %"FE_VALUE_STRING,
								*((FE_value*)(field->values_storage + count*sizeof(FE_value))));
							if ((0<FE_VALUE_MAX_OUTPUT_COLUMNS)&&
								(0==((count+1) % DOUBLE_VALUE_MAX_OUTPUT_COLUMNS)))
							{
								display_message(INFORMATION_MESSAGE,"\n");
							}											
						}																							
					} break;
					default:
					{
						display_message(INFORMATION_MESSAGE,"list_FE_node_field: "
							"Can't display that field value_type yet. Write the code!");
					} break;
				}	/* switch () */							
			}
			display_message(INFORMATION_MESSAGE,"\n");
			i++;
		}
		
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_field.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_field */

DECLARE_OBJECT_FUNCTIONS(FE_field)

DECLARE_DEFAULT_GET_OBJECT_NAME_FUNCTION(FE_field)

DECLARE_INDEXED_LIST_FUNCTIONS(FE_field)
DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_field,name,char *,strcmp)
DECLARE_INDEXED_LIST_IDENTIFIER_CHANGE_FUNCTIONS(FE_field,name)

DECLARE_CHANGE_LOG_FUNCTIONS(FE_field)

int FE_field_copy_without_identifier(struct FE_field *destination,
	struct FE_field *source)
/*******************************************************************************
LAST MODIFIED : 16 December 2002

DESCRIPTION :
Copies the contents but not the name identifier of <source> to <destination>.
Function prototype should be in finite_element_private.h, so not public.
???RC Change to macro so identifier member can vary?
?COPY_WITHOUT_IDENTIFIER object_type,identifier
==============================================================================*/
{
	char **component_names;
	int i, return_code;
	Value_storage *times, *values_storage;

	ENTER(FE_field_copy_without_identifier);
	if (destination && source)
	{
		return_code=1;
		component_names=(char **)NULL;
		values_storage=(Value_storage *)NULL;
		times=(Value_storage *)NULL;
		if (source->component_names)
		{
			if (ALLOCATE(component_names,char *,source->number_of_components))
			{
				for (i=0;i<source->number_of_components;i++)
				{
					component_names[i]=(char *)NULL;
				}
				/* copy the old names, clear any new ones */
				for (i=0;i<(source->number_of_components)&&return_code;i++)
				{
					if (source->component_names[i])
					{
						if (ALLOCATE(component_names[i],char,
							strlen(source->component_names[i])+1))
						{
							strcpy(component_names[i],source->component_names[i]);
						}
						else
						{
							return_code=0;
						}
					}
				}
			}
			else
			{
				return_code=0;
			}
		}
		if (0<source->number_of_values)
		{
			if (!((values_storage=make_value_storage_array(source->value_type,
				(struct FE_time_sequence *)NULL,source->number_of_values))&&
				copy_value_storage_array(values_storage,source->value_type,
					(struct FE_time_sequence *)NULL,(struct FE_time_sequence *)NULL,
					source->number_of_values,source->values_storage)))
			{
				return_code=0;
			}
		}
		if (0<source->number_of_times)
		{
			if (!((times=make_value_storage_array(source->time_value_type,
				(struct FE_time_sequence *)NULL,source->number_of_times))&&
				copy_value_storage_array(times,source->time_value_type,
					(struct FE_time_sequence *)NULL,(struct FE_time_sequence *)NULL,
					source->number_of_times,source->times)))
			{
				return_code=0;
			}
		}
		if (return_code)
		{
			REACCESS(FE_field_info)(&(destination->info), source->info);
			destination->cm_field_type=source->cm_field_type;
			if (destination->external)
			{
				if (destination->external->destroy)
				{
					(destination->external->destroy)(&(destination->external));
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_field_copy_without_identifier.  "
						"Invalid destination->external");
				}
			}
			if (source->external)
			{
				if (source->external->duplicate)
				{
					destination->external=(source->external->duplicate)(
						source->external);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_field_copy_without_identifier.  "
						"Invalid source->external");
				}
			}
			destination->fe_field_type=source->fe_field_type;
			REACCESS(FE_field)(&(destination->indexer_field),
				source->indexer_field);
			destination->number_of_indexed_values=
				source->number_of_indexed_values;
			if (destination->component_names)
			{
				for (i = 0; i < destination->number_of_components; i++)
				{
					if (destination->component_names[i])
					{
						DEALLOCATE(destination->component_names[i]);
					}
				}
				DEALLOCATE(destination->component_names);
			}
			destination->number_of_components=source->number_of_components;
			destination->component_names=component_names;
			COPY(Coordinate_system)(&(destination->coordinate_system),
				&(source->coordinate_system));
			destination->value_type=source->value_type;
			destination->time_value_type=source->time_value_type;
			/* replace old values_storage with new */
			if (0<destination->number_of_values)
			{
				free_value_storage_array(destination->values_storage,
					destination->value_type,(struct FE_time_sequence *)NULL,
					destination->number_of_values);
				DEALLOCATE(destination->values_storage);
			}
			destination->number_of_values=source->number_of_values;
			destination->values_storage=values_storage;
			/* replace old times with new */
			if (0<destination->number_of_times)
			{
				free_value_storage_array(destination->times,
					destination->time_value_type,(struct FE_time_sequence *)NULL,
					destination->number_of_times);
				DEALLOCATE(destination->times);
			}
			destination->number_of_times=source->number_of_times;
			destination->times=times;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_field_copy_without_identifier.  "
				"Could not copy dynamic contents");
		}
		if (!return_code)
		{
			if (component_names)
			{
				for (i=0;i<source->number_of_components;i++)
				{
					if (component_names[i])
					{
						DEALLOCATE(component_names[i]);
					}
				}
				DEALLOCATE(component_names);
			}
			if (values_storage)
			{
				free_value_storage_array(values_storage,source->value_type,
					(struct FE_time_sequence *)NULL,source->number_of_values);
				DEALLOCATE(values_storage);
			}
			if (times)
			{
				free_value_storage_array(times,source->time_value_type,
					(struct FE_time_sequence *)NULL,source->number_of_times);
				DEALLOCATE(times);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_copy_without_identifier.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_copy_without_identifier */

int FE_field_matches_description(struct FE_field *field,char *name,
	enum FE_field_type fe_field_type,struct FE_field *indexer_field,
	int number_of_indexed_values,enum CM_field_type cm_field_type,
	struct Coordinate_system *coordinate_system,enum Value_type value_type,
	int number_of_components,char **component_names,
	int number_of_times,enum Value_type time_value_type,
	struct FE_field_external_information *external)
/*******************************************************************************
LAST MODIFIED : 31 August 2001

DESCRIPTION :
Returns true if <field> has exactly the same <name>, <field_info>... etc. as
those given in the parameters.
==============================================================================*/
{
	char *component_name,*field_component_name;
	int i,return_code;

	ENTER(FE_field_matches_description);
	/* does not match until proven so */
	return_code=0;
	if (field&&name&&coordinate_system&&(0<=number_of_times))
	{
		if (field->name&&(0==strcmp(field->name,name))&&
			(fe_field_type==field->fe_field_type)&&
			((INDEXED_FE_FIELD != fe_field_type)||
				((indexer_field==field->indexer_field)&&
					(number_of_indexed_values==field->number_of_indexed_values)))&&
			(cm_field_type==field->cm_field_type)&&
			Coordinate_systems_match(&(field->coordinate_system),coordinate_system)&&
			(value_type == field->value_type)&&
			(number_of_components==field->number_of_components)&&
			(number_of_times==field->number_of_times)&&
			(time_value_type == field->time_value_type))
		{
			/* matches until disproven */
			return_code=1;
			/* check external */
			if (external)
			{
				if (field->external)
				{
					if ((external->compare)&&
						(external->compare==field->external->compare))
					{
						if ((external->compare)(external,field->external))
						{
							return_code=0;
						}
					}
					else
					{
						return_code=0;
					}
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				if (field->external)
				{
					return_code=0;
				}
			}
			/* check the component names match */
			i=number_of_components;
			while ((i>0)&&return_code)
			{
				i--;
				if ((field_component_name=
					get_automatic_component_name(field->component_names,i))&&
					(component_name=get_automatic_component_name(component_names,i)))
				{
					if (strcmp(component_name,field_component_name))
					{
						return_code=0;
					}
					DEALLOCATE(component_name);
				}
				else
				{
					return_code=0;
				}
				DEALLOCATE(field_component_name);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_matches_description.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_matches_description */

int FE_fields_match_fundamental(struct FE_field *field1,
	struct FE_field *field2)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Returns true if <field1> and <field2> describe the same fundamental quantities
including number of components, value type etc. which should be sufficient to
allow field1 and field2 to be interchanged without affecting the rest of the
program. Check this function fits will with FE_fields_match_exact.
Does not check the fields have the same name as this is a trivial change.
???RC Made fe_field_type a fundamental propery.
==============================================================================*/
{
	int return_code;

	ENTER(FE_fields_match_fundamental);
	if (field1 && field2)
	{
		if ((field1->value_type == field2->value_type) &&
			(field1->fe_field_type == field2->fe_field_type) &&
			(field1->number_of_components == field2->number_of_components) &&
			Coordinate_systems_match(&(field1->coordinate_system),
				&(field2->coordinate_system)))
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_fields_match_fundamental.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_fields_match_fundamental */

int FE_fields_match_exact(struct FE_field *field1, struct FE_field *field2)
/*******************************************************************************
LAST MODIFIED : 30 April 2003

DESCRIPTION :
Returns true if <field1> and <field2> have exactly the same contents.
==============================================================================*/
{
	char *component_name1, *component_name2;
	int i, return_code;

	ENTER(FE_fields_match_exact);
	/* does not match until proven so */
	return_code=0;
	if (field1 && field2)
	{
		if ((0 == strcmp(field1->name, field2->name)) &&
			(field1->fe_field_type == field2->fe_field_type) &&
			((INDEXED_FE_FIELD != field1->fe_field_type) ||
				(field1->indexer_field && field2->indexer_field &&
					(0 == strcmp(field1->indexer_field->name,
						field2->indexer_field->name)) &&
					FE_fields_match_fundamental(field1->indexer_field,
						field2->indexer_field) &&
					(field1->number_of_indexed_values ==
						field2->number_of_indexed_values))) &&
			(field1->cm_field_type == field2->cm_field_type) &&
			Coordinate_systems_match(&(field1->coordinate_system),
				&(field2->coordinate_system)) &&
			(field1->value_type == field2->value_type) &&
			(field1->number_of_components == field2->number_of_components) &&
			(field1->number_of_times == field2->number_of_times) &&
			(field1->time_value_type == field2->time_value_type))
		{
			/* matches until disproven */
			return_code = 1;
			/* check external */
			if (field1->external)
			{
				if (field2->external)
				{
					if ((field1->external->compare) &&
						(field1->external->compare == field2->external->compare))
					{
						if ((field1->external->compare)(field1->external, field2->external))
						{
							return_code = 0;
						}
					}
					else
					{
						return_code = 0;
					}
				}
				else
				{
					return_code = 0;
				}
			}
			else
			{
				if (field2->external)
				{
					return_code = 0;
				}
			}
			/* check the component names match */
			i = field1->number_of_components;
			while ((i > 0) && return_code)
			{
				i--;
				component_name1 =
					get_automatic_component_name(field1->component_names, i);
				component_name2 =
					get_automatic_component_name(field2->component_names, i);
				if (component_name1 && component_name2)
				{
					if (strcmp(component_name1, component_name2))
					{
						return_code = 0;
					}
				}
				else
				{
					return_code = 0;
				}
				DEALLOCATE(component_name2);
				DEALLOCATE(component_name1);
			}
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_fields_match_exact.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_fields_match_exact */

int FE_field_can_be_merged(struct FE_field *field, void *field_list_void)
/*******************************************************************************
LAST MODIFIED : 14 November 2002

DESCRIPTION :
Fetches a field with the same name as <field> from <field_list>.
Returns true if there is either no such field in the list or two fields are
identically defined.
==============================================================================*/
{
	int return_code;
	struct FE_field *other_field;
	struct LIST(FE_field) *field_list;

	ENTER(FE_field_can_be_merged);
	return_code = 0;
	if (field && (field_list = (struct LIST(FE_field) *)field_list_void))
	{
		if (other_field = FIND_BY_IDENTIFIER_IN_LIST(FE_field,name)(field->name,
			field_list))
		{
			if (FE_fields_match_fundamental(field, other_field))
			{
				return_code = 1;
			}
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_can_be_merged.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_can_be_merged */

int FE_field_has_multiple_times(struct FE_field *fe_field)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Returns true if any node_fields corresponding to <field> have time_sequences.
This will be improved when regionalised, so that hopefully the node field
list we will be looking at will not be global but will belong to the region.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_has_multiple_times);
	if (fe_field)
	{
		return_code = FE_region_FE_field_has_multiple_times(
			FE_field_get_FE_region(fe_field), fe_field);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_has_multiple_times.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_has_multiple_times */

int ensure_FE_field_is_in_list(struct FE_field *field, void *field_list_void)
/*******************************************************************************
LAST MODIFIED : 29 March 2006

DESCRIPTION :
Iterator function for adding <field> to <field_list> if not currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_field) *field_list;

	ENTER(ensure_FE_field_is_in_list);
	if (field&&(field_list=(struct LIST(FE_field) *)field_list_void))
	{
		if (!IS_OBJECT_IN_LIST(FE_field)(field,field_list))
		{
			return_code=ADD_OBJECT_TO_LIST(FE_field)(field,field_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_field_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_field_is_in_list */

int set_FE_field(struct Parse_state *state,void *field_address_void,
	void *fe_field_list_void)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Modifier function to set the field from the command line.
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct FE_field **field_address,*temp_FE_field;
	struct LIST(FE_field) *fe_field_list;

	ENTER(set_FE_field);
	if (state&&(field_address=(struct FE_field **)field_address_void)&&
		(fe_field_list=(struct LIST(FE_field) *)fe_field_list_void))
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (fuzzy_string_compare(current_token,"NONE"))
				{
					if (*field_address)
					{
						DEACCESS(FE_field)(field_address);
						*field_address=(struct FE_field *)NULL;
					}
					return_code=shift_Parse_state(state,1);
				}
				else
				{
					if (temp_FE_field=FIND_BY_IDENTIFIER_IN_LIST(FE_field,name)(
						current_token,fe_field_list))
					{
						if (*field_address!=temp_FE_field)
						{
							DEACCESS(FE_field)(field_address);
							*field_address=ACCESS(FE_field)(temp_FE_field);
						}
						return_code=shift_Parse_state(state,1);
					}
					else
					{
						display_message(ERROR_MESSAGE,"Unknown field: %s",current_token);
						display_parse_state_location(state);
						return_code=0;
					}
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," FIELD_NAME|none");
				if (temp_FE_field= *field_address)
				{
					display_message(INFORMATION_MESSAGE,"[%s]",temp_FE_field->name);
				}
				else
				{
					display_message(INFORMATION_MESSAGE,"[none]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing field name");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_field.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field */

int set_FE_field_conditional(struct Parse_state *state,
	void *field_address_void,void *set_field_data_void)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Modifier function to set the field from a command. <set_field_data_void> should
point to a struct Set_FE_field_conditional_data containing the
fe_field_list and an optional conditional function for narrowing the
range of fields available for selection. If the conditional_function is NULL,
this function works just like set_FE_field.
==============================================================================*/
{
	char *current_token;
	int return_code;
	struct FE_field **field_address,*selected_field,*temp_field;
	struct Set_FE_field_conditional_data *set_field_data;

	ENTER(set_FE_field_conditional);
	if (state&&(field_address=(struct FE_field **)field_address_void)&&
		(set_field_data=
			(struct Set_FE_field_conditional_data *)set_field_data_void)&&
		set_field_data->fe_field_list)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (fuzzy_string_compare(current_token,"NONE"))
				{
					if (*field_address)
					{
						DEACCESS(FE_field)(field_address);
						*field_address=(struct FE_field *)NULL;
					}
					return_code=1;
				}
				else
				{
					if (selected_field=
						FIND_BY_IDENTIFIER_IN_LIST(FE_field,name)(current_token,
						set_field_data->fe_field_list))
					{
						if ((NULL==set_field_data->conditional_function)||
							((set_field_data->conditional_function)(selected_field,
								set_field_data->conditional_function_user_data)))
						{
							if (*field_address != selected_field)
							{
								DEACCESS(FE_field)(field_address);
								*field_address=ACCESS(FE_field)(selected_field);
							}
							return_code=1;
						}
						else
						{
							display_message(ERROR_MESSAGE,"Field of incorrect type : %s",
								current_token);
							return_code=0;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,"Unknown field : %s",current_token);
						return_code=0;
					}
				}
				shift_Parse_state(state,1);
			}
			else
			{
				display_message(INFORMATION_MESSAGE," FIELD_NAME|none");
				/* if possible, then write the name */
				if (temp_field= *field_address)
				{
					display_message(INFORMATION_MESSAGE,"[%s]",temp_field->name);
				}
				else
				{
					display_message(INFORMATION_MESSAGE,"[none]");
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing field name");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_conditional.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_conditional */

int set_FE_fields(struct Parse_state *state,
	void *field_order_info_address_void, void *fe_field_list_void)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Modifier function to set an ordered list of fields, each separated by white
space until an unrecognised field name is encountered. Two special tokens are
understood in place of any fields: 'all' and 'none'.
For the case of 'all', a NULL FE_field_order_info structure is returned.
For the case of 'none', an empty FE_field_order_info structure is returned.
It is up to the calling function to destroy any FE_field_order_info structure
returned by this function, however, any such structure passed to this function
may be destroyed here - ie. in the 'all' case.
==============================================================================*/
{
	char *current_token;
	int i, number_of_fields, return_code;
	struct FE_field *field;
	struct FE_field_order_info **field_order_info_address;
	struct LIST(FE_field) *fe_field_list;

	ENTER(set_FE_fields);
	if (state && (field_order_info_address =
		(struct FE_field_order_info **)field_order_info_address_void) &&
		(fe_field_list = (struct LIST(FE_field) *)fe_field_list_void))
	{
		if (current_token = state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING, current_token) &&
				strcmp(PARSER_RECURSIVE_HELP_STRING, current_token))
			{
				return_code = 1;
				if (fuzzy_string_compare(current_token, "ALL"))
				{
					/* return a NULL field_order_info for the ALL case */
					if (*field_order_info_address)
					{
						DESTROY(FE_field_order_info)(field_order_info_address);
						*field_order_info_address = (struct FE_field_order_info *)NULL;
					}
					shift_Parse_state(state, 1);
				}
				else if ((*field_order_info_address &&
					clear_FE_field_order_info(*field_order_info_address)) ||
					(*field_order_info_address = CREATE(FE_field_order_info)()))
				{
					if (fuzzy_string_compare(current_token, "NONE"))
					{
						/* return the empty FE_field_order_info for the NONE case */
						shift_Parse_state(state, 1);
					}
					else
					{
						/* find fields by name in the parse state until one is not
							 recognized or there are no more tokens */
						while (return_code && (current_token = state->current_token) &&
							(field = FIND_BY_IDENTIFIER_IN_LIST(FE_field, name)(
								current_token, fe_field_list)))
						{
							if (!(add_FE_field_order_info_field(*field_order_info_address,
								field) && shift_Parse_state(state, 1)))
							{
								display_message(ERROR_MESSAGE,
									"set_FE_fields.  Could not add field to list");
								return_code = 0;
							}
						}
						if (0 == get_FE_field_order_info_number_of_fields(
							*field_order_info_address))
						{
							display_message(ERROR_MESSAGE,
								"Unknown field : %s", current_token);
							return_code = 0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE, "set_FE_fields.  Not enough memory");
					return_code = 0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE, " FIELD_NAMES|all|none");
				if (*field_order_info_address)
				{
					number_of_fields = get_FE_field_order_info_number_of_fields(
						*field_order_info_address);
					if (0 == number_of_fields)
					{
						display_message(INFORMATION_MESSAGE, "[none]");
					}
					else
					{
						display_message(INFORMATION_MESSAGE, "[");
						for (i = 0; i < number_of_fields; i++)
						{
							if (0 < i)
							{
								display_message(INFORMATION_MESSAGE, " ");
							}
							if (field =
								get_FE_field_order_info_field(*field_order_info_address, i))
							{
								display_message(INFORMATION_MESSAGE, "%s", field->name);
							}
						}
						display_message(INFORMATION_MESSAGE, "]");
					}
				}
				else
				{
					display_message(INFORMATION_MESSAGE, "[all]");
				}
				return_code = 1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE, "Missing field specifications");
			display_parse_state_location(state);
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE, "set_FE_fields.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_fields */

int FE_field_has_value_type(struct FE_field *field,
	void *user_data_value_type)
/*******************************************************************************
LAST MODIFIED : 4 May 1999

DESCRIPTION :
Returns true if the VALUE_TYPE specified in the <user_data_value_type> matches
the VALUE_TYPE of the <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_value_type);
	if (field)
	{
		if (((enum Value_type)user_data_value_type)==field->value_type)
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_has_value_type.  Invalid field");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_has_value_type */

struct FE_region *FE_field_get_FE_region(struct FE_field *fe_field)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Returns the FE_region that <fe_field> belongs to.
==============================================================================*/
{
	struct FE_region *fe_region;

	ENTER(FE_field_get_FE_region);
	if (fe_field && fe_field->info)
	{
		fe_region = fe_field->info->fe_region;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_get_FE_region.  Invalid argument(s)");
		fe_region = (struct FE_region *)NULL;
	}
	LEAVE;

	return (fe_region);
} /* FE_field_get_FE_region */

int FE_field_set_FE_field_info(struct FE_field *fe_field,
	struct FE_field_info *fe_field_info)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Changes the FE_field_info at <fe_field> to <fe_field_info>.
Private function only to be called by FE_region when merging FE_regions!
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_set_FE_field_info);
	if (fe_field && fe_field_info)
	{
		return_code =
			REACCESS(FE_field_info)(&(fe_field->info), fe_field_info);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_set_FE_field_info.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_set_FE_field_info */

int FE_field_get_access_count(struct FE_field *fe_field)
/*******************************************************************************
LAST MODIFIED : 11 March 2003

DESCRIPTION :
Returns the FE_region that <fe_field> belongs to.
==============================================================================*/
{
	int access_count;

	ENTER(FE_field_get_access_count);
	if (fe_field)
	{
		access_count = fe_field->access_count;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_get_access_count.  Invalid argument(s)");
		access_count = 0;
	}
	LEAVE;

	return (access_count);
} /* FE_field_get_access_count */

char *get_FE_field_component_name(struct FE_field *field,int component_no)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Returns the name of component <component_no> of <field>. If no name is stored
for the component, a string comprising the value component_no+1 is returned.
Up to calling function to DEALLOCATE the returned string.
==============================================================================*/
{
	char *component_name;

	ENTER(get_FE_field_component_name);
	if (field&&(0<=component_no)&&(component_no<field->number_of_components))
	{
		component_name=
			get_automatic_component_name(field->component_names,component_no);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_component_name.  Invalid argument(s)");
		component_name=(char *)NULL;
	}
	LEAVE;

	return (component_name);
} /* get_FE_field_component_name */

int set_FE_field_component_name(struct FE_field *field,int component_no,
	char *component_name)
/*******************************************************************************
LAST MODIFIED : 10 May 2000

DESCRIPTION :
Sets the name of component <component_no> of <field>. Only sets name if it is
different from that already returned for field to preserve default names if can.
==============================================================================*/
{
	char *temp_component_name;
	int different_name,i,return_code;

	ENTER(set_FE_field_component_name);
	if (field&&(0<=component_no)&&(component_no<field->number_of_components)&&
		component_name)
	{
		if (temp_component_name=get_FE_field_component_name(field,component_no))
		{
			different_name=strcmp(temp_component_name,component_name);
			DEALLOCATE(temp_component_name);
		}
		else
		{
			different_name=1;
		}
		if (different_name)
		{
			if (ALLOCATE(temp_component_name,char,strlen(component_name)+1))
			{
				strcpy(temp_component_name,component_name);
				/* component_names array may be non-existent if default names used */
				if (field->component_names)
				{
					if (field->component_names[component_no])
					{
						DEALLOCATE(field->component_names[component_no]);
					}
				}
				else
				{
					if (ALLOCATE(field->component_names,char *,
						field->number_of_components))
					{
						/* clear the pointers to names */
						for (i=0;i<field->number_of_components;i++)
						{
							field->component_names[i]=(char *)NULL;
						}
					}
				}
				if (field->component_names)
				{
					field->component_names[component_no]=temp_component_name;
					return_code=1;
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				return_code=0;
			}
		}
		else
		{
			return_code=1;
		}
		if (!return_code)
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_component_name.  Not enough memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_component_name.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_component_name */

struct Coordinate_system *get_FE_field_coordinate_system(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 22 January 1999

DESCRIPTION :
Returns a pointer to the coordinate system for the <field>.
???RC Should not be returning pointer to internal structure; change to
fill struct Coordinate_system at address passed to this function.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;

	ENTER(get_FE_field_coordinate_system);
	if (field)
	{
		coordinate_system = &field->coordinate_system;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_coordinate_system.  Invalid field");
		coordinate_system = (struct Coordinate_system *)NULL;	
	}
	LEAVE;

	return (coordinate_system);
} /* get_FE_field_coordinate_system */

int set_FE_field_coordinate_system(struct FE_field *field,
	struct Coordinate_system *coordinate_system)
/*******************************************************************************
LAST MODIFIED : 28 January 1999

DESCRIPTION :
Sets the coordinate system of the <field>.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_coordinate_system);
	if (field&&coordinate_system)
	{
		return_code=
			COPY(Coordinate_system)(&field->coordinate_system,coordinate_system);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_coordinate_system.  Invalid argument(s)");
		return_code=0;	
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_coordinate_system */

int get_FE_field_number_of_components(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 16 November 1998

DESCRIPTION :
Returns the number of components for the <field>.
==============================================================================*/
{
	int number_of_components;

	ENTER(get_FE_field_number_of_components);
	if (field)
	{
		number_of_components=field->number_of_components;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_number_of_components.  Missing field");
		number_of_components=0;
	}
	LEAVE;

	return (number_of_components);
} /* get_FE_field_number_of_components */

int set_FE_field_number_of_components(struct FE_field *field,
	int number_of_components)
/*******************************************************************************
LAST MODIFIED : 16 January 2002

DESCRIPTION :
Sets the number of components in the <field>. Automatically assumes names for
any new components. Clears/reallocates the values_storage for FE_field_types
that use them, eg. CONSTANT_FE_FIELD and INDEXED_FE_FIELD - but only if number
of components changes. If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	char **component_names;
	int i,number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_number_of_components);
	if (field&&(0<number_of_components))
	{
		return_code=1;
		if (number_of_components != field->number_of_components)
		{
			/* 1. make dynamic allocations for number_of_components-specific data */
			component_names=(char **)NULL;
			if (field->component_names)
			{
				if (ALLOCATE(component_names,char *,number_of_components))
				{
					/* copy the old names, clear any new ones */
					for (i=0;i<number_of_components;i++)
					{
						if (i<field->number_of_components)
						{
							component_names[i]=field->component_names[i];
						}
						else
						{
							component_names[i]=(char *)NULL;
						}
					}
				}
				else
				{
					return_code=0;
				}
			}
			values_storage=(Value_storage *)NULL;
			number_of_values=0;
			switch (field->fe_field_type)
			{
				case CONSTANT_FE_FIELD:
				{
					number_of_values=number_of_components;
				} break;
				case GENERAL_FE_FIELD:
				{
					number_of_values=0;
				} break;
				case INDEXED_FE_FIELD:
				{
					number_of_values=field->number_of_indexed_values*number_of_components;
				} break;
				default:
				{
					return_code=0;
				}
			}
			if (number_of_values != field->number_of_values)
			{
				if (!(values_storage=make_value_storage_array(field->value_type,
					(struct FE_time_sequence *)NULL,number_of_values)))
				{
					return_code=0;
				}
			}
			if (return_code)
			{
				/* 2. free current number_of_components-specific data */
				if (field->component_names)
				{
					/* free component_names no longer used */
					for (i = number_of_components; i < field->number_of_components; i++)
					{
						if (field->component_names[i])
						{
							DEALLOCATE(field->component_names[i]);
						}
					}
					DEALLOCATE(field->component_names);
				}
				if (field->values_storage)
				{
					free_value_storage_array(field->values_storage,field->value_type,
						(struct FE_time_sequence *)NULL,field->number_of_values);		
					DEALLOCATE(field->values_storage);
				}
				/* 3. establish the new number_of_components and associated data */
				field->number_of_components=number_of_components;
				field->component_names=component_names;
				field->values_storage=values_storage;
				field->number_of_values=number_of_values;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_field_number_of_components.  Not enough memory");
				DEALLOCATE(component_names);
				DEALLOCATE(values_storage);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_number_of_components.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_number_of_components */

int get_FE_field_number_of_values(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 18 November 1998

DESCRIPTION :
Returns the number of global values for the <field>.
==============================================================================*/
{
	int number_of_values;

	ENTER(get_FE_field_number_of_values);
	if (field)
	{
		number_of_values=field->number_of_values;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_number_of_values.  Invalid field");
		number_of_values=0;
	}
	LEAVE;

	return (number_of_values);
} /* get_FE_field_number_of_values */

int get_FE_field_number_of_times(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Returns the number of global times for the <field>.
==============================================================================*/
{
	int number_of_times;

	ENTER(get_FE_field_number_of_times);
	if (field)
	{
		number_of_times=field->number_of_times;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_number_of_times.  Invalid field");
		number_of_times=0;
	}
	LEAVE;

	return (number_of_times);
} /* get_FE_field_number_of_times */

int set_FE_field_number_of_times(struct FE_field *field,
	int number_of_times)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Sets the number of times stored with the <field>
REALLOCATES the requires memory in field->value_storage, based upon the 
field->time_value_type. 

For non-array types, the contents of field->times_storage is:
   | data type (eg FE_value) | x number_of_times

For array types, the contents of field->times is:
   ( | int (number of array values) | pointer to array (eg double *) | x number_of_times )

Sets data in this memory to 0, pointers to NULL.

MUST have called set_FE_field_time_value_type before calling this function.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int i,j, return_code,size;
	Value_storage *new_value, *times;

	ENTER(set_FE_field_number_of_times);
	if (field&&(0<=number_of_times))
	{					
		return_code=1;
		if (number_of_times != 0)
		{	
			field->number_of_times=number_of_times;			
			size = get_Value_storage_size(field->time_value_type,
				(struct FE_time_sequence *)NULL);		

			if (REALLOCATE(times,field->times,Value_storage,
				size*number_of_times))	
			{		
				field->times = times;		 	
				for (i=0;i<number_of_times;i++)
				{
					switch (field->time_value_type) 
					{
						/* set values to zero*/
						case DOUBLE_VALUE: 
						{						
							*((double *)times) = 0;
						}	break;
						case ELEMENT_XI_VALUE:
						{						
							new_value = times;
							*((struct FE_element **)new_value) = (struct FE_element *)NULL;
							new_value+=sizeof(struct FE_element *);
							for (j = 0 ; j < MAXIMUM_ELEMENT_XI_DIMENSIONS ; j++)
							{
								*((FE_value *)new_value) = 0;
								new_value+=sizeof(FE_value);
							}
						}	break;
						case FE_VALUE_VALUE:
						{						
							*((FE_value *)times) = 0;
						}	break;
						case FLT_VALUE: 
						{							
							*((float *)times) = 0;
						} break;	
						case SHORT_VALUE: 
						{							
							display_message(ERROR_MESSAGE," set_FE_field_number_of_times." 
								"SHORT_VALUE. Code not written yet. Beware alignment problems ");
							return_code =0;
						} break;
						case INT_VALUE: 
						{						
							*((int *)times) = 0;
						}	break;	
						case UNSIGNED_VALUE: 
						{							
							*((unsigned *)times) = 0;
						}	break;
						/* set number of array values to 0, array pointers to NULL*/
						case DOUBLE_ARRAY_VALUE:
						{ 						
							double **array_address;
							/* copy the number of array values (0!) to times*/						
							*((int *)times) = 0;
							/* copy the pointer to the array values (currently NULL), to times*/
							array_address = (double **)(times+sizeof(int));
							*array_address = (double *)NULL;
						} break;
						case FE_VALUE_ARRAY_VALUE:				
						{	
							FE_value **array_address;												
							*((int *)times) = 0;						
							array_address = (FE_value **)(times+sizeof(int));
							*array_address = (FE_value *)NULL;
						} break;
						case FLT_ARRAY_VALUE:			
						{		
							float **array_address;												
							*((int *)times) = 0;						
							array_address = (float **)(times+sizeof(int));
							*array_address = (float *)NULL;
						} break;	
						case SHORT_ARRAY_VALUE:			
						{		
							short **array_address;												
							*((int *)times) = 0;						
							array_address = (short **)(times+sizeof(int));
							*array_address = (short *)NULL;
						} break;			
						case INT_ARRAY_VALUE:								
						{	
							int **array_address;												
							*((int *)times) = 0;						
							array_address = (int **)(times+sizeof(int));
							*array_address = (int *)NULL;
						} break;	
						case UNSIGNED_ARRAY_VALUE:			
						{ 
							unsigned **array_address;												
							*((int *)times) = 0;						
							array_address = (unsigned **)(times+sizeof(int));
							*array_address = (unsigned *)NULL;
						} break;	
						case STRING_VALUE:
						{	
							char **str_address;							
							str_address = (char **)(times);
							*str_address = (char *)NULL;	
						} break;
						case UNKNOWN_VALUE:
						{
							display_message(ERROR_MESSAGE," set_FE_field_number_of_times." 
								" UNKNOWN_VALUE");
							return_code =0;
						} break;
					}	/*	switch (field->time_value_type) */				
					times += size;	
				}/* (i=0;i<number_of_times;i++) */
			}/* if (REALLOCATE */
			else
			{
				display_message(ERROR_MESSAGE,"set_FE_field_number_of_times."
					" Not enough memory");
				return_code=0;
			}	
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_number_of_times.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_number_of_times */

int get_FE_field_access_count(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 17 August 1999

DESCRIPTION :Debug function. May be naughty.
==============================================================================*/
{
	int access_count;
	if (field)
	{
		access_count=field->access_count;
	}
	else
	{
		access_count=-1;
	}
	return (access_count);
}

enum CM_field_type get_FE_field_CM_field_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 30 August 2001

DESCRIPTION :
Returns the CM_field_type for the <field>.
==============================================================================*/
{
	enum CM_field_type type;

	ENTER(get_FE_field_CM_field_type);
	if (field)
	{
		type=field->cm_field_type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_CM_field_type.  Invalid field");
		type=CM_GENERAL_FIELD;
	}
	LEAVE;

	return (type);
} /* get_FE_field_CM_field_type */

int set_FE_field_CM_field_type(struct FE_field *field,
	enum CM_field_type cm_field_type)
/*******************************************************************************
LAST MODIFIED : 30 August 2001

DESCRIPTION :
Sets the CM_field_type of the <field>.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_CM_field_type);
	if (field)
	{
		field->cm_field_type=cm_field_type;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_CM_field_type.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_CM_field_type */

enum FE_field_type get_FE_field_FE_field_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 31 August 1999

DESCRIPTION :
Returns the FE_field_type for the <field>.
==============================================================================*/
{
	enum FE_field_type fe_field_type;

	ENTER(get_FE_field_FE_field_type);
	if (field)
	{
		fe_field_type=field->fe_field_type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_FE_field_type.  Invalid field");
		fe_field_type=UNKNOWN_FE_FIELD;
	}
	LEAVE;

	return (fe_field_type);
} /* get_FE_field_FE_field_type */

int set_FE_field_type_constant(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Converts the <field> to type CONSTANT_FE_FIELD.
Allocates and clears the values_storage of the field to fit
field->number_of_components of the current value_type.
If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_type_constant);
	return_code=0;
	if (field)
	{
		/* 1. make dynamic allocations for any new type-specific data */
		number_of_values=field->number_of_components;
		if (values_storage=make_value_storage_array(field->value_type,
			(struct FE_time_sequence *)NULL,number_of_values))
		{
			/* 2. free current type-specific data */
			if (field->values_storage)
			{
				free_value_storage_array(field->values_storage,field->value_type,
					(struct FE_time_sequence *)NULL,field->number_of_values);		
				DEALLOCATE(field->values_storage);
			}
			REACCESS(FE_field)(&(field->indexer_field),NULL);
			field->number_of_indexed_values=0;
			/* 3. establish the new type */
			field->fe_field_type=CONSTANT_FE_FIELD;
			field->values_storage=values_storage;
			field->number_of_values=number_of_values;
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_type_constant.  Could not allocate values_storage");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_type_constant.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_type_constant */

int set_FE_field_type_general(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Converts the <field> to type GENERAL_FE_FIELD.
Frees any values_storage currently in use by the field.
If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_type_general);
	return_code=0;
	if (field)
	{
		/* 1. make dynamic allocations for any new type-specific data */
		/* none */
		/* 2. free current type-specific data */
		if (field->values_storage)
		{
			free_value_storage_array(field->values_storage,field->value_type,
				(struct FE_time_sequence *)NULL,field->number_of_values);		
			DEALLOCATE(field->values_storage);
		}
		REACCESS(FE_field)(&(field->indexer_field),NULL);
		field->number_of_indexed_values=0;
		/* 3. establish the new type */
		field->fe_field_type=GENERAL_FE_FIELD;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_type_general.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_type_general */

int get_FE_field_type_indexed(struct FE_field *field,
	struct FE_field **indexer_field,int *number_of_indexed_values)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
If the field is of type INDEXED_FE_FIELD, the indexer_field and
number_of_indexed_values it uses are returned - otherwise an error is reported.
Use function get_FE_field_FE_field_type to determine the field type.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_type_indexed);
	if (field&&(INDEXED_FE_FIELD==field->fe_field_type)&&indexer_field&&
		number_of_indexed_values)
	{
		*indexer_field=field->indexer_field;
		*number_of_indexed_values=field->number_of_indexed_values;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_type_indexed.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_type_indexed */

int set_FE_field_type_indexed(struct FE_field *field,
	struct FE_field *indexer_field,int number_of_indexed_values)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Converts the <field> to type INDEXED_FE_FIELD, indexed by the given
<indexer_field> and with the given <number_of_indexed_values>. The indexer_field
must return a single integer value to be valid.
Allocates and clears the values_storage of the field to fit
field->number_of_components x number_of_indexed_values of the current
value_type. If function fails the field is left exactly as it was.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_type_indexed);
	return_code=0;
	if (field&&indexer_field&&(0<number_of_indexed_values)&&
		(1==get_FE_field_number_of_components(indexer_field))&&
		(INT_VALUE==get_FE_field_value_type(indexer_field))&&
		/* and to avoid possible endless loops... */
		(INDEXED_FE_FIELD != get_FE_field_FE_field_type(indexer_field)))
	{
		/* 1. make dynamic allocations for any new type-specific data */
		number_of_values=field->number_of_components*number_of_indexed_values;
		if (values_storage=make_value_storage_array(field->value_type,
			(struct FE_time_sequence *)NULL,number_of_values))
		{
			/* 2. free current type-specific data */
			if (field->values_storage)
			{
				free_value_storage_array(field->values_storage,field->value_type,
					(struct FE_time_sequence *)NULL,field->number_of_values);		
				DEALLOCATE(field->values_storage);
			}
			/* 3. establish the new type */
			field->fe_field_type=INDEXED_FE_FIELD;
			REACCESS(FE_field)(&(field->indexer_field),indexer_field);
			field->number_of_indexed_values=number_of_indexed_values;
			field->values_storage=values_storage;
			field->number_of_values=number_of_values;
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_type_indexed.  Could not allocate values_storage");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_type_indexed.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_type_indexed */

int FE_field_set_indexer_field(struct FE_field *fe_field,
	struct FE_field *indexer_fe_field)
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
If <fe_field> is already indexed, substitutes <indexer_fe_field>.
Does not change any of the values currently stored in <fe_field>
Used to merge indexed fields into different FE_regions; should not be used for
any other purpose.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_set_indexer_field);
	return_code = 0;
	if (fe_field && (INDEXED_FE_FIELD == fe_field->fe_field_type) &&
		indexer_fe_field &&
		(1 == get_FE_field_number_of_components(indexer_fe_field)) &&
		(INT_VALUE == get_FE_field_value_type(indexer_fe_field)) &&
		/* and to avoid possible endless loops... */
		(INDEXED_FE_FIELD != get_FE_field_FE_field_type(indexer_fe_field)))
	{
		REACCESS(FE_field)(&(fe_field->indexer_field), indexer_fe_field);
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_set_indexer_field.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_set_indexer_field */

int FE_field_log_FE_field_change(struct FE_field *fe_field,
	void *fe_field_change_log_void)
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
Logs the field in <fe_field> as RELATED_OBJECT_CHANGED in the
struct CHANGE_LOG(FE_field) pointed to by <fe_field_change_log_void>.
???RC Later may wish to allow more than just RELATED_OBJECT_CHANGED, or have
separate functions for each type.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_log_FE_field_change);
	/*???RC try to make this as efficient as possible so no argument checking */
	return_code = CHANGE_LOG_OBJECT_CHANGE(FE_field)(
		(struct CHANGE_LOG(FE_field) *)fe_field_change_log_void,
		fe_field, CHANGE_LOG_RELATED_OBJECT_CHANGED(FE_field));
	LEAVE;

	return (return_code);
} /* FE_field_log_FE_field_change */

enum Value_type get_FE_field_value_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 31 August 1999

DESCRIPTION :
Returns the value_type of the <field>.
==============================================================================*/
{
	enum Value_type value_type;

	ENTER(get_FE_field_value_type);
	if (field)
	{
		value_type=field->value_type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_value_type.  Invalid field");
		value_type=UNKNOWN_VALUE;
	}
	LEAVE;

	return (value_type);
} /* get_FE_field_value_type */

int set_FE_field_value_type(struct FE_field *field,enum Value_type value_type)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Sets the value_type of the <field>. Clears/reallocates the values_storage for
FE_field_types that use them, eg. CONSTANT_FE_FIELD and INDEXED_FE_FIELD - but
only if the value_type changes. If function fails the field is left exactly as
it was. Should only call this function for unmanaged fields.
=========================================================================*/
{
	int number_of_values,return_code;
	Value_storage *values_storage;

	ENTER(set_FE_field_value_type);
	if (field)
	{
		return_code=1;
		if (value_type != field->value_type)
		{
			/* 1. make dynamic allocations for value_type-specific data */
			values_storage=(Value_storage *)NULL;
			number_of_values=field->number_of_values;
			if (0!=number_of_values)
			{
				if (!(values_storage=make_value_storage_array(value_type,
					(struct FE_time_sequence *)NULL,number_of_values)))
				{
					return_code=0;
				}
			}
			if (return_code)
			{
				/* 2. free current value_type-specific data */
				if (field->values_storage)
				{
					free_value_storage_array(field->values_storage,field->value_type,
						(struct FE_time_sequence *)NULL,field->number_of_values);		
					DEALLOCATE(field->values_storage);
				}
				/* 3. establish the new value_type and associated data */
				field->value_type=value_type;
				field->values_storage=values_storage;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_field_value_type.  Not enough memory");
				DEALLOCATE(values_storage);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_value_type.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/* set_FE_field_value_type */

enum Value_type get_FE_field_time_value_type(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Returns the time_value_type of the <field>.
==============================================================================*/
{
	enum Value_type time_value_type;

	ENTER(get_FE_field_time_value_type);
	if (field)
	{
		time_value_type=field->time_value_type;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_time_value_type.  Invalid field");
		time_value_type=UNKNOWN_VALUE;
	}
	LEAVE;

	return (time_value_type);
} /*get_FE_field_time_value_type */

int set_FE_field_time_value_type(struct FE_field *field,enum Value_type time_value_type)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

DESCRIPTION :
Sets the time_value_type of the <field>.
Should only call this function for unmanaged fields.
=========================================================================*/
{
	int return_code;

	ENTER(set_FE_field_time_value_type);
	if (field)
	{
		field->time_value_type=time_value_type;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_field_time_value_type.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/*set_FE_field_time_value_type */

int get_FE_field_max_array_size(struct FE_field *field,int *max_number_of_array_values, 
	enum Value_type *value_type)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Given the field, search vaules_storage  for the largest array, and return it in
max_number_of_array_values. Return the field value_type.
====================================================================================*/
{
 int return_code,size,i,number_of_array_values;
 
	Value_storage *values_storage;

	ENTER(get_FE_field_max_array_size);
	if (field)
	{
		if (field->number_of_values)
		{
			return_code=1;
			*value_type = field->value_type;
			switch (field->value_type)
			{
				case DOUBLE_ARRAY_VALUE:
				case FE_VALUE_ARRAY_VALUE:
				case FLT_ARRAY_VALUE:
				case SHORT_ARRAY_VALUE:
				case INT_ARRAY_VALUE:
				case UNSIGNED_ARRAY_VALUE:	
				case STRING_VALUE:
				{	
					*max_number_of_array_values = 0;
					size = get_Value_storage_size(*value_type,
						(struct FE_time_sequence *)NULL);
					values_storage = field->values_storage;
					for (i=0;i<field->number_of_values;i++)
					{		
						if (field->value_type == STRING_VALUE)
						{
							char *the_string,**str_address;										
							/* get the string's length*/					
							str_address = (char **)(values_storage);
							the_string = *str_address;
							number_of_array_values = strlen(the_string)+1;/* +1 for null termination*/
							if (number_of_array_values > *max_number_of_array_values)
							{
								*max_number_of_array_values = number_of_array_values;
							}
						}
						else	
						{	
							/* get the number of array values  for the specified array in vaules_storage */
							number_of_array_values = *((int *)values_storage);
							if (number_of_array_values > *max_number_of_array_values)
							{
								*max_number_of_array_values = number_of_array_values;
							}
						}
						values_storage+=(i*size);
					}
				} break;		
				default:
				{
					display_message(ERROR_MESSAGE," get_FE_field_max_array_size. Not an array type)");
					number_of_array_values = 0;
					return_code=0;
				} break;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE," get_FE_field_max_array_size. No values at field");
			
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE," get_FE_field_max_array_size. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* get_FE_field_max_array_size */

int get_FE_field_array_attributes(struct FE_field *field, int value_number,
 int *number_of_array_values, enum Value_type *value_type)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Get the value_type and the number of array values for the array in field->values_storage 
specified by value_number. 
Give an error if field->values_storage isn't storing array types.
====================================================================================*/
{

  int return_code,size;
 
	Value_storage *values_storage;

	ENTER(get_FE_field_array_attributes);
	if (field&&(0<=value_number)&&(value_number<=field->number_of_values))
	{
		if (field->number_of_values)
		{
			return_code=1;
			*value_type = field->value_type;
			switch (field->value_type)
			{
				case DOUBLE_ARRAY_VALUE:
				case FE_VALUE_ARRAY_VALUE:
				case FLT_ARRAY_VALUE: 
				case SHORT_ARRAY_VALUE:
				case INT_ARRAY_VALUE:
				case UNSIGNED_ARRAY_VALUE:
				{				
					/* get the correct offset*/	
					size = get_Value_storage_size(*value_type,
						(struct FE_time_sequence *)NULL);
					values_storage = field->values_storage+(value_number*size);
					/* get the number of array values  for the specified array in vaules_storage */			
					*number_of_array_values = *((int *)values_storage);
				} break;
				case STRING_VALUE:
				{
					char *the_string,**str_address;
					/* get the correct offset*/	
					size = get_Value_storage_size(*value_type,
						(struct FE_time_sequence *)NULL);
					values_storage = field->values_storage+(value_number*size);
					/* get the string*/	
					str_address = (char **)(values_storage);
					the_string = *str_address;
					*number_of_array_values = strlen(the_string)+1;/* +1 for null termination*/
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,"get_FE_field_array_attributes. Not an array type)");
					number_of_array_values = 0;
					return_code=0;
				} break;
			}
		}
		else
		{
			return_code=0;
			display_message(ERROR_MESSAGE,"get_FE_field_array_attributes. No values at the field");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,"get_FE_field_array_attributes. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* get_FE_field_array_attributes */

int get_FE_field_double_array_value(struct FE_field *field, int value_number,
	double *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Get the double array in field->values_storage specified by value_number, of
of length number_of_array_values. If number_of_array_values > the stored arrays 
max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_field_array_attributes() or get_FE_field_max_array_size() 
to get the size of an array.
==============================================================================*/
{

	int return_code,size,the_array_number_of_values,array_size;
	

	Value_storage *values_storage;
	double *the_array,**array_address;

	ENTER(get_FE_field_double_array_value);
	if (field&&array&&(0<=value_number)&&(value_number<=field->number_of_values))
	{
		if (field->number_of_values)
		{
			return_code=1;	 			 
			size = get_Value_storage_size(DOUBLE_ARRAY_VALUE,
				(struct FE_time_sequence *)NULL);
			/* get the correct offset*/
			values_storage = field->values_storage+(value_number*size);
			/* get the number of array values  for the specified array in vaules_storage */	
			the_array_number_of_values = *((int *)values_storage);
			if (number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(double);

			/* get the address to copy from*/	
			array_address = (double **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
		}
		else
		{	
			display_message(ERROR_MESSAGE,"get_FE_field_double_array_value. No values at field");
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,"get_FE_field_double_array_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
}/* get_FE_field_double_array_value */

int set_FE_field_double_array_value(struct FE_field *field, int value_number,
	double *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 1 September 1999

DESCRIPTION :
Finds any existing double array at the place specified by  value_number in 
field->values_storage.
Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the
specified  place in the field->values_storage. 

Therefore, should free the passed array, after passing it to this function.

The <field> must be of the correct FE_field_type to have such values and
<number> must be within the range valid for that type.
==============================================================================*/
{

	int return_code,size,array_size;

	double *pointer,*the_array,**array_address;

	Value_storage *values_storage;
	ENTER(set_FE_field_double_array_value);
	if (field&&array&&(0<=value_number)&&(value_number<=field->number_of_values))
	{
		return_code=1;	 
	
		if (field->value_type!=DOUBLE_ARRAY_VALUE)
		{
			display_message(ERROR_MESSAGE,"set_FE_field_double_array_value. "
				" value type doesn't match");
			return_code=0;
		}								

		size = get_Value_storage_size(DOUBLE_ARRAY_VALUE,
			(struct FE_time_sequence *)NULL);

		/* get the correct offset*/
		values_storage = field->values_storage+(value_number*size);
		/* get the pointer to stored the array, free any existing one */	
		array_address = (double **)(values_storage+sizeof(int));
		pointer = *array_address;
		if (pointer!=NULL)
			DEALLOCATE(pointer);		
		/* copy the number of array values into field->values_storage*/	
		*((int *)values_storage) = number_of_array_values; 
		/* Allocate the space for the array, and copy the data in */
		array_size = number_of_array_values*sizeof(double);
		if (ALLOCATE(the_array,double,array_size))
		{
			memcpy(the_array,array,array_size);
			/*copy the pointer to the array into field->values_storage  */		
			*array_address = the_array;
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_field_double_array_value. Out of Memory )");
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,"set_FE_field_double_array_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
}/* set_FE_field_double_array_value */

int get_FE_field_string_value(struct FE_field *field,int value_number,
	char **string)
/*******************************************************************************
LAST MODIFIED : 22 September 1999

DESCRIPTION :
Returns a copy of the string stored at <value_number> in the <field>.
Up to the calling function to DEALLOCATE the returned string.
Returned <*string> may be a valid NULL if that is what is in the field.
==============================================================================*/
{
	int return_code,size;
	char *the_string,**string_address;
	
	ENTER(get_FE_field_string_value);
	return_code=0;
	if (field&&(0<=value_number)&&(value_number<field->number_of_values)&&string)
	{
		/* get the pointer to the stored string */			
		size = get_Value_storage_size(STRING_VALUE,(struct FE_time_sequence *)NULL);
		string_address = (char **)(field->values_storage+value_number*size);
		if (the_string = *string_address)
		{
			if (ALLOCATE(*string,char,strlen(the_string)+1))
			{
				strcpy(*string,the_string);
				return_code=1;	 
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_string_value.  Not enough memory");
			}
		}
		else
		{
			/* no string, so successfully return NULL */
			*string = (char *)NULL;
			return_code=1;	 
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"get_FE_field_string_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_string_value */

int set_FE_field_string_value(struct FE_field *field,int value_number,
	char *string)
/*******************************************************************************
LAST MODIFIED : 22 September 1999

DESCRIPTION :
Copies and sets the <string> stored at <value_number> in the <field>.
<string> may be NULL.
==============================================================================*/
{
	int return_code,size;
	char *the_string,**string_address;

	ENTER(set_FE_field_string_value);
	return_code=0;
	if (field&&(0<=value_number)&&(value_number<field->number_of_values))
	{
		/* get the pointer to the stored string */			
		size = get_Value_storage_size(STRING_VALUE,(struct FE_time_sequence *)NULL);
		string_address = (char **)(field->values_storage+value_number*size);
		if (string)
		{
			/* reallocate the string currently there */
			if (REALLOCATE(the_string,*string_address,char,strlen(string)+1))
			{
				strcpy(the_string,string);
				*string_address=the_string;
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_field_string_value.  Not enough memory");
			}
		}
		else
		{
			/* NULL string; free the existing string */
			if (*string_address)
			{
				DEALLOCATE(*string_address);
			}
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_string_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	

	return (return_code);
} /* set_FE_field_string_value */

int get_FE_field_element_xi_value(struct FE_field *field,int number,
	struct FE_element **element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Gets the specified global value for the <field>.
==============================================================================*/
{
	int i, number_of_xi_dimensions, return_code;
	Value_storage *values_storage;

	ENTER(get_FE_field_element_xi_value);
	if (field&&(0<=number)&&(number<field->number_of_values)
		&&(field->value_type==ELEMENT_XI_VALUE))
	{
		if (field->number_of_values)
		{
			return_code=1;

			/* get the correct offset*/
			values_storage = field->values_storage + (number*(sizeof(struct FE_element *) +
				MAXIMUM_ELEMENT_XI_DIMENSIONS * sizeof(FE_value)));

			/* copy the element and xi out */	
			*element = *((struct FE_element **)values_storage);
			values_storage += sizeof(struct FE_element *);
			number_of_xi_dimensions = (*element)->shape->dimension;
			if (number_of_xi_dimensions <= MAXIMUM_ELEMENT_XI_DIMENSIONS)
			{
				/* Extract the xi values */
				for (i = 0 ; i < number_of_xi_dimensions ; i++)
				{
					xi[i] = *((FE_value *)values_storage);
					values_storage += sizeof(FE_value);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_element_xi_value.  Number of xi dimensions of element exceeds maximum");
				return_code=0;
			}
		}
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_field_element_xi_value. no values at field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_element_xi_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/* get_FE_field_element_xi_value */

int set_FE_field_element_xi_value(struct FE_field *field,int number,
	struct FE_element *element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 14 September 1999

DESCRIPTION :
Sets the specified global value for the <field>, to the passed Element and xi.
The <field> must be of the correct FE_field_type to have such values and
<number> must be within the range valid for that type.
==============================================================================*/
{
	int i, number_of_xi_dimensions, return_code;
	Value_storage  *values_storage;

	ENTER(set_FE_field_element_xi_value);
	if (field&&(0<=number)&&(number<=field->number_of_values)
		&&(field->value_type==ELEMENT_XI_VALUE) && element && xi)
	{
		return_code=1;	 
		number_of_xi_dimensions = element->shape->dimension;
		if (number_of_xi_dimensions <= MAXIMUM_ELEMENT_XI_DIMENSIONS)
		{

			/* get the correct offset*/
			values_storage = field->values_storage + (number*(sizeof(struct FE_element *) +
				MAXIMUM_ELEMENT_XI_DIMENSIONS * sizeof(FE_value)));
			
			/* copy the element in ensuring correct accessing */	
			REACCESS(FE_element)(((struct FE_element **)values_storage), element);
			values_storage += sizeof(struct Element *);
			/* Write in the xi values */
			for (i=0;i<MAXIMUM_ELEMENT_XI_DIMENSIONS;i++)
			{
				if (i<number_of_xi_dimensions)
				{
					*((FE_value *)values_storage) = xi[i];
				}
				else
				{
					/* set spare xi values to 0 */
					*((FE_value *)values_storage) = 0.0;
				}
				values_storage += sizeof(FE_value);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_field_element_xi_value.  Number of xi dimensions of element exceeds maximum");
			return_code=0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE," set_FE_field_element_xi_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* set_FE_field_element_xi_value */

int get_FE_field_FE_value_value(struct FE_field *field,int number,
	FE_value *value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Gets the specified global FE_value <value> from <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_FE_value_value);
	if (field&&(FE_VALUE_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values)&&value)
	{
		*value = *((FE_value *)(field->values_storage+(number*sizeof(FE_value))));
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_FE_value_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_FE_value_value */

int set_FE_field_FE_value_value(struct FE_field *field,int number,
	FE_value value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Sets the specified global FE_value <value> in <field>.
The <field> must be of type FE_VALUE_VALUE to have such values and
<number> must be within the range from get_FE_field_number_of_values.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_FE_value_value);
	if (field&&(FE_VALUE_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values))
	{
		*((FE_value *)(field->values_storage+(number*sizeof(FE_value)))) = value;
		return_code=1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"set_FE_field_FE_value_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_FE_value_value */

int get_FE_field_int_value(struct FE_field *field,int number,int *value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Gets the specified global int <value> from <field>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_field_int_value);
	if (field&&(INT_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values)&&value)
	{
		*value = *((int *)(field->values_storage+(number*sizeof(int))));
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_int_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_field_int_value */

int set_FE_field_int_value(struct FE_field *field,int number,int value)
/*******************************************************************************
LAST MODIFIED : 2 September 1999

DESCRIPTION :
Sets the specified global int <value> in <field>.
The <field> must be of type INT_VALUE to have such values and
<number> must be within the range from get_FE_field_number_of_values.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_int_value);
	if (field&&(INT_VALUE==field->value_type)&&field->values_storage&&
		(0<=number)&&(number<=field->number_of_values))
	{
		*((int *)(field->values_storage+(number*sizeof(int)))) = value;
		return_code=1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"set_FE_field_int_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_int_value */

int get_FE_field_time_FE_value(struct FE_field *field,int number,FE_value *value)
/*******************************************************************************
LAST MODIFIED : 10 June 1999

DESCRIPTION :
Gets the specified global time value for the <field>.
==============================================================================*/
{
	int return_code;
	Value_storage *times;

	ENTER(get_FE_field_time_FE_value);
	if (field&&(0<=number)&&(number<field->number_of_times))
	{
		if (field->number_of_times)
		{
			return_code=1;
			/* get the correct offset*/
			times = field->times+(number*sizeof(FE_value));
			/* copy the value in*/	
			*value = *((FE_value *)times);		
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_field_time_FE_value.  no times at field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_time_FE_value.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
}/*get_FE_field_time_FE_value */

int set_FE_field_time_FE_value(struct FE_field *field,int number,FE_value value)
/*******************************************************************************
LAST MODIFIED : l0 June 1999

DESCRIPTION :
Sets the specified global time value for the <field>, to the passed FE_value
The field value MUST have been previously allocated with set_FE_field_number_of_times
==============================================================================*/
{

	int return_code; 
	FE_value *times;

	ENTER( set_FE_field_time_FE_value);
	if (field&&(0<=number)&&(number<=field->number_of_times))
	{
		return_code=1;	 	
		if (field->time_value_type!=FE_VALUE_VALUE)
		{
			display_message(ERROR_MESSAGE," set_FE_field_time_FE_value. "
				" value type doesn't match");
			return_code=0;
		}								
		/* get the correct offset*/
		times = (FE_value *)(field->times+(number*sizeof(FE_value)));
		/* copy the value in*/		
		*times = value;
	}
	else
	{	
		display_message(ERROR_MESSAGE," set_FE_field_time_FE_value. Invalid argument(s)");
		return_code=0;
	}
	LEAVE;	
	return (return_code);
} /* set_FE_field_time_FE_value */

char *get_FE_field_name(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 19 February 1999

DESCRIPTION :
Returns a pointer to the name for the <field>.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	char *name;

	ENTER(get_FE_field_name);
	if (field)
	{
		name = field->name;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_name.  Invalid argument(s)");
		name = (char *)NULL;
	}
	LEAVE;

	return (name);
}/*get_FE_field_name */

int set_FE_field_name(struct FE_field *field, char *name)
/*******************************************************************************
LAST MODIFIED : 19 February 1999

DESCRIPTION :
Sets the name of the <field>.
Should only call this function for unmanaged fields.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_field_name);
	if (field&&name)
	{
		if (ALLOCATE(field->name,char,strlen(name)+1))
		{
			strcpy(field->name,name);	
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_field_name.  Not enough memory");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_field_name.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_name */

PROTOTYPE_GET_OBJECT_NAME_FUNCTION(FE_field_component)
/*****************************************************************************
LAST MODIFIED : 2 February 1999

DESCRIPTION :
Returns the FE_field_component component name.
Up to the calling function to deallocate the returned char string.
============================================================================*/
{
	int return_code;

	ENTER(GET_NAME(FE_field_component));
	if (object&&name_ptr)
	{
		if (*name_ptr=get_FE_field_component_name(object->field,object->number))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"GET_NAME(FE_field_component).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* GET_NAME(FE_field_component) */

int set_FE_field_component(struct Parse_state *state,void *component_void,
	void *fe_field_list_void)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Used in command parsing to translate a field component name into an field
component.
???DB.  Should it be here ?
???RC.  Does not ACCESS the field (unlike set_FE_field, above).
==============================================================================*/
{
	char *current_token,*field_component_name,*temp_name;
	int field_component_number,i,return_code;
	struct FE_field *field;
	struct FE_field_component *component;
	struct LIST(FE_field) *fe_field_list;

	ENTER(set_FE_field_component);
	if (state&&(component=(struct FE_field_component *)component_void)&&
		(fe_field_list=(struct LIST(FE_field) *)fe_field_list_void))
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if (field_component_name=strchr(current_token,'.'))
				{
					*field_component_name='\0';
					field_component_name++;
				}
				if (field=FIND_BY_IDENTIFIER_IN_LIST(FE_field,name)(current_token,
					fe_field_list))
				{
					if (field_component_name)
					{
						return_code=1;
						field_component_number=-1;
						for (i=0;(0>field_component_number)&&
							(i<field->number_of_components)&&return_code;i++)
						{
							if (temp_name=get_FE_field_component_name(field,i))
							{
								if (0==strcmp(field_component_name,temp_name))
								{
									field_component_number=i;
								}
								DEALLOCATE(temp_name);
							}
							else
							{
								display_message(WARNING_MESSAGE,
									"set_FE_field_component.  Not enough memory");
								return_code=0;
							}
						}
						if (return_code)
						{
							if (0 <= field_component_number)
							{
								component->field=field;
								component->number=field_component_number;
							}
							else
							{
								display_message(WARNING_MESSAGE,
									"Unknown field component %s.%s",current_token,
									field_component_name);
								return_code=0;
							}
						}
					}
					else
					{
						component->field=field;
						component->number=0;
						return_code=1;
					}
				}
				else
				{
					display_message(WARNING_MESSAGE,"Unknown field %s",current_token);
					return_code=1;
				}
				shift_Parse_state(state,1);
			}
			else
			{
				display_message(INFORMATION_MESSAGE," FIELD_NAME.COMPONENT_NAME");
				if (component->field)
				{
					if (1<component->field->number_of_components)
					{
						display_message(INFORMATION_MESSAGE,"[%s.%s]",
							component->field->name,
							(component->field->component_names)[component->number]);
					}
					else
					{
						display_message(INFORMATION_MESSAGE,"[%s]",component->field->name);
					}
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"Missing field component name");
			display_parse_state_location(state);
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_field_component.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_field_component */

struct FE_node_field_creator *CREATE(FE_node_field_creator)(
	int number_of_components)
/*******************************************************************************
LAST MODIFIED : 16 November 2001

DESCRIPTION :
An object for defining the components, number_of_versions,
number_of_derivatives and their types at a node.
By default each component has 1 version and no derivatives.
==============================================================================*/
{
	int i;
	struct FE_node_field_creator *node_field_creator;

	ENTER(CREATE(FE_node_field_creator));
	if (number_of_components)
	{
		if ((ALLOCATE(node_field_creator, struct FE_node_field_creator, 1))&&
			(ALLOCATE(node_field_creator->numbers_of_versions, int, 
			number_of_components)) &&
			(ALLOCATE(node_field_creator->numbers_of_derivatives, int, 
			number_of_components))&&
			(ALLOCATE(node_field_creator->nodal_value_types, 
			enum FE_nodal_value_type *, number_of_components)))
		{
			node_field_creator->number_of_components = number_of_components;
			for (i = 0 ; node_field_creator && (i < number_of_components) ; i++)
			{
				node_field_creator->numbers_of_versions[i] = 1;
				node_field_creator->numbers_of_derivatives[i] = 0;
				if (ALLOCATE(node_field_creator->nodal_value_types[i], 
					enum FE_nodal_value_type, 1))
				{
					*(node_field_creator->nodal_value_types[i]) = FE_NODAL_VALUE;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_node_field_creator).  Unable to allocate arrays");
					DEALLOCATE(node_field_creator);
					node_field_creator = (struct FE_node_field_creator *)NULL;
				}
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_node_field_creator).  Unable to allocate arrays");
			node_field_creator = (struct FE_node_field_creator *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_node_field_creator).  Invalid argument(s)");
		node_field_creator = (struct FE_node_field_creator *)NULL;
	}
	LEAVE;

	return (node_field_creator);
} /* CREATE(FE_node_field_creator) */

struct FE_node_field_creator *create_FE_node_field_creator_from_node_field(
	struct FE_node *node, struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 4 February 2001

DESCRIPTION :
Creates an FE_node_field_creator from <node>,<field>
==============================================================================*/
{
	enum FE_nodal_value_type nodal_value_type;
	int i,j,number_of_components,number_of_derivatives,number_of_versions,success;
	struct FE_node_field_component *node_field_components;
	struct FE_node_field_creator *node_field_creator;
	struct FE_node_field *node_field;

	ENTER(create_FE_node_field_creator_from_node_field);
	node_field_creator = (struct FE_node_field_creator *)NULL;			
	if (node&&field&&node->fields)
	{	
		if((node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node->fields->node_field_list))&&
			(node_field_components=node_field->components))
		{	
			number_of_components=field->number_of_components;
			if (node_field_creator=CREATE(FE_node_field_creator)(number_of_components))
			{
				success=1;
				for(i=0;(i<number_of_components)&&success;i++)
				{
					number_of_versions=node_field_components[i].number_of_versions;
					if (!FE_node_field_creator_define_versions(node_field_creator,i,
						number_of_versions))
					{
						success=0;
					}
					number_of_derivatives=node_field_components[i].number_of_derivatives;
					for(j=1;(j<=number_of_derivatives)&&success;j++)
					{
						nodal_value_type=node_field_components[i].nodal_value_types[j];
						if (!FE_node_field_creator_define_derivative(node_field_creator,i,
							nodal_value_type))
						{
							success=0;
						}
					}
				}
				if (!success)
				{
					DESTROY(FE_node_field_creator)(&node_field_creator);
					display_message(ERROR_MESSAGE,
						"create_FE_node_field_creator_from_node_field.  Failed");
				}
			}
			else
			{	
				display_message(ERROR_MESSAGE,
					"create_FE_node_field_creator_from_node_field.  Unable to allocate");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"create_FE_node_field_creator_from_node_field. field not defined at node");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"create_FE_node_field_creator_from_node_field.  Invalid argument(s)");
	}
	LEAVE;

	return (node_field_creator);
} /* create_FE_node_field_creator_from_node_field */

int DESTROY(FE_node_field_creator)(
	struct FE_node_field_creator **node_field_creator_address)
/*******************************************************************************
LAST MODIFIED : 16 November 2001

DESCRIPTION :
Frees the memory for the node field creator and sets 
<*node_field_creator_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_node_field_creator *node_field_creator;

	ENTER(DESTROY(FE_node_field_creator));
	if ((node_field_creator_address)&&(node_field_creator = 
		*node_field_creator_address))
	{
		for (i = 0 ; i < node_field_creator->number_of_components ; i++)
		{
			DEALLOCATE(node_field_creator->nodal_value_types[i]);
		}
		DEALLOCATE(node_field_creator->nodal_value_types);
		DEALLOCATE(node_field_creator->numbers_of_derivatives);
		DEALLOCATE(node_field_creator->numbers_of_versions);
		DEALLOCATE(*node_field_creator_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node_field_creator) */

int FE_node_field_creator_get_nodal_derivative_versions(
	struct FE_node_field_creator *node_field_creator, 
	int *number_of_derivatives, 
	enum FE_nodal_value_type **nodal_derivative_types,int **max_versions)
/*******************************************************************************
LAST MODIFIED: 11 February 2002

DESCRIPTION:
Given <node_field_creator>, returns <number_of_derivatives>
which is the size of the arrays <nodal_derivative_types> (containing the 
FE_nodal_value_type of the derivates present at the node_field_creator) 
and <max_versions> (which contains the maximum number of versions of each 
derivative type).
Note: This function allocates the arrays nodal_derivative_types and max_versions, 
the user is responsible for freeing them.
==============================================================================*/
{
	enum FE_nodal_value_type  *the_nodal_derivative_types,**nodal_value_types,
		*the_nodal_value_types,a_nodal_value_type;
	int array_size,found,max_array_size,i,j,k,number_of_components,
		number_of_component_derivatives,number_of_versions,	return_code,*max_nodal_versions;
	max_nodal_versions=(int *)NULL;
	the_nodal_derivative_types=(enum FE_nodal_value_type *)NULL;
	return_code = 0;
	if(node_field_creator&&number_of_derivatives)
	{
		/*max_array_size will contain the max possible comb of versions and derviative types */
		/*will usually be too big.*/
		max_array_size=0;
		number_of_components=node_field_creator->number_of_components;
		for(i=0;i<number_of_components;i++)
		{
			max_array_size+=node_field_creator->numbers_of_versions[i]*
				node_field_creator->numbers_of_derivatives[i];
		}
		if(ALLOCATE(the_nodal_derivative_types,enum FE_nodal_value_type,max_array_size)&&
			ALLOCATE(max_nodal_versions,int,max_array_size))
		{	
			/*fill in arrays with blanks*/
			for(i=0;i<max_array_size;i++)
			{
				the_nodal_derivative_types[i]=FE_NODAL_UNKNOWN;
				max_nodal_versions[i]=0;
			}
			return_code = 1;			
			/*nodal_value_types an array of arrays of FE_nodal_value_type*/
			nodal_value_types=node_field_creator->nodal_value_types;
			/*for all components*/		
			array_size=0;
			for(i=0;i<number_of_components;i++)
			{										
				number_of_component_derivatives=node_field_creator->numbers_of_derivatives[i];
				number_of_versions=node_field_creator->numbers_of_versions[i];						
				/*the_nodal_value_types an array of FE_nodal_value_type*/
				the_nodal_value_types=*nodal_value_types;
				/* for all the derivatives*/
				/* number_of_component_derivatives+1 as also have nodal value*/
				for(j=0;j<number_of_component_derivatives+1;j++)
				{	
					if(j!=0)/*don't consider 1st as this is nodal value, not derivative*/
					{						
						a_nodal_value_type=*the_nodal_value_types;
						k=0;
						found=0;
						/*loop through any previously stored derivative/versions*/
						while((k<=array_size)&&(!found))
						{
							/* have we already stored the derivative/version */
							if((a_nodal_value_type==the_nodal_derivative_types[k])&&
								(max_nodal_versions[k]==number_of_versions))
							{
								found=1;
							}
							else
							{
								k++;
							}
						}
						if(!found)
						{
							/* if we haven't found the derivative/version, store it*/
							the_nodal_derivative_types[array_size]=a_nodal_value_type;
							max_nodal_versions[array_size]=number_of_versions;
							array_size++;
						}					
					}/* 	if(j!=0)*/
					the_nodal_value_types++;
				}/* for(j=0;j<number_of_component_derivatives+1;j++) */
				nodal_value_types++;
			}/* for(i=0;i<number_of_components;i++) */
			*number_of_derivatives=array_size;	
			*nodal_derivative_types=the_nodal_derivative_types;
			*max_versions=max_nodal_versions;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_field_creator_get_nodal_derivative_versions. array alocation failed");
			return_code = 0;
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"FE_node_field_creator_get_nodal_derivative_versions. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
}/* FE_node_field_creator_get_nodal_derivative_versions*/

int FE_node_field_creator_define_derivative(
	struct FE_node_field_creator *node_field_creator, int component_number,
	enum FE_nodal_value_type derivative_type)
/*******************************************************************************
LAST MODIFIED: 16 November 2001

DESCRIPTION:
Adds the derivative of specified <derivative_type> to the <component_number>
specified.
==============================================================================*/
{
	enum FE_nodal_value_type *new_nodal_value_types;
	int number_of_derivatives, return_code;
	ENTER(FE_node_field_creator_define_derivative);

	if (node_field_creator && (component_number >= 0) && 
		 (component_number < node_field_creator->number_of_components))
	{
		number_of_derivatives = node_field_creator->numbers_of_derivatives
			[component_number];
		if (REALLOCATE(new_nodal_value_types, 
			node_field_creator->nodal_value_types[component_number],
			enum FE_nodal_value_type, number_of_derivatives + 2))
		{
			node_field_creator->nodal_value_types[component_number] = 
				new_nodal_value_types;
			node_field_creator->nodal_value_types[component_number][
				number_of_derivatives + 1] = derivative_type;
			node_field_creator->numbers_of_derivatives[component_number]++;
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_field_creator_define_derivative.  "
				"Unable to REALLOCATE nodal value types array.");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_creator_define_derivative. Invalid arguments");
		return_code = 0;
	}
	LEAVE;
	return (return_code);
}/* FE_node_field_creator_define_derivative */

int FE_node_field_creator_define_versions(
	struct FE_node_field_creator *node_field_creator, int component_number,
	int number_of_versions)
/*******************************************************************************
LAST MODIFIED: 16 April 2003

DESCRIPTION:
Specifies the <number_of_versions> for <component_number> specified.
==============================================================================*/
{
	int return_code;
	ENTER(FE_node_field_creator_define_derivative);

	if (node_field_creator && (component_number >= 0) && 
		 (component_number < node_field_creator->number_of_components))
	{
		node_field_creator->numbers_of_versions[component_number] =
			number_of_versions;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_creator_define_derivative. Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_creator_define_derivative */

struct FE_node *CREATE(FE_node)(int cm_node_identifier,
	struct FE_region *fe_region, struct FE_node *template_node)
/*******************************************************************************
LAST MODIFIED : 19 February 2003

DESCRIPTION :
Creates and returns a node with the specified <cm_node_identifier>.
If <fe_region> is supplied a blank node with the given identifier but no fields
is returned. If <template_node> is supplied, a copy of it, including all fields
and values but with the new identifier, is returned.
Exactly one of <fe_region> or <template_node> must be supplied.
The new node is set to belong to the ultimate master FE_region of <fe_region>
if supplied, or to the same master FE_region as <template_node> if supplied.
Note that <cm_node_identifier> must be non-negative.
==============================================================================*/
{
	int return_code;
	struct FE_node *node;

	ENTER(CREATE(FE_node));
	node = (struct FE_node *)NULL;
	if ((0 <= cm_node_identifier) &&
		(((!fe_region) && template_node) || (fe_region && (!template_node))))
	{
		if (ALLOCATE(node, struct FE_node, 1))
		{
			return_code = 1;
			/* clear the new node so we can destroy it if anything fails */
			node->cm_node_identifier = cm_node_identifier;
			node->fields = (struct FE_node_field_info *)NULL;
			node->values_storage = (Value_storage *)NULL;
			node->access_count = 0;
			if (template_node)
			{
				if (!(node->fields =
					ACCESS(FE_node_field_info)(template_node->fields)))
				{
					display_message(ERROR_MESSAGE, "CREATE(FE_node).  "
						"Could not set field info from template node");
					return_code = 0;
				}
				if (template_node->values_storage)
				{
					if (!allocate_and_copy_FE_node_values_storage(template_node,
						&node->values_storage))
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_node).  Could not copy values from template node");
						/* values_storage may be corrupt, so clear it */
						node->values_storage = (Value_storage *)NULL;
						return_code = 0;
					}
				}
			}
			else
			{
				if (!(node->fields = ACCESS(FE_node_field_info)(
					FE_region_get_FE_node_field_info(fe_region,
						/*number_of_values*/0, (struct LIST(FE_node_field) *)NULL))))
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_node).  FE_region could not supply node field info");
					return_code = 0;
				}
			}
			if (!return_code)
			{
				DESTROY(FE_node)(&node);
				node = (struct FE_node *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_node).  Could not allocate memory for node");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE, "CREATE(FE_node).  Invalid argument(s)");
	}
	LEAVE;

	return (node);
} /* CREATE(FE_node) */

int DESTROY(FE_node)(struct FE_node **node_address)
/*******************************************************************************
LAST MODIFIED : 11 October 2002

DESCRIPTION :
Frees the memory for the node, sets <*node_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_node *node;

	ENTER(DESTROY(FE_node));
	if ((node_address) && (node = *node_address))
	{
		if (0 == node->access_count)
		{
			/* free the node values_storage */
			if (node->fields)
			{
				FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
					FE_node_field_free_values_storage_arrays,
					(void *)node->values_storage,node->fields->node_field_list);		
				DEACCESS(FE_node_field_info)(&(node->fields));
			}
			DEALLOCATE(node->values_storage);

			/* free the memory associated with the node */
			DEALLOCATE(*node_address);
		}
		else
		{
			*node_address = (struct FE_node *)NULL;
		}
		return_code = 1;
	}
	else
	{
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node) */

DECLARE_OBJECT_FUNCTIONS(FE_node)

PROTOTYPE_COPY_OBJECT_FUNCTION(FE_node)
/*******************************************************************************
LAST MODIFIED : 17 March 1999

DESCRIPTION :
Creates an EXACT copy of the node.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_info *node_field_info;

	ENTER(COPY(FE_node));
	return_code=0;
	/* check the arguments */
	if (source&&destination)
	{
		DEACCESS(FE_node_field_info)(&(destination->fields));
		/* free the node values_storage */
		if (destination->fields)
		{			
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				FE_node_field_free_values_storage_arrays,
				(void *)destination->values_storage,destination->fields->node_field_list);		
		}
		DEALLOCATE(destination->values_storage);

		/* copy the new */
		node_field_info=source->fields;
		if ( allocate_and_copy_FE_node_values_storage(source,&(destination->values_storage)))
		{			
			destination->fields=ACCESS(FE_node_field_info)(node_field_info);
			destination->cm_node_identifier=source->cm_node_identifier;
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"COPY(FE_node).  Could not do copy_FE_node_values_storage for node");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"COPY(FE_node).  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* COPY(FE_node) */

struct FE_node_field_copy_with_FE_field_list_data
{
	int number_of_values, values_storage_size;
	struct LIST(FE_field) *fe_field_list;
	struct LIST(FE_node_field) *node_field_list;
};

static int FE_node_field_copy_with_FE_field_list(
	struct FE_node_field *node_field, void *copy_data_void)
/*******************************************************************************
LAST MODIFIED : 6 March 2003

DESCRIPTION :
If the FE_field in <node_field> is in <fe_field_list>, makes a copy of it in
the <node_field_list>. It is is a GENERAL_FE_FIELD, the value pointer for
the copy is set to the current <value_storage_size>, and both it and the
<number_of_values> are increased by the appropriate size for <node_field>.
==============================================================================*/
{
	int number_of_values, return_code, values_storage_size;
	struct FE_node_field *offset_node_field;
	struct FE_node_field_copy_with_FE_field_list_data *copy_data;

	ENTER(FE_node_field_copy_with_FE_field_list);
	if (node_field && (copy_data =
		(struct FE_node_field_copy_with_FE_field_list_data *)copy_data_void))
	{
		return_code = 1;
		if (IS_OBJECT_IN_LIST(FE_field)(node_field->field,
			copy_data->fe_field_list))
		{
			if (GENERAL_FE_FIELD == node_field->field->fe_field_type)
			{
				number_of_values = FE_node_field_get_number_of_values(node_field);
				values_storage_size = number_of_values *
					get_Value_storage_size(node_field->field->value_type,
						node_field->time_sequence);
				/* adjust size for proper word alignment in memory */
				ADJUST_VALUE_STORAGE_SIZE(values_storage_size);
				
				if ((offset_node_field =
					copy_create_FE_node_field_with_offset(node_field,
						copy_data->values_storage_size - node_field->components->value)) &&
					ADD_OBJECT_TO_LIST(FE_node_field)(offset_node_field,
						copy_data->node_field_list))
				{
					copy_data->number_of_values += number_of_values;
					copy_data->values_storage_size += values_storage_size;
				}
				else
				{
					DESTROY(FE_node_field)(&offset_node_field);
					return_code = 0;
				}
			}
			else
			{
				/* non-GENERAL FE_node_fields can be shared */
				return_code = ADD_OBJECT_TO_LIST(FE_node_field)(node_field,
					copy_data->node_field_list);
			}
			if (!return_code)
			{
				display_message(ERROR_MESSAGE,
					"FE_node_field_copy_with_FE_field_list.  Failed");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_copy_with_FE_field_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_copy_with_FE_field_list */

struct FE_node *FE_node_copy_with_FE_field_list(struct FE_node *node,
	struct LIST(FE_field) *fe_field_list)
/*******************************************************************************
LAST MODIFIED : 6 March 2003

DESCRIPTION :
Creates a copy of <node> containing only FE_node_fields from <node> which have
their FE_field listed in <fe_field_list>.
==============================================================================*/
{
	struct FE_node *copy_node;
	struct FE_node_field_copy_with_FE_field_list_data copy_data;
	struct FE_node_field_info *fe_node_field_info;
	struct FE_region *fe_region;
	Value_storage *values_storage;

	ENTER(FE_node_copy_with_FE_field_list);
	copy_node = (struct FE_node *)NULL;
	if (node && node->fields && (fe_region = node->fields->fe_region) &&
		fe_field_list)
	{
		copy_data.number_of_values = 0;
		copy_data.values_storage_size = 0;
		copy_data.fe_field_list = fe_field_list;
		copy_data.node_field_list = CREATE(LIST(FE_node_field))();
		if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			FE_node_field_copy_with_FE_field_list, (void *)&copy_data,
				node->fields->node_field_list))
		{
			values_storage = (Value_storage *)NULL;
			if ((0 == copy_data.values_storage_size) ||
				(ALLOCATE(values_storage, Value_storage,
					copy_data.values_storage_size) &&
					merge_FE_node_values_storage(node, values_storage,
						copy_data.node_field_list, (struct FE_node *)NULL)))
			{
				/* create a node field info for the combined list */
				if (fe_node_field_info = FE_region_get_FE_node_field_info(
					fe_region, copy_data.number_of_values, copy_data.node_field_list))
				{
					if (copy_node = CREATE(FE_node)(node->cm_node_identifier, fe_region,
						(struct FE_node *)NULL))
					{
						/* fill in the fields and values storage */
						REACCESS(FE_node_field_info)(&(copy_node->fields),
							fe_node_field_info);
						copy_node->values_storage = values_storage;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_node_copy_with_FE_field_list.  Could not get node field info");
					/* do not bother to clean up dynamic contents of values_storage */
					DEALLOCATE(values_storage);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_node_copy_with_FE_field_list.  Could copy values_storage");
				/* cannot clean up dynamic contents of values_storage */
				DEALLOCATE(values_storage);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_copy_with_FE_field_list.  Error cloning node field list");
		}
		DESTROY(LIST(FE_node_field))(&(copy_data.node_field_list));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_copy_with_FE_field_list.  Invalid argument(s)");
	}
	LEAVE;

	return (copy_node);
} /* FE_node_copy_with_FE_field_list */

PROTOTYPE_GET_OBJECT_NAME_FUNCTION(FE_node)
/*****************************************************************************
LAST MODIFIED : 5 November 1997

DESCRIPTION :
Returns the FE_node->cm_node_identifier identifier as a string.
Up to the calling routine to deallocate the returned char string!
============================================================================*/
{
	char temp_string[20];
	int return_code;

	ENTER(GET_NAME(FE_node));
	if (object&&name_ptr)
	{
		sprintf(temp_string,"%i",object->cm_node_identifier);
		if (ALLOCATE(*name_ptr,char,strlen(temp_string)+1))
		{
			strcpy(*name_ptr,temp_string);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"GET_NAME(FE_node).  Could not allocate space for name");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"GET_NAME(FE_node).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* GET_NAME(FE_node) */

int FE_region_get_FE_node_field_info_adding_new_times(
	struct FE_region *fe_region, struct FE_node_field_info **node_field_info_address, 
	struct FE_node_field *new_node_field)
/*******************************************************************************
LAST MODIFIED : 13 December 2005

DESCRIPTION :
Updates the pointer to <node_field_info_address> to point to a node_field info
which appends to the fields in <node_field_info_address> one <new_node_field>.
The node_field_info returned in <node_field_info_address> will be for the
<new_number_of_values>.
The <fe_region> maintains an internal list of these structures so they can be 
shared between nodes.  This function allows a fast path when adding a single 
field.  If the node_field passed in is only referenced by one external object
then it is assumed that this function can modify it rather than copying.  If 
there are more references then the object is copied and then modified.
This function handles the access and deaccess of the <node_field_info_address>
as if it is just updating then there is nothing to do.
==============================================================================*/
{
	int return_code;
	struct FE_node_field *node_field, *node_field_copy;
	struct FE_node_field_info *existing_node_field_info, *new_node_field_info;
	struct LIST(FE_node_field) *node_field_list;

	ENTER(FE_region_get_FE_node_field_info_adding_new_times);
	if (fe_region && node_field_info_address && 
		(existing_node_field_info = *node_field_info_address))
	{
		return_code = 1;
		if (node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(new_node_field->field,
			existing_node_field_info->node_field_list))
		{
			if (FE_node_field_info_used_only_once(existing_node_field_info))
			{
				if (node_field->access_count > 1)
				{
					/* Need to copy this node_field */
					node_field_copy = copy_create_FE_node_field_with_offset(node_field,
						/*value_offset*/0);
					REMOVE_OBJECT_FROM_LIST(FE_node_field)(node_field,
						existing_node_field_info->node_field_list);
					/* Update the time sequence */
					FE_node_field_set_FE_time_sequence(node_field_copy, new_node_field->time_sequence);
					ADD_OBJECT_TO_LIST(FE_node_field)(node_field_copy,
						existing_node_field_info->node_field_list);
				}
				else
				{
					FE_node_field_set_FE_time_sequence(node_field, new_node_field->time_sequence);
				}
				/* Should check there isn't a node_field equivalent to this modified one
					already in the list, and if there is use that instead */
			}
			else
			{
				/* Need to copy after all */
				node_field_list = CREATE_LIST(FE_node_field)();
				if (COPY_LIST(FE_node_field)(node_field_list, existing_node_field_info->node_field_list))
				{
					/* Find the correct node field in the new list */
					if (node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
						new_node_field->field, node_field_list))
					{
						node_field_copy = copy_create_FE_node_field_with_offset(node_field,
							/*value_offset*/0);
						REMOVE_OBJECT_FROM_LIST(FE_node_field)(node_field, node_field_list);
						/* Update the time sequence */
						FE_node_field_set_FE_time_sequence(node_field_copy, new_node_field->time_sequence);
						ADD_OBJECT_TO_LIST(FE_node_field)(node_field_copy, node_field_list);
						/* create the new node information, number_of_values has not changed */
						if (new_node_field_info = FE_region_get_FE_node_field_info(
							fe_region, existing_node_field_info->number_of_values, node_field_list))
						{
							REACCESS(FE_node_field_info)(node_field_info_address,
								new_node_field_info);
						}
					}
				}
				DESTROY(LIST(FE_node_field))(&node_field_list);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_region_get_FE_node_field_info_adding_new_times.  Field not already defined.");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_region_get_FE_node_field_info_adding_new_field.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_region_get_FE_node_field_info_adding_new_field */

int define_FE_field_at_node(struct FE_node *node, struct FE_field *field,
	struct FE_time_sequence *fe_time_sequence, 
	struct FE_node_field_creator *fe_node_field_creator)
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
Defines a field at a node (does not assign values)
==============================================================================*/
{
	enum FE_nodal_value_type **component_nodal_value_types;
	enum FE_time_sequence_mapping time_sequence_mapping;
	enum Value_type value_type;
	int *component_number_of_derivatives,*component_number_of_versions,
		existing_values_storage_size, i, j, new_number_of_times, new_values_storage_size,
		number_of_values, number_of_values_in_component, previous_number_of_times,
		return_code,size,total_number_of_values,value_size;
	struct FE_node_field *existing_node_field, *merged_node_field, *new_node_field,
		*node_field;
	struct FE_node_field_component *component;
	struct FE_node_field_info *node_field_info;
	struct FE_region *fe_region;
	struct FE_time_sequence *existing_time_sequence;
	struct LIST(FE_node_field) *new_node_field_list;
	struct Merge_FE_node_field_into_list_data merge_data;
	Value_storage *new_value, *storage;

	ENTER(define_FE_field_at_node);
	return_code = 0;
	if (node && field && (fe_region = FE_field_get_FE_region(field)) &&
		(node_field_info = node->fields) &&
		(node_field_info->fe_region == fe_region) &&
		(component_number_of_derivatives =
			fe_node_field_creator->numbers_of_derivatives) &&
		(component_number_of_versions =
			fe_node_field_creator->numbers_of_versions) &&
		(component_nodal_value_types =
			fe_node_field_creator->nodal_value_types) &&
		(field->number_of_components == fe_node_field_creator->number_of_components))
	{
		value_type = field->value_type;
		size = get_Value_storage_size(value_type, fe_time_sequence);
		return_code = 1;

		/* create the node field */
		if (node_field = CREATE(FE_node_field)(field))
		{
			/* access now, deaccess at end to clean up if fails */
			ACCESS(FE_node_field)(node_field);
			if (fe_time_sequence)
			{
				FE_node_field_set_FE_time_sequence(node_field, 
					fe_time_sequence);
			}
			number_of_values = 0;
			if (GENERAL_FE_FIELD == field->fe_field_type)
			{
				i = field->number_of_components;
				component = node_field->components;
				new_values_storage_size = 0;
				while (return_code && (i > 0))
				{
					/*???DB.  Inline assign_FE_node_field_component and get rid of
					  it ? */
					return_code = assign_FE_node_field_component(component,
						node_field_info->values_storage_size +
						new_values_storage_size,
						*component_number_of_derivatives,
						*component_number_of_versions,
						*component_nodal_value_types);
					number_of_values_in_component = (*component_number_of_versions) *
						(1+(*component_number_of_derivatives));
					number_of_values += number_of_values_in_component;
					new_values_storage_size += number_of_values_in_component*size;
					component_number_of_derivatives++;
					component_number_of_versions++;
					component_nodal_value_types++;
					component++;
					i--;
				}
			}
			if (return_code)
			{
				if (existing_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
					field,node_field_info->node_field_list))
				{
					if (existing_node_field->time_sequence)
					{
						existing_time_sequence = ACCESS(FE_time_sequence)(existing_node_field->time_sequence);
					}
					else
					{
						existing_time_sequence = (struct FE_time_sequence *)NULL;
					}

					/* Check they are consistent or we are only adding times */
					/* Need to copy node field list in case it is modified  */
					new_node_field_list = CREATE_LIST(FE_node_field)();
					if (COPY_LIST(FE_node_field)(new_node_field_list,
							node_field_info->node_field_list))
					{
						merge_data.requires_merged_storage = 0;
						merge_data.values_storage_size = 0;
						merge_data.number_of_values = node_field_info->number_of_values;
						merge_data.list = new_node_field_list;
						if (merge_FE_node_field_into_list(node_field, (void *)(&merge_data)))
						{
							if (merge_data.requires_merged_storage)
							{
								/* Time sequences are different or it would have failed */
								/* get the node_field_info for the new list */
								merged_node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
									field, new_node_field_list);
								FE_region_get_FE_node_field_info_adding_new_times(
									node_field_info->fe_region, &node->fields,
									merged_node_field);
								new_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
									field, node->fields->node_field_list);
								/* Update values storage, similar to copy_value_storage_array but
								   we are updating existing storage and need to initialise the new values */
								/* Offsets must not have changed so we can use the existing_node_field */
								storage = node->values_storage + existing_node_field->components->value;
								value_size=get_Value_storage_size(value_type, new_node_field->time_sequence);
								time_sequence_mapping = 
									FE_time_sequences_mapping(existing_time_sequence, new_node_field->time_sequence);
								switch (time_sequence_mapping)
								{
									case FE_TIME_SEQUENCE_MAPPING_IDENTICAL:
									{
										/* Do nothing, in fact we shouldn't get here as the merge_data.requires_merged_storage
											should be false in this case */
									} break;
									case FE_TIME_SEQUENCE_MAPPING_APPEND:
									{
										previous_number_of_times = FE_time_sequence_get_number_of_times(existing_time_sequence);
										new_number_of_times = FE_time_sequence_get_number_of_times(new_node_field->time_sequence);
										for (i=0;(i<number_of_values)&&return_code;i++)
										{
											reallocate_time_values_storage_array(value_type, 
												new_number_of_times, storage, storage,
												/*initialise_storage*/1, previous_number_of_times);
											storage += value_size;
										}
									} break;
									default:
									{
										/* Need a temporary pointer as we will be allocating the new
											memory, copying the existing values and then replacing the 
											pointer with the new value */
										void *temp_storage;
										
										/* Fallback default implementation */
										for (i=0;(i<number_of_values)&&return_code;i++)
										{
											if (!(allocate_time_values_storage_array(value_type,
														new_node_field->time_sequence,(Value_storage *)&temp_storage,/*initialise_storage*/1)&&
													copy_time_sequence_values_storage_array(storage,value_type,
														existing_time_sequence,new_node_field->time_sequence,(Value_storage *)&temp_storage)))
											{
												display_message(ERROR_MESSAGE,
													"copy_value_storage_array.  Failed to copy array");
												return_code = 0;
											}
											/* Must free the src array now otherwise we will lose any reference to it */
											free_value_storage_array(storage,value_type,existing_time_sequence,1);
											/* Update the value storage with the new pointer */
											*(void **)storage = temp_storage;
											storage += value_size;
										}
									} break;
								}
							}
							/* else existing time sequence includes new times so do nothing */
						}
						else
						{
							display_message(ERROR_MESSAGE, "define_FE_field_at_node.  "
								"Field already defined incompatibly at node.");
						}
					}
					if (existing_time_sequence)
					{
						DEACCESS(FE_time_sequence)(&existing_time_sequence);
					}
				}
				else
				{
					existing_values_storage_size = node_field_info->values_storage_size;
					total_number_of_values = node_field_info->number_of_values + number_of_values;
					if (FE_region_get_FE_node_field_info_adding_new_field(fe_region,
							&node_field_info, node_field, total_number_of_values))
					{
						if (GENERAL_FE_FIELD == field->fe_field_type)
						{
							ADJUST_VALUE_STORAGE_SIZE(new_values_storage_size);
							if (REALLOCATE(new_value, node->values_storage, Value_storage,
									node_field_info->values_storage_size +
									new_values_storage_size))
							{
								node->values_storage = new_value;
								/* initialize new values */
								new_value += existing_values_storage_size;
								for (i = number_of_values ; i > 0 ; i--)
								{
									if (fe_time_sequence)
									{
										allocate_time_values_storage_array(value_type,
											fe_time_sequence, new_value, /*initialise_storage*/1);
										new_value += size;
									}
									else
									{
										switch (value_type)
										{
											case ELEMENT_XI_VALUE:
											{											
												*((struct FE_element **)new_value) =
													(struct FE_element *)NULL;
												new_value += sizeof(struct FE_element *);
												for (j = 0; j < MAXIMUM_ELEMENT_XI_DIMENSIONS; j++)
												{
													*((FE_value *)new_value) = FE_VALUE_INITIALIZER;
													new_value += sizeof(FE_value);
												}
											} break;
											case FE_VALUE_VALUE:
											{																					
												*((FE_value *)new_value) = FE_VALUE_INITIALIZER;
												new_value += size;
											} break;
											case UNSIGNED_VALUE:
											{																					
												*((unsigned *)new_value) = 0;
												new_value += size;
											} break;	
											case INT_VALUE:
											{																			
												*((int *)new_value) = 0;
												new_value += size;
											} break;
											case DOUBLE_VALUE:
											{																							
												*((double *)new_value) = 0;
												new_value += size;
											} break;	
											case FLT_VALUE:
											{																						
												*((float *)new_value) = 0;
												new_value += size;
											} break;
											case SHORT_VALUE:
											{
												display_message(ERROR_MESSAGE,
													"define_FE_field_at_node.  SHORT_VALUE: Code not "
													"written yet. Beware alignmemt problems!");
												return_code = 0;
											} break;
											case DOUBLE_ARRAY_VALUE:
											{	
												double *array = (double *)NULL;
												double **array_address;
												int zero = 0;										
												/* copy number of array values to values_storage*/
												*((int *)new_value) = zero;
												/* copy pointer to array values to values_storage */
												array_address =
													(double **)(new_value + sizeof(int));
												*array_address = array;
												new_value += size;
											} break;																			
											case FE_VALUE_ARRAY_VALUE:
											{	
												FE_value *array = (FE_value *)NULL;
												FE_value **array_address;
												int zero = 0;
												*((int *)new_value) = zero;													
												array_address =
													(FE_value **)(new_value + sizeof(int));
												*array_address = array;	
												new_value += size;
											} break;
											case FLT_ARRAY_VALUE:
											{	
												float *array = (float *)NULL;	
												float **array_address;
												int zero = 0;
												*((int *)new_value) = zero;												
												array_address = (float **)(new_value + sizeof(int));
												*array_address = array;	
												new_value += size;
											} break;		
											case SHORT_ARRAY_VALUE:
											{	
												short *array = (short *)NULL;	
												short **array_address;
												int zero = 0;
												*((int *)new_value) = zero;												
												array_address = (short **)(new_value + sizeof(int));
												*array_address = array;	
												new_value += size;
											} break;									
											case  INT_ARRAY_VALUE:
											{	
												int *array = (int *)NULL;	
												int **array_address;
												int zero = 0;
												*((int *)new_value) = zero;												
												array_address = (int **)(new_value + sizeof(int));
												*array_address = array;	
												new_value += size;
											} break;															
											case  UNSIGNED_ARRAY_VALUE:
											{	
												unsigned *array = (unsigned *)NULL;	
												unsigned **array_address;
												int zero = 0;
												*((int *)new_value) = zero;												
												array_address =
													(unsigned **)(new_value + sizeof(int));
												*array_address = array;	
												new_value += size;
											} break;
											case STRING_VALUE:
											{	
												char **string_address;

												string_address = (char **)(new_value);
												*string_address = (char *)NULL;	
												new_value += size;
											} break;	
											case  UNKNOWN_VALUE:
											{
												display_message(ERROR_MESSAGE,
													"define_FE_field_at_node.  UNKNOWN_VALUE");
												return_code = 0;
											} break;
										}
									}
								}
							}
							else
							{
								display_message(ERROR_MESSAGE, "define_FE_field_at_node.  "
									"Could not reallocate nodal values");
								return_code = 0;
							}
						}
						if (return_code)
						{
							/* Already handled the accessing in FE_region_get_FE_node_field_info_adding_new_field */
							node->fields = node_field_info;
						}
						else
						{
							DEACCESS(FE_node_field_info)(&node_field_info);
						}
					}
				}
			}
			DEACCESS(FE_node_field)(&node_field);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"define_FE_field_at_node.  Could not create node_field");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"define_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* define_FE_field_at_node */ 

struct FE_node_field_add_to_list_with_exclusion_data
{
	int value_exclusion_length, value_exclusion_start;
	struct FE_node_field *excluded_node_field;
	struct LIST(FE_node_field) *node_field_list;
};

static int FE_node_field_add_to_list_with_exclusion(
	struct FE_node_field *node_field,void *exclusion_data_void)
/*******************************************************************************
LAST MODIFIED : 14 September 2000

DESCRIPTION :
If <node_field> is before the excluded_node_field, it is added to the list.
If <node_field> is the excluded_node_field, it is ignored.
If <node_field> is after the excluded_node_field, a copy of it is made with
a new value reduced by the <value_exclusion_length>.
==============================================================================*/
{
	int return_code;
	struct FE_node_field *offset_node_field;
	struct FE_node_field_add_to_list_with_exclusion_data *exclusion_data;

	ENTER(FE_node_field_add_to_list_with_exclusion);
	if (node_field && (exclusion_data=
		(struct FE_node_field_add_to_list_with_exclusion_data *)
		exclusion_data_void))
	{
		return_code=1;
		if (node_field != exclusion_data->excluded_node_field)
		{
			if ((GENERAL_FE_FIELD == node_field->field->fe_field_type) &&
				(node_field->components->value > exclusion_data->value_exclusion_start))
			{
				/* create copy of node_field with component->value reduced
					 by value_exclusion_length */
				if (offset_node_field=copy_create_FE_node_field_with_offset(
					node_field,-exclusion_data->value_exclusion_length))
				{
					if (!ADD_OBJECT_TO_LIST(FE_node_field)(offset_node_field,
						exclusion_data->node_field_list))
					{
						DESTROY(FE_node_field)(&offset_node_field);
						return_code=0;
					}
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				return_code=ADD_OBJECT_TO_LIST(FE_node_field)(node_field,
					exclusion_data->node_field_list);
			}
			if (!return_code)
			{
				display_message(ERROR_MESSAGE,
					"FE_node_field_add_to_list_with_exclusion.  Failed");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_add_to_list_with_exclusion.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_add_to_list_with_exclusion */

int FE_element_ensure_FE_field_nodes_are_not_in_list(
	struct FE_element *element,void *node_list_field_data_void)
/*******************************************************************************
LAST MODIFIED : 28 April 2003

DESCRIPTION :
Iterator function which, if <element> has nodes and the listed <fe_field>
defined on it, ensures those nodes contributing to <fe_field> are not in the
<fe_node_list>.
==============================================================================*/
{
	int i, number_of_element_field_nodes, number_of_nodes, return_code;
	struct Node_list_field_data *node_list_field_data;
	struct FE_node **element_field_nodes;

	ENTER(FE_element_ensure_FE_field_nodes_are_not_in_list);
	if (element && (node_list_field_data =
		(struct Node_list_field_data *)node_list_field_data_void))
	{
		return_code = 1;
		/* only elements with nodes are considered */
		if (get_FE_element_number_of_nodes(element, &number_of_nodes))
		{
			if ((0 < number_of_nodes) &&
				FE_field_is_defined_in_element(node_list_field_data->fe_field, element))
			{
				/* get the nodes used by this element field */
				if (calculate_FE_element_field_nodes(element, node_list_field_data->fe_field,
					&number_of_element_field_nodes, &element_field_nodes,
					/*top_level_element*/(struct FE_element *)NULL))
				{
					for (i = 0; (i < number_of_element_field_nodes) && return_code; i++)
					{
						if (element_field_nodes[i] &&
							IS_OBJECT_IN_LIST(FE_node)(element_field_nodes[i],
								node_list_field_data->fe_node_list))
						{
							return_code = REMOVE_OBJECT_FROM_LIST(FE_node)(
								element_field_nodes[i], node_list_field_data->fe_node_list);
						}
					}
					if (0 < number_of_element_field_nodes)
					{
						for (i = 0; i < number_of_element_field_nodes; i++)
						{
							if (element_field_nodes[i])
							{
								DEACCESS(FE_node)(&(element_field_nodes[i]));
							}
						}
						DEALLOCATE(element_field_nodes);
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_element_ensure_FE_field_nodes_are_not_in_list.  "
						"Could not get element field nodes");
					return_code = 0;
				}
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_ensure_FE_field_nodes_are_not_in_list.  "
				"Could not get number of nodes");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_ensure_FE_field_nodes_are_not_in_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_ensure_FE_field_nodes_are_not_in_list */

int undefine_FE_field_at_node(struct FE_node *node, struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 28 April 2003

DESCRIPTION :
Removes definition of <field> at <node>. If field is of type GENERAL_FE_FIELD
then removes values storage for it and shifts values storage for all subsequent
fields down.
Note: Must ensure that the node field is not in-use by any elements before it
is undefined!
==============================================================================*/
{
	int bytes_to_copy,field_number_of_values,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_add_to_list_with_exclusion_data exclusion_data;
	struct FE_node_field_info *existing_node_field_info,*new_node_field_info;
	struct FE_region *fe_region;
	Value_storage *values_storage;

	ENTER(undefine_FE_field_at_node);
	if (node && field && (fe_region = FE_field_get_FE_region(field)) &&
		(existing_node_field_info = node->fields) &&
		(existing_node_field_info->fe_region == fe_region))
	{
		/* check if the field is already defined at the node */
		if (node_field = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			existing_node_field_info->node_field_list))
		{
			field_number_of_values = FE_node_field_get_number_of_values(node_field);
			if (GENERAL_FE_FIELD == field->fe_field_type)
			{
				exclusion_data.value_exclusion_start = node_field->components->value;
				exclusion_data.value_exclusion_length = field_number_of_values *
					get_Value_storage_size(node_field->field->value_type,
						node_field->time_sequence);
				/* adjust size for proper word alignment in memory */
				ADJUST_VALUE_STORAGE_SIZE(exclusion_data.value_exclusion_length);
			}
			else
			{
				exclusion_data.value_exclusion_start =
					existing_node_field_info->values_storage_size;
				exclusion_data.value_exclusion_length = 0;
			}
			exclusion_data.excluded_node_field = node_field;
			exclusion_data.node_field_list = CREATE(LIST(FE_node_field))();
			if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				FE_node_field_add_to_list_with_exclusion, (void *)&exclusion_data,
				existing_node_field_info->node_field_list))
			{
				/* create the new node information */
				if (new_node_field_info = FE_region_get_FE_node_field_info(fe_region,
					existing_node_field_info->number_of_values - field_number_of_values,
					exclusion_data.node_field_list))
				{
					if (0 < exclusion_data.value_exclusion_length)
					{
						/* copy values_storage after the removed field */
						bytes_to_copy = existing_node_field_info->values_storage_size -
							(exclusion_data.value_exclusion_start +
								exclusion_data.value_exclusion_length);
						if (0<bytes_to_copy)
						{
							/* use memmove instead of memcpy as memory blocks overlap */
							memmove(node->values_storage+exclusion_data.value_exclusion_start,
								node->values_storage+exclusion_data.value_exclusion_start+
								exclusion_data.value_exclusion_length,bytes_to_copy);
						}
						/* free the currently used space */
						if (REALLOCATE(values_storage,node->values_storage,Value_storage,
							new_node_field_info->values_storage_size))
						{
							node->values_storage=values_storage;
						}
					}
					REACCESS(FE_node_field_info)(&(node->fields),new_node_field_info);
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"undefine_FE_field_at_node.  Could not create node field info");
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"undefine_FE_field_at_node.  Could not copy node field list");
				return_code=0;
			}
			DESTROY(LIST(FE_node_field))(&exclusion_data.node_field_list);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"undefine_FE_field_at_node.  Field %s is not defined at node %d",
				field->name,node->cm_node_identifier);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"undefine_FE_field_at_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* undefine_FE_field_at_node */

int define_FE_field_at_node_simple(struct FE_node *node, struct FE_field *field,
	int number_of_derivatives, enum FE_nodal_value_type *derivative_value_types)
/*******************************************************************************
LAST MODIFIED : 19 September 2002

DESCRIPTION :
Defines <field> at <node> using the same <number_of_derivatives>
and <nodal_value_types> for each component, and only 1 version.
==============================================================================*/
{
	int j, n, number_of_components, return_code;
	struct FE_node_field_creator *node_field_creator;

	ENTER(define_FE_field_at_node_simple);
	if (node && field &&
		(0 < (number_of_components = get_FE_field_number_of_components(field))) &&
		(0 <= number_of_derivatives) && derivative_value_types)
	{
		return_code = 1;
		if(node_field_creator = CREATE(FE_node_field_creator)(number_of_components))
		{
			for (n = 0; n < number_of_components; n++)
			{
				for (j = 0 ; j < number_of_derivatives ; j++)
				{
					FE_node_field_creator_define_derivative(node_field_creator, 
						/*component_number*/n, derivative_value_types[j]);
				}
			}
			if (!define_FE_field_at_node(node, field, (struct FE_time_sequence *)NULL,
				node_field_creator))
			{
				display_message(ERROR_MESSAGE, "define_FE_field_at_node_simple.  "
					"Could not define field at node");
				return_code = 0;
			}
			DESTROY(FE_node_field_creator)(&(node_field_creator));
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"define_FE_field_at_node_simple.  ");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"define_FE_field_at_node_simple.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* define_FE_field_at_node_simple */

int for_FE_field_at_node(struct FE_field *field,
	FE_node_field_iterator_function *iterator,void *user_data,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
If an <iterator> is supplied and the <field> is defined at the <node> then the
result of the <iterator> is returned.  Otherwise, if an <iterator> is not
supplied and the <field> is defined at the <node> then a non-zero is returned.
Otherwise, zero is returned.
???DB.  Multiple behaviour dangerous ?
==============================================================================*/
{
	int return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_iterator_and_data iterator_and_data;

	ENTER(for_FE_field_at_node);
	return_code=0;
	if (field&&node&&(node->fields))
	{
		node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node->fields->node_field_list);
	
		if (node_field)
		{
			if (iterator)
			{
				iterator_and_data.iterator=iterator;
				iterator_and_data.user_data=user_data;
				iterator_and_data.node=node;
				return_code=for_FE_field_at_node_iterator(node_field,
					&iterator_and_data);
			}
			else
			{
				return_code=1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"for_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_node */

int for_each_FE_field_at_node(FE_node_field_iterator_function *iterator,
	void *user_data,struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 10 February 1999

DESCRIPTION :
Calls the <iterator> for each field defined at the <node> until the <iterator>
returns 0 or it runs out of fields.  Returns the result of the last <iterator>
called.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_node);
	return_code=0;
	if (iterator&&node&&(node->fields))
	{
		iterator_and_data.iterator=iterator;
		iterator_and_data.user_data=user_data;
		iterator_and_data.node=node;	
		return_code=FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
			for_FE_field_at_node_iterator,&iterator_and_data,
			node->fields->node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_node */

int for_each_FE_field_at_node_indexer_first(
	FE_node_field_iterator_function *iterator,void *user_data,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Calls the <iterator> for each field defined at the <node> until the <iterator>
returns 0 or it runs out of fields.  Returns the result of the last <iterator>
called. This version insists that any field used as an indexer_field for another
field in the list is output first.
==============================================================================*/
{
	int return_code;
	struct FE_node_field_priority_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_node);
	return_code=0;
	if (iterator&&node&&(node->fields))
	{
		if (iterator_and_data.priority_field_list=CREATE(LIST(FE_field))())
		{
			/* make priority list of indexer fields for fields defined at node */
			FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				FE_node_field_add_indexer_field_to_list,
				(void *)(iterator_and_data.priority_field_list),
				node->fields->node_field_list);
			iterator_and_data.iterator=iterator;
			iterator_and_data.user_data=user_data;
			iterator_and_data.node=node;
			/* call iterator function for fields in priority list */
			iterator_and_data.priority_on=1;
			return_code=FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				for_FE_field_at_node_priority_iterator,&iterator_and_data,
				node->fields->node_field_list);
			/* call iterator function for fields not in priority list */
			iterator_and_data.priority_on=0;
			return_code=FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
				for_FE_field_at_node_priority_iterator,&iterator_and_data,
				node->fields->node_field_list);
			DESTROY(LIST(FE_field))(&(iterator_and_data.priority_field_list));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_node */

static int FE_node_field_has_FE_field_values(
	struct FE_node_field *node_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 19 October 1999

DESCRIPTION:
Returns true if <node_field> has a field with values_storage.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_has_FE_field_values);
	USE_PARAMETER(dummy);
	if (node_field&&node_field->field)
	{
		return_code=(0<node_field->field->number_of_values);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_has_FE_field_values.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_has_FE_field_values */

int FE_node_has_FE_field_values(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 24 September 1999

DESCRIPTION :
Returns true if any single field defined at <node> has values stored with
the field.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_has_FE_field_values);
	if (node&&node->fields)
	{
		return_code=((struct FE_node_field *)NULL != 
			FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
				FE_node_field_has_FE_field_values,(void *)NULL,
				node->fields->node_field_list));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_has_FE_field_values.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_has_FE_field_values */

struct FE_node_field_info *FE_node_get_FE_node_field_info(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Returns the FE_node_field_info from <node>. Must not be modified!
==============================================================================*/
{
	struct FE_node_field_info *fe_node_field_info;

	ENTER(FE_node_get_FE_node_field_info);
	if (node)
	{
		fe_node_field_info = node->fields;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_get_FE_node_field_info.  Invalid argument(s)");
		fe_node_field_info = (struct FE_node_field_info *)NULL;
	}
	LEAVE;

	return (fe_node_field_info);
} /* FE_node_get_FE_node_field_info */

int FE_node_set_FE_node_field_info(struct FE_node *node,
	struct FE_node_field_info *fe_node_field_info)
/*******************************************************************************
LAST MODIFIED : 24 February 2003

DESCRIPTION :
Changes the FE_node_field_info at <node> to <fe_node_field_info>.
Note it is very important that the old and the new FE_node_field_info structures
describe the same data layout in the nodal values_storage!
Private function only to be called by FE_region when merging FE_regions!
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_set_FE_node_field_info);
	if (node && fe_node_field_info)
	{
		return_code =
			REACCESS(FE_node_field_info)(&(node->fields), fe_node_field_info);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_set_FE_node_field_info.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_set_FE_node_field_info */

struct FE_region *FE_node_get_FE_region(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Returns the FE_region that <node> belongs to.
==============================================================================*/
{
	struct FE_region *fe_region;

	ENTER(FE_node_get_FE_node_field_info);
	if (node && node->fields)
	{
		fe_region = node->fields->fe_region;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_get_FE_region.  Invalid argument(s)");
		fe_region = (struct FE_region *)NULL;
	}
	LEAVE;

	return (fe_region);
} /* FE_node_get_FE_region */

int FE_node_to_node_string(struct FE_node *node, char **string_address)
/*****************************************************************************
LAST MODIFIED : 20 March 2003

DESCRIPTION :
Returns an allocated <string> of the identifier of <node>.
============================================================================*/
{
	char tmp_string[50];
	int return_code;

	ENTER(FE_node_to_node_string);
	if (node && string_address)
	{
		sprintf(tmp_string, "%d", get_FE_node_identifier(node));
		*string_address = duplicate_string(tmp_string);
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_to_node_string.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_to_node_string */

int equivalent_FE_field_at_nodes(struct FE_field *field,struct FE_node *node_1,
	struct FE_node *node_2)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Returns non-zero if the <field> is defined in the same way at the two nodes.
Note this will also return true if <field> is not defined at both nodes.
==============================================================================*/
{
	int return_code;
	struct FE_node_field *node_field_1, *node_field_2;

	ENTER(equivalent_FE_field_at_nodes);
	return_code = 0;
	if (field && node_1 && node_2)
	{
		if (node_1->fields == node_2->fields)
		{
			return_code = 1;
		}
		else
		{
			node_field_1 = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node_1->fields->node_field_list);
			node_field_2 = FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node_2->fields->node_field_list);
			return_code = ((!node_field_1) && (!node_field_2)) || (
				node_field_1 && node_field_2 && 
				FE_node_fields_match(node_field_1, node_field_2,
					/*ignore_field_and_time_sequence*/0, /*ignore_component_value*/1));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"equivalent_FE_field_at_nodes.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* equivalent_FE_field_at_nodes */

int equivalent_FE_fields_at_nodes(struct FE_node *node_1,
	struct FE_node *node_2)
/*******************************************************************************
LAST MODIFIED : 23 May 2000

DESCRIPTION :
Returns true if all fields are defined in the same way at the two nodes.
==============================================================================*/
{
	int return_code;

	ENTER(equivalent_FE_fields_at_nodes);
	return_code=0;
	if (node_1&&(node_1->fields)&&node_2&&(node_2->fields)&&
		(node_1->fields==node_2->fields))
	{
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* equivalent_FE_fields_at_nodes */

int FE_nodal_value_version_exists(struct FE_node *node,
	struct FE_field *field, int component_number, int version,
	enum FE_nodal_value_type type)
/*******************************************************************************
LAST MODIFIED : 23 June 1999

DESCRIPTION :
Returns 1 if the <field>, <component_number>, <version> and <type> are stored at the
node and valid at <time>.
???DB.  May need speeding up
==============================================================================*/
{
	int return_code;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	ENTER(FE_nodal_value_version_exists);
	return_code=0;
	if (node && field && (0<=component_number)&&
		(component_number < field->number_of_components) && (0<=version))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,
			version,type,get_FE_field_value_type(field),
			&values_storage,&time_sequence))
		{
			return_code=1;
		}
		else
		{	
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_nodal_value_version_exists.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_nodal_value_version_exists */

int get_FE_nodal_value_as_string(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type, FE_value time, char **string)
/*******************************************************************************
LAST MODIFIED : 22 November 2001

DESCRIPTION :
Returns as a string the value for the (<version>, <type>) for the <field>
<component_number> at the <node>.
It is up to the calling function to DEALLOCATE the returned string.
==============================================================================*/
{
	char temp_string[40];
	int return_code;

	ENTER(get_FE_nodal_value_as_string);
	return_code=0;
	(*string)=(char *)NULL;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		switch (field->value_type)
		{
			case ELEMENT_XI_VALUE:
			{
				FE_value xi[MAXIMUM_ELEMENT_XI_DIMENSIONS];
				int error,i;
				struct FE_element *element;

				if (get_FE_nodal_element_xi_value(node,field,
					component_number,version,type,&element,xi)&&element->shape)
				{
					error=0;
					switch (element->cm.type)
					{
						case CM_ELEMENT:
						{
							append_string(string,"E",&error);
						} break;
						case CM_FACE:
						{
							append_string(string,"F",&error);
						} break;
						case CM_LINE:
						{
							append_string(string,"L",&error);
						} break;
						default:
						{
							error=1;
						} break;
					}
					sprintf(temp_string," %d",element->cm.number);
					append_string(string,temp_string,&error);
					for (i=0;i<element->shape->dimension;i++)
					{
						sprintf(temp_string," %g",xi[i]);
						append_string(string,temp_string,&error);
					}
					return_code = !error;
				}
			} break;
			case FE_VALUE_VALUE:
			{
				FE_value value;

				if (get_FE_nodal_FE_value_value(node,field,component_number,
					version,type,time,&value))
				{
					sprintf(temp_string,"%g",value);
					return_code=append_string(string,temp_string,&return_code);
				}
			} break;
			case INT_VALUE:
			{
				int value;

				if (get_FE_nodal_int_value(node,field,component_number,
					version,type,time,&value))
				{
					sprintf(temp_string,"%d",value);
					return_code=append_string(string,temp_string,&return_code);
				}
			} break;
			case STRING_VALUE:
			{
				return_code=get_FE_nodal_string_value(node,field,component_number,
					version,type,string);
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_value_as_string.  Unknown value type %s",
					Value_type_string(field->value_type));
			} break;
		}
		if (!return_code)
		{
			display_message(ERROR_MESSAGE,"get_FE_nodal_value_as_string.  Failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_value_as_string.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_value_as_string */

#define INSTANTIATE_GET_FE_NODAL_VALUE_FUNCTION( value_type, value_enum ) \
int get_FE_nodal_ ## value_type ## _value(struct FE_node *node, \
	struct FE_field *field, int component_number, int version, \
	enum FE_nodal_value_type type, FE_value time, value_type *value) \
/******************************************************************************* \
LAST MODIFIED : 21 April 2005 \
 \
DESCRIPTION : \
Gets a particular value (<version>, <type>) for the <field> \
and <component_number> at the <node> and <time>. \
???DB.  May need speeding up \
==============================================================================*/ \
{ \
   value_type *array; \
	FE_value xi; \
	int return_code, time_index_one, time_index_two; \
	struct FE_time_sequence *time_sequence; \
	Value_storage *values_storage = NULL; \
 \
	ENTER(get_FE_nodal_ ## value_type ## _value); \
	return_code=0; \
	if (node && field && (0 <= component_number) && \
		(component_number < field->number_of_components) && (0<=version) && value) \
	{ \
		switch (field->fe_field_type) \
		{ \
			case CONSTANT_FE_FIELD: \
			{ \
				*value = *((value_type *)(field->values_storage)+component_number); \
				return_code=1; \
			} break; \
			case GENERAL_FE_FIELD: \
			{ \
				if (find_FE_nodal_values_storage_dest(node,field,component_number, \
					version,type, value_enum ,&values_storage,&time_sequence)) \
				{ \
					if (time_sequence) \
					{ \
						FE_time_sequence_get_interpolation_for_time(time_sequence, \
							time, &time_index_one, &time_index_two, &xi); \
	               array = *((value_type **)values_storage); \
						*value = array[time_index_one] * (1.0 - xi) + \
								array[time_index_two] * xi; \
					} \
					else \
					{ \
						*value = *((value_type *)values_storage); \
					} \
					return_code=1; \
				} \
				else \
				{	 \
					display_message(ERROR_MESSAGE,"get_FE_nodal_" #value_type "_value.  " \
						"find_FE_nodal_values_storage_dest failed"); \
				} \
			} break; \
			case INDEXED_FE_FIELD: \
			{ \
				int index; \
\
				if (get_FE_nodal_int_value(node,field->indexer_field, \
               /*component_number*/0,/*version*/0,	\
					FE_NODAL_VALUE,time,&index)) \
				{ \
					/* index numbers start at 1 */ \
					if ((1<=index)&&(index<=field->number_of_indexed_values)) \
					{ \
						*value = *((value_type *)(field->values_storage)+ \
							field->number_of_indexed_values*component_number+index-1); \
						return_code=1;	 \
					} \
					else \
					{	 \
						display_message(ERROR_MESSAGE,"get_FE_nodal_" #value_type "_value.  " \
							"Index field %s gave out-of-range index %d in field %s", \
							field->indexer_field->name,index,field->name); \
					} \
				} \
				else \
				{	 \
					display_message(ERROR_MESSAGE,"get_FE_nodal_" #value_type "_value.  " \
						"Field %s, indexed by %s not defined at node %", \
						field->name,field->indexer_field->name,node->cm_node_identifier); \
					return_code=0;	 \
				} \
			} break; \
			default: \
			{ \
				display_message(ERROR_MESSAGE, \
					"get_FE_nodal_" #value_type "_value.  Unknown FE_field_type"); \
			} break; \
		} \
	}		 \
	else \
	{ \
		display_message(ERROR_MESSAGE, \
			"get_FE_nodal_" #value_type "_value.  Invalid argument(s)"); \
	} \
	LEAVE; \
 \
	return (return_code); \
} /* get_FE_nodal_ ## value_type ## _value */

#define INSTANTIATE_SET_FE_NODAL_VALUE_FUNCTION( value_type, value_enum ) \
int set_FE_nodal_ ## value_type ## _value(struct FE_node *node, \
	struct FE_field *field, int component_number, int version, \
	enum FE_nodal_value_type type, FE_value time, value_type value) \
/******************************************************************************* \
LAST MODIFIED : 21 April 2005 \
 \
DESCRIPTION : \
Sets a particular value (<version>, <type>) for the <field> \
and <component_number> at the <node>. \
==============================================================================*/ \
{ \
   value_type *array; \
	int return_code, time_index;  \
	struct FE_time_sequence *time_sequence; \
	Value_storage *values_storage = NULL; \
 \
	ENTER(set_FE_nodal_ ## value_type ## _value); \
	return_code=0; \
	/* check arguments */ \
	if (node && field && (0<=component_number) && \
		(component_number < field->number_of_components) && (0<=version)) \
	{ \
		/* get the values storage */ \
		if (find_FE_nodal_values_storage_dest(node,field,component_number, \
         version,type, value_enum,&values_storage,&time_sequence)) \
		{ \
			if (time_sequence) \
			{ \
				if (FE_time_sequence_get_index_for_time(time_sequence, time, &time_index)) \
				{ \
					array = *((value_type **)values_storage); \
					array[time_index] = value; \
					return_code = 1; \
				} \
			   else \
				{ \
					display_message(ERROR_MESSAGE,"set_FE_nodal_" #value_type "_value.  " \
						"Time value for time %g not defined at this node.", time); \
					return_code=0; \
				} \
			} \
			else \
			{ \
				/* copy in the value */ \
				*((value_type *)values_storage) = value; \
				return_code=1; \
			} \
         if (return_code) \
         { \
				/* Check this node is being managed by the region it belongs to (All nodes \
					are created with respect to some region but they are not necessarily merged \
					into it yet. */ \
				if (node->fields && node->fields->fe_region && \
					FE_region_or_data_hack_FE_region_contains_FE_node(node->fields->fe_region, node)) \
				{ \
					/* If so, notify the change */ \
					FE_region_notify_FE_node_field_change(node->fields->fe_region, node, \
						field); \
				} \
			} \
		} \
		else \
		{	 \
			display_message(ERROR_MESSAGE,"set_FE_nodal_" #value_type "_value.  " \
				"find_FE_nodal_values_storage_dest failed"); \
			return_code=0; \
		} \
	} \
	else \
	{ \
		display_message(ERROR_MESSAGE, \
			"set_FE_nodal_" #value_type "_value.  Invalid argument(s)"); \
	} \
	LEAVE; \
 \
	return (return_code); \
} /* set_FE_nodal_ ## value_type ## _value */

#define INSTANTIATE_GET_FE_NODAL_VALUE_STORAGE_FUNCTION( value_type, value_enum ) \
int get_FE_nodal_ ## value_type ## _storage(struct FE_node *node, \
	struct FE_field *field, int component_number, int version, \
	enum FE_nodal_value_type type, FE_value time, value_type **value) \
/******************************************************************************* \
LAST MODIFIED : 8 May 2007 \
 \
DESCRIPTION : \
Returns a pointer to the memory which contains the values storage for this  \
degree of freedom.  This pointer will be invalid if the node is modified so \
it should only be used temporarily. \
==============================================================================*/ \
{ \
   value_type *array; \
	int return_code, time_index;  \
	struct FE_time_sequence *time_sequence; \
	Value_storage *values_storage = NULL; \
 \
	ENTER(get_FE_nodal_ ## value_type ## _storage); \
	return_code=0; \
	/* check arguments */ \
	if (node && field && (0<=component_number) && \
		(component_number < field->number_of_components) && (0<=version)) \
	{ \
		/* get the values storage */ \
		if (find_FE_nodal_values_storage_dest(node,field,component_number, \
         version,type, value_enum,&values_storage,&time_sequence)) \
		{ \
			if (time_sequence) \
			{ \
				if (FE_time_sequence_get_index_for_time(time_sequence, time, &time_index)) \
				{ \
					array = *((value_type **)values_storage); \
					*value = &(array[time_index]);		\
					return_code = 1; \
				} \
			   else \
				{ \
					display_message(ERROR_MESSAGE,"get_FE_nodal_" #value_type "_storage.  " \
						"Time value for time %g not defined at this node.", time); \
					return_code=0; \
				} \
			} \
			else \
			{ \
				/* copy in the value */ \
				*value = (value_type *)values_storage; \
				return_code=1; \
			} \
         if (return_code) \
         { \
				/* Check this node is being managed by the region it belongs to (All nodes \
					are created with respect to some region but they are not necessarily merged \
					into it yet. */ \
				/* Notify the clients that this node is changed, even though it hasn't \
					changed yet.  If users of the this function have used begin_cache and \
					end cache around their routines then the correct notifications will happen \
					once the end cache is done */ \
				if (node->fields && node->fields->fe_region && \
					FE_region_or_data_hack_FE_region_contains_FE_node(node->fields->fe_region, node)) \
				{ \
					/* If so, notify the change */ \
					FE_region_notify_FE_node_field_change(node->fields->fe_region, node, \
						field); \
				} \
			} \
		} \
		else \
		{	 \
			display_message(ERROR_MESSAGE,"get_FE_nodal_" #value_type "_storage.  " \
				"find_FE_nodal_values_storage_dest failed"); \
			return_code=0; \
		} \
	} \
	else \
	{ \
		display_message(ERROR_MESSAGE, \
			"get_FE_nodal_" #value_type "_storage.  Invalid argument(s)"); \
	} \
	LEAVE; \
 \
	return (return_code); \
} /* set_FE_nodal_ ## value_type ## _value */

#define INSTANTIATE_FE_NODAL_VALUE_FUNCTIONS( value_type , value_enum ) \
INSTANTIATE_GET_FE_NODAL_VALUE_FUNCTION(value_type,value_enum) \
INSTANTIATE_SET_FE_NODAL_VALUE_FUNCTION(value_type,value_enum) \
INSTANTIATE_GET_FE_NODAL_VALUE_STORAGE_FUNCTION(value_type,value_enum)

INSTANTIATE_FE_NODAL_VALUE_FUNCTIONS( FE_value , FE_VALUE_VALUE )
INSTANTIATE_FE_NODAL_VALUE_FUNCTIONS( double , DOUBLE_VALUE )
INSTANTIATE_FE_NODAL_VALUE_FUNCTIONS( float , FLT_VALUE )
INSTANTIATE_FE_NODAL_VALUE_FUNCTIONS( int , INT_VALUE )
INSTANTIATE_FE_NODAL_VALUE_FUNCTIONS( short , SHORT_VALUE )

int get_FE_nodal_element_xi_value(struct FE_node *node,
	struct FE_field *field, int component_number, int version,
	enum FE_nodal_value_type type, struct FE_element **element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 3 September 1999

DESCRIPTION :
Gets a particular element_xi_value (<version>, <type>) for the field <component>
at the <node>.
???DB.  May need speeding up
==============================================================================*/
{
	int i,return_code;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_element_xi_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		element&&xi&&(field->value_type==ELEMENT_XI_VALUE))
	{
		values_storage=(Value_storage *)NULL;
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				values_storage=field->values_storage +
					get_Value_storage_size(ELEMENT_XI_VALUE,
						(struct FE_time_sequence *)NULL)*component_number;
				return_code=1;
			} break;
			case GENERAL_FE_FIELD:
			{
				if (find_FE_nodal_values_storage_dest(node,field,component_number,
					version,type,ELEMENT_XI_VALUE,&values_storage,&time_sequence))
				{
					return_code=1;
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_element_xi_value.  "
						"find_FE_nodal_values_storage_dest failed");
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index;

				if (get_FE_nodal_int_value(node,field->indexer_field,
					/*component_number*/0,/*version*/0,
					FE_NODAL_VALUE,/*time*/0,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						values_storage=field->values_storage+
							get_Value_storage_size(ELEMENT_XI_VALUE,
							(struct FE_time_sequence *)NULL)*
							(field->number_of_indexed_values*component_number+index-1);
						return_code=1;	
					}
					else
					{	
						display_message(ERROR_MESSAGE,"get_FE_nodal_element_xi_value.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_element_xi_value.  "
						"Field %s, indexed by %s not defined at node %",
						field->name,field->indexer_field->name,node->cm_node_identifier);
					return_code=0;	
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_element_xi_value.  Unknown FE_field_type");
			} break;
		}
		if (return_code&&values_storage)
		{
			*element = *((struct FE_element **)values_storage);
			values_storage += sizeof(struct FE_element *);
			for (i = 0 ; i < MAXIMUM_ELEMENT_XI_DIMENSIONS ; i++)
			{
				xi[i] = *((FE_value *)values_storage);
				values_storage += sizeof(FE_value);
			}
		}
		else
		{
			if (return_code)
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_element_xi_value.  No values storage");
				return_code=0;
			}
		}
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_element_xi_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_element_xi_value */

int set_FE_nodal_element_xi_value(struct FE_node *node,
	struct FE_field *field, int component_number, int version,
	enum FE_nodal_value_type type,struct FE_element *element, FE_value *xi)
/*******************************************************************************
LAST MODIFIED : 14 September 1999

DESCRIPTION :
Sets a particular element_xi_value (<version>, <type>) for the field
<component> at the <node>.
==============================================================================*/
{
	int i, number_of_xi_dimensions, return_code; 
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_element_xi_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		element&&element->shape&&xi&&(field->value_type==ELEMENT_XI_VALUE))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,field,component_number,
			version,type,ELEMENT_XI_VALUE,&values_storage,&time_sequence))
		{
			number_of_xi_dimensions = element->shape->dimension;
			/* copy in the element_xi_value */		
			REACCESS(FE_element)((struct FE_element **)values_storage, element);
			values_storage += sizeof(struct FE_element *);
			for (i = 0 ; i < MAXIMUM_ELEMENT_XI_DIMENSIONS ; i++)
			{
				if (i<number_of_xi_dimensions)
				{
					*((FE_value *)values_storage) = xi[i];
				}
				else
				{
					/* set spare xi values to 0 */
					*((FE_value *)values_storage) = 0.0;
				}
				values_storage += sizeof(FE_value);
			}
			return_code=1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,"set_FE_nodal_element_xi_value.  "
				"find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_element_xi_value.  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_element_xi_value */

int FE_node_conditional_iterator(struct FE_node *node, void *data_void)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
If <node> satisfies the <conditional_function> with <conditional_user_data>,
calls <iterator_function> with it and the <iterator_user_data>.
<data_void> points at a struct FE_node_conditional_iterator_data.
==============================================================================*/
{
	int return_code;
	struct FE_node_conditional_iterator_data *data;
	
	ENTER(FE_node_conditional_iterator);
	if (node && (data = (struct FE_node_conditional_iterator_data *)data_void) &&
		data->conditional_function && data->iterator_function)
	{
		if ((data->conditional_function)(node, data->conditional_user_data))
		{
			return_code = (data->iterator_function)(node, data->iterator_user_data);
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_conditional_iterator.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_conditional_iterator */

int FE_node_is_in_Multi_range(struct FE_node *node,void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Conditional function returning true if <node> identifier is in the
<multi_range>.
==============================================================================*/
{
	int return_code;
	struct Multi_range *multi_range;

	ENTER(FE_node_is_in_Multi_range);
	if (node&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		return_code=
			Multi_range_is_value_in_range(multi_range,node->cm_node_identifier);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_in_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_in_Multi_range */

int FE_node_is_not_in_Multi_range(struct FE_node *node,void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Conditional function returning true if <node> identifier is NOT in the
<multi_range>.
==============================================================================*/
{
	int return_code;
	struct Multi_range *multi_range;

	ENTER(FE_node_is_not_in_Multi_range);
	if (node&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		return_code=
			!Multi_range_is_value_in_range(multi_range,node->cm_node_identifier);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_not_in_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_not_in_Multi_range */

int add_FE_node_number_to_Multi_range(struct FE_node *node,
	void *multi_range_void)
/*******************************************************************************
LAST MODIFIED : 20 February 2000

DESCRIPTION :
Iterator function for adding the number of <node> to <multi_range>.
==============================================================================*/
{
	int node_number,return_code;
	struct Multi_range *multi_range;

	ENTER(add_FE_node_number_to_Multi_range);
	if (node&&(multi_range=(struct Multi_range *)multi_range_void))
	{
		node_number=get_FE_node_identifier(node);
		return_code=Multi_range_add_range(multi_range,node_number,node_number);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_node_number_to_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_node_number_to_Multi_range */

int add_FE_node_to_list(struct FE_node *node, void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 March 2003

DESCRIPTION :
Iterator function for adding <node> to <node_list>. Does not expect <node> to
already be in list so more efficient than ensure_FE_node_is_in_list
==============================================================================*/
{
	int return_code;

	ENTER(add_FE_node_to_list);
	return_code =
		ADD_OBJECT_TO_LIST(FE_node)(node, (struct LIST(FE_node) *)node_list_void);
	LEAVE;

	return (return_code);
} /* add_FE_node_to_list */

int ensure_FE_node_is_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Iterator function for adding <node> to <node_list> if not currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_FE_node_is_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		if (!IS_OBJECT_IN_LIST(FE_node)(node,node_list))
		{
			return_code=ADD_OBJECT_TO_LIST(FE_node)(node,node_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_in_list */

int ensure_FE_node_is_in_list_conditional(struct FE_node *node,
	void *list_conditional_data_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for adding <node> to a list - if not already in it - if a
conditional function with user_data is true.
The node_list, conditional function and user_data are passed in a
struct FE_node_list_conditional_data * in the second argument.
Warning: Must not be iterating over the list being added to!
==============================================================================*/
{
	int return_code;
	struct FE_node_list_conditional_data *list_conditional_data;

	ENTER(ensure_FE_node_is_in_list_conditional);
	if (node&&(list_conditional_data=
		(struct FE_node_list_conditional_data *)list_conditional_data_void)&&
		list_conditional_data->node_list&&list_conditional_data->function)
	{
		if ((list_conditional_data->function)(node,
			list_conditional_data->user_data))
		{
			if (!IS_OBJECT_IN_LIST(FE_node)(node,list_conditional_data->node_list))
			{
				return_code=
					ADD_OBJECT_TO_LIST(FE_node)(node,list_conditional_data->node_list);
			}
			else
			{
				return_code=1;
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_in_list_conditional.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_in_list_conditional */

int ensure_FE_node_is_not_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for removing <node> from <node_list> if currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_FE_node_is_not_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		if (IS_OBJECT_IN_LIST(FE_node)(node,node_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_node)(node,node_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_node_is_not_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_node_is_not_in_list */

int toggle_FE_node_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
If <node> is in <node_list> it is taken out, otherwise it is added.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(toggle_FE_node_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		if (IS_OBJECT_IN_LIST(FE_node)(node,node_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_node)(node,node_list);
		}
		else
		{
			return_code=ADD_OBJECT_TO_LIST(FE_node)(node,node_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"toggle_FE_node_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* toggle_FE_node_in_list */

int FE_node_is_embedded_in_changed_element(struct FE_node *node,
	void *data_void)
/*******************************************************************************
LAST MODIFIED : 25 May 2001

DESCRIPTION :
Returns true if <node> contains a field which is embedded in one of the elements
in the <changed_element_list>, or in any elements using nodes from the
<changed_node_list>, both passed in the <data_void>.
==============================================================================*/
{
	int return_code;
	struct FE_node_is_embedded_in_changed_element_data *data;

	ENTER(FE_node_is_embedded_in_changed_element);
	if (node &&
		(data = (struct FE_node_is_embedded_in_changed_element_data *)data_void))
	{
		data->node = node;
		if (FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
			FE_node_field_is_embedded_in_changed_element, data_void,
			node->fields->node_field_list))
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_is_embedded_in_changed_element.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_embedded_in_changed_element */

static int FE_node_field_has_field_with_name(
	struct FE_node_field *node_field, void *field_name_void)
/*******************************************************************************
LAST MODIFIED : 14 November 2002

DESCRIPTION :
Returns true if the name of the field in <node_field> matches <field_name>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_field_has_field_with_name);
	return_code = 0;
	if (node_field && node_field->field && field_name_void)
	{
		if (0 == strcmp(node_field->field->name, (char *)field_name_void))
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_has_field_with_name.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_has_field_with_name */

static int FE_node_field_can_be_merged(struct FE_node_field *node_field,
	void *node_field_list_void)
/*******************************************************************************
LAST MODIFIED : 6 May 2003

DESCRIPTION :
Fetches a node_field with field of the same name as that in <node_field> from
<node_field_list>. Returns true if there is either no such node_field in the
list or the two node_fields are identically defined apart from the field itself.
Checks first that the FE_fields match.
==============================================================================*/
{
	int return_code;
	struct FE_node_field *other_node_field;
	struct LIST(FE_node_field) *node_field_list;

	ENTER(FE_node_field_can_be_merged);
	return_code = 0;
	if (node_field && node_field->field &&
		(node_field_list = (struct LIST(FE_node_field) *)node_field_list_void))
	{
		if (other_node_field = FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
			FE_node_field_has_field_with_name, (void *)node_field->field->name,
			node_field_list))
		{
			if (FE_fields_match_exact(node_field->field, other_node_field->field))
			{
				if (FE_node_fields_match(node_field, other_node_field,
					/*ignore_field_and_time_sequence*/1, /*ignore_component_value*/1))
				{
					return_code = 1;
				}
			}
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_can_be_merged.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_can_be_merged */

int FE_node_can_be_merged(struct FE_node *node, void *data_void)
/*******************************************************************************
LAST MODIFIED : 15 November 2002

DESCRIPTION :
Fetches a node with the same identifier as <node> from <data>->node_list.
Returns true if there is either no such node in the list or the two nodes have
the same node field definitions for all fields of the same name.
Note that the actual field may be different, but it is assumed that the same
name fields are already proven to be compatible. <data_void> should point at a
properly initialised struct FE_node_can_be_merged_data.
After using the function, deallocate data->compatible_node_field_info!
==============================================================================*/
{
	int i, return_code;
	struct FE_node *other_node;
	struct FE_node_field_info **node_field_info;
	struct FE_node_can_be_merged_data *data;

	ENTER(FE_node_can_be_merged);
	return_code = 0;
	if (node && (data = (struct FE_node_can_be_merged_data *)data_void) &&
		data->node_list)
	{
		if (other_node = FIND_BY_IDENTIFIER_IN_LIST(FE_node,cm_node_identifier)(
			node->cm_node_identifier, data->node_list))
		{
			/* check if the node_field_info have already been proved compatible */
			node_field_info = data->compatible_node_field_info;
			for (i = 0; (i < data->number_of_compatible_node_field_info) &&
				(!return_code); i++)
			{
				if ((*node_field_info == node->fields) &&
					(*(node_field_info + 1) == other_node->fields))
				{
					return_code = 1;
				}
				node_field_info += 2;
			}
			if (!return_code)
			{
				/* slow path: loop through node fields */
				if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
					FE_node_field_can_be_merged,
					(void *)other_node->fields->node_field_list,
					node->fields->node_field_list))
				{
					/* store combination of node field info in compatible list */
					if (REALLOCATE(node_field_info, data->compatible_node_field_info,
						struct FE_node_field_info *,
						2*(data->number_of_compatible_node_field_info + 1)))
					{
						node_field_info[data->number_of_compatible_node_field_info*2] =
							node->fields;
						node_field_info[data->number_of_compatible_node_field_info*2 + 1] =
							other_node->fields;
						data->compatible_node_field_info = node_field_info;
						data->number_of_compatible_node_field_info++;
						return_code = 1;
					}
					else
					{
						display_message(ERROR_MESSAGE, "FE_node_can_be_merged.  "
							"Could not reallocate compatible_node_field_info");
					}
				}
			}
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_can_be_merged.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_node_can_be_merged */

int FE_node_has_FE_field_and_string_data(struct FE_node *node,void *data_void)
/*******************************************************************************
LAST MODIFIED : 26 September 2000

DESCRIPTION :
Returns true(1) if the <data_void>->fe_field is define at the <node> AND
the nodal string at <node>,<data_void>->fe_field is equal to <data_void>->string.
Otherwise returns false (0)
==============================================================================*/
{
	int return_code;	
	struct FE_field_and_string_data *field_and_string_data;
	struct FE_field *fe_field;
	char *required_string,*field_string;

	ENTER(FE_node_has_FE_field_and_string_data);
	field_and_string_data=(struct FE_field_and_string_data *)NULL;
	fe_field=(struct FE_field *)NULL;
	required_string=(char *)NULL;
	field_string=(char *)NULL;	
	return_code=0;
	if (node&&(field_and_string_data=(struct FE_field_and_string_data *)data_void))
	{
		fe_field=field_and_string_data->fe_field;
		required_string=field_and_string_data->string;
		if (FE_field_is_defined_at_node(fe_field,node))
		{
			if (get_FE_nodal_string_value(node,fe_field,0,0,FE_NODAL_VALUE,&field_string))
			{
				if (!strcmp(required_string,field_string))
				{
					return_code=1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_node_has_FE_field_and_string_data.  Invalid argument(s)");	
	}
	LEAVE;

	return (return_code);
} /*FE_node_has_FE_field_and_string_data */

int FE_node_is_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <node> is in <node_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(FE_node_is_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code = IS_OBJECT_IN_LIST(FE_node)(node,node_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_in_list */

int FE_node_is_not_in_list(struct FE_node *node,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <node> is not in <node_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_node) *node_list;

	ENTER(FE_node_is_not_in_list);
	if (node&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code = !IS_OBJECT_IN_LIST(FE_node)(node,node_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_is_not_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_is_not_in_list */

PROTOTYPE_ENUMERATOR_STRING_FUNCTION(FE_nodal_value_type)
{
	char *enumerator_string;

	ENTER(ENUMERATOR_STRING(FE_nodal_value_type));
	switch (enumerator_value)
	{
		case FE_NODAL_VALUE:
		{
			enumerator_string = "value";
		} break;
		case FE_NODAL_D_DS1:
		{
			enumerator_string = "d/ds1";
		} break;
		case FE_NODAL_D_DS2:
		{
			enumerator_string = "d/ds2";
		} break;
		case FE_NODAL_D_DS3:
		{
			enumerator_string = "d/ds3";
		} break;
		case FE_NODAL_D2_DS1DS2:
		{
			enumerator_string = "d2/ds1ds2";
		} break;
		case FE_NODAL_D2_DS1DS3:
		{
			enumerator_string = "d2/ds1ds3";
		} break;
		case FE_NODAL_D2_DS2DS3:
		{
			enumerator_string = "d2/ds2ds3";
		} break;
		case FE_NODAL_D3_DS1DS2DS3:
		{
			enumerator_string = "d3/ds1ds2ds3";
		} break;
		case FE_NODAL_UNKNOWN:
		{
			enumerator_string = "unknown";
		} break;
		default:
		{
			enumerator_string = (char *)NULL;
		} break;
	}
	LEAVE;

	return (enumerator_string);
} /* ENUMERATOR_STRING(FE_nodal_value_type) */

DEFINE_DEFAULT_ENUMERATOR_FUNCTIONS(FE_nodal_value_type)

#if defined (OLD_CODE) 
/* superceded by  get_FE_nodal_value_type,get_FE_nodal_array_number_of_elements */
int get_FE_nodal_array_attributes(struct FE_node *node,
	struct FE_field_component *component,int version,
	enum FE_nodal_value_type type,enum Value_type *value_type,
	int *number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 19 February 2003

DESCRIPTION :
Get the value_type and the number of array values for the array in the nodal 
values_storage for the given node, component, version,type.

Give an error if field->values_storage isn't storing array types.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type;
	int i,length,return_code,size;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	Value_storage *values_storage;

	ENTER(get_FE_nodal_array_attributes);
	return_code=0;
	if (node&&component&&(component->field)&&(0<=component->number)&&
		(component->number<component->field->number_of_components)&&(0<=version))
	{
		if (node_field = FE_node_get_FE_node_field(node, component->field))
		{
			if ((node_field_component=node_field->components)&&
				(nodal_value_type=node_field_component->nodal_value_types))
			{
				/* get the value type*/
				*value_type	= node_field->field->value_type;
				switch (node_field->field->value_type)
				{
					case DOUBLE_ARRAY_VALUE:
					case FE_VALUE_ARRAY_VALUE:
					case FLT_ARRAY_VALUE:	
					case SHORT_ARRAY_VALUE:
					case INT_ARRAY_VALUE:
					case UNSIGNED_ARRAY_VALUE:	
					case STRING_VALUE:				
					{								
						node_field_component += component->number;
						if (version<node_field_component->number_of_versions)
						{
							length=1+(node_field_component->number_of_derivatives);
							i=0;
							while ((i<length)&&(type!=nodal_value_type[i]))
							{
								i++;
							}
							if (i<length)
							{
								size = get_Value_storage_size(*value_type);
								/* get the offset into nodal values_storage*/
								values_storage = node->values_storage+(node_field_component->value)+
									((version*length+i)*size);
								if (node_field->field->value_type!=STRING_VALUE)
								{
								/*copy in the number_of_array_values  */							
								*number_of_array_values = *((int *)(values_storage));
								}
								else
								{	
									char *the_string,**str_address;								
									str_address = (char **)(values_storage);
									the_string = *str_address;
									*number_of_array_values = strlen(the_string)+1;/* +1 for NULL term.*/
								}
								return_code=1;
							}
						}
					} break;				
					default:
					{					
						display_message(ERROR_MESSAGE,
							"get_FE_nodal_array_attributes. Not an array type");
					} break;
				}


			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_array_attributes. Invalid node/field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_array_attributes."
			" Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /*get_FE_nodal_array_attributes */
#endif /* OLD_CODE*/

#if defined (UNEMAP_USE_NODES)
enum Value_type get_FE_nodal_value_type(struct FE_node *node,
	struct FE_field *field,int component_number,int version)
/*******************************************************************************
LAST MODIFIED : 19 February 2003

DESCRIPTION :
Get's a node's field's value type
==============================================================================*/
{
	enum Value_type value_type;
	struct FE_node_field *node_field;

	ENTER(get_FE_nodal_value_type);
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		if (node_field = FE_node_get_FE_node_field(node, field))
		{		
			/* get the value type*/
			value_type	= node_field->field->value_type;		
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_value_type."
			" Invalid argument(s)");
		value_type	=UNKNOWN_VALUE;
	}
	LEAVE;

	return (value_type);
} /*get_FE_nodal_value_type */

int get_FE_nodal_array_number_of_elements(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type)
/*******************************************************************************
LAST MODIFIED : 19 February 2003

DESCRIPTION :
Returns the number of elements  for the array in the nodal 
values_storage for the given node, component, version,type.

Returns -1 upon error.

Give an error if field->values_storage isn't storing array types.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_type;
	int i,length,size,number_of_array_elements;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	Value_storage *values_storage;

	ENTER(get_FE_nodal_array_number_of_elements);
	number_of_array_elements=-1;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		if (node_field = FE_node_get_FE_node_field(node, field))
		{
			if ((node_field_component=node_field->components + component_number)&&
				(nodal_value_type=node_field_component->nodal_value_types))
			{			
				switch (node_field->field->value_type)
				{
					case DOUBLE_ARRAY_VALUE:
					case FE_VALUE_ARRAY_VALUE:
					case FLT_ARRAY_VALUE:	
					case SHORT_ARRAY_VALUE:
					case INT_ARRAY_VALUE:
					case UNSIGNED_ARRAY_VALUE:	
					case STRING_VALUE:				
					{								
						if (version<node_field_component->number_of_versions)
						{
							length=1+(node_field_component->number_of_derivatives);
							i=0;
							while ((i<length)&&(type!=nodal_value_type[i]))
							{
								i++;
							}
							if (i<length)
							{/* get the value type*/			
								size = get_Value_storage_size(node_field->field->value_type,
									(struct FE_time_sequence *)NULL);
								/* get the offset into nodal values_storage*/
								values_storage = node->values_storage+(node_field_component->value)+
									((version*length+i)*size);
								if (node_field->field->value_type!=STRING_VALUE)
								{
								/*copy in the number_of_array_values  */							
								number_of_array_elements = *((int *)(values_storage));
								}
								else
								{	
									char *the_string,**str_address;								
									str_address = (char **)(values_storage);
									the_string = *str_address;
									number_of_array_elements = strlen(the_string)+1;/* +1 for NULL term.*/
								}							
							}
						}
					} break;				
					default:
					{					
						display_message(ERROR_MESSAGE,
							"get_FE_nodal_array_number_of_elements. Not an array type");
					} break;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_array_number_of_elements. Invalid node/field");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"."
			"get_FE_nodal_array_number_of_elements Invalid argument(s)");
	}
	LEAVE;

	return (number_of_array_elements);
} /* get_FE_nodal_array_number_of_elements*/

int get_FE_nodal_double_array_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,double *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Gets a particular double array value (<version>, <type>) for the field <component> 
at the <node> of length number_of_array_values. 
If number_of_array_values > the stored arrays max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_nodal_array_attributes to get the size of an array.
??JW write get_FE_nodal_max_array_size() to avoid many ALLOCATES 
if need to locally and repetatively get many arrays.  

==============================================================================*/
{
	int return_code,the_array_number_of_values,array_size;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	double *the_array,**array_address;

	ENTER(get_FE_nodal_double_array_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		array)
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,
			version,type,DOUBLE_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(double);

			/* get the address to copy from*/		
			array_address = (double **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_double_array_value. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_double_array_value.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_double_array_value */

int set_FE_nodal_double_array_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,double *array,int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 20 April 1999

DESCRIPTION :
Finds any existing double array at the place specified by (<version>, <type>) 
for the field <component>  at the <node>.

Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the
specified place in the node->values_storage. 

Therefore, should free the passed array, after passing it to this function.

The nodal values_storage MUST have been previously allocated within 
define_FE_field_at_node.
==============================================================================*/
{
	int return_code,array_size;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;
	double *pointer,*the_array,**array_address;


	ENTER(set_FE_nodal_double_array_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
			DOUBLE_ARRAY_VALUE,&values_storage,&time_sequence))
		{				
			/* get the pointer to stored the array, free any existing one */
			array_address = (double **)(values_storage+sizeof(int));
			pointer = *array_address;		
			if (pointer!=NULL)
			{				
				DEALLOCATE(pointer);		
			}
			/* copy the number of array values into field->values_storage*/			
			*((int *)values_storage) = number_of_array_values;
			/* Allocate the space for the array, and copy the data in */
			array_size = number_of_array_values*sizeof(double);
			if (ALLOCATE(the_array,double,array_size))
			{
				memcpy(the_array,array,array_size);
				/*copy the pointer to the array into field->values_storage  */
				*array_address = the_array;				
				return_code=1;
			}
			else
			{
				*array_address = (double *)NULL;	
				*((int *)values_storage) = 0;
				display_message(ERROR_MESSAGE,
					"set_FE_nodal_double_array_value. Out of Memory )");
				return_code=0;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,"set_FE_nodal_double_array_value.  "
				"find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_double_array_value. Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_double_array_value */

int get_FE_nodal_short_array(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,short *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION :
Gets a particular short array value (<version>, <type>) for the field <component> 
at the <node> of length number_of_array_values. 
If number_of_array_values > the stored arrays max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_nodal_array_attributes to get the size of an array.
??JW write get_FE_nodal_max_array_size() to avoid many ALLOCATES 
if need to locally and repetatively get many arrays.  

==============================================================================*/
{
	int return_code,the_array_number_of_values,array_size;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address;

	ENTER(get_FE_nodal_short_array);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		array)
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
			SHORT_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(short);

			/* get the address to copy from*/		
			array_address = (short **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_short_array */

int set_FE_nodal_short_array(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,short *array,int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION :
Finds any existing short array at the place specified by (<version>, <type>) 
for the field <component>  at the <node>.

Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the specified 
place in the node->values_storage. 

Therefore, should free the passed array, after passing it to this function.

The nodal values_storage MUST have been previously allocated within 
define_FE_field_at_node.
==============================================================================*/
{
	int return_code,array_size; 
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;
	short *pointer,*the_array,**array_address;


	ENTER(set_FE_nodal_short_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
			SHORT_ARRAY_VALUE,&values_storage,&time_sequence))
		{				
			/* get the pointer to stored the array, free any existing one */
			array_address = (short **)(values_storage+sizeof(int));
			pointer = *array_address;		
			if (pointer!=NULL)
			{				
				DEALLOCATE(pointer);		
			}
			/* copy the number of array values into field->values_storage*/			
			*((int *)values_storage) = number_of_array_values;
			/* Allocate the space for the array, and copy the data in */
			array_size = number_of_array_values*sizeof(short);
			if (ALLOCATE(the_array,short,array_size))
			{
				memcpy(the_array,array,array_size);
				/*copy the pointer to the array into field->values_storage  */
				*array_address = the_array;				
				return_code=1;
			}
			else
			{
				*array_address = (short *)NULL;	
				*((int *)values_storage) = 0;
				display_message(ERROR_MESSAGE,
					"set_FE_nodal_short_array. Out of Memory )");
				return_code=0;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_short_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_short_array. Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_short_array */

int get_FE_nodal_FE_value_array(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,FE_value *array, int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 8 June 1999

DESCRIPTION :
Gets a particular FE_value array value (<version>, <type>) for the field <component> 
at the <node> of length number_of_array_values. 
If number_of_array_values > the stored arrays max length, gets the max length.
MUST allocate space for the array before calling this function.

Use get_FE_nodal_array_attributes to get the size of an array.
??JW write get_FE_nodal_max_array_size() to avoid many ALLOCATES 
if need to locally and repetatively get many arrays.  

==============================================================================*/
{
	int return_code,the_array_number_of_values,array_size;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address;

	ENTER(get_FE_nodal_FE_value_array);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		array)
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
			FE_VALUE_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (number_of_array_values>the_array_number_of_values)
			{
				number_of_array_values=the_array_number_of_values;
			}
			array_size = number_of_array_values*sizeof(FE_value);

			/* get the address to copy from*/		
			array_address = (FE_value **)(values_storage+sizeof(int));
			the_array = *array_address;
			/*copy the data to the passed array */
			memcpy(array,the_array,array_size);
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_FE_value_array */

int set_FE_nodal_FE_value_array(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,FE_value *array,int number_of_array_values)
/*******************************************************************************
LAST MODIFIED : 13 September 2000

DESCRIPTION :
Finds any existing FE_value array at the place specified by (<version>, <type>) 
for the field <component>  at the <node>.

Frees it.
Allocates a new array, according to number_of_array_values. 
Copies the contents of the passed array to this allocated one.
Copies number of array values, and the pointer to the allocated array to the specified 
place in the node->values_storage. 
Can pass a null <array>, with <number_of_array_values>=0.

Therefore, should free the passed array, after passing it to this function.

The nodal values_storage MUST have been previously allocated within 
define_FE_field_at_node.
==============================================================================*/
{
	int return_code,array_size;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;
	FE_value *pointer,*the_array,**array_address;


	ENTER(set_FE_nodal_FE_value_array);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
         FE_VALUE_ARRAY_VALUE,&values_storage,&time_sequence))
		{				
			/* get the pointer to stored the array, free any existing one */
			array_address = (FE_value **)(values_storage+sizeof(int));
			pointer = *array_address;		
			if (pointer!=NULL)
			{				
				DEALLOCATE(pointer);		
			}
			/* copy the number of array values into field->values_storage*/			
			*((int *)values_storage) = number_of_array_values;
			/* Allocate the space for the array, and copy the data in */
			array_size = number_of_array_values*sizeof(FE_value);
			if (array_size)
			{
				if (ALLOCATE(the_array,FE_value,array_size))
				{
					memcpy(the_array,array,array_size);
					/*copy the pointer to the array into field->values_storage  */
					*array_address = the_array;				
					return_code=1;
				}
				else
				{
					*array_address = (FE_value *)NULL;	
					*((int *)values_storage) = 0;
					display_message(ERROR_MESSAGE,
						"set_FE_nodal_FE_value_array. Out of Memory )");
					return_code=0;
				}
			}
			else
			{
				/* no array set yet. This is a valid thing to do*/
				*array_address =(FE_value *)NULL;
				*((int *)values_storage) = 0;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_FE_value_array. find_FE_nodal_values_storage_dest failed");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_FE_value_array. Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_FE_value_array */

FE_value get_FE_nodal_FE_value_array_element(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,int element_number)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
Gets a particular FE_value_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 

==============================================================================*/
{
	int the_array_number_of_values;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address,value;

	ENTER(get_FE_nodal_FE_value_array_element);
	value=0.0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
         FE_VALUE_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (FE_value **)(values_storage+sizeof(int));
				the_array = *array_address;
				value=the_array[element_number];
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_FE_value_array_element */

FE_value get_FE_nodal_FE_value_array_interpolated_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,int element_number,FE_value proportion)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
returns the interpolated value between the array (*element_number= value_low) 
and *(element_number+1)=value_high, according to 
value=<proportion>*value_low+(1-<proportion>)*value_high;
==============================================================================*/
{
	int the_array_number_of_values;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address,value,value_low,value_high;

	ENTER(get_FE_nodal_FE_value_array_interpolated_value);
	value=0.0;
	value_low=0.0;
	value_high=0.0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
         FE_VALUE_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (FE_value **)(values_storage+sizeof(int));
				the_array = *array_address;
				/* interpolate between adjacent values */
				value_low=the_array[element_number];
				/* can't go off the end of the array */
				if (element_number==(the_array_number_of_values-1))
				{
					value=value_low;
				}
				else
				{
					value_high=the_array[element_number+1];
					value=proportion*value_low+(1-proportion)*value_high;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_interpolated_value. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_interpolated_value. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array_interpolated_value.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_FE_value_array_interpolated_value */

int set_FE_nodal_FE_value_array_element(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,int element_number,FE_value value)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
sets a particular FE_value_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 

==============================================================================*/
{
	int the_array_number_of_values,return_code;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	FE_value *the_array,**array_address

	ENTER(set_FE_nodal_FE_value_array_element);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
			FE_VALUE_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (FE_value **)(values_storage+sizeof(int));
				the_array = *array_address;
				the_array[element_number]=value;
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"set_FE_nodal_FE_value_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_FE_value_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_FE_value_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_FE_value_array_element */

short get_FE_nodal_short_array_element(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,int element_number)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
Gets a particular short_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 

==============================================================================*/
{
	int the_array_number_of_values;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address,value;

	ENTER(get_FE_nodal_short_array_element);
	value=0.0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
			SHORT_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (short **)(values_storage+sizeof(int));
				the_array = *array_address;
				value=the_array[element_number];
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_short_array_element */

short get_FE_nodal_short_array_interpolated_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,int element_number,FE_value proportion)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
returns the interpolated value between the array (*element_number= value_low) 
and *(element_number+1)=value_high, according to 
value=<proportion>*value_low+(1-<proportion>)*value_high;
==============================================================================*/
{
	int the_array_number_of_values;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address,value,value_low,value_high;

	ENTER(get_FE_nodal_short_array_interpolated_value);
	value=0.0;
	value_low=0.0;
	value_high=0.0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
         SHORT_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (short **)(values_storage+sizeof(int));
				the_array = *array_address;
				/* interpolate between adjacent values */
				value_low=the_array[element_number];
				/* can't go off the end of the array */
				if (element_number==(the_array_number_of_values-1))
				{
					value=value_low;
				}
				else
				{
					value_high=the_array[element_number+1];
					value=proportion*value_low+(1-proportion)*value_high;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_interpolated_value. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_interpolated_value. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array_interpolated_value.Invalid argument(s)");
	}
	LEAVE;

	return (value);
} /* get_FE_nodal_short_array_interpolated_value */

int set_FE_nodal_short_array_element(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,int element_number,short value)
/*******************************************************************************
LAST MODIFIED : 4 October 1999

DESCRIPTION :
sets a particular short_array_value element for the array 
(<version>, <type>) for the field <component> 
at the <node>. 
==============================================================================*/
{
	int the_array_number_of_values,return_code;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	short *the_array,**array_address

	ENTER(set_FE_nodal_short_array_element);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&
		(element_number>-1))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
			FE_VALUE_ARRAY_VALUE,&values_storage,&time_sequence))
		{					
			the_array_number_of_values = *((int *)values_storage);
			if (element_number<the_array_number_of_values)
			{
				/* get the address to copy from*/		
				array_address = (short **)(values_storage+sizeof(int));
				the_array = *array_address;
				the_array[element_number]=value;
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"set_FE_nodal_short_array_element. element_number_out_of_range");	
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_short_array_element. find_FE_nodal_values_storage_dest failed");			
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_short_array_element.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_short_array_element */

int get_FE_nodal_FE_value_array_value_at_FE_value_time(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,FE_value time,FE_value *value)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
Gets the FE_value <value> from the node's FE_value array at the given
<component> <version> <type>, using the <time> to index the array.
The field must have time defined for it, and the number of times must match
the number of array elements. If <time> is within the node field's time array's 
range, but doesn't correspond exactly to an array element, interpolates to determine 
<value>.	
 	
==============================================================================*/
{
	int array_number_of_values,array_index,index_high,index_low,number_of_times,
		return_code;	
	FE_value time_high,time_low,prop;
	
	ENTER(get_FE_nodal_FE_value_array_value_at_FE_value_time);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		if ((get_FE_field_time_value_type(field)==FE_VALUE_VALUE)
			&&(number_of_times=get_FE_field_number_of_times(field)))
		{	
			array_number_of_values = get_FE_nodal_array_number_of_elements(node,
				field,component_number,version,type);									
			if (number_of_times==array_number_of_values)
			{
				/* field has the right time values, and is defined at node. We're OK*/
				/*get the field's time array index of <time>*/
				return_code=get_FE_field_time_array_index_at_FE_value_time(field,
					time,&time_high,&time_low,&array_index,&index_high,&index_low);
				prop=(time_high-time)/(time_high-time_low);
				/* interpolate the nodal value at this array index*/
				*value=get_FE_nodal_FE_value_array_interpolated_value(node,field,component_number,version,
					type,index_low,prop);					
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_FE_value_array_value_at_FE_value_time."
					" number_of_times!=array_number_of_values");
			}					
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_value_at_FE_value_time."
				" Time is not stored as FE_VALUE_VALUE");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			" get_FE_nodal_FE_value_array_value_at_FE_value_time .Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_FE_value_array_value_at_FE_value_time */

int get_FE_nodal_short_array_value_at_FE_value_time(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,FE_value time,short *value)
/*******************************************************************************
LAST MODIFIED : 8 May 2000

DESCRIPTION :
Gets the short <value> from the node's short array at the given
<component> <version> <type>, using the <time> to index the array.
The field must have time defined for it, and the number of times must match
the number of array elements. If <time> is within the node field's time array's 
range, but doesn't correspond exactly to an array element, interpolates to determine 
<value>.	
 	
==============================================================================*/
{
	int array_number_of_values,array_index,index_high,index_low,number_of_times,
		return_code;	
	FE_value time_high,time_low,prop;
	
	ENTER(get_FE_nodal_short_array_value_at_FE_value_time);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		if ((get_FE_field_time_value_type(field)==FE_VALUE_VALUE)
			&&(number_of_times=get_FE_field_number_of_times(field)))
		{	
			array_number_of_values = get_FE_nodal_array_number_of_elements(node,
				field,component_number,version,type);									
			if (number_of_times==array_number_of_values)
			{			
				/* field has the right time values, and is defined at node. We're OK*/
				/*get the field's time array index of <time>*/
				return_code=get_FE_field_time_array_index_at_FE_value_time(field,
					time,&time_high,&time_low,&array_index,&index_high,&index_low);				
				prop=(time_high-time)/(time_high-time_low);		
				/* interpolate the nodal value at this array index*/ 
				*value=get_FE_nodal_short_array_interpolated_value(node,field,component_number,version,
					type,index_low,prop);					
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_short_array_value_at_FE_value_time."
					" number_of_times!=array_number_of_values");
			}					
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_value_at_FE_value_time."
				" Time is not stored as FE_VALUE_VALUE");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			" get_FE_nodal_short_array_value_at_FE_value_time .Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_short_array_value_at_FE_value_time */

int get_FE_nodal_FE_value_array_min_max(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,FE_value *minimum,FE_value *maximum)
/*******************************************************************************
LAST MODIFIED : 29 September 1999

DESCRIPTION :
Gets a the minimum and maximum values for the FE_value_array 
(<version>, <type>) for the field <component> at the <node>

==============================================================================*/
{
	FE_value *array,**array_address,min,max;
	int return_code,array_number_of_values,count;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_FE_value_array_min_max);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
         FE_VALUE_ARRAY_VALUE,&values_storage,&time_sequence))
		{							
			array_number_of_values = *((int *)values_storage);		
			/* get the address to copy from*/		
			array_address = (FE_value **)(values_storage+sizeof(int));
			array = *array_address;	
			min=array[0];
			max=array[0];
			for (count=0;count<array_number_of_values;count++)
			{
				if (array[count]>max)
				{
					max=array[count];
				}
				if (array[count]<min)
				{
					min=array[count];
				}
			}
			*minimum=min;
			*maximum=max;
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_FE_value_array_min_max. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_FE_value_array_min_max.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_FE_value_array_min_max */

int get_FE_nodal_short_array_min_max(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,short *minimum,short *maximum)
/*******************************************************************************
LAST MODIFIED : 29 September 1999

DESCRIPTION :
Gets a the minimum and maximum values for the _value_array 
(<version>, <type>) for the field <component> at the <node>

==============================================================================*/
{
	int return_code,array_number_of_values,count;
	short *array,**array_address,min,max;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_short_array_min_max);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		if (find_FE_nodal_values_storage_dest(node,field,component_number,version,type,
         SHORT_ARRAY_VALUE,&values_storage,&time_sequence))
		{							
			array_number_of_values = *((int *)values_storage);		
			/* get the address to copy from*/		
			array_address = (short **)(values_storage+sizeof(int));
			array = *array_address;	
			min=array[0];
			max=array[0];
			for (count=0;count<array_number_of_values;count++)
			{
				if (array[count]>max)
				{
					max=array[count];
				}
				if (array[count]<min)
				{
					min=array[count];
				}
			}
			*minimum=min;
			*maximum=max;
			return_code =1;
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_short_array_min_max. find_FE_nodal_values_storage_dest failed");
			return_code=0;	
		}	
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_short_array_min_max.Invalid argument(s)");
	}
	LEAVE;
	return (return_code);
} /* get_FE_nodal_short_array_min_max */
#endif /* defined (UNEMAP_USE_NODES) */

int get_FE_field_time_array_index_at_FE_value_time(struct FE_field *field,
	FE_value time,FE_value *the_time_high,FE_value *the_time_low,
	int *the_array_index,int *the_index_high,int *the_index_low)
/*******************************************************************************
LAST MODIFIED : 1 August 2000

DESCRIPTION 
Given a <field> and <time>, checks that <field> has times defined and returns:
<the_array_index>, the array index of <field> times closest to <time>.
<the_index_high>, <the_index_low> the upper and lower limits for <the_array_index>
(ideally <the_index_high>==<the_index_low>==<the_array_index>).
<the_time_low> the time corresponding to <the_index_low>.
<the_time_high> the time corresponding to <the_index_high>.

All this information (rather than just <the_array_index> ) is returned so can
perform interpolation, etc.
==============================================================================*/
{	
	int array_index,done,index_high,index_low,number_of_times,return_code,step;	
	FE_value first_time,last_time,this_time,fe_value_index,time_high,time_low;

	ENTER(get_FE_field_time_array_index_at_FE_value_time);
	return_code=0;
	if (field&&the_time_high&&the_time_low&&the_array_index&&the_index_high&&
		the_index_low&&(number_of_times=get_FE_field_number_of_times(field)))
	{		
		get_FE_field_time_FE_value(field,0,&first_time);
		get_FE_field_time_FE_value(field,number_of_times-1,&last_time);
		/*Initial est. of the array index, assuming times evenly spaced, no gaps */	
		/*This assumption and hence estimate is true for most signal files. */
		fe_value_index=((time-first_time)/(last_time-first_time))*(number_of_times-1);
		fe_value_index+=0.5;/*round float to nearest int */
		array_index=floor(fe_value_index);
		time_low=0;
		time_high=0;
		done=0;
		index_low=0;
		index_high=number_of_times-1;
		/* do binary search for <time>'s array index. Also look at time of */
		/* adjacent array element, as index estimate may be slightly off due to*/
		/* rounding error. This avoids unnecessarily long search from end of array */
		while(!done)
		{	
			if (get_FE_field_time_FE_value(field,array_index,&this_time))
			{
				if (this_time>=time)
				{ 
					index_high=array_index;					
					if (array_index>0)
					{
						/* get adjacent array element*/
						get_FE_field_time_FE_value(field,array_index-1,&time_low);
						/* are we between elements?*/
						if (time_low<time)
						{			
							index_low=array_index-1;
							return_code=1;
							done=1;
						}	
						else
						{
							time_low=0;
						}
					}
					else
					{
						/* can't get lower adjacent array element when array_index=0. Finished*/
						get_FE_field_time_FE_value(field,array_index,&time_low);
						index_low=array_index;
						return_code=1;
						done=1;
					}
				}
				else /* (this_time<time) */
				{
					index_low=array_index;
					if (array_index<(number_of_times-1))
					{
						/* get adjacent array element*/
						get_FE_field_time_FE_value(field,array_index+1,&time_high);	
						/* are we between elements?*/
						if (time_high>time)
						{		
							index_high=array_index+1;
							return_code=1;
							done=1;
						}	
						else
						{
							time_high=0;
						}
					}
					else
					{
						/* can't get higher adjacent array element when */
						/*array_index=(number_of_times-1). Finished*/
						get_FE_field_time_FE_value(field,array_index,&time_high);
						index_high=array_index;
						return_code=1;
						done=1;
					}
				}	
				if (!done)
				{	
					step=(index_high-index_low)/2;	
					/* No exact match, can't subdivide further, must do interpolation.*/
					if (step==0)												
					{	
						done=1;	
						return_code=1;														
					}
					else
					{
						array_index=index_low+step;
					}
						
				}/* if (!done)	*/
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_field_time_array_index_at_FE_value_time time out of range");
			}
		}	/* while(!done)	*/
		/* index_low and index_high should now be adjacent */
		if (!time_low)
		{
			get_FE_field_time_FE_value(field,index_low,&time_low);
		}
		if (!time_high)
		{
			get_FE_field_time_FE_value(field,index_high,&time_high);
		}
		*the_time_high=time_high;
		*the_time_low=time_low;
		*the_array_index=array_index;
		*the_index_high=index_high;
		*the_index_low=index_low;
	}
	else
	{
		return_code=0;
		display_message(ERROR_MESSAGE,
			"get_FE_field_time_array_index_at_FE_value_time. Invalid arguments time out of range");
	}	
	LEAVE;
	return (return_code);
}/*get_FE_field_time_array_index_at_FE_value_time*/

int get_FE_nodal_string_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,char **string)
/*******************************************************************************
LAST MODIFIED : 3 September 1999

DESCRIPTION :
Returns a copy of the string for <version>, <type> of <field><component_number> 
at the <node>. Up to the calling function to DEALLOCATE the returned string.
Returned <*string> may be a valid NULL if that is what is in the node.
==============================================================================*/
{
	char *the_string;
	int return_code;
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	ENTER(get_FE_nodal_string_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version)&&string)
	{
		values_storage=(Value_storage *)NULL;
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				values_storage=field->values_storage +
					get_Value_storage_size(STRING_VALUE,(struct FE_time_sequence *)NULL)
					*component_number;
				return_code=1;
			} break;
			case GENERAL_FE_FIELD:
			{
				if (find_FE_nodal_values_storage_dest(node,field,component_number,
					version,type,STRING_VALUE,&values_storage,&time_sequence))
				{
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,"get_FE_nodal_string_value.  "
						"find_FE_nodal_values_storage_dest failed");
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index;

				if (get_FE_nodal_int_value(node,field->indexer_field,
					/*component_number*/0,/*version*/0,
					FE_NODAL_VALUE,/*time*/0,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						values_storage=field->values_storage+
							get_Value_storage_size(STRING_VALUE,
							(struct FE_time_sequence *)NULL)*
							(field->number_of_indexed_values*component_number+index-1);
						return_code=1;	
					}
					else
					{
						display_message(ERROR_MESSAGE,"get_FE_nodal_string_value.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"get_FE_nodal_string_value.  "
						"Field %s, indexed by %s not defined at node %",
						field->name,field->indexer_field->name,node->cm_node_identifier);
					return_code=0;	
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_string_value.  Unknown FE_field_type");
			} break;
		}
		if (return_code&&values_storage)
		{
			if (the_string = *((char **)values_storage))
			{
				if (ALLOCATE(*string,char,strlen(the_string)+1))
				{
					strcpy(*string,the_string);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_nodal_string_value.  Not enough memory");
					return_code=0;
				}
			}
			else
			{
				/* no string, so successfully return NULL */
				*string = (char *)NULL;
			}
		}
		else
		{
			if (return_code)
			{
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_element_xi_value.  No values storage");
				return_code=0;
			}
		}
	}		
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_string_value.Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_string_value */

int set_FE_nodal_string_value(struct FE_node *node,
	struct FE_field *field,int component_number,int version,
	enum FE_nodal_value_type type,char *string)
/*******************************************************************************
LAST MODIFIED : 22 September 1999

DESCRIPTION :
Copies and sets the <string> for <version>, <type> of <field><component_number>
at the <node>. <string> may be NULL.
==============================================================================*/
{
	char *the_string,**string_address;
	int return_code; 
	struct FE_time_sequence *time_sequence;
	Value_storage *values_storage = NULL;

	ENTER(set_FE_nodal_string_value);
	return_code=0;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components)&&(0<=version))
	{
		/* get the values storage */
		if (find_FE_nodal_values_storage_dest(node,field,component_number,
			version,type,STRING_VALUE,&values_storage,&time_sequence))
		{
			/* get the pointer to the stored string */			
			string_address = (char **)(values_storage);
			if (string)
			{
				/* reallocate the string currently there */
				if (REALLOCATE(the_string,*string_address,char,strlen(string)+1))
				{
					strcpy(the_string,string);
					*string_address=the_string;
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_nodal_string_value.  Not enough memory");
				}
			}
			else
			{
				/* NULL string; free the existing string */
				if (*string_address)
				{
					DEALLOCATE(*string_address);
				}
				return_code=1;
			}
		}
		else
		{	
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_string_value.  find_FE_nodal_values_storage_dest failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_string_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_string_value */

int set_FE_nodal_field_double_values(struct FE_field *field,
	struct FE_node *node,double *values, int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the doubles in values. 
Returns the number of doubles copied in number_of_values.
Assumes that values is set up with the correct number of doubles.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,number_of_derivatives,
		length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	double *dest,*source;

	ENTER(set_FE_nodal_field_double_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==DOUBLE_VALUE)
		{
			if (node_field =FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))
			{
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (double *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length = (1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_double_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_double_values.  "
				"field->value_type != DOUBLE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_double_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_field_double_values */

int get_FE_nodal_field_number_of_values(struct FE_field *field,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Returns the total number of values stored for that field at the node, equals
sum of <1+num_derivatives>*num_versions for each component.
==============================================================================*/
{
	int number_of_values;
	struct FE_node_field *node_field;
	
	ENTER(get_FE_nodal_field_number_of_values);
	if (field&&node&&node->fields)
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node->fields->node_field_list))
		{
			number_of_values=FE_node_field_get_number_of_values(node_field);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_nodal_field_number_of_values.  Can't find field %s at node %d",
				field->name,node->cm_node_identifier);
			number_of_values=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_nodal_field_number_of_values.  Invalid argument(s)");
		number_of_values=0;
	}
	LEAVE;

	return (number_of_values);
} /* get_FE_nodal_field_number_of_values */

int get_FE_nodal_field_FE_value_values(struct FE_field *field,
	struct FE_node *node,int *number_of_values,FE_value **values)
/*******************************************************************************
LAST MODIFIED : 20 September 1999

DESCRIPTION :
Allocates and returns a copy of the <number_of_values>-length <values> array
stored at the <node> for all components derivatives and versions of <field>.
It is up to the calling function to DEALLOCATE the returned array.
==============================================================================*/
{
	int i,j,length,number_of_derivatives,number_of_versions,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	FE_value *dest,*source;

	ENTER(get_FE_nodal_field_FE_value_values);
	return_code=0;
	if (field&&node&&number_of_values&&values&&node->values_storage)
	{
		if (field->value_type==FE_VALUE_VALUE)
		{
			if ((node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))&&node_field->components)
			{
				*number_of_values=FE_node_field_get_number_of_values(node_field);
				if (ALLOCATE(*values,FE_value,*number_of_values))
				{
					dest= *values;
					for (i=0;i<field->number_of_components;i++)
					{
						component = &(node_field->components[i]);
						source=(FE_value *)(node->values_storage + component->value);
						number_of_versions = component->number_of_versions;
						number_of_derivatives = component->number_of_derivatives;
						length=(1+number_of_derivatives)*number_of_versions;
						for (j=length;0<j;j--)
						{
							*dest = *source;
							dest++;
							source++;
						}
					}
					return_code=1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_nodal_field_FE_value_values.  Not enough memory");
				}
			}
			else
			{	
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_field_FE_value_values.  Can't find field %s at node %d",
					field->name,node->cm_node_identifier);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"get_FE_nodal_field_FE_value_values.  "
				"value_type not FE_VALUE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_field_FE_value_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_field_FE_value_values */

int set_FE_nodal_field_FE_value_values(struct FE_field *field,
	struct FE_node *node,FE_value *values,int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the FE_values in values. 
Returns the number of FE_values copied in number_of_values.
Assumes that values is set up with the correct number of FE_values.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,number_of_derivatives,
		length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	FE_value *dest,*source;

	ENTER(set_FE_nodal_field_FE_value_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==FE_VALUE_VALUE)
		{
			if (node_field =FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))
			{
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (FE_value *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length =(1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_FE_value_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_FE_value_values.  "
				"field->value_type not FE_VALUE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_FE_value_values.  "
			"Invalid arguments.  %p %p %p",field,node,values);
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_field_FE_value_values */

int set_FE_nodal_field_FE_values_at_time(struct FE_field *field,
	struct FE_node *node,FE_value *values,int *number_of_values,
	FE_value time)
/*******************************************************************************
LAST MODIFIED : 15 November 2001

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the FE_values in values. 
Returns the number of FE_values copied in number_of_values.
Assumes that values is set up with the correct number of FE_values.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,number_of_derivatives,
		length,i,j,the_number_of_values, time_index;
	FE_value *array,**dest,*source;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;

	ENTER(set_FE_nodal_field_FE_value_values);
	return_code = 0;
	the_number_of_values = 0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==FE_VALUE_VALUE)
		{
			if (node_field =FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))
			{
				if ((node_field->time_sequence) &&
					(FE_time_sequence_get_index_for_time(
					node_field->time_sequence, time, &time_index)))
				{
					return_code=1;
					number_of_components = node_field->field->number_of_components;
					source = values;
					for (i=0;(i<number_of_components)&&return_code;i++)
					{					
						j=0;
						component = &(node_field->components[i]);
						dest = (FE_value **)(node->values_storage + component->value);
						number_of_versions = component->number_of_versions;
						number_of_derivatives = component->number_of_derivatives;
						length =(1+number_of_derivatives)*number_of_versions;
						while ((j<length) && return_code)
						{
							array = *dest;
							array[time_index] = *source;
							j++;
							dest++;
							source++;
						}				
						the_number_of_values += length;
					}
					*number_of_values = the_number_of_values; 			
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"set_FE_nodal_field_FE_values_at_time.  "
						"Either the field does not depend on time or the specified time (%f) has not been defined.", time);
					return_code = 0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_nodal_field_FE_values_at_time.  "
					"Can't find field in node.");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"set_FE_nodal_field_FE_values_at_time.  "
				"field->value_type not FE_VALUE_VALUE");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_nodal_field_FE_values_at_time.  "
			"Invalid arguments.  %p %p %p",field,node,values);
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_field_FE_values_at_time */

int set_FE_nodal_field_float_values(struct FE_field *field,
	struct FE_node *node,float *values, int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the floats in values. 
Returns the number of floats copied in number_of_values.
Assumes that values is set up with the correct number of floats.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,number_of_derivatives,
		length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	float *dest,*source;

	ENTER(set_FE_nodal_field_float_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==FLT_VALUE)
		{
			if (node_field =FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))
			{		 
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (float *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length =(1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_float_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_float_values.  "
				"field->value_type != FLT_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_float_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_field_float_values */

int get_FE_nodal_field_int_values(struct FE_field *field,
	struct FE_node *node,int *number_of_values,int **values)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Allocates and returns a copy of the <number_of_values>-length <values> array
stored at the <node> for all components derivatives and versions of <field>.
It is up to the calling function to DEALLOCATE the returned array.
==============================================================================*/
{
	int i,j,length,number_of_derivatives,number_of_versions,return_code;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	int *dest,*source;

	ENTER(get_FE_nodal_field_int_values);
	return_code=0;
	if (field&&node&&number_of_values&&values&&node->values_storage)
	{
		if (field->value_type==INT_VALUE)
		{
			if ((node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
				node->fields->node_field_list))&&node_field->components)
			{
				*number_of_values=FE_node_field_get_number_of_values(node_field);
				if (ALLOCATE(*values,int,*number_of_values))
				{
					return_code=1;
					dest= *values;
					for (i=0;i<field->number_of_components;i++)
					{
						component = &(node_field->components[i]);
						source=(int *)(node->values_storage + component->value);
						number_of_versions = component->number_of_versions;
						number_of_derivatives = component->number_of_derivatives;
						length=(1+number_of_derivatives)*number_of_versions;
						for (j=length;0<j;j--)
						{
							*dest = *source;
							dest++;
							source++;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_nodal_field_int_values.  Not enough memory");
				}
			}
			else
			{	
				display_message(ERROR_MESSAGE,
					"get_FE_nodal_field_int_values.  Can't find field %s at node %d",
					field->name,node->cm_node_identifier);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"get_FE_nodal_field_int_values.  "
				"value_type not FE_VALUE_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_nodal_field_int_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return (return_code);
} /* get_FE_nodal_field_int_values */

int set_FE_nodal_field_int_values(struct FE_field *field,
	struct FE_node *node,int *values, int *number_of_values)
/*******************************************************************************
LAST MODIFIED : 30 August 1999

DESCRIPTION :
Sets the node field's values storage (at node->values_storage, NOT 
field->values_storage) with the integers in values. 
Returns the number of integers copied in number_of_values.
Assumes that values is set up with the correct number of ints.
Assumes that the node->values_storage has been allocated with enough 
memory to hold all the values.
Assumes that the nodal fields have been set up, with information to 
place the values.
==============================================================================*/
{
	int return_code,number_of_components,number_of_versions,
		number_of_derivatives,length,i,j,the_number_of_values=0;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;
	int *dest,*source;

	ENTER(set_FE_nodal_field_int_values);
	return_code=0;
	if (field&&node&&values&&(node->values_storage))
	{
		if (field->value_type==INT_VALUE)
		{
			if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				field,node->fields->node_field_list))
			{
				return_code=1;
				number_of_components = node_field->field->number_of_components;
				source = values;
				for (i=0;i<number_of_components;i++)
				{					
					j=0;
					component = &(node_field->components[i]);
					dest = (int *)(node->values_storage + component->value);
					number_of_versions = component->number_of_versions;
					number_of_derivatives = component->number_of_derivatives;
					length =(1+number_of_derivatives)*number_of_versions;
					while (j<length)
					{
						*dest = *source;
						j++;
						dest++;
						source++;
					}				
					the_number_of_values += length;
				}
				*number_of_values = the_number_of_values; 			
			}
			else
			{	
				display_message(ERROR_MESSAGE,"set_FE_nodal_field_int_values.  "
					"Can't find field in node");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"set_FE_nodal_field_int_values.  "
				"field->value_type != INT_VALUE");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_nodal_field_int_values.  "
			"Invalid arguments");
	}
	LEAVE;

	return (return_code);
} /* set_FE_nodal_field_int_values */

int get_FE_node_number_of_values(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 5 November 1998

DESCRIPTION :
Returns the number of values stored at the <node>.
==============================================================================*/
{
	int number_of_values;

	ENTER(get_FE_node_number_of_values);
	if (node&&(node->fields))
	{
		number_of_values=node->fields->number_of_values;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_number_of_values.  Invalid node");
		number_of_values=0;
	}
	LEAVE;

	return (number_of_values);
} /* get_FE_node_number_of_values */

int get_FE_node_number_of_fields(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 5 November 1998

DESCRIPTION :
Returns the number of fields stored at the <node>.
==============================================================================*/
{
	int number_of_fields;

	ENTER(get_FE_node_number_of_fields);
	if (node&&(node->fields))
	{
		number_of_fields=
			NUMBER_IN_LIST(FE_node_field)(node->fields->node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_number_of_fields.  Invalid node");
		number_of_fields=0;
	}
	LEAVE;

	return (number_of_fields);
} /* get_FE_node_number_of_fields */

struct FE_time_sequence *get_FE_node_field_FE_time_sequence(struct FE_node *node,
	struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 15 November 2004

DESCRIPTION :
Returns the <fe_time_sequence> corresponding to the <node> and <field>.  If the
<node> and <field> have no time dependence then the function will return NULL.
==============================================================================*/
{
	struct FE_node_field *node_field;
	struct FE_time_sequence *time_sequence;

	ENTER(get_FE_node_field_FE_time_sequence);
	if (node&&field)
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,node->fields->node_field_list))
		{
			time_sequence = node_field->time_sequence;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_node_field_component_FE_time_sequence.  "
				"Field %s not defined at node %d",field->name,node->cm_node_identifier);
			time_sequence = (struct FE_time_sequence *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_FE_time_sequence.  Invalid argument(s)");
		time_sequence = (struct FE_time_sequence *)NULL;
	}
	LEAVE;

	return (time_sequence);
} /* get_FE_node_field_FE_time_sequence */

enum FE_nodal_value_type *get_FE_node_field_component_nodal_value_types(
	struct FE_node *node,struct FE_field *field,int component_number)
/*******************************************************************************
LAST MODIFIED : 20 April 2000

DESCRIPTION :
Returns an array of the (1+number_of_derivatives) value types for the
node field component.
It is up to the calling function to DEALLOCATE the returned array.
==============================================================================*/
{
	enum FE_nodal_value_type *nodal_value_types;
	int i,number_of_derivatives;
	struct FE_node_field *node_field;
	struct FE_node_field_component *component;

	ENTER(get_FE_node_field_component_nodal_value_types);
	nodal_value_types=(enum FE_nodal_value_type *)NULL;
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components))
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,node->fields->node_field_list))
		{
			component=&(node_field->components[component_number]);
			number_of_derivatives=component->number_of_derivatives;
			if (ALLOCATE(nodal_value_types,enum FE_nodal_value_type,
				1+number_of_derivatives))
			{
				for (i=0;i<=number_of_derivatives;i++)
				{
					/* non-GENERAL_FE_FIELD do not have nodal_value_types since
						 derivatives do not make sense */
					if (component->nodal_value_types)
					{
						nodal_value_types[i]=component->nodal_value_types[i];
					}
					else
					{
						nodal_value_types[i]=FE_NODAL_VALUE;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_node_field_component_nodal_value_types.  Not enough memory");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_node_field_component_nodal_value_types.  "
				"Field %s not defined at node %d",field->name,node->cm_node_identifier);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_component_nodal_value_types.  Invalid argument(s)");
	}
	LEAVE;

	return (nodal_value_types);
} /* get_FE_node_field_component_nodal_value_types */

int get_FE_node_field_component_number_of_derivatives(struct FE_node *node,
	struct FE_field *field,int component_number)
/*******************************************************************************
LAST MODIFIED : 23 September 1999

DESCRIPTION :
Returns the number of derivatives for the node field component.
==============================================================================*/
{
	int number_of_derivatives;
	struct FE_node_field *node_field;

	ENTER(get_FE_node_field_number_of_derivatives);
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components))
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,node->fields->node_field_list))
		{
			number_of_derivatives = 
				node_field->components[component_number].number_of_derivatives;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_node_field_component_number_of_derivatives.  "
				"Field %s not defined at node %d",field->name,node->cm_node_identifier);
			number_of_derivatives=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_number_of_derivatives.  Invalid argument(s)");
		number_of_derivatives=0;
	}
	LEAVE;

	return (number_of_derivatives);
} /* get_FE_node_field_number_of_derivatives */

int get_FE_node_field_component_number_of_versions(struct FE_node *node,
	struct FE_field *field,int component_number)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Returns the number of versions for the node field component.
==============================================================================*/
{
	int number_of_versions;
	struct FE_node_field *node_field;

	ENTER(get_FE_node_field_component_number_of_versions);
	if (node&&field&&(0<=component_number)&&
		(component_number<field->number_of_components))
	{
		if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
			field,node->fields->node_field_list))
		{
			number_of_versions = 
				node_field->components[component_number].number_of_versions;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_node_field_component_number_of_versions.  "
				"Field %s not defined at node %d",field->name,node->cm_node_identifier);
			number_of_versions=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_field_component_number_of_versions.  Invalid argument(s)");
		number_of_versions=0;
	}
	LEAVE;

	return (number_of_versions);
} /* get_FE_node_field_component_number_of_versions */

int get_FE_node_identifier(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 16 January 2003

DESCRIPTION :
Returns the integer identifier of the <node>.
==============================================================================*/
{
	int identifier;

	ENTER(get_FE_node_identifier);
	if (node)
	{
		identifier = node->cm_node_identifier;
	}
	else
	{
		display_message(ERROR_MESSAGE, "get_FE_node_identifier.  Invalid node");
		identifier = 0;
	}
	LEAVE;

	return (identifier);
} /* get_FE_node_identifier */

int set_FE_node_identifier(struct FE_node *node, int identifier)
/*******************************************************************************
LAST MODIFIED : 16 January 2003

DESCRIPTION :
Changes the identifier of <node> to <identifier>.
Caution! Should only call for nodes that are NOT in indexed lists;
Must wrap in LIST_BEGIN_IDENTIFIER_CHANGE/LIST_END_IDENTIFIER_CHANGE to ensure
node is temporarily removed from all the indexed lists it is in and re-added
afterwards. FE_region should be the only object that needs to call this.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_node_identifier);
	if (node && (0 < identifier))
	{
		node->cm_node_identifier = identifier;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_node_identifier.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_identifier */

int get_FE_node_access_count(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 26 September 2000

DESCRIPTION :
Returns the acccess count of the <node>.
Useful for drawing the access count as a field when trying to debug why things
cannot be destroyed.
==============================================================================*/
{
	int access_count;

	ENTER(get_FE_node_identifier);
	if (node)
	{
		access_count=node->access_count;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_node_access_count.  Invalid node");
		access_count=0;
	}
	LEAVE;

	return (access_count);
} /* get_FE_node_access_count */

struct FE_field *get_FE_node_default_coordinate_field(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 5 November 1998

DESCRIPTION :
Returns the default coordinate field of the <node>.
==============================================================================*/
{
	struct FE_field *default_coordinate_field;
	struct FE_node_field *default_coordinate_node_field;

	ENTER(get_FE_node_default_coordinate_field);
	if (node&&(node->fields))
	{	
		if (default_coordinate_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
			FE_node_field_is_coordinate_field,(void *)NULL,
			node->fields->node_field_list))
		{
			default_coordinate_field=default_coordinate_node_field->field;
		}
		else
		{
			default_coordinate_field=(struct FE_field *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_default_coordinate_field.  Invalid node");
		default_coordinate_field=(struct FE_field *)NULL;
	}
	LEAVE;

	return (default_coordinate_field);
} /* get_FE_node_default_coordinate_field */

int FE_node_find_default_coordinate_field_iterator(
	struct FE_node *node, void *fe_field_ptr_void)
/*******************************************************************************
LAST MODIFIED : 30 November 2001

DESCRIPTION :
An FE_node iterator that returns 1 when an appropriate default_coordinate
fe_field is found.  The fe_field found is returned as fe_field_void.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(FE_node_find_default_coordinate_field_iterator);
	if (node)
	{
		if (field = get_FE_node_default_coordinate_field(node))
		{
			*((struct FE_field **)fe_field_ptr_void) = field;
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_find_default_coordinate_field_iterator.  Missing element");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_find_default_coordinate_field_iterator */

int merge_FE_node(struct FE_node *destination, struct FE_node *source)
/*******************************************************************************
LAST MODIFIED : 24 February 2003

DESCRIPTION :
Merges the fields from <source> into <destination>. Existing fields in the
<destination> keep the same node field description as before with new field
storage following them. Where existing fields in <destination> are passed in
<source>, values from <source> take precedence, but the node field structure
remains unchanged.
Function is atomic; <destination> is unchanged if <source> cannot be merged.
==============================================================================*/
{
	int number_of_values, values_storage_size, return_code;
	struct FE_node_field_info *destination_fields, *fe_node_field_info,
		*source_fields;
	struct FE_region *fe_region;
	struct LIST(FE_node_field) *node_field_list;
	struct Merge_FE_node_field_into_list_data merge_data;
	Value_storage *values_storage;

	ENTER(merge_FE_node);
	if (destination && (destination_fields = destination->fields) &&
		(fe_region = destination_fields->fe_region) &&
		source && (source_fields = source->fields) &&
		(source_fields->fe_region == fe_region))
	{
		return_code = 1;
		/* construct a node field list containing the fields from destination */
		node_field_list = CREATE_LIST(FE_node_field)();
		if (COPY_LIST(FE_node_field)(node_field_list,
			destination_fields->node_field_list))
		{
			/* sum the values_storage_size and number_of_values */
			number_of_values = 0;
			values_storage_size = 0;
			if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(count_nodal_size,
				(void *)(&values_storage_size), node_field_list) &&
				FOR_EACH_OBJECT_IN_LIST(FE_node_field)(count_nodal_values,
					(void *)(&number_of_values), node_field_list))
			{
				/* include the new information */
				merge_data.requires_merged_storage = 0;
				merge_data.values_storage_size = values_storage_size;
				merge_data.number_of_values = number_of_values;
				/* node field list */
				merge_data.list = node_field_list;
				if (FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
					merge_FE_node_field_into_list, (void *)(&merge_data),
					source_fields->node_field_list))
				{
					if (!merge_data.requires_merged_storage)
					{
						/* Don't need to reallocate memory as we are only overwriting
							existing values */
						merge_FE_node_values_storage(destination, (Value_storage *)NULL,
							node_field_list, source);
					}
					else
					{
						number_of_values = merge_data.number_of_values;
						values_storage_size = merge_data.values_storage_size;
						values_storage = (Value_storage *)NULL;
						/* allocate the new values storage and fill it with values from the
							destination and the source, favouring the latter but merging all
							time arrays */
						if ((0 == values_storage_size) ||
							(ALLOCATE(values_storage, Value_storage, values_storage_size) &&
								merge_FE_node_values_storage(destination, values_storage,
									node_field_list, source)))
						{
							/* create a node field info for the combined list */
							if (fe_node_field_info = FE_region_get_FE_node_field_info(
									 fe_region, number_of_values, node_field_list))
							{
								/* clean up old destination values_storage */
								if (destination->values_storage)
								{
									if (destination_fields)
									{			
										FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
											FE_node_field_free_values_storage_arrays,
											(void *)destination->values_storage, 
											destination_fields->node_field_list);
									}
									DEALLOCATE(destination->values_storage);
								}
								/* insert new fields and values_storage */
								REACCESS(FE_node_field_info)(&(destination->fields),
									fe_node_field_info);
								destination->values_storage = values_storage;
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"merge_FE_node.  Could not get node field info");
								/* do not bother to clean up dynamic contents of values_storage */
								DEALLOCATE(values_storage);
								return_code = 0;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_node.  Could copy values_storage");
							/* cannot clean up dynamic contents of values_storage */
							DEALLOCATE(values_storage);
							return_code = 0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"merge_FE_node.  Error merging node field list");
					return_code = 0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"merge_FE_node.  Error counting nodal values");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"merge_FE_node.  Could not copy node field list");
			return_code = 0;
		}
		DESTROY(LIST(FE_node_field))(&node_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE, "merge_FE_node.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_node */

#if !defined (WINDOWS_DEV_FLAG)
int list_FE_node(struct FE_node *node,void *list_node_information)
/*******************************************************************************
LAST MODIFIED : 19 July 2000

DESCRIPTION :
Outputs the information contained at the node.
==============================================================================*/
{
	int return_code;

	ENTER(list_FE_node);
	if (node)
	{
		return_code=1;
		/* write the number */
		display_message(INFORMATION_MESSAGE,"node : %d\n",node->cm_node_identifier);
		if (list_node_information)
		{
			/* write the field information */
			if (node->fields)
			{
				FOR_EACH_OBJECT_IN_LIST(FE_node_field)(list_FE_node_field,(void *)node,
					node->fields->node_field_list);
			}
#if defined (DEBUG)
			/*???debug*/
			display_message(INFORMATION_MESSAGE,"  access count = %d\n",
				node->access_count);
#endif /* defined (DEBUG) */
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_node.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_node */
#endif /* !defined (WINDOWS_DEV_FLAG) */

DECLARE_INDEXED_LIST_FUNCTIONS(FE_node)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_node,cm_node_identifier,int,compare_int)
DECLARE_INDEXED_LIST_IDENTIFIER_CHANGE_FUNCTIONS(FE_node,cm_node_identifier)

DECLARE_CHANGE_LOG_FUNCTIONS(FE_node)

#if defined (OLD_CODE)
PROTOTYPE_MANAGER_COPY_WITH_IDENTIFIER_FUNCTION(FE_node,cm_node_identifier)
{
	int return_code;

	ENTER(MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier));
	if (source&&destination)
	{
		if (return_code=MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier)(
			destination,source))
		{
			destination->cm_node_identifier=source->cm_node_identifier;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
		"MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITH_IDENTIFIER(FE_node,cm_node_identifier) */

PROTOTYPE_MANAGER_COPY_WITHOUT_IDENTIFIER_FUNCTION(FE_node,cm_node_identifier)
/*******************************************************************************
LAST MODIFIED : 14 April 1999

DESCRIPTION :
Creates an EXACT copy of the node (without the identifier).
==============================================================================*/
{
	int return_code;
	Value_storage *temp_values_storage;

	ENTER(MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier));
	if (source&&destination)
	{
		/* make local copy of source values storage */
		temp_values_storage=(Value_storage *)NULL;
		if (allocate_and_copy_FE_node_values_storage(source,&temp_values_storage))
		{
			if (destination->fields)
			{
				FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
					FE_node_field_free_values_storage_arrays,
					(void *)destination->values_storage,destination->fields->node_field_list);
				DEALLOCATE(destination->values_storage);
			}
			destination->values_storage=temp_values_storage;
			REACCESS(FE_node_field_info)(&(destination->fields),source->fields);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier).  Could not allocate memory for node");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITHOUT_IDENTIFIER(FE_node,cm_node_identifier) */

PROTOTYPE_MANAGER_COPY_IDENTIFIER_FUNCTION(FE_node,cm_node_identifier,int)
{
	int return_code;

	ENTER(MANAGER_COPY_IDENTIFIER(FE_node,cm_node_identifier));
	/*???RC cannot rename nodes that are in use by any list outside the manager
		since they must be removed and re-added to keep indexed list working. Hence,
		disallow this for now */
	if (destination)
	{
		/*???RC renaming nodes in use by any list outside the manager will cause
			list to be corrupted. Allow identifier change under protest here so that
			curve / editor work, but disallow name change in select object for
			any object in use outside the manager. */
		destination->cm_node_identifier=cm_node_identifier;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_IDENTIFIER(FE_node,cm_node_identifier).  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_IDENTIFIER(FE_node,cm_node_identifier) */

int overwrite_FE_node_with_cm_node_identifier(struct FE_node *destination,
	struct FE_node *source)
/*******************************************************************************
LAST MODIFIED : 27 September 1995

DESCRIPTION :
Overwrites without merging.
???DB.  Used by node editor.  Merging/overwriting needs sorting out.
==============================================================================*/
{
	int return_code;

	ENTER(overwrite_FE_node_with_cm_node_identifier);
	if (source&&destination)
	{
		if (return_code=overwrite_FE_node_without_cm_node_identifier(destination,source))
		{
			destination->cm_node_identifier=source->cm_node_identifier;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"overwrite_FE_node_cm_node_identifier.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* overwrite_FE_node_with_cm_node_identifier */

int overwrite_FE_node_without_cm_node_identifier(struct FE_node *destination,
	struct FE_node *source)
/*******************************************************************************
LAST MODIFIED : 12 April 1999

DESCRIPTION :
Overwrites without merging.
???DB.  Used by node editor.  Merging/overwriting needs sorting out.
==============================================================================*/
{
	int return_code;
	Value_storage *temp_values_storage;
	ENTER(overwrite_FE_node_without_cm_node_identifier);
	if (source&&destination)
	{
		/* make local copy of source values storage */
		temp_values_storage=(Value_storage *)NULL;		
		if (0<source->fields->number_of_values)
		{		
			if (allocate_and_copy_FE_node_values_storage(source,&temp_values_storage))
			{
				if (destination->fields)
				{
					FOR_EACH_OBJECT_IN_LIST(FE_node_field)(
						FE_node_field_free_values_storage_arrays,
						(void *)destination->values_storage,destination->fields->node_field_list);
					DEALLOCATE(destination->values_storage);
				}
				destination->values_storage=temp_values_storage;
				REACCESS(FE_node_field_info)(&(destination->fields),source->fields);
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"overwrite_FE_node_without_cm_node_identifier.Error allocating value memory");
				return_code=0;
			}
		}
		else
		{
			destination->values_storage=(Value_storage *)NULL;
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"overwrite_FE_node_without_cm_node_identifier.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* overwrite_FE_node_without_cm_node_identifier */
#endif /* defined (OLD_CODE) */

#if defined (OLD_CODE)
int set_FE_node_group_list(struct Parse_state *state,void *node_list_void,
	void *node_group_manager_void)
/*******************************************************************************
LAST MODIFIED : 7 October 1996

DESCRIPTION :
Used in command parsing to create a list of node groups.
???DB.  Should it be here ?
==============================================================================*/
{
	char *current_token;
	int end_list,number_of_groups,return_code;
	struct GROUP(FE_node) *group;
	struct LIST(GROUP(FE_node)) *list;
	struct MANAGER(GROUP(FE_node)) *node_group_manager;

	ENTER(set_FE_node_group_list);
	if (state)
	{
		if (current_token=state->current_token)
		{
			if (strcmp(PARSER_HELP_STRING,current_token)&&
				strcmp(PARSER_RECURSIVE_HELP_STRING,current_token))
			{
				if ((list=(struct LIST(GROUP(FE_node)) *)node_list_void)&&
					(node_group_manager=
					(struct MANAGER(GROUP(FE_node)) *)node_group_manager_void))
				{
					if (fuzzy_string_compare(current_token,"NONE"))
					{
						REMOVE_ALL_OBJECTS_FROM_LIST(GROUP(FE_node))(list);
						return_code=1;
					}
					else
					{
						return_code=1;
						end_list=0;
						while (!end_list&&return_code&&(current_token))
						{
							if (group=FIND_BY_IDENTIFIER_IN_MANAGER(GROUP(FE_node),name)(
								current_token,node_group_manager))
							{
								if (ADD_OBJECT_TO_LIST(GROUP(FE_node))(group,list))
								{
									return_code=shift_Parse_state(state,1);
									if (current_token=state->current_token)
									{
										if (fuzzy_string_compare(current_token,","))
										{
											return_code=shift_Parse_state(state,1);
										}
										else
										{
											end_list=1;
										}
									}
									else
									{
										end_list=1;
									}
								}
								else
								{
									display_message(WARNING_MESSAGE,
										"set_FE_node_group_list.  Could not add group to list");
									return_code=0;
								}
							}
							else
							{
								display_message(WARNING_MESSAGE,"Unknown node group: %s",
									current_token);
								display_parse_state_location(state);
								return_code=0;
							}
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_node_group_list.  Invalid argument(s)");
					return_code=0;
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE," NAME_1,NAME_2, ... ,NAME_N|none");
				if (list=(struct LIST(GROUP(FE_node)) *)node_list_void)
				{
					/* we only want a comma after the name if there is another name to
						follow, so pass the number of groups into the iterator procedure */
					number_of_groups=NUMBER_IN_LIST(GROUP(FE_node))(list);
					if (0==number_of_groups)
					{
						display_message(INFORMATION_MESSAGE,"[none]");
					}
					else
					{
						display_message(INFORMATION_MESSAGE,"[");
						FOR_EACH_OBJECT_IN_LIST(GROUP(FE_node))
							(set_FE_node_group_list_sub,(void *)&number_of_groups,list);
						display_message(INFORMATION_MESSAGE,"]");
					}
				}
				return_code=1;
			}
		}
		else
		{
			display_message(WARNING_MESSAGE,"No node groups given");
			display_parse_state_location(state);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_node_group_list.  Missing state");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_group_list */
#endif /* defined (OLD_CODE) */

#if defined (OLD_CODE)
int list_group_FE_node(struct GROUP(FE_node) *node_group,void *list_nodes)
/*******************************************************************************
LAST MODIFIED : 21 September 2000

DESCRIPTION :
Outputs the information contained by the node group.
==============================================================================*/
{
	char *group_name;
	int return_code;
	struct Multi_range *node_ranges;

	ENTER(list_group_FE_node);
	if (node_group)
	{
		if (return_code=GET_NAME(GROUP(FE_node))(node_group,&group_name))
		{
			if (list_nodes)
			{
				display_message(INFORMATION_MESSAGE,"Node group %s:\n",group_name);
				node_ranges=CREATE(Multi_range)();
				if (FOR_EACH_OBJECT_IN_GROUP(FE_node)(
					add_FE_node_number_to_Multi_range,(void *)node_ranges,node_group))
				{
					return_code=Multi_range_display_ranges(node_ranges);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"list_group_FE_node.  Could not get node ranges");
					return_code=0;
				}
				DESTROY(Multi_range)(&node_ranges);
			}
			else
			{
				display_message(INFORMATION_MESSAGE,"  %s\n",group_name);
			}
			DEALLOCATE(group_name);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_group_FE_node.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_group_FE_node */
#endif /* defined (OLD_CODE) */

#if defined (OLD_CODE)
int FE_node_group_intersects_list(struct GROUP(FE_node) *node_group,
	void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Returns true if <node_group> contains any nodes in <node_list>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_node_group_intersects_list);
	if (node_group&&node_list_void)
	{
		return_code = (struct FE_node *)NULL !=
			FIRST_OBJECT_IN_GROUP_THAT(FE_node)(FE_node_is_in_list,
				node_list_void,node_group);
	}
	else
	{
		display_message(WARNING_MESSAGE,
			"FE_node_group_intersects_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_group_intersects_list */
#endif /* defined (OLD_CODE) */

struct FE_basis *CREATE(FE_basis)(int *type)
/*******************************************************************************
LAST MODIFIED : 02 April 2008

DESCRIPTION :
A basis is created with the specified <type> (duplicated).  The basis is
returned.
==============================================================================*/
{
	char valid_type;
	FE_value *blending_matrix,*polygon_blending_matrix,*reorder_1,*reorder_2,
		*temp_matrix;
	int *argument,*arguments,*basis_function_number,*basis_function_numbers,
		*basis_type,fn,i,j,k,l,need_reorder,new_func_count,new_std_func_count,
		number_of_basis_functions,
		number_of_polygon_verticies,number_of_standard_basis_functions,
		number_of_xi_coordinates,offset_1,offset_2,polygon_offset,*reorder_offsets,
		*reorder_xi,*reorder_xi_entry,simplex_dimension,simplex_offset,simplex_order,
		simplex_type,step_1,step_2,*temp_int_ptr_1,*temp_int_ptr_2,temp_int_1,
		temp_int_2,temp_int_3,*type_column,*type_entry,xi_coordinate;
	Standard_basis_function *standard_basis;
	struct FE_basis *basis;

	ENTER(CREATE(FE_basis));
	if (type&&((number_of_xi_coordinates= *type)>0))
	{
		/* check that the type is valid */
		if (ALLOCATE(arguments,int,number_of_xi_coordinates+1)&&
			ALLOCATE(blending_matrix,FE_value,1)&&
			ALLOCATE(basis_function_numbers,int,2*(number_of_xi_coordinates+1))&&
			ALLOCATE(reorder_xi,int,number_of_xi_coordinates))
		{
#if defined (DEBUG)
			/*???debug */
			printf("create basis : %d\n",number_of_xi_coordinates);
#endif /* defined (DEBUG) */
			*arguments=number_of_xi_coordinates;
			*blending_matrix=1;
			/* assign a (2*<number_of_xi_coordinates>+1)-tuple to each basis function
				so that can order the basis functions (rows of the blending matrix) with
				FE_nodal_value_type varying fastest, xi1 varying next fastest, xi2
				varying next fastest and so on */
			basis_function_number=basis_function_numbers;
			for (i=2*(number_of_xi_coordinates+1);i>0;i--)
			{
				*basis_function_number=0;
				basis_function_number++;
			}
			basis_function_numbers[1]=number_of_xi_coordinates;
			valid_type=1;
			number_of_basis_functions=1;
			number_of_standard_basis_functions=1;
			xi_coordinate=0;
			type_entry=type+1;
			standard_basis=monomial_basis_functions;
			/* for non-tensor product bases (simplex and polygon), the blending
				matrix is initially calculated as the tensor product of the current
				blending matrix and the blending matrix for the non-tensor product
				basis.  This implies that all the coordinates for the non-tensor
				product basis will be consecutive.  The coordinates (columns of the
				blending matrix) then have to be reordered */
			reorder_xi_entry=reorder_xi;
			argument=arguments+1;
			while (valid_type&&(xi_coordinate<number_of_xi_coordinates))
			{
				xi_coordinate++;
				switch (*type_entry)
				{
					case LINEAR_LAGRANGE:
					{
						if (temp_matrix=tensor_product(2,2,
							linear_lagrange_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							temp_int_1=number_of_basis_functions*
								2*(number_of_xi_coordinates+1);
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								2*temp_int_1))
							{
								*reorder_xi_entry=xi_coordinate;
								reorder_xi_entry++;
								basis_function_numbers=temp_int_ptr_1;
								memcpy(basis_function_numbers+temp_int_1,basis_function_numbers,
									temp_int_1*sizeof(int));
								basis_function_number=basis_function_numbers+(temp_int_1+
									2*xi_coordinate);
								for (i=number_of_basis_functions;i>0;i--)
								{
									*basis_function_number=1;
									basis_function_number[1]=0;
									basis_function_number += 2*(number_of_xi_coordinates+1);
								}
								number_of_basis_functions *= 2;
								number_of_standard_basis_functions *= 2;
								*argument=1;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case QUADRATIC_LAGRANGE:
					{
						if (temp_matrix=tensor_product(3,3,
							quadratic_lagrange_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							temp_int_1=number_of_basis_functions*
								2*(number_of_xi_coordinates+1);
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								3*temp_int_1))
							{
								*reorder_xi_entry=xi_coordinate;
								reorder_xi_entry++;
								basis_function_numbers=temp_int_ptr_1;
								memcpy(basis_function_numbers+temp_int_1,basis_function_numbers,
									temp_int_1*sizeof(int));
								memcpy(basis_function_numbers+(2*temp_int_1),
									basis_function_numbers,temp_int_1*sizeof(int));
								basis_function_number=basis_function_numbers+(temp_int_1+
									2*xi_coordinate);
								for (i=number_of_basis_functions;i>0;i--)
								{
									*basis_function_number=1;
									basis_function_number[1]=0;
									basis_function_number[temp_int_1]=2;
									basis_function_number[temp_int_1+1]=0;
									basis_function_number += 2*(number_of_xi_coordinates+1);
								}
								number_of_basis_functions *= 3;
								number_of_standard_basis_functions *= 3;
								*argument=2;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case CUBIC_LAGRANGE:
					{
						if (temp_matrix=tensor_product(4,4,cubic_lagrange_blending_matrix,
							number_of_basis_functions,number_of_standard_basis_functions,
							blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							temp_int_1=number_of_basis_functions*
								2*(number_of_xi_coordinates+1);
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								4*temp_int_1))
							{
								*reorder_xi_entry=xi_coordinate;
								reorder_xi_entry++;
								basis_function_numbers=temp_int_ptr_1;
								memcpy(basis_function_numbers+temp_int_1,basis_function_numbers,
									temp_int_1*sizeof(int));
								memcpy(basis_function_numbers+(2*temp_int_1),
									basis_function_numbers,temp_int_1*sizeof(int));
								memcpy(basis_function_numbers+(3*temp_int_1),
									basis_function_numbers,temp_int_1*sizeof(int));
								basis_function_number=basis_function_numbers+(temp_int_1+
									2*xi_coordinate);
								for (i=number_of_basis_functions;i>0;i--)
								{
									*basis_function_number=1;
									basis_function_number[1]=0;
									basis_function_number[temp_int_1]=2;
									basis_function_number[temp_int_1+1]=0;
									basis_function_number[2*temp_int_1]=3;
									basis_function_number[2*temp_int_1+1]=0;
									basis_function_number += 2*(number_of_xi_coordinates+1);
								}
								number_of_basis_functions *= 4;
								number_of_standard_basis_functions *= 4;
								*argument=3;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case CUBIC_HERMITE:
					{
						if (temp_matrix=tensor_product(4,4,cubic_hermite_blending_matrix,
							number_of_basis_functions,number_of_standard_basis_functions,
							blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							temp_int_1=number_of_basis_functions*
								2*(number_of_xi_coordinates+1);
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								4*temp_int_1))
							{
								*reorder_xi_entry=xi_coordinate;
								reorder_xi_entry++;
								basis_function_numbers=temp_int_ptr_1;
								memcpy(basis_function_numbers+temp_int_1,basis_function_numbers,
									temp_int_1*sizeof(int));
								memcpy(basis_function_numbers+(2*temp_int_1),
									basis_function_numbers,temp_int_1*sizeof(int));
								memcpy(basis_function_numbers+(3*temp_int_1),
									basis_function_numbers,temp_int_1*sizeof(int));
								basis_function_number=basis_function_numbers+(temp_int_1+
									2*xi_coordinate);
								for (i=number_of_basis_functions;i>0;i--)
								{
									*basis_function_number=0;
									basis_function_number[1]=1;
									basis_function_number[temp_int_1]=1;
									basis_function_number[temp_int_1+1]=0;
									basis_function_number[2*temp_int_1]=1;
									basis_function_number[2*temp_int_1+1]=1;
									basis_function_number += 2*(number_of_xi_coordinates+1);
								}
								number_of_basis_functions *= 4;
								number_of_standard_basis_functions *= 4;
								*argument=3;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case HERMITE_LAGRANGE:
					{
						if (temp_matrix=tensor_product(3,3,
							hermite_lagrange_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							temp_int_1=number_of_basis_functions*
								2*(number_of_xi_coordinates+1);
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								3*temp_int_1))
							{
								*reorder_xi_entry=xi_coordinate;
								reorder_xi_entry++;
								basis_function_numbers=temp_int_ptr_1;
								memcpy(basis_function_numbers+temp_int_1,basis_function_numbers,
									temp_int_1*sizeof(int));
								memcpy(basis_function_numbers+(2*temp_int_1),
									basis_function_numbers,temp_int_1*sizeof(int));
								basis_function_number=basis_function_numbers+(temp_int_1+
									2*xi_coordinate);
								for (i=number_of_basis_functions;i>0;i--)
								{
									*basis_function_number=0;
									basis_function_number[1]=1;
									basis_function_number[temp_int_1]=1;
									basis_function_number[temp_int_1+1]=0;
									basis_function_number += 2*(number_of_xi_coordinates+1);
								}
								number_of_basis_functions *= 3;
								number_of_standard_basis_functions *= 3;
								*argument=2;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case LAGRANGE_HERMITE:
					{
						if (temp_matrix=tensor_product(3,3,
							lagrange_hermite_blending_matrix,number_of_basis_functions,
							number_of_standard_basis_functions,blending_matrix))
						{
							DEALLOCATE(blending_matrix);
							blending_matrix=temp_matrix;
							temp_int_1=number_of_basis_functions*
								2*(number_of_xi_coordinates+1);
							if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
								3*temp_int_1))
							{
								*reorder_xi_entry=xi_coordinate;
								reorder_xi_entry++;
								basis_function_numbers=temp_int_ptr_1;
								memcpy(basis_function_numbers+temp_int_1,basis_function_numbers,
									temp_int_1*sizeof(int));
								memcpy(basis_function_numbers+(2*temp_int_1),
									basis_function_numbers,temp_int_1*sizeof(int));
								basis_function_number=basis_function_numbers+(temp_int_1+
									2*xi_coordinate);
								for (i=number_of_basis_functions;i>0;i--)
								{
									*basis_function_number=1;
									basis_function_number[1]=0;
									basis_function_number[temp_int_1]=1;
									basis_function_number[temp_int_1+1]=1;
									basis_function_number += 2*(number_of_xi_coordinates+1);
								}
								number_of_basis_functions *= 3;
								number_of_standard_basis_functions *= 3;
								*argument=2;
								argument++;
								valid_type=1;
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							valid_type=0;
						}
					} break;
					case POLYGON:
					{
						/* check if the other polygon coordinate is before */
						valid_type=2;
						number_of_polygon_verticies=0;
						type_column=type_entry;
						i=xi_coordinate-1;
						j=number_of_xi_coordinates-xi_coordinate;
						while (valid_type&&(i>0))
						{
							j++;
							type_column -= j;
							if (NO_RELATION!= *type_column)
							{
								if (0<number_of_polygon_verticies)
								{
									valid_type=0;
								}
								else
								{
									if ((number_of_polygon_verticies= *type_column)<3)
									{
										valid_type=0;
									}
								}
							}
							i--;
						}
						if (valid_type)
						{
							if (0<number_of_polygon_verticies)
							{
								/* make sure that it is not connected to a following xi */
								type_entry++;
								i=number_of_xi_coordinates-xi_coordinate;
								while (valid_type&&(i>0))
								{
									if (NO_RELATION!= *type_entry)
									{
										valid_type=0;
									}
									type_entry++;
									i--;
								}
							}
							else
							{
								/* check if the other polygon coordinate is after */
								type_entry++;
								i=number_of_xi_coordinates-xi_coordinate;
								while (valid_type&&(i>0))
								{
									if (NO_RELATION!= *type_entry)
									{
										if (0<number_of_polygon_verticies)
										{
											valid_type=0;
										}
										else
										{
											if ((number_of_polygon_verticies= *type_entry)>2)
											{
												polygon_offset=number_of_xi_coordinates-xi_coordinate+
													1-i;
												if (POLYGON!=type_entry[(polygon_offset*
													(2*(number_of_xi_coordinates-xi_coordinate+1)-
													polygon_offset+1))/2-polygon_offset])
												{
													valid_type=0;
												}
											}
											else
											{
												valid_type=0;
											}
										}
									}
									type_entry++;
									i--;
								}
								if (valid_type&&(0<number_of_polygon_verticies))
								{
									*reorder_xi_entry=xi_coordinate;
									reorder_xi_entry++;
									*reorder_xi_entry=xi_coordinate+polygon_offset;
									reorder_xi_entry++;
									/* see polygon_basis_functions for the polygon blending
										matrix */
									if (ALLOCATE(polygon_blending_matrix,FE_value,
										(number_of_polygon_verticies+1)*
										4*number_of_polygon_verticies))
									{
										temp_matrix=polygon_blending_matrix;
										for (j=number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix=1;
											temp_matrix++;
										}
										for (j=number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix=0;
											temp_matrix++;
										}
										for (j=number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix= -1;
											temp_matrix++;
										}
										for (j=(4*number_of_polygon_verticies+1)*
											number_of_polygon_verticies;j>0;j--)
										{
											*temp_matrix=0;
											temp_matrix++;
										}
										temp_matrix=polygon_blending_matrix+
											(6*number_of_polygon_verticies);
										*temp_matrix=1;
										temp_matrix += number_of_polygon_verticies;
										*temp_matrix= -1;
										temp_matrix[number_of_polygon_verticies-1]=1;
										step_1=3*number_of_polygon_verticies+1;
										step_2=number_of_polygon_verticies-1;
										for (j=number_of_polygon_verticies-1;j>0;j--)
										{
											temp_matrix += step_1;
											*temp_matrix=1;
											temp_matrix += step_2;
											*temp_matrix=1;
											temp_matrix++;
											*temp_matrix= -1;
										}
										if (temp_matrix=tensor_product(
											number_of_polygon_verticies+1,
											4*number_of_polygon_verticies,polygon_blending_matrix,
											number_of_basis_functions,
											number_of_standard_basis_functions,blending_matrix))
										{
											DEALLOCATE(blending_matrix);
											blending_matrix=temp_matrix;
											temp_int_1=number_of_basis_functions*
												2*(number_of_xi_coordinates+1);
											if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,int,
												(number_of_polygon_verticies+1)*temp_int_1))
											{
												basis_function_numbers=temp_int_ptr_1;
												for (i=number_of_polygon_verticies;i>0;i--)
												{
													memcpy(basis_function_numbers+(i*temp_int_1),
														basis_function_numbers,temp_int_1*sizeof(int));
												}
												basis_function_number=basis_function_numbers+
													(2*xi_coordinate);
												for (i=number_of_basis_functions;i>0;i--)
												{
													for (j=number_of_polygon_verticies;j>0;j--)
													{
														basis_function_number[j*temp_int_1]=j;
														basis_function_number[j*temp_int_1+1]=0;
													}
													basis_function_number +=
														2*(number_of_xi_coordinates+1);
												}
												number_of_basis_functions *=
													number_of_polygon_verticies+1;
												number_of_standard_basis_functions *=
													4*number_of_polygon_verticies;
												*argument= -(1+2*(1/*polygon_offset*/+1/*order*/*
													number_of_xi_coordinates));
												argument++;
												*argument= -2*number_of_polygon_verticies;
												argument++;
												standard_basis=polygon_basis_functions;
												valid_type=2;
											}
											else
											{
												valid_type=0;
											}
										}
										else
										{
											valid_type=0;
										}
										DEALLOCATE(polygon_blending_matrix);
									}
									else
									{
										valid_type=0;
									}
								}
								else
								{
									valid_type=0;
								}
							}
						}
					} break;
					case LINEAR_SIMPLEX:
					case QUADRATIC_SIMPLEX:
					{
						/* simplex */
						/* to avoid increment/check of row */
						valid_type=2;
						/* determine if this is the first component of the simplex */
						simplex_dimension=1;
						type_column=type_entry;
						i=xi_coordinate-1;
						j=number_of_xi_coordinates-xi_coordinate;
						while (valid_type&&(i>0))
						{
							j++;
							type_column -= j;
							if (NO_RELATION!= *type_column)
							{
								simplex_dimension++;
							}
							i--;
						}
						if (1==simplex_dimension)
						{
							/* first component of the simplex */
							*reorder_xi_entry=xi_coordinate;
							reorder_xi_entry++;
							simplex_type= *type_entry;
								/*???DB.  Maybe able to remove if can work how to calculate the
									blending matrix for an arbitrary order */
							/* determine the simplex dimension */
							type_entry++;
							i=1;
							while (valid_type && (i<=number_of_xi_coordinates-xi_coordinate))
							{
								if (NO_RELATION!= *type_entry)
								{
									simplex_offset=i;
									if (simplex_type==type_entry[simplex_offset*
										(2*(number_of_xi_coordinates-xi_coordinate+1)+
										(1-simplex_offset))/2-i])
									{
										*reorder_xi_entry=xi_coordinate+i;
										reorder_xi_entry++;
										simplex_dimension++;
									}
									else
									{
										valid_type = 0;
									}
								}
								type_entry++;
								i++;
							}
							if (valid_type && (2<=simplex_dimension))
							{
								/*???DB.  Should be able to calculate the blending matrix for
									arbitrary dimension and arbitrary order, but get the basics
									going first */
								switch (simplex_type)
								{
									case LINEAR_SIMPLEX:
									{
										simplex_order=1;
										switch (simplex_dimension)
										{
											case 2:
											{
												if (temp_matrix=tensor_product(3,4,
													linear_simplex_2d_blending_matrix,
													number_of_basis_functions,
													number_of_standard_basis_functions,blending_matrix))
												{
													DEALLOCATE(blending_matrix);
													blending_matrix=temp_matrix;
													temp_int_1=number_of_basis_functions*
														2*(number_of_xi_coordinates+1);
													if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
														int,3*temp_int_1))
													{
														basis_function_numbers=temp_int_ptr_1;
														memcpy(basis_function_numbers+temp_int_1,
															basis_function_numbers,temp_int_1*sizeof(int));
														memcpy(basis_function_numbers+(2*temp_int_1),
															basis_function_numbers,temp_int_1*sizeof(int));
														basis_function_number=basis_function_numbers+
															(temp_int_1+2*xi_coordinate);
														temp_int_2=temp_int_1+
															2*(*(reorder_xi_entry-1)-xi_coordinate);
														for (i=number_of_basis_functions;i>0;i--)
														{
															*basis_function_number=1;
															basis_function_number[1]=0;
															basis_function_number[temp_int_2]=1;
															basis_function_number[temp_int_2+1]=0;
															basis_function_number +=
																2*(number_of_xi_coordinates+1);
														}
														number_of_basis_functions *= 3;
														number_of_standard_basis_functions *= 4;
													}
													else
													{
														valid_type=0;
													}
												}
												else
												{
													valid_type=0;
												}
											} break;
											case 3:
											{
												if (temp_matrix=tensor_product(4,8,
													linear_simplex_3d_blending_matrix,
													number_of_basis_functions,
													number_of_standard_basis_functions,blending_matrix))
												{
													DEALLOCATE(blending_matrix);
													blending_matrix=temp_matrix;
													temp_int_1=number_of_basis_functions*
														2*(number_of_xi_coordinates+1);
													if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
														int,4*temp_int_1))
													{
														basis_function_numbers=temp_int_ptr_1;
														memcpy(basis_function_numbers+temp_int_1,
															basis_function_numbers,temp_int_1*sizeof(int));
														memcpy(basis_function_numbers+(2*temp_int_1),
															basis_function_numbers,temp_int_1*sizeof(int));
														memcpy(basis_function_numbers+(3*temp_int_1),
															basis_function_numbers,temp_int_1*sizeof(int));
														basis_function_number=basis_function_numbers+
															(temp_int_1+2*xi_coordinate);
														temp_int_2=temp_int_1+
															2*(*(reorder_xi_entry-2)-xi_coordinate);
														temp_int_3=2*temp_int_1+
															2*(*(reorder_xi_entry-1)-xi_coordinate);
														for (i=number_of_basis_functions;i>0;i--)
														{
															*basis_function_number=1;
															basis_function_number[1]=0;
															basis_function_number[temp_int_2]=1;
															basis_function_number[temp_int_2+1]=0;
															basis_function_number[temp_int_3]=1;
															basis_function_number[temp_int_3+1]=0;
															basis_function_number +=
																2*(number_of_xi_coordinates+1);
														}
														number_of_basis_functions *= 4;
														number_of_standard_basis_functions *= 8;
													}
													else
													{
														valid_type=0;
													}
												}
												else
												{
													valid_type=0;
												}
											} break;
											default:
											{
												valid_type=0;
											} break;
										}
									} break;
									case QUADRATIC_SIMPLEX:
									{
										simplex_order=2;
										switch (simplex_dimension)
										{
											case 2:
											{
												if (temp_matrix=tensor_product(6,9,
													quadratic_simplex_2d_blending_matrix,
													number_of_basis_functions,
													number_of_standard_basis_functions,blending_matrix))
												{
													DEALLOCATE(blending_matrix);
													blending_matrix=temp_matrix;
													temp_int_1=number_of_basis_functions*
														2*(number_of_xi_coordinates+1);
													if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
														int,6*temp_int_1))
													{
														basis_function_numbers=temp_int_ptr_1;
														memcpy(basis_function_numbers+temp_int_1,
															basis_function_numbers,temp_int_1*sizeof(int));
														memcpy(basis_function_numbers+(2*temp_int_1),
															basis_function_numbers,temp_int_1*sizeof(int));
														memcpy(basis_function_numbers+(3*temp_int_1),
															basis_function_numbers,temp_int_1*sizeof(int));
														memcpy(basis_function_numbers+(4*temp_int_1),
															basis_function_numbers,temp_int_1*sizeof(int));
														memcpy(basis_function_numbers+(5*temp_int_1),
															basis_function_numbers,temp_int_1*sizeof(int));
														basis_function_number=basis_function_numbers+
															(temp_int_1+2*xi_coordinate);
														temp_int_2=2*(*(reorder_xi_entry-1)-xi_coordinate);
														for (i=number_of_basis_functions;i>0;i--)
														{
															*basis_function_number=1;
															basis_function_number[1]=0;
															basis_function_number[temp_int_1]=2;
															basis_function_number[temp_int_1+1]=0;
															basis_function_number[2*temp_int_1+temp_int_2]=1;
															basis_function_number[2*temp_int_1+temp_int_2+1]=
																0;
															basis_function_number[3*temp_int_1]=1;
															basis_function_number[3*temp_int_1+1]=0;
															basis_function_number[3*temp_int_1+temp_int_2]=1;
															basis_function_number[3*temp_int_1+temp_int_2+1]=
																0;
															basis_function_number[4*temp_int_1+temp_int_2]=2;
															basis_function_number[4*temp_int_1+temp_int_2+1]=
																0;
															basis_function_number +=
																2*(number_of_xi_coordinates+1);
														}
														number_of_basis_functions *= 6;
														number_of_standard_basis_functions *= 9;
													}
													else
													{
														valid_type=0;
													}
												}
												else
												{
													valid_type=0;
												}
											} break;
											case 3:
											{
												new_func_count = 10;
												new_std_func_count = 27;
												if (temp_matrix=tensor_product(new_func_count,new_std_func_count,
													quadratic_simplex_3d_blending_matrix,
													number_of_basis_functions,
													number_of_standard_basis_functions,blending_matrix))
												{
													DEALLOCATE(blending_matrix);
													blending_matrix=temp_matrix;
													temp_int_1=number_of_basis_functions*
														2*(number_of_xi_coordinates+1);
													if (REALLOCATE(temp_int_ptr_1,basis_function_numbers,
														int,new_func_count*temp_int_1))
													{
														basis_function_numbers=temp_int_ptr_1;
														for (fn=1; fn<new_func_count; ++fn)
														{
															memcpy(basis_function_numbers+(fn*temp_int_1),
																basis_function_numbers,temp_int_1*sizeof(int));
														}
														basis_function_number=basis_function_numbers+
															(temp_int_1+2*xi_coordinate);
														temp_int_2=2*(*(reorder_xi_entry-2)-xi_coordinate);
														temp_int_3=2*(*(reorder_xi_entry-1)-xi_coordinate);
														for (i=number_of_basis_functions;i>0;i--)
														{
															*basis_function_number=1;
															basis_function_number[1]=0;
															basis_function_number[temp_int_1]=2;
															basis_function_number[temp_int_1+1]=0;
															basis_function_number[2*temp_int_1+temp_int_2]=1;
															basis_function_number[2*temp_int_1+temp_int_2+1]=0;
															
															basis_function_number[3*temp_int_1]=1;
															basis_function_number[3*temp_int_1+1]=0;
															basis_function_number[3*temp_int_1+temp_int_2]=1;
															basis_function_number[3*temp_int_1+temp_int_2+1]=0;

															basis_function_number[4*temp_int_1+temp_int_2]=2;
															basis_function_number[4*temp_int_1+temp_int_2+1]=0;

															basis_function_number[5*temp_int_1+temp_int_3]=1;
															basis_function_number[5*temp_int_1+temp_int_3+1]=0;
															
															basis_function_number[6*temp_int_1]=1;
															basis_function_number[6*temp_int_1+1]=0;
															basis_function_number[6*temp_int_1+temp_int_3]=1;
															basis_function_number[6*temp_int_1+temp_int_3+1]=0;
															
															basis_function_number[7*temp_int_1+temp_int_2]=1;
															basis_function_number[7*temp_int_1+temp_int_2+1]=0;
															basis_function_number[7*temp_int_1+temp_int_3]=1;
															basis_function_number[7*temp_int_1+temp_int_3+1]=0;
															
															basis_function_number[8*temp_int_1+temp_int_3]=2;
															basis_function_number[8*temp_int_1+temp_int_3+1]=0;
															
															basis_function_number += 2*(number_of_xi_coordinates+1);
														}
														number_of_basis_functions *= new_func_count;
														number_of_standard_basis_functions *= new_std_func_count;
													}
													else
													{
														valid_type=0;
													}
												}
												else
												{
													valid_type=0;
												}
											} break;
											default:
											{
												valid_type=0;
											} break;
										}
									} break;
									default:
									{
										valid_type=0;
									} break;
								}
								for (i=simplex_dimension;i>0;i--)
								{
									*argument=simplex_order;
									argument++;
								}
							}
							else
							{
								valid_type=0;
							}
						}
						else
						{
							/* skip rest of row */
							type_entry += number_of_xi_coordinates-xi_coordinate+1;
						}
					} break;
					default:
					{
						valid_type=0;
					} break;
				}
				if (1==valid_type)
				{
					/* 1-dimensional basis component */
					type_entry++;
					i=number_of_xi_coordinates-xi_coordinate;
					while (valid_type&&(i>0))
					{
						if (NO_RELATION!= *type_entry)
						{
							valid_type=0;
						}
						type_entry++;
						i--;
					}
				}
			}
			if (valid_type)
			{
				/* allocate memory for the basis */
				if (ALLOCATE(basis,struct FE_basis,1)&&ALLOCATE(basis_type,int,
					1+number_of_xi_coordinates*(number_of_xi_coordinates+1)/2)&&
					ALLOCATE(basis->blending_matrix,FE_value,number_of_basis_functions*
					number_of_standard_basis_functions))
				{
					/* reorder the xi coordinates */
					need_reorder=0;
					for (i=0;i<number_of_xi_coordinates;i++)
					{
						if (i+1!=reorder_xi[i])
						{
							need_reorder=1;
						}
						reorder_xi[i]=number_of_xi_coordinates*reorder_xi[i]+i;
					}
					if (need_reorder)
					{
						ALLOCATE(reorder_offsets,int,number_of_standard_basis_functions);
						ALLOCATE(temp_int_ptr_1,int,number_of_xi_coordinates+1);
						if (reorder_offsets&&temp_int_ptr_1)
						{
							heapsort((void *)reorder_xi,number_of_xi_coordinates,sizeof(int),
								sort_integers);
							for (i=0;i<number_of_xi_coordinates;i++)
							{
								reorder_xi[i] %= number_of_xi_coordinates;
							}
							reorder_1=basis->blending_matrix;
							reorder_2=blending_matrix;
							for (i=number_of_basis_functions;i>0;i--)
							{
								*reorder_1= *reorder_2;
								reorder_1 += number_of_standard_basis_functions;
								reorder_2 += number_of_standard_basis_functions;
							}
							offset_1=1;
							reorder_offsets[0]=0;
							for (i=0;i<number_of_xi_coordinates;i++)
							{
								offset_2=1;
								for (j=reorder_xi[i];j>0;j--)
								{
									if ((temp_int_1=arguments[j])<0)
									{
										/* polygon */
										temp_int_1= -temp_int_1;
										if (temp_int_1%2)
										{
											/* first polygon coordinate */
											/* do nothing for second because all standard basis
												functions carried by first */
											temp_int_1 /= 2;
											temp_int_1 %= number_of_xi_coordinates;
											offset_2 *= 4*(-arguments[j+temp_int_1])/2;
										}
									}
									else
									{
										offset_2 *= temp_int_1+1;
									}
								}
								if ((temp_int_1=arguments[reorder_xi[i]+1])<0)
								{
									/* polygon */
									temp_int_1= -temp_int_1;
									if (temp_int_1%2)
									{
										/* first polygon coordinate */
										temp_int_1 /= 2;
										temp_int_1 %= number_of_xi_coordinates;
										temp_int_1=4*(-arguments[reorder_xi[i]+1+temp_int_1])/2-1;
									}
									else
									{
										/* do nothing for second because all standard basis
											functions carried by first */
										temp_int_1=0;
									}
								}
								for (j=1;j<=temp_int_1;j++)
								{
									for (k=0;k<offset_1;k++)
									{
										reorder_1=basis->blending_matrix+j*offset_1+k;
										reorder_offsets[j*offset_1+k]=
											reorder_offsets[(j-1)*offset_1+k]+offset_2;
										reorder_2=blending_matrix+reorder_offsets[j*offset_1+k];
										for (l=number_of_basis_functions;l>0;l--)
										{
											*reorder_1= *reorder_2;
											reorder_1 += number_of_standard_basis_functions;
											reorder_2 += number_of_standard_basis_functions;
										}
									}
								}
								offset_1 *= temp_int_1+1;
							}
							reorder_1=basis->blending_matrix;
							basis->blending_matrix=blending_matrix;
							blending_matrix=reorder_1;
							temp_int_ptr_1[0]=arguments[0];
							/* don't need to allow for reordering polygon coordinates because
								the exelem format only allows specification of bases with
								circumferential first */
							for (i=number_of_xi_coordinates;i>0;i--)
							{
								if ((temp_int_1=arguments[reorder_xi[i-1]+1])<0)
								{
									/* polygon */
									if ((-temp_int_1)%2)
									{
										temp_int_1= -temp_int_1;
										/* first polygon coordinate */
										temp_int_1 /= 2;
										polygon_offset=temp_int_1%number_of_xi_coordinates;
										temp_int_1 /= number_of_xi_coordinates;
										polygon_offset=reorder_xi[i-1+polygon_offset]-
											reorder_xi[i-1];
										temp_int_1= -(1+2*(polygon_offset+
											temp_int_1*number_of_xi_coordinates));
									}
								}
								temp_int_ptr_1[i]=temp_int_1;
							}
							temp_int_ptr_2=arguments;
							arguments=temp_int_ptr_1;
							temp_int_ptr_1=temp_int_ptr_2;
						}
						else
						{
							display_message(ERROR_MESSAGE,
							"CREATE(FE_basis).  Could not allocate memory for reordering xi");
							DEALLOCATE(basis);
							DEALLOCATE(basis->blending_matrix);
							DEALLOCATE(basis_type);
							DEALLOCATE(arguments);
						}
						DEALLOCATE(reorder_offsets);
						DEALLOCATE(temp_int_ptr_1);
					}
					if (basis)
					{
						basis->access_count=0;
						/* copy the basis type */
						basis->type=basis_type;
						type_entry=type;
						for (i=1+number_of_xi_coordinates*(number_of_xi_coordinates+1)/2-1;
							i>=0;i--)
						{
							*basis_type= *type_entry;
							basis_type++;
							type_entry++;
						}
						basis->number_of_basis_functions=number_of_basis_functions;
						basis->number_of_standard_basis_functions=
							number_of_standard_basis_functions;
						/* reorder the basis functions */
						basis_function_number=basis_function_numbers;
						for (i=0;i<number_of_basis_functions;i++)
						{
							*basis_function_number=i;
							basis_function_number += 2*(number_of_xi_coordinates+1);
						}
						heapsort((void *)basis_function_numbers,number_of_basis_functions,
							2*(number_of_xi_coordinates+1)*sizeof(int),sort_basis_functions);
						/* reorder the blending matrix */
						reorder_1=basis->blending_matrix;
						basis_function_number=basis_function_numbers;
						for (i=0;i<number_of_basis_functions;i++)
						{
							reorder_2=blending_matrix+(((*basis_function_number)%
								number_of_basis_functions)*number_of_standard_basis_functions);
							for (j=0;j<number_of_standard_basis_functions;j++)
							{
								*reorder_1=  *reorder_2;
								reorder_1++;
								reorder_2++;
							}
							basis_function_number += 2*(number_of_xi_coordinates+1);
						}
/*???debug */
/*{
	FE_value *value;
	int i,j;

	printf("%d) %d %d\n",xi_coordinate,number_of_basis_functions,
		number_of_standard_basis_functions);
	value=basis->blending_matrix;
	for (i=number_of_standard_basis_functions;i>0;i--)
	{
		for (j=number_of_basis_functions;j>0;j--)
		{
			printf("%g ",*value);
			value++;
		}
		printf("\n");
	}
	for (i=0;i<number_of_basis_functions;i++)
	{
		printf("%d ",basis_function_numbers[i]);
	}
	printf("\n");
	for (i=0;i<=xi_coordinate;i++)
	{
		printf("%d ",arguments[i]);
	}
	printf("\n");
	printf("%p %p %p\n",standard_basis,monomial_basis_functions,
		polygon_basis_functions);
}*/
						/* create the names for the values that multiply the basis
							functions */
							/*???DB.  To be done */
						basis->value_names=(char **)NULL;
						basis->arguments=arguments;
						basis->standard_basis=standard_basis;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_basis).  Could not allocate memory for basis");
					if (basis)
					{
						DEALLOCATE(basis);
						DEALLOCATE(basis_type);
					}
					DEALLOCATE(arguments);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,"CREATE(FE_basis).  Invalid basis type");
				DEALLOCATE(arguments);
				basis=(struct FE_basis *)NULL;
			}
			DEALLOCATE(basis_function_numbers);
			DEALLOCATE(blending_matrix);
			DEALLOCATE(reorder_xi);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_basis).  Could not allocate memory for basis calculation");
			if (arguments)
			{
				DEALLOCATE(arguments);
				if (blending_matrix)
				{
					DEALLOCATE(blending_matrix);
					DEALLOCATE(basis_function_numbers);
				}
			}
			basis=(struct FE_basis *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"CREATE(FE_basis).  Invalid argument(s)");
		basis=(struct FE_basis *)NULL;
	}
	LEAVE;

	return (basis);
} /* CREATE(FE_basis) */

int DESTROY(FE_basis)(struct FE_basis **basis_address)
/*******************************************************************************
LAST MODIFIED : 1 October 1995

DESCRIPTION :
Frees the memory for the basis and sets <*basis_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_basis *basis;

	ENTER(DESTROY(FE_basis));
	/* check the arguments */
	if ((basis_address)&&(basis= *basis_address))
	{
		if (0==basis->access_count)
		{
			DEALLOCATE(basis->type);
			DEALLOCATE(basis->blending_matrix);
			DEALLOCATE(basis->arguments);
			DEALLOCATE(*basis_address);
			return_code=1;
		}
		else
		{
			return_code=1;
			*basis_address=(struct FE_basis *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_basis) */

struct FE_basis *make_FE_basis(int *basis_type,
	struct MANAGER(FE_basis) *basis_manager )
/*******************************************************************************
LAST MODIFIED : 2 August 1999

DESCRIPTION :
Finds the specfied FE_basis in the basis manager. If it isn't there, creates it,
and adds it to the manager.
==============================================================================*/
{
	struct FE_basis *basis;

	ENTER(make_FE_basis);
	if (basis_manager)
	{
		if (!(basis=FIND_BY_IDENTIFIER_IN_MANAGER(FE_basis,type)
			(basis_type,basis_manager)))
		{
			if (basis=CREATE(FE_basis)(basis_type))
			{
				if (!ADD_OBJECT_TO_MANAGER(FE_basis)(basis,basis_manager))
				{
					DESTROY(FE_basis)(&basis);
					display_message(ERROR_MESSAGE,
						"make_FE_basis. Could not add basis to manager");
					basis = (struct FE_basis *)NULL;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"make_FE_basis Could not create a new basis");
				basis = (struct FE_basis *)NULL;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"make_FE_basis. Invalid arguments");
		basis = (struct FE_basis *)NULL;
	}
	LEAVE;

	return (basis);
} /* make_FE_basis */

DECLARE_OBJECT_FUNCTIONS(FE_basis)

DECLARE_INDEXED_LIST_FUNCTIONS(FE_basis)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_basis,type,int *, \
	compare_FE_basis_type)
DECLARE_INDEXED_LIST_IDENTIFIER_CHANGE_FUNCTIONS(FE_basis,type)

PROTOTYPE_MANAGER_COPY_WITHOUT_IDENTIFIER_FUNCTION(FE_basis,type)
{
	char **destination_value_names,**source_value_name,**value_name;
	FE_value *blending_matrix,*destination_blending_matrix,
		*source_blending_matrix;
	int *argument,*destination_arguments,i,return_code,*source_argument;

	ENTER(MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type));
	if (source&&destination)
	{
		/* copy the source value names */
		if (source_value_name=source->value_names)
		{
			i=source->number_of_basis_functions;
			if (ALLOCATE(destination_value_names,char *,i))
			{
				value_name=destination_value_names;
				return_code=1;
				while (return_code&&(i>0))
				{
					if (*source_value_name)
					{
						if (ALLOCATE(*value_name,char,strlen(*source_value_name)+1))
						{
							strcpy(*value_name,*source_value_name);
							value_name++;
							source_value_name++;
							i--;
						}
						else
						{
							display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for value name");
							return_code=0;
							while (i<source->number_of_basis_functions)
							{
								value_name--;
								if (*value_name)
								{
									DEALLOCATE(*value_name);
								}
								i++;
							}
							DEALLOCATE(destination_value_names);
						}
					}
					else
					{
						*value_name=(char *)NULL;
						value_name++;
						source_value_name++;
						i--;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for value names");
				return_code=0;
			}
		}
		else
		{
			return_code=1;
			destination_value_names=(char **)NULL;
		}
		if (return_code)
		{
			/* copy the source blending matrix */
			if (source_blending_matrix=source->blending_matrix)
			{
				i=(source->number_of_basis_functions)*
					(source->number_of_standard_basis_functions);
				if (ALLOCATE(destination_blending_matrix,FE_value,i))
				{
					blending_matrix=destination_blending_matrix;
					while (i>0)
					{
						*blending_matrix= *source_blending_matrix;
						blending_matrix++;
						source_blending_matrix++;
						i--;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for blending matrix");
					return_code=0;
					if (value_name=destination_value_names)
					{
						for (i=source->number_of_basis_functions;i>0;i--)
						{
							if (*value_name)
							{
								DEALLOCATE(*value_name);
							}
							value_name++;
						}
						DEALLOCATE(destination_value_names);
					}
				}
			}
			if (return_code)
			{
				i=(source->number_of_standard_basis_functions)+1;
				if (ALLOCATE(destination_arguments,int,i))
				{
					argument=destination_arguments;
					source_argument=(int *)(source->arguments);
					while (i>0)
					{
						*argument= *source_argument;
						argument++;
						source_argument++;
						i--;
					}
					/* clear the destination value names */
					if (value_name=destination->value_names)
					{
						for (i=destination->number_of_basis_functions;i>0;i--)
						{
							DEALLOCATE(*value_name);
							value_name++;
						}
						DEALLOCATE(destination->value_names);
					}
					destination->number_of_basis_functions=
						source->number_of_basis_functions;
					destination->value_names=destination_value_names;
					/* clear the destination blending matrix */
					DEALLOCATE(destination->blending_matrix);
					destination->blending_matrix=destination_blending_matrix;
					destination->number_of_standard_basis_functions=
						source->number_of_standard_basis_functions;
					/* clear the destination standard basis function arguments */
					DEALLOCATE(destination->arguments);
					destination->arguments=(void *)destination_arguments;
					source->standard_basis=destination->standard_basis;
				}
				else
				{
					display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Insufficient memory for arguments");
					return_code=0;
					DEALLOCATE(destination_blending_matrix);
					if (value_name=destination_value_names)
					{
						for (i=source->number_of_basis_functions;i>0;i--)
						{
							if (*value_name)
							{
								DEALLOCATE(*value_name);
							}
							value_name++;
						}
						DEALLOCATE(destination_value_names);
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type) */

PROTOTYPE_MANAGER_COPY_IDENTIFIER_FUNCTION(FE_basis,type,int *)
{
	int *basis_type,*destination_type,i,number_of_xi_coordinates,return_code,size;

	ENTER(MANAGER_COPY_IDENTIFIER(FE_basis,type));
	if (destination&&(basis_type=type)&&((number_of_xi_coordinates= *type)>0))
	{
		size=1+(number_of_xi_coordinates*(number_of_xi_coordinates+1))/2;
		if (ALLOCATE(destination_type,int,size))
		{
			DEALLOCATE(destination->type);
			destination->type=destination_type;
			for (i=size;i>0;i--)
			{
				*destination_type= *basis_type;
				basis_type++;
				destination_type++;
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
"MANAGER_COPY_IDENTIFIER(FE_basis,type).  Could not allocate memory for type");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_IDENTIFIER(FE_basis,type).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_IDENTIFIER(FE_basis,type) */

PROTOTYPE_MANAGER_COPY_WITH_IDENTIFIER_FUNCTION(FE_basis,type)
{
	int return_code;

	ENTER(MANAGER_COPY_WITH_IDENTIFIER(FE_basis,type));
	if (source&&destination)
	{
		if (return_code=MANAGER_COPY_WITHOUT_IDENTIFIER(FE_basis,type)(
			destination,source))
		{
			return_code=MANAGER_COPY_IDENTIFIER(FE_basis,type)(destination,
				source->type);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITH_IDENTIFIER(FE_basis,type).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITH_IDENTIFIER(FE_basis,type) */

DECLARE_MANAGER_FUNCTIONS(FE_basis)

DECLARE_DEFAULT_MANAGED_OBJECT_NOT_IN_USE_FUNCTION(FE_basis)

DECLARE_MANAGER_IDENTIFIER_FUNCTIONS(FE_basis,type,int *)

int *FE_basis_string_to_type_array(const char *basis_description_string)
/*******************************************************************************
LAST MODIFIED : 3 November 2004

DESCRIPTION :
Creates a type array from the <basis_description_string>.  Returns the type
array which can be used in CREATE(FE_basis) and make_FE_basis.
It is up to the calling function to DEALLOCATE the returned array.

Some examples of basis descriptions are:
1. c.Hermite*c.Hermite*l.Lagrange  This has cubic variation in xi1 and xi2 and
	linear variation in xi3.
2. c.Hermite*l.simplex(3)*l.simplex  This has cubic variation in xi1 and 2-D
	linear simplex variation for xi2 and xi3.
3. polygon(5,3)*l.Lagrange*polygon  This has linear variation in xi2 and a 2-D
	5-gon for xi1 and xi3.
==============================================================================*/
{
	const char *index,*start_basis_name;
	int *basis_type,component,i,j,*first_simplex,no_error,
		number_of_polygon_vertices,number_of_xi_coordinates,previous_component,
		*temp_basis_type,*xi_basis_type,xi_number;

	ENTER(FE_basis_string_to_type_array);
	basis_type=(int *)NULL;
	if (basis_description_string)
	{
		number_of_xi_coordinates=1;
		index=basis_description_string;
		while (index=strchr(index,'*'))
		{
			index++;
			number_of_xi_coordinates++;
		}
		if (ALLOCATE(basis_type,int,
			1+(number_of_xi_coordinates*(1+ number_of_xi_coordinates))/2))
		{
			/* decipher the basis description */
			xi_number=0;
			start_basis_name=basis_description_string;
			/* skip leading blanks */
			while (' '== *start_basis_name)
			{
				start_basis_name++;
			}
			xi_basis_type=basis_type;
			*xi_basis_type=number_of_xi_coordinates;
			xi_basis_type++;
			no_error=1;
			while (no_error&&(xi_number<number_of_xi_coordinates))
			{
				xi_number++;
				/* determine the interpolation in the xi direction */
				if ((0==strncmp(start_basis_name,"l.simplex",9))||
					(0==strncmp(start_basis_name,"q.simplex",9)))
				{
					/*???debug */
					/*printf("simplex\n");*/
					if (0==strncmp(start_basis_name,"l.simplex",9))
					{
						*xi_basis_type=LINEAR_SIMPLEX;
					}
					else
					{
						*xi_basis_type=QUADRATIC_SIMPLEX;
					}
					/*???debug */
					/*printf("%p %d %d\n",xi_basis_type,*xi_basis_type,LINEAR_SIMPLEX);*/
					start_basis_name += 9;
					/* skip blanks */
					while (' '== *start_basis_name)
					{
						start_basis_name++;
					}
					/* check for links to other simplex components */
					if ('('== *start_basis_name)
					{
						/*???debug */
						/*printf("first simplex component\n");*/
						xi_basis_type++;
						/* assign links to other simplex components */
						previous_component=xi_number+1;
						if ((1==sscanf(start_basis_name,"(%d %n",&component,&i))&&
							(previous_component<=component)&&
							(component<=number_of_xi_coordinates))
						{
							do
							{
								start_basis_name += i;
								while (previous_component<component)
								{
									*xi_basis_type=NO_RELATION;
									xi_basis_type++;
									previous_component++;
								}
								*xi_basis_type=1;
								xi_basis_type++;
								previous_component++;
							} while ((')'!=start_basis_name[0])&&
								(1==sscanf(start_basis_name,"%*[; ]%d %n",&component,&i))&&
								(previous_component<=component)&&
								(component<=number_of_xi_coordinates));
							if (')'==start_basis_name[0])
							{
								/* fill rest of basis_type row with NO_RELATION */
								while (previous_component <= number_of_xi_coordinates)
								{
									*xi_basis_type=NO_RELATION;
									xi_basis_type++;
									previous_component++;
								}
								start_basis_name ++;
							}
							else
							{
								/* have no links to succeeding xi directions */
								display_message(ERROR_MESSAGE,
									"Invalid simplex component of basis");
								no_error=0;
							}
						}
						else
						{
							/* have no links to succeeding xi directions */
							display_message(ERROR_MESSAGE,
								"Invalid simplex component of basis");
							no_error=0;
						}
					}
					else
					{
						/*???debug */
						/*printf("not first simplex component\n");*/
						/* check that links have been assigned */
						temp_basis_type=xi_basis_type;
						i=xi_number-1;
						j=number_of_xi_coordinates-xi_number;
						first_simplex=(int *)NULL;
						while (no_error&&(i>0))
						{
							j++;
							temp_basis_type -= j;
							if (NO_RELATION!= *temp_basis_type)
							{
								/*???debug */
								/*printf("%p %p\n",xi_basis_type,(temp_basis_type-(xi_number-i)));
								  printf("%d %d\n",*xi_basis_type,*(temp_basis_type-(xi_number-i)));*/
								if (*xi_basis_type== *(temp_basis_type-(xi_number-i)))
								{
									first_simplex=temp_basis_type;
								}
								else
								{
									no_error=0;
								}
							}
							i--;
						}
						/*???debug */
						/*printf("%d %p\n",no_error,first_simplex);*/
						if (no_error&&first_simplex)
						{
							xi_basis_type++;
							first_simplex++;
							i=xi_number;
							while (i<number_of_xi_coordinates)
							{
								*xi_basis_type= *first_simplex;
								xi_basis_type++;
								first_simplex++;
								i++;
							}
						}
						else
						{
							no_error=0;
						}
					}
				}
				else
				{
					if (0==strncmp(start_basis_name,"polygon",7))
					{
						*xi_basis_type=POLYGON;
						start_basis_name += 7;
						/* skip blanks */
						while (' '== *start_basis_name)
						{
							start_basis_name++;
						}
						/* check for link to other polygon component */
						if ('('== *start_basis_name)
						{
							/* assign link to other polygon component */
							if ((2==sscanf(start_basis_name,"(%d ;%d )%n",
									  &number_of_polygon_vertices,&component,&i))&&
								(3<=number_of_polygon_vertices)&&
								(xi_number<component)&&
								(component<=number_of_xi_coordinates)&&
								('*'== start_basis_name[i]))
							{
								start_basis_name += i;
								/* assign link */
								xi_basis_type++;
								i=xi_number+1;
								while (i<component)
								{
									*xi_basis_type=NO_RELATION;
									xi_basis_type++;
									i++;
								}
								*xi_basis_type=number_of_polygon_vertices;
								xi_basis_type++;
								while (i<number_of_xi_coordinates)
								{
									*xi_basis_type=NO_RELATION;
									xi_basis_type++;
									i++;
								}
							}
							else
							{
								/* have no links to succeeding xi directions */
								display_message(ERROR_MESSAGE,
									"Invalid polygon component of basis");
								no_error=0;
							}
						}
						else
						{
							/* check that link has been assigned */
							temp_basis_type=xi_basis_type;
							i=xi_number-1;
							j=number_of_xi_coordinates-xi_number;
							number_of_polygon_vertices=0;
							while (no_error&&(i>0))
							{
								j++;
								temp_basis_type -= j;
								if (NO_RELATION!= *temp_basis_type)
								{
									if (0<number_of_polygon_vertices)
									{
										no_error=0;
									}
									else
									{
										if ((number_of_polygon_vertices= *temp_basis_type)<3)
										{
											no_error=0;
										}
									}
								}
								i--;
							}
							if (no_error&&(3<=number_of_polygon_vertices))
							{
								xi_basis_type++;
								i=xi_number;
								while (i<number_of_xi_coordinates)
								{
									*xi_basis_type=NO_RELATION;
									xi_basis_type++;
									i++;
								}
							}
							else
							{
								no_error=0;
							}
						}
					}
					else
					{
						if (0==strncmp(start_basis_name,"l.Lagrange",10))
						{
							*xi_basis_type=LINEAR_LAGRANGE;
							start_basis_name += 10;
						}
						else
						{
							if (0==strncmp(start_basis_name,"q.Lagrange",10))
							{
								*xi_basis_type=QUADRATIC_LAGRANGE;
								start_basis_name += 10;
							}
							else
							{
								if (0==strncmp(start_basis_name,"c.Lagrange",10))
								{
									*xi_basis_type=CUBIC_LAGRANGE;
									start_basis_name += 10;
								}
								else
								{
									if (0==strncmp(start_basis_name,"c.Hermite",9))
									{
										*xi_basis_type=CUBIC_HERMITE;
										start_basis_name += 9;
									}
									else
									{
										if (0==strncmp(start_basis_name,"LagrangeHermite",15))
										{
											*xi_basis_type=LAGRANGE_HERMITE;
											start_basis_name += 15;
										}
										else
										{
											if (0==strncmp(start_basis_name,"HermiteLagrange",15))
											{
												*xi_basis_type=HERMITE_LAGRANGE;
												start_basis_name += 15;
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"Invalid basis type");
												no_error=0;
											}
										}
									}
								}
							}
						}
						if (no_error)
						{
							/* skip blanks */
							while (' '== *start_basis_name)
							{
								start_basis_name++;
							}
							/* check for simplex elements */
							if ('('== *start_basis_name)
							{
								/* assign links to succeeding simplex xi directions */
								temp_basis_type=xi_basis_type;
								i=xi_number;
								while (no_error&&(i<number_of_xi_coordinates)&&
									(')'!= *start_basis_name))
								{
									temp_basis_type++;
									if (';'== *start_basis_name)
									{
										*temp_basis_type=NO_RELATION;
										start_basis_name++;
									}
									else
									{
										if (0==strncmp(start_basis_name,"l.Lagrange",10))
										{
											*temp_basis_type=LINEAR_LAGRANGE;
											start_basis_name += 10;
										}
										else
										{
											if (0==strncmp(start_basis_name,"q.Lagrange",10))
											{
												*temp_basis_type=QUADRATIC_LAGRANGE;
												start_basis_name += 10;
											}
											else
											{
												if (0==strncmp(start_basis_name,"c.Lagrange",10))
												{
													*temp_basis_type=CUBIC_LAGRANGE;
													start_basis_name += 10;
												}
												else
												{
													if (0==strncmp(start_basis_name,"c.Hermite",9))
													{
														*temp_basis_type=CUBIC_HERMITE;
														start_basis_name += 9;
													}
													else
													{
														if (0==strncmp(start_basis_name,
																 "LagrangeHermite",15))
														{
															*temp_basis_type=LAGRANGE_HERMITE;
															start_basis_name += 15;
														}
														else
														{
															if (0==strncmp(start_basis_name,
																	 "HermiteLagrange",15))
															{
																*temp_basis_type=HERMITE_LAGRANGE;
																start_basis_name += 15;
															}
															else
															{
																display_message(ERROR_MESSAGE,
																	"Invalid basis type");
																no_error=0;
															}
														}
													}
												}
											}
										}
										if (';'== *start_basis_name)
										{
											start_basis_name++;
										}
									}
									i++;
								}
								if (no_error)
								{
									while (i<number_of_xi_coordinates)
									{
										temp_basis_type++;
										*temp_basis_type=NO_RELATION;
										i++;
									}
								}
							}
							else
							{
								temp_basis_type=xi_basis_type;
								for (i=xi_number;i<number_of_xi_coordinates;i++)
								{
									temp_basis_type++;
									*temp_basis_type=NO_RELATION;
								}
							}
							if (no_error&&(xi_number<number_of_xi_coordinates))
							{
								xi_basis_type += number_of_xi_coordinates-xi_number+1;
							}
						}
					}
				}
				if ('*' == *start_basis_name)
				{
					start_basis_name++;
				}
				else
				{
					if ('\0' != *start_basis_name)
					{
						display_message(ERROR_MESSAGE,"Invalid basis type");
						no_error=0;
					}
				}
			}
			if (!no_error)
			{
				display_message(ERROR_MESSAGE,"Invalid basis description");
				DEALLOCATE(basis_type);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE, "FE_basis_string_to_type_array.  "
				"Unable to allocate basis type array.");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_basis_string_to_type_array.  Invalid argument)");
	}
	LEAVE;

	return (basis_type);
} /* FE_basis_string_to_type_array */

char *FE_basis_type_string(enum FE_basis_type basis_type)
/*******************************************************************************
LAST MODIFIED : 1 April 1999

DESCRIPTION :
Returns a pointer to a static string token for the given <basis_type>.
The calling function must not deallocate the returned string.
???RC Not complete
#### Must ensure implemented correctly for new FE_basis_types ####
==============================================================================*/
{
	char *basis_type_string;

	ENTER(FE_basis_type_string);
	switch (basis_type)
	{
		case NO_RELATION:
		{
			basis_type_string="no_relation";
		} break;
		case BSPLINE:
		{
			basis_type_string="???bspline";
		} break;
		case CUBIC_HERMITE:
		{
			basis_type_string="c.Hermite";
		} break;
		case CUBIC_LAGRANGE:
		{
			basis_type_string="c.Lagrange";
		} break;
		case FOURIER:
		{
			basis_type_string="???fourier";
		} break;
		case HERMITE_LAGRANGE:
		{
			basis_type_string="HermiteLagrange";
		} break;
		case LAGRANGE_HERMITE:
		{
			basis_type_string="LagrangeHermite";
		} break;
		case LINEAR_LAGRANGE:
		{
			basis_type_string="l.Lagrange";
		} break;
		case LINEAR_SIMPLEX:
		{
			basis_type_string="l.simplex";
		} break;
		case POLYGON:
		{
			basis_type_string="polygon";
		} break;
		case QUADRATIC_LAGRANGE:
		{
			basis_type_string="q.Lagrange";
		} break;
		case QUADRATIC_SIMPLEX:
		{
			basis_type_string="q.simplex";
		} break;
		case SERENDIPITY:
		{
			basis_type_string="???serendipity";
		} break;
		case SINGULAR:
		{
			basis_type_string="???singular";
		} break;
		case TRANSITION:
		{
			basis_type_string="???transition";
		} break;
		default:
		{
			display_message(ERROR_MESSAGE,
				"FE_basis_type_string.  Invalid basis_type");
			basis_type_string=(char *)NULL;
		} break;
	}
	LEAVE;

	return (basis_type_string);
} /* FE_basis_type_string */

int FE_basis_get_dimension(struct FE_basis *basis,
	int *dimension_address)
/*******************************************************************************
LAST MODIFIED : 6 November 2002

DESCRIPTION :
Returns the dimension of <basis>.
If fails, puts zero at <dimension_address>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_basis_get_dimension);
	if (basis && basis->type && dimension_address)
	{
		*dimension_address = basis->type[0];
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_basis_get_dimension.  Invalid argument(s)");
		if (dimension_address)
		{
			*dimension_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_basis_get_dimension */

int FE_basis_get_number_of_basis_functions(struct FE_basis *basis,
	int *number_of_basis_functions_address)
/*******************************************************************************
LAST MODIFIED : 15 May 2003

DESCRIPTION :
Returns the number_of_basis_functions of <basis>.
If fails, puts zero at <number_of_basis_functions_address>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_basis_get_number_of_basis_functions);
	if (basis && basis->type && number_of_basis_functions_address)
	{
		*number_of_basis_functions_address = basis->number_of_basis_functions;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_basis_get_number_of_basis_functions.  Invalid argument(s)");
		if (number_of_basis_functions_address)
		{
			*number_of_basis_functions_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_basis_get_number_of_basis_functions */

int FE_basis_get_xi_basis_type(struct FE_basis *basis,
	int xi_number, enum FE_basis_type *basis_type_address)
/*******************************************************************************
LAST MODIFIED : 6 November 2002

DESCRIPTION :
Returns the basis type of <basis> on <xi_number> -- on main diagonal of
type array. The first xi_number is 0.
==============================================================================*/
{
	int i, offset, return_code;

	ENTER(FE_basis_get_xi_basis_type);
	if (basis && basis->type && (0 <= xi_number) &&
		(xi_number < basis->type[0]) && basis_type_address)
	{
		/* first value in basis->type is the dimension */
		offset = 1;
		for (i = 0; i < xi_number; i++)
		{
			offset += *(basis->type) - i;
		}
		*basis_type_address = (enum FE_basis_type)basis->type[offset];
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_basis_get_xi_basis_type.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_basis_get_xi_basis_type */

int FE_basis_get_next_linked_xi_number(
	struct FE_basis *basis, int xi_number,
	int *next_xi_number_address, int *xi_link_number_address)
/*******************************************************************************
LAST MODIFIED : 6 November 2002

DESCRIPTION :
Returns in <next_xi_number_address> the next xi number higher than <xi_number>
which is linked in basis with it, plus in <xi_link_number_address> the number
denoting how it is linked; currently used only for polygon basiss to denote the
number of polygon sides.
If there is no remaining linked dimension, 0 is returned in both addresses.
<xi_number> is from 0 to one less than the basis dimension.
Also checks that the linked xi numbers have the same basis type.
==============================================================================*/
{
	enum FE_basis_type basis_type;
	int i, limit, offset, return_code;

	ENTER(FE_basis_get_next_linked_xi_number);
	if (basis && basis->type &&
		(0 <= xi_number) && (xi_number < *(basis->type)) &&
		next_xi_number_address && xi_link_number_address)
	{
		return_code = 1;
		offset = 1; /* The first element is the dimension */
		for (i = 0; i < xi_number; i++)
		{
			offset += *(basis->type) - i;
		}
		basis_type = (enum FE_basis_type)basis->type[offset];
		limit = *(basis->type) - xi_number;
		offset++;
		for (i = 1; (i < limit) && (0 == basis->type[offset]); i++)
		{
			offset++;
		}
		if (i < limit)
		{
			*next_xi_number_address = i + xi_number;
			*xi_link_number_address = basis->type[offset];
			/* finally check the basis type matches */
			offset = 1; /* The first element is the dimension */
			for (i = 0; i < *next_xi_number_address; i++)
			{
				offset += *(basis->type) - i;
			}
			if (basis->type[offset] != basis_type)
			{
				display_message(ERROR_MESSAGE,
					"FE_basis_get_next_linked_xi_number.  "
					"Basis has linked xi directions with different basis type");
				return_code = 0;
			}
		}
		else
		{
			*next_xi_number_address = 0;
			*xi_link_number_address = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_basis_get_next_linked_xi_number.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_basis_get_next_linked_xi_number */

struct Linear_combination_of_global_values
	*CREATE(Linear_combination_of_global_values)(int number_of_global_values)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Allocates memory and assigns fields for a linear combination of global values.
Allocates storage for the global and coefficient indices and sets to -1.
==============================================================================*/
{
	int *coefficient_index,*global_index,i;
	struct Linear_combination_of_global_values *linear_combination;

	ENTER(CREATE(Linear_combination_of_global_values));
	/* check the arguments */
	if (number_of_global_values>0)
	{
		if ((ALLOCATE(linear_combination,struct Linear_combination_of_global_values,
			1))&&(ALLOCATE(global_index,int,number_of_global_values))&&
			(ALLOCATE(coefficient_index,int,number_of_global_values)))
		{
			linear_combination->number_of_global_values=number_of_global_values;
			linear_combination->global_value_indices=global_index;
			linear_combination->coefficient_indices=coefficient_index;
			for (i=number_of_global_values;i>0;i--)
			{
				*global_index= -1;
				*coefficient_index= -1;
				global_index++;
				coefficient_index++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(Linear_combination_of_global_values).  Could not allocate memory");
			if (linear_combination)
			{
				DEALLOCATE(global_index);
				DEALLOCATE(linear_combination);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(Linear_combination_of_global_values).  Invalid argument(s)");
		linear_combination=(struct Linear_combination_of_global_values *)NULL;
	}
	LEAVE;

	return (linear_combination);
} /* CREATE(Linear_combination_of_global_values) */

int DESTROY(Linear_combination_of_global_values)(
	struct Linear_combination_of_global_values **linear_combination_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Frees the memory for the linear combination and sets
<*linear_combination_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct Linear_combination_of_global_values *linear_combination;

	ENTER(DESTROY(Linear_combination_of_global_values));
	if ((linear_combination_address)&&
		(linear_combination= *linear_combination_address))
	{
		DEALLOCATE(linear_combination->global_value_indices);
		DEALLOCATE(linear_combination->coefficient_indices);
		DEALLOCATE(*linear_combination_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(Linear_combination_of_global_values) */

static struct Linear_combination_of_global_values *copy_create_Linear_combination_of_global_values(
	struct Linear_combination_of_global_values *source)
/*******************************************************************************
LAST MODIFIED : 15 February 2002

DESCRIPTION :
Creates and returns an exact copy of the struct Linear_combination_of_global_values
<source>.
==============================================================================*/
{	
	int i,number_of_global_values;
	struct Linear_combination_of_global_values *map;

	ENTER(copy_create_Linear_combination_of_global_values);
	map=(struct Linear_combination_of_global_values *)NULL;
	if(source)
	{
		number_of_global_values=source->number_of_global_values;
		map=CREATE(Linear_combination_of_global_values)(number_of_global_values);
		if(map)
		{
			for(i=0;i<number_of_global_values;i++)
			{
				map->global_value_indices=source->global_value_indices;
				map->coefficient_indices=source->coefficient_indices;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"copy_create_Linear_combination_of_global_values, failed to create map");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
				"copy_create_Linear_combination_of_global_values, Invalid argument");
	}
	LEAVE;
	return(map);
}/* copy_create_Linear_combination_of_global_values */

struct Standard_node_to_element_map *CREATE(Standard_node_to_element_map)(
	int node_index,int number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 27 March 2003

DESCRIPTION :
Allocates memory and assigns fields for a standard node to element map.
Allocates storage for the nodal value and scale factor indices and sets to -1.
==============================================================================*/
{
	int i,*nodal_value_index,*scale_factor_index;
	struct Standard_node_to_element_map *map;

	ENTER(CREATE(Standard_node_to_element_map));
	if ((node_index >= 0) && (number_of_nodal_values > 0))
	{
		if ((ALLOCATE(map,struct Standard_node_to_element_map,1))&&
			(ALLOCATE(nodal_value_index,int,number_of_nodal_values))&&
			(ALLOCATE(scale_factor_index,int,number_of_nodal_values)))
		{
			map->node_index=node_index;
			map->number_of_nodal_values=number_of_nodal_values;
			map->nodal_value_indices=nodal_value_index;
			map->scale_factor_indices=scale_factor_index;
			for (i=number_of_nodal_values;i>0;i--)
			{
				/* a nodal_value_index of -1 gives zero values */
				*nodal_value_index= -1;
				/* a scale_factor_index of -1 gives unit scale factors */
				*scale_factor_index= -1;
				nodal_value_index++;
				scale_factor_index++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(Standard_node_to_element_map).  Could not allocate memory for map");
			if (map)
			{
				DEALLOCATE(nodal_value_index);
				DEALLOCATE(map);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(Standard_node_to_element_map).  Invalid argument(s)");
		map=(struct Standard_node_to_element_map *)NULL;
	}
	LEAVE;

	return (map);
} /* CREATE(Standard_node_to_element_map) */

int DESTROY(Standard_node_to_element_map)(
	struct Standard_node_to_element_map **map_address)
/*******************************************************************************
LAST MODIFIED : 23 September 1995

DESCRIPTION :
Frees the memory for the map and sets <*map_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct Standard_node_to_element_map *map;

	ENTER(DESTROY(Standard_node_to_element_map));
	if ((map_address)&&(map= *map_address))
	{
		DEALLOCATE(map->nodal_value_indices);
		DEALLOCATE(map->scale_factor_indices);
		DEALLOCATE(*map_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(Standard_node_to_element_map) */

static struct Standard_node_to_element_map *copy_create_Standard_node_to_element_map(
	struct Standard_node_to_element_map *source)
/*******************************************************************************
LAST MODIFIED : 15 February 2002

DESCRIPTION :
Creates and returns an exact copy of the struct Standard_node_to_element_map
<source>.
==============================================================================*/
{	
	int i, node_index, number_of_nodal_values;
	struct Standard_node_to_element_map *map;

	ENTER(copy_create_Standard_node_to_element_map)
	map = (struct Standard_node_to_element_map *)NULL;	
	if (source)
	{
		node_index = source->node_index;
		number_of_nodal_values = source->number_of_nodal_values;
		map = CREATE(Standard_node_to_element_map)(node_index,
			number_of_nodal_values);
		if (map)
		{
			for (i = 0; i < number_of_nodal_values; i++)
			{
				map->nodal_value_indices[i] = source->nodal_value_indices[i];
				map->scale_factor_indices[i] = source->scale_factor_indices[i];
			}
		}
		else
		{		 
			display_message(ERROR_MESSAGE,
				"copy_create_Standard_node_to_element_map.  Failed to create map");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
				"copy_create_Standard_node_to_element_map.  Invalid argument");
	}
	LEAVE;

	return(map);
} /* copy_create_Standard_node_to_element_map */

int Standard_node_to_element_map_get_node_index(
	struct Standard_node_to_element_map *standard_node_map,
	int *node_index_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the node index from <standard_node_map>.
If fails, sets *<node_index_address> to zero.
==============================================================================*/
{
	int return_code;

	ENTER(Standard_node_to_element_map_get_node_index)
	if (standard_node_map && node_index_address)
	{
		*node_index_address = standard_node_map->node_index;
		return_code = 1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"Standard_node_to_element_map_get_node_index.  Invalid argument(s)");
		if (node_index_address)
		{
			*node_index_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* Standard_node_to_element_map_get_node_index */

int Standard_node_to_element_map_get_number_of_nodal_values(
	struct Standard_node_to_element_map *standard_node_map,
	int *number_of_nodal_values_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the number of nodal values used by <standard_node_map>.
If fails, sets *<number_of_nodal_values_address> to zero.
==============================================================================*/
{
	int return_code;

	ENTER(Standard_node_to_element_map_get_number_of_nodal_values)
	if (standard_node_map && number_of_nodal_values_address)
	{
		*number_of_nodal_values_address = standard_node_map->number_of_nodal_values;
		return_code = 1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"Standard_node_to_element_map_get_number_of_nodal_values.  "
			"Invalid argument(s)");
		if (number_of_nodal_values_address)
		{
			*number_of_nodal_values_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* Standard_node_to_element_map_get_number_of_nodal_values */

int Standard_node_to_element_map_get_nodal_value_index(
	struct Standard_node_to_element_map *standard_node_map,
	int nodal_value_number, int *nodal_value_index_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the nodal value index at <nodal_value_number> in <standard_node_map>.
If fails, sets *<nodal_value_index_address> to zero.
==============================================================================*/
{
	int return_code;

	ENTER(Standard_node_to_element_map_get_nodal_value_index)
	if (standard_node_map && standard_node_map->nodal_value_indices &&
		(0 <= nodal_value_number) &&
		(nodal_value_number < standard_node_map->number_of_nodal_values) &&
		nodal_value_index_address)
	{
		*nodal_value_index_address =
			standard_node_map->nodal_value_indices[nodal_value_number];
		return_code = 1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"Standard_node_to_element_map_get_nodal_value_index.  "
			"Invalid argument(s)");
		if (nodal_value_index_address)
		{
			*nodal_value_index_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* Standard_node_to_element_map_get_nodal_value_index */

int Standard_node_to_element_map_set_nodal_value_index(
	struct Standard_node_to_element_map *standard_node_map,
	int nodal_value_number, int nodal_value_index)
/*******************************************************************************
LAST MODIFIED : 27 March 2003

DESCRIPTION :
Sets nodal_value_index <nodal_value_number> of <standard_node_map> to
<nodal_value_index>.
Note a negative <nodal_value_index> gives a value of zero without needing to
get a value from the node.
==============================================================================*/
{
	int return_code;

	ENTER(Standard_node_to_element_map_set_nodal_value_index)
	if (standard_node_map && standard_node_map->nodal_value_indices &&
		(0 <= nodal_value_number) &&
		(nodal_value_number < standard_node_map->number_of_nodal_values) &&
		(-1 == standard_node_map->nodal_value_indices[nodal_value_number]))
	{
		standard_node_map->nodal_value_indices[nodal_value_number] =
			nodal_value_index;
		return_code = 1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"Standard_node_to_element_map_set_nodal_value_index.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* Standard_node_to_element_map_set_nodal_value_index */

int Standard_node_to_element_map_get_scale_factor_index(
	struct Standard_node_to_element_map *standard_node_map,
	int nodal_value_number, int *scale_factor_index_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the nodal value index at <nodal_value_number> in <standard_node_map>.
If fails, sets *<scale_factor_index_address> to zero.
==============================================================================*/
{
	int return_code;

	ENTER(Standard_node_to_element_map_get_scale_factor_index)
	if (standard_node_map && standard_node_map->scale_factor_indices &&
		(0 <= nodal_value_number) &&
		(nodal_value_number < standard_node_map->number_of_nodal_values) &&
		scale_factor_index_address)
	{
		*scale_factor_index_address =
			standard_node_map->scale_factor_indices[nodal_value_number];
		return_code = 1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"Standard_node_to_element_map_get_scale_factor_index.  "
			"Invalid argument(s)");
		if (scale_factor_index_address)
		{
			*scale_factor_index_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* Standard_node_to_element_map_get_scale_factor_index */

int Standard_node_to_element_map_set_scale_factor_index(
	struct Standard_node_to_element_map *standard_node_map,
	int nodal_value_number, int scale_factor_index)
/*******************************************************************************
LAST MODIFIED : 27 March 2003

DESCRIPTION :
Sets scale_factor_index <nodal_value_number> of <standard_node_map> to
<scale_factor_index>.
Note a negative <scale_factor_index> gives a unit scale factor without
needing to get a value from the scale factor set.
==============================================================================*/
{
	int return_code;

	ENTER(Standard_node_to_element_map_set_scale_factor_index)
	if (standard_node_map && standard_node_map->scale_factor_indices &&
		(0 <= nodal_value_number) &&
		(nodal_value_number < standard_node_map->number_of_nodal_values) &&
		(-1 == standard_node_map->scale_factor_indices[nodal_value_number]))
	{
		standard_node_map->scale_factor_indices[nodal_value_number] =
			scale_factor_index;
		return_code = 1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"Standard_node_to_element_map_set_scale_factor_index.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* Standard_node_to_element_map_set_scale_factor_index */

struct General_node_to_element_map *CREATE(General_node_to_element_map)(
	int node_index,int number_of_nodal_values)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Allocates memory and assigns fields for a general node to element map.
Allocates storage for the pointers to the linear combinations of field values
and sets to NULL.
==============================================================================*/
{
	int i;
	struct General_node_to_element_map *map;
	struct Linear_combination_of_global_values **element_value;

	ENTER(CREATE(General_node_to_element_map));
	if ((node_index>=0)&&(number_of_nodal_values>0))
	{
		if ((ALLOCATE(map,struct General_node_to_element_map,1))&&
			(ALLOCATE(element_value,struct Linear_combination_of_global_values *,
			number_of_nodal_values)))
		{
			map->node_index=node_index;
			map->number_of_nodal_values=number_of_nodal_values;
			map->element_values=element_value;
			for (i=number_of_nodal_values;i>0;i--)
			{
				*element_value=(struct Linear_combination_of_global_values *)NULL;
				element_value++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(General_node_to_element_map).  Could not allocate memory for map");
			DEALLOCATE(map);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(General_node_to_element_map).  Invalid argument(s)");
		map=(struct General_node_to_element_map *)NULL;
	}
	LEAVE;

	return (map);
} /* CREATE(General_node_to_element_map) */

int DESTROY(General_node_to_element_map)(
	struct General_node_to_element_map **map_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Frees the memory for the map and sets <*map_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct General_node_to_element_map *map;
	struct Linear_combination_of_global_values **linear_combination;

	ENTER(DESTROY(General_node_to_element_map));
	if ((map_address)&&(map= *map_address))
	{
		linear_combination=map->element_values;
		for (i=map->number_of_nodal_values;i>0;i--)
		{
			DESTROY(Linear_combination_of_global_values)(linear_combination);
			linear_combination++;
		}
		DEALLOCATE(map->element_values);
		DEALLOCATE(*map_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(General_node_to_element_map) */

static struct General_node_to_element_map *copy_create_General_node_to_element_map(
	struct General_node_to_element_map *source)
/*******************************************************************************
LAST MODIFIED : 15 February 2002

DESCRIPTION :
Creates and returns an exact copy of the struct General_node_to_element_map
<source>.
==============================================================================*/
{	
	int i,node_index,number_of_nodal_values;
	struct General_node_to_element_map *map;
	struct Linear_combination_of_global_values **element_value,
		**source_element_value;

	ENTER(copy_create_General_node_to_element_map)
	map=(struct General_node_to_element_map *)NULL;
	element_value=(struct Linear_combination_of_global_values **)NULL;
	source_element_value=(struct Linear_combination_of_global_values **)NULL;	
	if(source)
	{
		node_index=source->node_index;
		number_of_nodal_values=source->number_of_nodal_values;
		source_element_value=source->element_values;
		map=CREATE(General_node_to_element_map)(node_index,number_of_nodal_values);
		if(map)
		{
			element_value=map->element_values;
			for (i=number_of_nodal_values;i>0;i--)
			{
				
				*element_value=copy_create_Linear_combination_of_global_values(
					*source_element_value);
				element_value++;
				source_element_value++;
			}
		}
		else
		{		 
			display_message(ERROR_MESSAGE,
				"copy_create_General_node_to_element_map, failed to create map");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
				"copy_create_General_node_to_element_map, Invalid argument");
	}
	LEAVE;
	return(map);
}/* copy_create_General_node_to_element_map */

int General_node_to_element_map_get_node_index(
	struct General_node_to_element_map *general_node_map,
	int *node_index_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the node index from <general_node_map>.
If fails, sets *<node_index_address> to zero.
==============================================================================*/
{
	int return_code;

	ENTER(General_node_to_element_map_get_node_index)
	if (general_node_map && node_index_address)
	{
		*node_index_address = general_node_map->node_index;
		return_code = 1;
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"General_node_to_element_map_get_node_index.  Invalid argument(s)");
		if (node_index_address)
		{
			*node_index_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return(return_code);
} /* General_node_to_element_map_get_node_index */

struct FE_element_field_component *copy_create_FE_element_field_component(
	struct FE_element_field_component *source_component)
/*******************************************************************************
LAST MODIFIED : 15 February 2002

DESCRIPTION :
Creates and returns an exact copy of the struct FE_element_field_component 
<source_component>.
==============================================================================*/
{
	int  i,number_of_maps;
	struct FE_element_field_component *component;

	ENTER(copy_create_FE_element_field_component);
	component=(struct FE_element_field_component *)NULL;
	if(source_component)
	{
		switch(source_component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
			{
				number_of_maps=source_component->map.standard_node_based.number_of_nodes;
			}	break;
			case GENERAL_NODE_TO_ELEMENT_MAP:	
			{
				number_of_maps=source_component->map.general_node_based.number_of_nodes;
			}	break;
			case FIELD_TO_ELEMENT_MAP:	
			{
				number_of_maps=source_component->map.field_based.number_of_element_values;
			}	break;
			case ELEMENT_GRID_MAP:
			{
				number_of_maps=1;
			}	break;
		}/* switch(source_component->type) */
		/*create the component*/
		component=CREATE(FE_element_field_component)(source_component->type,number_of_maps,
			source_component->basis,source_component->modify);
		/* fill in the interior of component */
		if(component)
		{			
			switch(source_component->type)
			{
				case STANDARD_NODE_TO_ELEMENT_MAP:
				{																
					for(i=0;i<number_of_maps;i++)
					{					
						component->map.standard_node_based.node_to_element_maps[i]=
							copy_create_Standard_node_to_element_map(
								source_component->map.standard_node_based.node_to_element_maps[i]);
					}													
				}	break;
				case GENERAL_NODE_TO_ELEMENT_MAP:	
				{									
					for(i=0;i<number_of_maps;i++)
					{					
						component->map.general_node_based.node_to_element_maps[i]=
							copy_create_General_node_to_element_map(
								source_component->map.general_node_based.node_to_element_maps[i]);
					}														
				}	break;
				case FIELD_TO_ELEMENT_MAP:	
				{											
					for(i=0;i<number_of_maps;i++)
					{					
						component->map.field_based.element_values[i]=
							copy_create_Linear_combination_of_global_values(
								source_component->map.field_based.element_values[i]);									
					}													
				}	break;
				case ELEMENT_GRID_MAP:
				{					
					for(i=0;i<source_component->basis->type[0];i++)
					{
						component->map.element_grid_based.number_in_xi[i]=
							source_component->map.element_grid_based.number_in_xi[i];
					}
					component->map.element_grid_based.value_index=
						source_component->map.element_grid_based.value_index;
				}	break;
			}/* switch(source_component->type) */
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"copy_create_FE_element_field_component, failed to create component");
		}
	} 
	else
	{
		display_message(ERROR_MESSAGE,
				"copy_create_FE_element_field_component, Invalid argument");
	}
	LEAVE;
	return(component);
}/* copy_create_FE_element_field_component */

struct FE_element_field_component *CREATE(FE_element_field_component)(
	enum Global_to_element_map_type type,int number_of_maps,
	struct FE_basis *basis,FE_element_field_component_modify modify)
/*******************************************************************************
LAST MODIFIED : 28 September 1998

DESCRIPTION :
Allocates memory and enters values for a component of a element field.
Allocates storage for the global to element maps and sets to NULL.
==============================================================================*/
{
	int i,*number_in_xi;
	struct FE_element_field_component *component;
	struct General_node_to_element_map **general_node_to_element_map;
	struct Linear_combination_of_global_values **element_value;
	struct Standard_node_to_element_map **standard_node_to_element_map;

	ENTER(CREATE(FE_element_field_component));
	if ((number_of_maps>0)&&basis)
	{
		if (ALLOCATE(component,struct FE_element_field_component,1))
		{
			switch (type)
			{
				case STANDARD_NODE_TO_ELEMENT_MAP:
				{
					if (ALLOCATE(component->map.standard_node_based.node_to_element_maps,
						struct Standard_node_to_element_map *,number_of_maps))
					{
						component->map.standard_node_based.number_of_nodes=number_of_maps;
						standard_node_to_element_map=
							component->map.standard_node_based.node_to_element_maps;
						for (i=number_of_maps;i>0;i--)
						{
							*standard_node_to_element_map=
								(struct Standard_node_to_element_map *)NULL;
							standard_node_to_element_map++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
		"CREATE(FE_element_field_component).  Could not allocate memory for maps");
						DEALLOCATE(component);
					}
				} break;
				case GENERAL_NODE_TO_ELEMENT_MAP:
				{
					if (ALLOCATE(component->map.general_node_based.node_to_element_maps,
						struct General_node_to_element_map *,number_of_maps))
					{
						component->map.general_node_based.number_of_nodes=number_of_maps;
						general_node_to_element_map=
							component->map.general_node_based.node_to_element_maps;
						for (i=number_of_maps;i>0;i--)
						{
							*general_node_to_element_map=
								(struct General_node_to_element_map *)NULL;
							general_node_to_element_map++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
		"CREATE(FE_element_field_component).  Could not allocate memory for maps");
						DEALLOCATE(component);
					}
				} break;
				case FIELD_TO_ELEMENT_MAP:
				{
					if (ALLOCATE(component->map.field_based.element_values,
						struct Linear_combination_of_global_values *,number_of_maps))
					{
						component->map.field_based.number_of_element_values=number_of_maps;
						element_value=component->map.field_based.element_values;
						for (i=number_of_maps;i>0;i--)
						{
							*element_value=(struct Linear_combination_of_global_values *)NULL;
							element_value++;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
		"CREATE(FE_element_field_component).  Could not allocate memory for maps");
						DEALLOCATE(component);
					}
				} break;
				case ELEMENT_GRID_MAP:
				{
					if (ALLOCATE(component->map.element_grid_based.number_in_xi,int,
						(basis->type)[0]))
					{
						number_in_xi=component->map.element_grid_based.number_in_xi;
						for (i=(basis->type)[0];i>0;i--)
						{
							*number_in_xi=0;
							number_in_xi++;
						}
						component->map.element_grid_based.value_index=0;
					}
					else
					{
						display_message(ERROR_MESSAGE,
"CREATE(FE_element_field_component).  Could not allocate memory for number_in_xi");
						DEALLOCATE(component);
					}
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_element_field_component).  Invalid type");
					DEALLOCATE(component);
				} break;
			}
			if (component)
			{
				component->type=type;
				component->basis=ACCESS(FE_basis)(basis);
				component->modify=modify;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
"CREATE(FE_element_field_component).  Could not allocate memory for component");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field_component).  Invalid argument(s)");
		component=(struct FE_element_field_component *)NULL;
	}
	LEAVE;

	return (component);
} /* CREATE(FE_element_field_component) */

int DESTROY(FE_element_field_component)(
	struct FE_element_field_component **component_address)
/*******************************************************************************
LAST MODIFIED : 28 September 1998

DESCRIPTION :
Frees the memory for the component and sets <*component_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_element_field_component *component;
	struct General_node_to_element_map **general_node_map;
	struct Linear_combination_of_global_values **linear_combination;
	struct Standard_node_to_element_map **standard_node_map;

	ENTER(DESTROY(FE_element_field_component));
	if ((component_address)&&(component= *component_address))
	{
		DEACCESS(FE_basis)(&(component->basis));
		switch (component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
			{
				standard_node_map=
					component->map.standard_node_based.node_to_element_maps;
				for (i=component->map.standard_node_based.number_of_nodes;i>0;i--)
				{
					DESTROY(Standard_node_to_element_map)(standard_node_map);
					standard_node_map++;
				}
				DEALLOCATE(component->map.standard_node_based.node_to_element_maps);
			} break;
			case GENERAL_NODE_TO_ELEMENT_MAP:
			{
				general_node_map=
					component->map.general_node_based.node_to_element_maps;
				for (i=component->map.general_node_based.number_of_nodes;i>0;i--)
				{
					DESTROY(General_node_to_element_map)(general_node_map);
					general_node_map++;
				}
				DEALLOCATE(component->map.general_node_based.node_to_element_maps);
			} break;
			case FIELD_TO_ELEMENT_MAP:
			{
				linear_combination=component->map.field_based.element_values;
				for (i=component->map.field_based.number_of_element_values;i>0;i--)
				{
					DESTROY(Linear_combination_of_global_values)(
						linear_combination);
					linear_combination++;
				}
				DEALLOCATE(component->map.field_based.element_values);
			} break;
			case ELEMENT_GRID_MAP:
			{
				DEALLOCATE(component->map.element_grid_based.number_in_xi);
			} break;
		}
		DEALLOCATE(*component_address);
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field_component) */

int FE_element_field_component_get_basis(
	struct FE_element_field_component *element_field_component,
	struct FE_basis **basis_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Gets the <basis> used by <element_field_component>.
If fails, puts NULL in *<basis_address> if supplied.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_get_basis);
	return_code = 0;
	if (element_field_component && basis_address)
	{
		if (*basis_address = element_field_component->basis)
		{
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_component_get_basis.  Missing basis");
		}
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_get_basis.  Invalid argument(s)");
	}
	if ((!return_code) && basis_address)
	{
		*basis_address = (struct FE_basis *)NULL;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_get_basis */

int FE_element_field_component_get_general_node_map(
	struct FE_element_field_component *element_field_component, int node_number,
	struct General_node_to_element_map **general_node_map_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Gets the <general_node_map> relating global node values to those at local
<node_number> for <element_field_component> of type
GENERAL_NODE_TO_ELEMENT_MAP. <node_number> starts at 0 and must be less than
the number of nodes in the component.
If fails, puts NULL in *<general_node_map_address> if supplied.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_get_general_node_map);
	return_code = 0;
	if (element_field_component &&
		(GENERAL_NODE_TO_ELEMENT_MAP == element_field_component->type) &&
		element_field_component->map.general_node_based.node_to_element_maps &&
		(0 <= node_number) && (node_number <
			element_field_component->map.general_node_based.number_of_nodes) &&
		general_node_map_address)
	{
		if (*general_node_map_address = element_field_component->map.
			general_node_based.node_to_element_maps[node_number])
		{
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_component_get_general_node_map.  "
				"Missing general_node_to_element_map");
		}
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_get_general_node_map.  Invalid argument(s)");
	}
	if ((!return_code) && general_node_map_address)
	{
		*general_node_map_address = (struct General_node_to_element_map *)NULL;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_get_general_node_map */

int FE_element_field_component_get_grid_map_number_in_xi(
	struct FE_element_field_component *element_field_component,
	int xi_number, int *number_in_xi_address)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Gets the <number_in_xi> = number of spaces between grid points = one less than
the number of grid points on <xi_number> for <element_field_component> of type
ELEMENT_GRID_MAP. <xi_number> starts at 0 and must be less than the dimension
of the basis in <element_field_component>.
If fails, puts zero in *<number_in_xi_address> if supplied.
==============================================================================*/
{
	int dimension, return_code;

	ENTER(FE_element_field_component_get_grid_map_number_in_xi);
	if (element_field_component &&
		(ELEMENT_GRID_MAP == element_field_component->type) &&
		element_field_component->map.element_grid_based.number_in_xi &&
		(0 <= xi_number) &&
		FE_basis_get_dimension(element_field_component->basis, &dimension) &&
		(xi_number < dimension) && number_in_xi_address)
	{
		*number_in_xi_address =
			element_field_component->map.element_grid_based.number_in_xi[xi_number];
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_get_grid_map_number_in_xi.  "
			"Invalid argument(s)");
		if (number_in_xi_address)
		{
			*number_in_xi_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_get_grid_map_number_in_xi */

int FE_element_field_component_set_grid_map_number_in_xi(
	struct FE_element_field_component *element_field_component,
	int xi_number, int number_in_xi)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Sets the <number_in_xi> = number of spaces between grid points = one less than
the number of grid points on <xi_number> for <element_field_component> of type
ELEMENT_GRID_MAP. <xi_number> starts at 0 and must be less than the dimension
of the basis in <element_field_component>. <number_in_xi> must be positive.
The number_in_xi must currently be unset for this <xi_number>.
==============================================================================*/
{
	int dimension, return_code;

	ENTER(FE_element_field_component_set_grid_map_number_in_xi);
	if (element_field_component &&
		(ELEMENT_GRID_MAP == element_field_component->type) &&
		element_field_component->map.element_grid_based.number_in_xi &&
		(0 <= xi_number) &&
		FE_basis_get_dimension(element_field_component->basis, &dimension) &&
		(xi_number < dimension) && (0 <= number_in_xi) && (0 ==
			element_field_component->map.element_grid_based.number_in_xi[xi_number]))
	{
		element_field_component->map.element_grid_based.number_in_xi[xi_number] =
			number_in_xi;
		return_code = 1;
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_set_grid_map_number_in_xi.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_set_grid_map_number_in_xi */

int FE_element_field_component_set_grid_map_value_index(
	struct FE_element_field_component *element_field_component, int value_index)
/*******************************************************************************
LAST MODIFIED : 16 October 2002

DESCRIPTION :
Sets the <value_index> = starting point in the element's value_storage for the
grid-based values for <element_field_component> of type ELEMENT_GRID_MAP.
<value_index> must be non-negative.
The value_index must currently be 0.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_set_grid_map_value_index);
	if (element_field_component &&
		(ELEMENT_GRID_MAP == element_field_component->type) &&
		(0 == element_field_component->map.element_grid_based.value_index))
	{
		element_field_component->map.element_grid_based.value_index = value_index;
		return_code = 1;
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_set_grid_map_value_index.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_set_grid_map_value_index */

int FE_element_field_component_get_modify(
	struct FE_element_field_component *element_field_component,
	FE_element_field_component_modify *modify_address)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Gets the <modify> function used by <element_field_component> -- can be NULL.
If fails, puts NULL in *<modify_address> if supplied.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_get_modify);
	if (element_field_component && modify_address)
	{
		*modify_address = element_field_component->modify;
		return_code = 1;
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_get_modify.  Invalid argument(s)");
		if (modify_address)
		{
			*modify_address = (FE_element_field_component_modify)NULL;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_get_modify */

int FE_element_field_component_set_modify(
	struct FE_element_field_component *element_field_component,
	FE_element_field_component_modify modify)
/*******************************************************************************
LAST MODIFIED : 12 May 2003

DESCRIPTION :
Sets the <modify> function used by <element_field_component> -- can be NULL.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_set_modify);
	if (element_field_component)
	{
		element_field_component->modify = modify;
		return_code = 1;
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_set_modify.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_set_modify */

int FE_element_field_component_get_number_of_nodes(
	struct FE_element_field_component *element_field_component,
	int *number_of_nodes_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Gets the number of local nodes for <element_field_component> of type
STANDARD_NODE_TO_ELEMENT_MAP or GENERAL_NODE_TO_ELEMENT_MAP.
If fails, puts zero in *<number_of_nodes_address> if supplied.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_get_number_of_nodes);
	return_code = 0;
	if (element_field_component && number_of_nodes_address)
	{
		switch (element_field_component->type)
		{
			case STANDARD_NODE_TO_ELEMENT_MAP:
			{
				*number_of_nodes_address =
					element_field_component->map.standard_node_based.number_of_nodes;
				return_code = 1;
			} break;
			case GENERAL_NODE_TO_ELEMENT_MAP:
			{
				*number_of_nodes_address =
					element_field_component->map.general_node_based.number_of_nodes;
				return_code = 1;
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_component_get_number_of_nodes.  "
					"Invalid element field component type");
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_get_number_of_nodes.  Invalid argument(s)");
	}
	if ((!return_code) && number_of_nodes_address)
	{
		*number_of_nodes_address = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_get_number_of_nodes */

int FE_element_field_component_get_standard_node_map(
	struct FE_element_field_component *element_field_component, int node_number,
	struct Standard_node_to_element_map **standard_node_map_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Gets the <standard_node_map> relating global node values to those at local
<node_number> for <element_field_component> of type
STANDARD_NODE_TO_ELEMENT_MAP. <node_number> starts at 0 and must be less than
the number of nodes in the component.
If fails, puts NULL in *<standard_node_map_address> if supplied.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_get_standard_node_map);
	return_code = 0;
	if (element_field_component &&
		(STANDARD_NODE_TO_ELEMENT_MAP == element_field_component->type) &&
		element_field_component->map.standard_node_based.node_to_element_maps &&
		(0 <= node_number) && (node_number <
			element_field_component->map.standard_node_based.number_of_nodes) &&
		standard_node_map_address)
	{
		if (*standard_node_map_address = element_field_component->map.
			standard_node_based.node_to_element_maps[node_number])
		{
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_component_get_standard_node_map.  "
				"Missing standard_node_to_element_map");
		}
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_get_standard_node_map.  Invalid argument(s)");
	}
	if ((!return_code) && standard_node_map_address)
	{
		*standard_node_map_address = (struct Standard_node_to_element_map *)NULL;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_get_standard_node_map */

int FE_element_field_component_set_standard_node_map(
	struct FE_element_field_component *element_field_component,
	int node_number, struct Standard_node_to_element_map *standard_node_map)
/*******************************************************************************
LAST MODIFIED : 15 May 2003

DESCRIPTION :
Sets the <standard_node_map> relating global node values to those at local
<node_number> for <element_field_component> of type
STANDARD_NODE_TO_ELEMENT_MAP. <node_number> starts at 0 and must be less than
the number of nodes in the component.
The standard_node_map must currently be unset for this <xi_number>.
On successful return <standard_node_map> will be owned by the component.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_set_standard_node_map);
	if (element_field_component &&
		(STANDARD_NODE_TO_ELEMENT_MAP == element_field_component->type) &&
		element_field_component->map.standard_node_based.node_to_element_maps &&
		(0 <= node_number) && (node_number <
			element_field_component->map.standard_node_based.number_of_nodes) &&
		(!element_field_component->map.standard_node_based.node_to_element_maps[
			node_number]))
	{
		element_field_component->map.standard_node_based.
			node_to_element_maps[node_number] = standard_node_map;
		return_code = 1;
	} 
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_set_standard_node_map.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_set_standard_node_map */

int FE_element_field_component_get_type(
	struct FE_element_field_component *element_field_component,
	enum Global_to_element_map_type *type_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the type of mapping used by <element_field_component>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_component_get_type);
	if (element_field_component && type_address)
	{
		*type_address = element_field_component->type;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_component_get_type.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_component_get_type */

static int FE_element_field_components_match(
	struct FE_element_field_component *component_1,
	struct FE_element_node_scale_field_info *info_1,
	struct LIST(FE_node) *global_node_list1,
	struct FE_element_field_component *component_2,
	struct FE_element_node_scale_field_info *info_2,
	int differences_are_errors)
/*******************************************************************************
LAST MODIFIED : 7 May 2003

DESCRIPTION :
Returns true if <component_1> and <component_2> are equivalent for
<info_1> and <info_2>, respectively.
If the <global_node_list1> is supplied, instead of matching node pointers from
<info_1>, the global node of the same identifier is compared. Used in
"can be merged" code when used non-global nodes are in the element.
If <differences_are_errors> is set, differences are reported as errors. This
will be the case for 'can be merged' code, but not for determining if field
headers have to change in output files.
==============================================================================*/
{
	int j, k, l, m, *number_in_xi_1, *number_in_xi_2,
		*number_in_scale_factor_set_1, *number_in_scale_factor_set_2,
		number_of_values, return_code, *scale_factor_index_1, *scale_factor_index_2,
		start_scale_factor_set_1, start_scale_factor_set_2,
		*value_index_1, *value_index_2;
	struct FE_node *node1, *node2;
	struct General_node_to_element_map **general_node_map_1, **general_node_map_2;
	struct Linear_combination_of_global_values **element_value_1,
		**element_value_2;
	struct Standard_node_to_element_map **standard_node_map_1,
		**standard_node_map_2;
	void **scale_factor_set_identifier_1, **scale_factor_set_identifier_2;

	ENTER(FE_element_field_components_match);
	return_code = 0;
	if (component_1 && info_1 && component_2 && info_2)
	{
		if ((component_1->type == component_2->type) &&
			(component_1->basis == component_2->basis) &&
			(component_1->modify == component_2->modify))
		{
			return_code = 1;
			switch (component_1->type)
			{
				case STANDARD_NODE_TO_ELEMENT_MAP:
				{
					if (((j = component_1->map.standard_node_based.number_of_nodes) ==
						component_2->map.standard_node_based.number_of_nodes) &&
						(standard_node_map_1 =
							component_1->map.standard_node_based.node_to_element_maps) &&
						(standard_node_map_2 =
							component_2->map.standard_node_based.node_to_element_maps))
					{
						/* check each standard node to element map */
						while (return_code && (j > 0))
						{
							if ((*standard_node_map_1) && (*standard_node_map_2) &&
								(node1 = (info_1->nodes)[(*standard_node_map_1)->node_index]) &&
								(node2 = (info_2->nodes)[(*standard_node_map_2)->node_index]) &&
								(((!global_node_list1) && (node1 == node2)) ||
									(global_node_list1 && (node2 ==
										FIND_BY_IDENTIFIER_IN_LIST(FE_node,cm_node_identifier)(
											get_FE_node_identifier(node1), global_node_list1)))) &&
								((k = (*standard_node_map_1)->number_of_nodal_values) ==
									(*standard_node_map_2)->number_of_nodal_values) &&
								(value_index_1 =
									(*standard_node_map_1)->nodal_value_indices) &&
								(value_index_2 =
									(*standard_node_map_2)->nodal_value_indices) &&
								(scale_factor_index_1 =
									(*standard_node_map_1)->scale_factor_indices) &&
								(scale_factor_index_2 =
									(*standard_node_map_2)->scale_factor_indices))
							{
								/* determine the merged scale factor set */
								start_scale_factor_set_1 = 0;
								l = info_1->number_of_scale_factor_sets;
								number_in_scale_factor_set_1 =
									info_1->numbers_in_scale_factor_sets;
								scale_factor_set_identifier_1 =
									info_1->scale_factor_set_identifiers;
								while ((l > 0) && (*scale_factor_index_1 >=
									start_scale_factor_set_1 +
									(*number_in_scale_factor_set_1)))
								{
									start_scale_factor_set_1 +=
										*number_in_scale_factor_set_1;
									scale_factor_set_identifier_1++;
									number_in_scale_factor_set_1++;
									l--;
								}
								/* determine the new scale factor set */
								start_scale_factor_set_2 = 0;
								l = info_2->number_of_scale_factor_sets;
								number_in_scale_factor_set_2 =
									info_2->numbers_in_scale_factor_sets;
								scale_factor_set_identifier_2 =
									info_2->scale_factor_set_identifiers;
								while ((l > 0) && (*scale_factor_index_2 >=
									start_scale_factor_set_2 +
									(*number_in_scale_factor_set_2)))
								{
									start_scale_factor_set_2 +=
										*number_in_scale_factor_set_2;
									scale_factor_set_identifier_2++;
									number_in_scale_factor_set_2++;
									l--;
								}
								if ((!scale_factor_set_identifier_1 &&
									!scale_factor_set_identifier_2) ||
									(scale_factor_set_identifier_1 &&
										scale_factor_set_identifier_2 &&
										(*scale_factor_set_identifier_1 ==
										*scale_factor_set_identifier_2) &&
										(*number_in_scale_factor_set_1 ==
											*number_in_scale_factor_set_2)))
								{
									while (return_code && (k > 0) &&
										(*value_index_1 == *value_index_2) &&
										((*scale_factor_index_1) - start_scale_factor_set_1 ==
											(*scale_factor_index_2) -
											start_scale_factor_set_2))
									{
										value_index_1++;
										value_index_2++;
										scale_factor_index_1++;
										scale_factor_index_2++;
										k--;
									}
									if (k <= 0)
									{
										standard_node_map_1++;
										standard_node_map_2++;
										j--;
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"FE_element_field_components_match.  "
											"Invalid standard node to element map");
										return_code = 0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"FE_element_field_components_match.  "
										"Inconsistent scale factor sets");
									return_code = 0;
								}
							}
							else
							{
								if (differences_are_errors)
								{
									display_message(ERROR_MESSAGE,
										"FE_element_field_components_match.  "
										"Inconsistent standard node to element maps");
								}
								return_code = 0;
							}
						}
					}
					else
					{
						if (differences_are_errors)
						{
							display_message(ERROR_MESSAGE,
								"FE_element_field_components_match.  "
								"Different or invalid standard node to element maps");
						}
						return_code = 0;
					}
				} break;
				case GENERAL_NODE_TO_ELEMENT_MAP:
				{
					if (((j = component_1->map.general_node_based.number_of_nodes) ==
						component_2->map.general_node_based.number_of_nodes) &&
						(general_node_map_1 =
							component_1->map.general_node_based.node_to_element_maps) &&
						(general_node_map_2 =
							component_2->map.general_node_based.node_to_element_maps))
					{
						/* check each general node to element map */
						while (return_code && (j > 0))
						{
							if ((*general_node_map_1) && (*general_node_map_2) &&
								(node1 = (info_1->nodes)[(*general_node_map_1)->node_index]) &&
								(node2 = (info_2->nodes)[(*general_node_map_1)->node_index]) &&
								(((!global_node_list1) && (node1 == node2)) ||
									(global_node_list1 && (node2 ==
										FIND_BY_IDENTIFIER_IN_LIST(FE_node,cm_node_identifier)(
											get_FE_node_identifier(node1), global_node_list1)))) &&
								((k = (*general_node_map_1)->number_of_nodal_values) ==
									(*general_node_map_2)->number_of_nodal_values) &&
								(element_value_1 = (*general_node_map_1)->element_values)
								&& (element_value_2 =
									(*general_node_map_2)->element_values))
							{
								while (return_code && (k > 0))
								{
									if ((*element_value_1) && (*element_value_2) &&
										((l =
											(*element_value_1)->number_of_global_values) ==
											(*element_value_2)->number_of_global_values)
										&& (value_index_1 =
											(*element_value_1)->global_value_indices) &&
										(value_index_2 =
											(*element_value_2)->global_value_indices) &&
										(scale_factor_index_1 =
											(*element_value_1)->coefficient_indices) &&
										(scale_factor_index_2 =
											(*element_value_2)->coefficient_indices))
									{
										/* determine the element scale factor set */
										start_scale_factor_set_1 = 0;
										m = info_1->number_of_scale_factor_sets;
										number_in_scale_factor_set_1 =
											info_1->numbers_in_scale_factor_sets;
										scale_factor_set_identifier_1 =
											info_1->scale_factor_set_identifiers;
										while ((m > 0) && (*scale_factor_index_1 >=
											start_scale_factor_set_1 +
											(*number_in_scale_factor_set_1)))
										{
											start_scale_factor_set_1 +=
												*number_in_scale_factor_set_1;
											scale_factor_set_identifier_1++;
											number_in_scale_factor_set_1++;
											m--;
										}
										/* determine the new scale factor set */
										start_scale_factor_set_2 = 0;
										m = info_2->number_of_scale_factor_sets;
										number_in_scale_factor_set_2 =
											info_2->numbers_in_scale_factor_sets;
										scale_factor_set_identifier_2 =
											info_2->scale_factor_set_identifiers;
										while ((m > 0) && (*scale_factor_index_2 >=
											start_scale_factor_set_2 +
											(*number_in_scale_factor_set_2)))
										{
											start_scale_factor_set_2 +=
												*number_in_scale_factor_set_2;
											scale_factor_set_identifier_2++;
											number_in_scale_factor_set_2++;
											m--;
										}
										if ((*scale_factor_set_identifier_1 ==
											*scale_factor_set_identifier_2) &&
											(*number_in_scale_factor_set_1 ==
												*number_in_scale_factor_set_2))
										{
											while (return_code && (l > 0) &&
												(*value_index_1 == *value_index_2) &&
												((*scale_factor_index_1) -
													start_scale_factor_set_1 ==
													(*scale_factor_index_2) -
													start_scale_factor_set_2))
											{
												value_index_1++;
												value_index_2++;
												scale_factor_index_1++;
												scale_factor_index_2++;
												l--;
											}
											if (l <= 0)
											{
												element_value_1++;
												element_value_2++;
												k--;
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"FE_element_field_components_match.  "
													"Invalid general node to element map");
												return_code = 0;
											}
										}
										else
										{
											if (differences_are_errors)
											{
												display_message(ERROR_MESSAGE,
													"FE_element_field_components_match.  Inconsistent "
													"scale factor sets in global to element map");
											}
											return_code = 0;
										}
									}
									else
									{
										if (differences_are_errors)
										{
											display_message(ERROR_MESSAGE,
												"FE_element_field_components_match.  "
												"Minorly inconsistent global to element map");
										}
										return_code = 0;
									}
								}
								general_node_map_1++;
								general_node_map_2++;
								j--;
							}
							else
							{
								if (differences_are_errors)
								{
									display_message(ERROR_MESSAGE,
										"FE_element_field_components_match.  "
										"Majorly inconsistent global to element map");
								}
								return_code = 0;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"FE_element_field_components_match.  "
							"Invalid global to element map");
						return_code = 0;
					}
				} break;
				case FIELD_TO_ELEMENT_MAP:
				{
					if (((j = component_1->map.field_based.number_of_element_values) ==
						component_2->map.field_based.number_of_element_values) &&
						(element_value_1 =
							component_1->map.field_based.element_values) &&
						(element_value_2 =
							component_2->map.field_based.element_values))
					{
						/* check each field to element map */
						while (return_code && (j > 0))
						{
							if ((*element_value_1) && (*element_value_2) &&
								((k = (*element_value_1)->number_of_global_values) ==
									(*element_value_2)->number_of_global_values) &&
								(value_index_1 =
									(*element_value_1)->global_value_indices) &&
								(value_index_2 =
									(*element_value_2)->global_value_indices) &&
								(scale_factor_index_1 =
									(*element_value_1)->coefficient_indices) &&
								(scale_factor_index_2 =
									(*element_value_2)->coefficient_indices))
							{
								while (return_code && (k > 0) &&
									(*value_index_1 == *value_index_2) &&
									(*scale_factor_index_1 == *scale_factor_index_2))
								{
									value_index_1++;
									value_index_2++;
									scale_factor_index_1++;
									scale_factor_index_2++;
									k--;
								}
								if (k <= 0)
								{
									element_value_1++;
									element_value_2++;
									j--;
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"FE_element_field_components_match.  "
										"Invalid field to element map");
									return_code = 0;
								}
							}
							else
							{
								if (differences_are_errors)
								{
									display_message(ERROR_MESSAGE,
										"FE_element_field_components_match.  "
										"Inconsistent global to element map");
								}
								return_code = 0;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"FE_element_field_components_match.  "
							"Invalid global to element map");
						return_code = 0;
					}
				} break;
				case ELEMENT_GRID_MAP:
				{
					number_in_xi_1 = component_1->map.element_grid_based.number_in_xi;
					number_in_xi_2 = component_2->map.element_grid_based.number_in_xi;
					j = (component_1->basis->type)[0];
					number_of_values = 1;
					while (j && (*number_in_xi_1 == *number_in_xi_2))
					{
						number_of_values *= (*number_in_xi_1) + 1;
						j--;
						number_in_xi_1++;
						number_in_xi_2++;
					}
					if (j)
					{
						if (differences_are_errors)
						{
							display_message(ERROR_MESSAGE,
								"FE_element_field_components_match.  Inconsistent grids");
						}
						return_code = 0;
					}
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"FE_element_field_components_match.  "
						"Invalid global to element map type");
					return_code = 0;
				} break;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_components_match.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_components_match */

struct FE_element_field *CREATE(FE_element_field)(struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 2 November 1995

DESCRIPTION :
Allocates memory and assigns fields for an element field.  The storage is
allocated for the pointers to the components and set to NULL.
==============================================================================*/
{
	int i;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;

	ENTER(CREATE(FE_element_field));
	if (field)
	{
		if ((ALLOCATE(element_field,struct FE_element_field,1))&&
			(ALLOCATE(component,struct FE_element_field_component *,
			field->number_of_components)))
		{
			element_field->access_count=0;
			element_field->field=ACCESS(FE_field)(field);
			element_field->components=component;
			for (i=field->number_of_components;i>0;i--)
			{
				*component=(struct FE_element_field_component *)NULL;
				component++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field).  Could not allocate memory for element field");
			DEALLOCATE(element_field);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field).  Invalid argument(s)");
		element_field=(struct FE_element_field *)NULL;
	}
	LEAVE;

	return (element_field);
} /* CREATE(FE_element_field) */

int DESTROY(FE_element_field)(
	struct FE_element_field **element_field_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Frees the memory for element field and sets <*element_field_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;

	ENTER(DESTROY(FE_element_field));
	if ((element_field_address)&&(element_field= *element_field_address))
	{
		if (0==element_field->access_count)
		{
			/* the element field will be destroyed as part as part of destroying
				element field information.  So it will already have been removed from
				the appropriate list */
			/* destroy the global to element maps */
			component=element_field->components;
			for (i=element_field->field->number_of_components;i>0;i--)
			{
				DESTROY(FE_element_field_component)(component);
				component++;
			}
			DEALLOCATE(element_field->components);
			DEACCESS(FE_field)(&(element_field->field));
			DEALLOCATE(*element_field_address);
		}
		else
		{
			*element_field_address=(struct FE_element_field *)NULL;
		}
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field) */

DECLARE_OBJECT_FUNCTIONS(FE_element_field)

static int FE_element_field_not_in_list(struct FE_element_field *element_field,
	void *element_field_list)
/*******************************************************************************
LAST MODIFIED : 15 May 2003

DESCRIPTION :
Checks if the <element_field> is not in the <element_field_list>.
???RC Should try to re-use FE_element_fields_match...
==============================================================================*/
{
	int i,j,k,l,*number_in_xi_1,*number_in_xi_2,number_of_xi_coordinates,
		return_code,*scale_factor_index_1,*scale_factor_index_2,*value_index_1,
		*value_index_2;
	struct FE_element_field *element_field_2;
	struct LIST(FE_element_field) *list;
	struct FE_element_field_component **component_1,**component_2;
	struct General_node_to_element_map **general_node_map_1,**general_node_map_2;
	struct Linear_combination_of_global_values **element_value_1,
		**element_value_2;
	struct Standard_node_to_element_map **standard_node_map_1,
		**standard_node_map_2;

	ENTER(FE_element_field_not_in_list);
	if (element_field&&(element_field->field)&&
		(list=(struct LIST(FE_element_field) *)element_field_list))
	{
		if ((element_field_2=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,
			field)(element_field->field,list))&&
			(component_1=element_field->components)&&
			(component_2=element_field_2->components))
		{
			return_code=0;
			i=element_field->field->number_of_components;
			while (!return_code&&(i>0))
			{
				if ((*component_1)&&(*component_2)&&
					((*component_1)->type==(*component_2)->type)&&
					((*component_1)->basis==(*component_2)->basis)&&
					((*component_1)->modify==(*component_2)->modify))
				{
					number_of_xi_coordinates=((*component_1)->basis->type)[0];
					switch ((*component_1)->type)
					{
						case STANDARD_NODE_TO_ELEMENT_MAP:
						{
							if (((j=(*component_1)->map.standard_node_based.
								number_of_nodes)==(*component_2)->map.standard_node_based.
								number_of_nodes)&&(standard_node_map_1=(*component_1)->map.
								standard_node_based.node_to_element_maps)&&
								(standard_node_map_2=(*component_2)->map.standard_node_based.
								node_to_element_maps))
							{
								while (!return_code&&(j>0))
								{
									if ((*standard_node_map_1)&&(*standard_node_map_2)&&
										((*standard_node_map_1)->node_index==
										(*standard_node_map_2)->node_index)&&
										((k=(*standard_node_map_1)->number_of_nodal_values)==
										(*standard_node_map_2)->number_of_nodal_values)&&
										(value_index_1=(*standard_node_map_1)->
										nodal_value_indices)&&(value_index_2=
										(*standard_node_map_2)->nodal_value_indices)&&
										(scale_factor_index_1=(*standard_node_map_1)->
										scale_factor_indices)&&(scale_factor_index_2=
										(*standard_node_map_2)->scale_factor_indices))
									{
										while (!return_code&&(k>0))
										{
											if ((*value_index_1== *value_index_2)&&
												(*scale_factor_index_1== *scale_factor_index_2))
											{
												value_index_1++;
												value_index_2++;
												scale_factor_index_1++;
												scale_factor_index_2++;
												k--;
											}
											else
											{
												return_code=1;
											}
										}
										standard_node_map_1++;
										standard_node_map_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						case GENERAL_NODE_TO_ELEMENT_MAP:
						{
							if (((j=(*component_1)->map.general_node_based.
								number_of_nodes)==(*component_2)->map.general_node_based.
								number_of_nodes)&&(general_node_map_1=(*component_1)->map.
								general_node_based.node_to_element_maps)&&
								(general_node_map_2=(*component_2)->map.general_node_based.
								node_to_element_maps))
							{
								while (!return_code&&(j>0))
								{
									if ((*general_node_map_1)&&(*general_node_map_2)&&
										((*general_node_map_1)->node_index==
										(*general_node_map_2)->node_index)&&
										((k=(*general_node_map_1)->number_of_nodal_values)==
										(*general_node_map_2)->number_of_nodal_values)&&
										(element_value_1=(*general_node_map_1)->element_values)&&
										(element_value_2=(*general_node_map_2)->element_values))
									{
										while (!return_code&&(k>0))
										{
											if ((*element_value_1)&&(*element_value_2)&&
												((l=(*element_value_1)->number_of_global_values)==
												(*element_value_2)->number_of_global_values)&&
												(value_index_1=(*element_value_1)->
												global_value_indices)&&(value_index_2=
												(*element_value_2)->global_value_indices)&&
												(scale_factor_index_1=(*element_value_1)->
												coefficient_indices)&&(scale_factor_index_2=
												(*element_value_2)->coefficient_indices))
											{
												while (!return_code&&(l>0))
												{
													if ((*value_index_1== *value_index_2)&&
														(*scale_factor_index_1== *scale_factor_index_2))
													{
														value_index_1++;
														value_index_2++;
														scale_factor_index_1++;
														scale_factor_index_2++;
														l--;
													}
													else
													{
														return_code=1;
													}
												}
												element_value_1++;
												element_value_2++;
												k--;
											}
											else
											{
												return_code=1;
											}
										}
										general_node_map_1++;
										general_node_map_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						case FIELD_TO_ELEMENT_MAP:
						{
							if (((j=(*component_1)->map.field_based.
								number_of_element_values)==(*component_2)->map.field_based.
								number_of_element_values)&&(element_value_1=(*component_1)->
								map.field_based.element_values)&&(element_value_2=
								(*component_2)->map.field_based.element_values))
							{
								while (!return_code&&(j>0))
								{
									if ((*element_value_1)&&(*element_value_2)&&
										((k=(*element_value_1)->number_of_global_values)==
										(*element_value_2)->number_of_global_values)&&
										(value_index_1=(*element_value_1)->
										global_value_indices)&&(value_index_2=
										(*element_value_2)->global_value_indices)&&
										(scale_factor_index_1=(*element_value_1)->
										coefficient_indices)&&(scale_factor_index_2=
										(*element_value_2)->coefficient_indices))
									{
										while (!return_code&&(k>0))
										{
											if ((*value_index_1== *value_index_2)&&
												(*scale_factor_index_1== *scale_factor_index_2))
											{
												value_index_1++;
												value_index_2++;
												scale_factor_index_1++;
												scale_factor_index_2++;
												k--;
											}
											else
											{
												return_code=1;
											}
										}
										element_value_1++;
										element_value_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						case ELEMENT_GRID_MAP:
						{
							if (((*component_1)->map.element_grid_based.value_index==
								(*component_2)->map.element_grid_based.value_index)&&
								(number_in_xi_1=
								(*component_1)->map.element_grid_based.number_in_xi)&&
								(number_in_xi_2=
								(*component_2)->map.element_grid_based.number_in_xi))
							{
								j=number_of_xi_coordinates;
								while (!return_code&&(j>0))
								{
									if (*number_in_xi_1== *number_in_xi_2)
									{
										number_in_xi_1++;
										number_in_xi_2++;
										j--;
									}
									else
									{
										return_code=1;
									}
								}
							}
							else
							{
								return_code=1;
							}
						} break;
						default:
						{
							display_message(ERROR_MESSAGE,
								"FE_element_field_not_in_list.  Invalid map type");
							return_code=1;
						} break;
					}
					component_1++;
					component_2++;
					i--;
				}
				else
				{
					return_code=1;
				}
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_not_in_list.  Invalid argument(s)");
		return_code=1;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_not_in_list */

static int FE_element_field_add_to_list_no_field_duplication(
	struct FE_element_field *element_field, void *element_field_list_void)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Adds <element_field> to <element_field_list>, but fails and reports an error if
the field in <element_field> is already used in the list.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element_field) *element_field_list;

	ENTER(FE_element_field_add_to_list_no_field_duplication);
	if (element_field && (element_field->field) && (element_field_list =
		(struct LIST(FE_element_field) *)element_field_list_void))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field, field)(
			element_field->field, element_field_list))
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_add_to_list_no_field_duplication.  "
				"Field %s is used more than once in element field list",
				element_field->field->name);
			return_code = 0;
		}
		else
		{
			if (ADD_OBJECT_TO_LIST(FE_element_field)(element_field,
				element_field_list))
			{
				return_code = 1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_add_to_list_no_field_duplication.  "
					"Could not add field %s to list",
					element_field->field->name);
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_add_to_list_no_field_duplication.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_add_to_list_no_field_duplication */

static int FE_element_fields_match(struct FE_element_field *element_field_1,
	struct FE_element_node_scale_field_info *info_1,
	struct LIST(FE_node) *global_node_list1,
	struct FE_element_field *element_field_2,
	struct FE_element_node_scale_field_info *info_2,
	int ignore_field_and_time_sequence, int differences_are_errors)
/*******************************************************************************
LAST MODIFIED : 7 May 2003

DESCRIPTION :
Returns true if <element_field_1> and <element_field_2> produce equivalent
results with <info_1> and <info_2>, respectively. No comparison of field and
time_sequence members will be made if <ignore_field_and_time_sequence> is set.
If the <global_node_list1> is supplied, instead of matching node pointers from
<info_1>, the global node of the same identifier is compared. Used in
"can be merged" code when used non-global nodes are in the element.
Use with caution!
If <differences_are_errors> is set, differences are reported as errors. This
will be the case for 'can be merged' code, but not for determining if field
headers have to change in output files.
???RC FE_element_field does not have time_sequence -- yet.
==============================================================================*/
{
	int i, number_of_components, return_code;
	struct FE_element_field_component **component_1,**component_2;

	ENTER(FE_element_fields_match);
	if (element_field_1 && info_1 && element_field_2 && info_2)
	{
		if (ignore_field_and_time_sequence || (element_field_1->field &&
			(element_field_1->field == element_field_2->field)))
		{
			if ((number_of_components =
				get_FE_field_number_of_components(element_field_1->field)) ==
				get_FE_field_number_of_components(element_field_2->field))
			{
				if ((component_1 = element_field_1->components) &&
					(component_2 = element_field_2->components))
				{
					return_code = 1;
					/* only GENERAL_FE_FIELD has components to check */
					if (GENERAL_FE_FIELD == element_field_1->field->fe_field_type)
					{
						for (i = number_of_components; (return_code) && (0 < i); i--)
						{
							if (FE_element_field_components_match(*component_1, info_1,
								global_node_list1, *component_2, info_2, differences_are_errors))
							{
								component_1++;
								component_2++;
							}
							else
							{
								if (differences_are_errors)
								{
									display_message(ERROR_MESSAGE,
										"Field components do not match");
								}
								return_code = 0;
							}
						}
					}
				}
				else
				{
					if (differences_are_errors)
					{
						display_message(ERROR_MESSAGE,
							"Missing element field component arrays");
					}
					return_code = 0;
				}
			}
			else
			{
				if (differences_are_errors)
				{
					display_message(ERROR_MESSAGE,
						"Number of components in element field do not match");
				}
				return_code = 0;
			}
		}
		else
		{
			if (differences_are_errors)
			{
				display_message(ERROR_MESSAGE,
					"Fields in element field do not match");
			}
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_fields_match.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_fields_match */

#if !defined (WINDOWS_DEV_FLAG)
static int list_FE_element_field(struct FE_element_field *element_field,
	void *dummy_user_data)
/*******************************************************************************
LAST MODIFIED : 01 April 2008

DESCRIPTION :
Outputs the information contained by the element field.
==============================================================================*/
{
	char *component_name,*type_string;
	int *basis_type,i,j,k,*nodal_value_index,*number_in_xi,
		number_of_components,number_of_nodal_values,
		number_of_xi_coordinates,return_code,*scale_factor_index;
	struct FE_element_field_component **element_field_component;
	struct FE_field *field;
	struct Standard_node_to_element_map **node_to_element_map;

	ENTER(list_FE_element_field);
	if (element_field&&!dummy_user_data)
	{
		if (field=element_field->field)
		{
			return_code=1;
			display_message(INFORMATION_MESSAGE,"  %s",field->name);
			if (type_string=ENUMERATOR_STRING(CM_field_type)(field->cm_field_type))
			{
				display_message(INFORMATION_MESSAGE,", %s",type_string);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"list_FE_element_field.  Invalid CM field type");
				return_code=0;
			}
			if (type_string=ENUMERATOR_STRING(Coordinate_system_type)(
				field->coordinate_system.type))
			{
				display_message(INFORMATION_MESSAGE,", %s",type_string);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"list_FE_element_field.  Invalid field coordinate system");
				return_code=0;
			}
			number_of_components=field->number_of_components;
			display_message(INFORMATION_MESSAGE,", #Components=%d\n",
				number_of_components);
			element_field_component=element_field->components;
			i=0;
			while (return_code&&(i<number_of_components))
			{
				display_message(INFORMATION_MESSAGE,"    ");
				if (component_name=get_FE_field_component_name(field,i))
				{
					display_message(INFORMATION_MESSAGE,component_name);
					DEALLOCATE(component_name);
				}
				if (GENERAL_FE_FIELD==field->fe_field_type)
				{
					if (*element_field_component)
					{
						display_message(INFORMATION_MESSAGE,".  ");
						if (((*element_field_component)->basis)&&
							(basis_type=(*element_field_component)->basis->type))
						{
							/*???DB.  Only correct for tensor products */
							number_of_xi_coordinates= *basis_type;
							basis_type++;
							j=number_of_xi_coordinates;
							while (j>0)
							{
								switch (*basis_type)
								{
									case LINEAR_LAGRANGE:
									{
										display_message(INFORMATION_MESSAGE,"linear Lagrange");
									} break;
									case QUADRATIC_LAGRANGE:
									{
										display_message(INFORMATION_MESSAGE,"quadratic Lagrange");
									} break;
									case CUBIC_LAGRANGE:
									{
										display_message(INFORMATION_MESSAGE,"cubic Lagrange");
									} break;
									case CUBIC_HERMITE:
									{
										display_message(INFORMATION_MESSAGE,"cubic Hermite");
									} break;
									case LAGRANGE_HERMITE:
									{
										display_message(INFORMATION_MESSAGE,"Lagrange Hermite");
									} break;
									case HERMITE_LAGRANGE:
									{
										display_message(INFORMATION_MESSAGE,"Hermite Lagrange");
									} break;
									case LINEAR_SIMPLEX:
									{
										display_message(INFORMATION_MESSAGE,"linear Simplex");
									} break;
									case QUADRATIC_SIMPLEX:
									{
										display_message(INFORMATION_MESSAGE,"quadratic Simplex");
									} break;
								}
								if (j>1)
								{
									display_message(INFORMATION_MESSAGE,"*");
								}
								basis_type += j;
								j--;
							}
						}
						if ((*element_field_component)->modify)
						{
							display_message(INFORMATION_MESSAGE,", modify");
						}
						else
						{
							display_message(INFORMATION_MESSAGE,", no modify");
						}
						switch ((*element_field_component)->type)
						{
							case STANDARD_NODE_TO_ELEMENT_MAP:
							{
								display_message(INFORMATION_MESSAGE,", standard node based\n");
								if (node_to_element_map=(*element_field_component)->map.
									standard_node_based.node_to_element_maps)
								{
									j=(*element_field_component)->map.standard_node_based.
										number_of_nodes;
									while (j>0)
									{
										if (*node_to_element_map)
										{
											number_of_nodal_values=(*node_to_element_map)->
												number_of_nodal_values;
											display_message(INFORMATION_MESSAGE,"      %d.  #Values=%d\n",
												(*node_to_element_map)->node_index,
												number_of_nodal_values);
											if (nodal_value_index=(*node_to_element_map)->nodal_value_indices)
											{
												display_message(INFORMATION_MESSAGE,"        Value indices:");
												for (k=number_of_nodal_values;k>0;k--)
												{
													display_message(INFORMATION_MESSAGE," %d",*nodal_value_index);
													nodal_value_index++;
												}
												display_message(INFORMATION_MESSAGE,"\n");
											}
											if (scale_factor_index=(*node_to_element_map)->scale_factor_indices)
											{
												display_message(INFORMATION_MESSAGE,"        Scale factor indices:");
												for (k=number_of_nodal_values;k>0;k--)
												{
													display_message(INFORMATION_MESSAGE," %d",*scale_factor_index);
													scale_factor_index++;
												}
												display_message(INFORMATION_MESSAGE,"\n");
											}
										}
										j--;
										node_to_element_map++;
									}
								}
							} break;
							case GENERAL_NODE_TO_ELEMENT_MAP:
							{
								display_message(INFORMATION_MESSAGE,", general node based\n");
							} break;
							case FIELD_TO_ELEMENT_MAP:
							{
								display_message(INFORMATION_MESSAGE,", field to element\n");
							} break;
							case ELEMENT_GRID_MAP:
							{
								display_message(INFORMATION_MESSAGE,", grid based\n");
								number_in_xi=(*element_field_component)->map.element_grid_based.
									number_in_xi;
								number_of_xi_coordinates=
									((*element_field_component)->basis->type)[0];
								display_message(INFORMATION_MESSAGE,"      ");
								for (j=0;j<number_of_xi_coordinates;j++)
								{
									if (j>0)
									{
										display_message(INFORMATION_MESSAGE,", ");
									}
									display_message(INFORMATION_MESSAGE,"#xi%d=%d",j+1,number_in_xi[j]);
								}
								display_message(INFORMATION_MESSAGE,"\n");
							} break;
							default:
							{
								display_message(INFORMATION_MESSAGE,"\n");
							} break;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"list_FE_element_field.  Missing element field component");
						return_code=0;
					}
				}
				else
				{
					display_message(INFORMATION_MESSAGE,"\n");
				}
				element_field_component++;
				i++;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"list_FE_element_field.  Missing field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_element_field.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element_field */
#endif /* !defined (WINDOWS_DEV_FLAG) */

static int FE_element_field_private_get_component_FE_basis(
	struct FE_element_field *element_field, int component_number,
	struct FE_basis **fe_basis)
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
If <element_field> is standard node based, returns the <fe_basis> used for
<component_number>.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_component *component;

	ENTER(FE_element_field_private_get_component_FE_basis);
	return_code = 0;
	if (element_field && element_field->field && fe_basis &&
		(0 <= component_number) &&
		(component_number < element_field->field->number_of_components))
	{
		*fe_basis = (struct FE_basis *)NULL;
		/* only GENERAL_FE_FIELD has components and can be grid-based */
		if (GENERAL_FE_FIELD == element_field->field->fe_field_type)
		{
			/* get first field component */
			if (element_field->components &&
				(component = element_field->components[component_number]))
			{
				if (component->basis)
				{
					*fe_basis = component->basis;
					return_code = 1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_element_field_private_get_component_FE_basis.  "
						"Field does not have an FE_basis.");
					return_code = 0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_private_get_component_FE_basis.  "
					"Missing element field component");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_private_get_component_FE_basis.  "
				"Field is not general, not grid-based");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_private_get_component_FE_basis.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_private_get_component_FE_basis */

int FE_element_field_is_coordinate_field(struct FE_element_field *element_field,
	void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 2 September 2001

DESCRIPTION :
Returns a non-zero if the <element_field> is for a coordinate field.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_is_coordinate_field);
	return_code=0;
	if (element_field)
	{
		return_code=FE_field_is_coordinate_field(element_field->field,dummy_void); 	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_is_coordinate_field.  Invalid argument");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_is_coordinate_field */

int FE_element_field_is_anatomical_fibre_field(
	struct FE_element_field *element_field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 2 September 2001

DESCRIPTION :
Returns a non-zero if the <element_field> is for a anatomical fibre field.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_is_anatomical_fibre_field);
	return_code=0;
	if (element_field)
	{
		return_code=FE_field_is_anatomical_fibre_field(element_field->field,
			dummy_void);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_is_anatomical_fibre_field. Invalid argument");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_is_anatomical_fibre_field */

static int for_FE_field_at_element_iterator(
	struct FE_element_field *element_field,void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
FE_element_field iterator for for_each_FE_field_at_element.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_element_iterator);
	if (element_field&&(iterator_and_data=
		(struct FE_element_field_iterator_and_data *)iterator_and_data_void)&&
		iterator_and_data->iterator)
	{
		return_code=(iterator_and_data->iterator)(iterator_and_data->element,
			element_field->field,iterator_and_data->user_data);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_element_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_element_iterator */

static int FE_element_field_add_indexer_field_to_list(
	struct FE_element_field *element_field,void *field_list_void)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
If the field in the <element_field> is of type INDEXED_FE_FIELD, function
ensures its indexer_field is put in the <field_list>.
Used by for_each_FE_field_at_element_indexer_first to put indexer_fields into a
priority list for iterating through first.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;
	struct LIST(FE_field) *field_list;

	ENTER(FE_element_field_add_indexer_field_to_list);
	if (element_field&&(field=element_field->field)&&
		(field_list=(struct LIST(FE_field) *)field_list_void))
	{
		return_code=1;
		if (INDEXED_FE_FIELD==field->fe_field_type)
		{
			if (!IS_OBJECT_IN_LIST(FE_field)(field->indexer_field,field_list))
			{
				return_code=
					ADD_OBJECT_TO_LIST(FE_field)(field->indexer_field,field_list);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_add_indexer_field_to_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_add_indexer_field_to_list */

static int for_FE_field_at_element_priority_iterator(
	struct FE_element_field *element_field,void *iterator_and_data_void)
/*******************************************************************************
LAST MODIFIED : 5 October 1999

DESCRIPTION :
FE_element_field iterator for for_each_FE_field_at_element. Only calls the
iterator function if the priority_on flag matches the field status in
priority_list.
==============================================================================*/
{
	int priority_field,return_code;
	struct FE_element_field_priority_iterator_and_data *iterator_and_data;

	ENTER(for_FE_field_at_element_iterator);
	if (element_field&&(iterator_and_data=
		(struct FE_element_field_priority_iterator_and_data *)
		iterator_and_data_void)&&iterator_and_data->iterator)
	{
		priority_field=IS_OBJECT_IN_LIST(FE_field)(element_field->field,
			iterator_and_data->priority_field_list);
		if ((iterator_and_data->priority_on&&priority_field)||
			((!iterator_and_data->priority_on)&&(!priority_field)))
		{
			return_code=(iterator_and_data->iterator)(iterator_and_data->element,
				element_field->field,iterator_and_data->user_data);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_element_iterator.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_element_iterator */

struct FE_element_field_lists_merge_data
/*******************************************************************************
LAST MODIFIED : 31 October 2002

DESCRIPTION :
The data needed to merge an element_field into the list.  This structure is
local to this module.
==============================================================================*/
{
	struct LIST(FE_element_field) *list;
	/* node_scale_field_info for merged elements in above <list> */
	struct FE_element_node_scale_field_info *merge_info;
	/* node_scale_field_info for all element fields passed directly to
		 merge_FE_element_field_into_list function */
	struct FE_element_node_scale_field_info *source_info;
	/* accumulating size of values_storage in the element. Incremented to fit
		 any grid-based element fields added by merge_FE_element_field_into_list */
	int values_storage_size;
}; /* struct FE_element_field_lists_merge_data */

static int merge_FE_element_field_into_list(
	struct FE_element_field *new_element_field, void *data_void)
/*******************************************************************************
LAST MODIFIED : 24 March 2003

DESCRIPTION :
Merges the <new_element_field> into the <list>. The <new_element_field>
references nodes, scale factors and values relative to the <source_info>.
If an element field already exists in <list> for that field, this function
checks <new_element_field> refers to the same nodes and equivalent scale factor
sets and values_storage in <merge_info>.
If no such element field exists currently, a new one is constructed that refers
to nodes, scale factors and values in the <merge_info> in a compatible way to
<new_element_field>, and this is added to the <list>.
For new grid-based fields this function increments the values_storage_size in
the <data> to fit the new grid values and references them in the element field
constructed for it.
No values_storage arrays are allocated or copied by this function.
==============================================================================*/
{
	int i, j, k, l, m, *new_number_in_scale_factor_set, *new_number_in_xi,
		*new_scale_factor_index, *new_value_index,new_values_storage_size,
		node_index, *number_in_scale_factor_set, *number_in_xi, number_of_values,
		return_code, *scale_factor_index, start_new_scale_factor_set,
		start_scale_factor_set, *value_index;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component, **new_component;
	struct FE_element_field_lists_merge_data *data;
	struct FE_element_node_scale_field_info *merge_info, *source_info;
	struct FE_field *field;
	struct FE_node *new_node, **node;
	struct General_node_to_element_map **new_general_node_map, **general_node_map;
	struct Linear_combination_of_global_values **element_value,
		**new_element_value;
	struct Standard_node_to_element_map **new_standard_node_map,
		**standard_node_map;
	void **new_scale_factor_set_identifier, **scale_factor_set_identifier;

	ENTER(merge_FE_element_field_into_list);
	if (new_element_field && (field = new_element_field->field) &&
		(data = (struct FE_element_field_lists_merge_data *)data_void) &&
		data->list)
	{
		merge_info = data->merge_info;
		source_info = data->source_info;

		return_code = 1;
		/* check if the new element field is in the existing list */
		if (element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field, field)(
			field, data->list))
		{
			/* only GENERAL_FE_FIELD has components to check for merge */
			if (GENERAL_FE_FIELD == field->fe_field_type)
			{
				/* must have merge_info and source_info for general */
				if (merge_info && source_info)
				{
					/* check the new element field for consistency */
					if ((component = element_field->components) &&
						(new_component = new_element_field->components))
					{
						/* check each component */
						i = field->number_of_components;
						while (return_code && (i > 0))
						{
							if (FE_element_field_components_match(*component, merge_info,
								/*global_node_list1*/(struct LIST(FE_node) *)NULL,
								*new_component, source_info, /*differences_are_errors*/1))
							{
								component++;
								new_component++;
								i--;
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"merge_FE_element_field_into_list.  "
									"Inconsistent element field components");
								return_code = 0;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"merge_FE_element_field_into_list.  Invalid element field");
						return_code = 0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"merge_FE_element_field_into_list.  "
						"Missing merge or source node field info");
					return_code = 0;
				}
			}
		}
		else
		{
			/* add the new element field */
			if (element_field = CREATE(FE_element_field)(field))
			{
				/* only GENERAL_FE_FIELD has components to copy for merge */
				if (GENERAL_FE_FIELD == field->fe_field_type)
				{
					/* must have merge_info and source_info for general */
					if (merge_info && source_info)
					{
						new_component = new_element_field->components;
						i = field->number_of_components;
						component = element_field->components;
						while (return_code && (i > 0))
						{
							if ((*new_component) && ((*new_component)->basis))
							{
								switch ((*new_component)->type)
								{
									case STANDARD_NODE_TO_ELEMENT_MAP:
									{
										if ((new_standard_node_map = (*new_component)->map.
											standard_node_based.node_to_element_maps) &&
											((j = (*new_component)->map.standard_node_based.
												number_of_nodes) > 0) &&
											(*component = CREATE(FE_element_field_component)(
												STANDARD_NODE_TO_ELEMENT_MAP, j,
												(*new_component)->basis, (*new_component)->modify)))
										{
											standard_node_map = (*component)->map.standard_node_based.
												node_to_element_maps;
											while (return_code && (j > 0))
											{
												if ((*new_standard_node_map) &&
													((k = (*new_standard_node_map)->
														number_of_nodal_values) > 0) &&
													(new_value_index =
														(*new_standard_node_map)->nodal_value_indices) &&
													(new_scale_factor_index =
														(*new_standard_node_map)->scale_factor_indices))
												{
													/* check that the new node_index is actually for a
														 real node */
													node_index = (*new_standard_node_map)->node_index;
													if ((0 <= node_index) &&
														(node_index < source_info->number_of_nodes) &&
														source_info->nodes)
													{
														/* determine the node index */
														node = merge_info->nodes;
														new_node = source_info->nodes[node_index];
														/*???RC since using this function in
															define_FE_field_at_element, have to handle case of
															NULL nodes just by using existing node_index */
														if (new_node)
														{
															node_index = 0;
															while ((node_index < merge_info->number_of_nodes)
																&& (*node != new_node))
															{
																node_index++;
																node++;
															}
														}
														/* determine the new scale factor set */
														start_new_scale_factor_set = 0;
														l = source_info->number_of_scale_factor_sets;
														new_number_in_scale_factor_set =
															source_info->numbers_in_scale_factor_sets;
														new_scale_factor_set_identifier =
															source_info->scale_factor_set_identifiers;
														while ((l > 0) && (*new_scale_factor_index >=
															start_new_scale_factor_set +
															(*new_number_in_scale_factor_set)))
														{
															start_new_scale_factor_set +=
																*new_number_in_scale_factor_set;
															new_scale_factor_set_identifier++;
															new_number_in_scale_factor_set++;
															l--;
														}
														/* determine the merge scale factor set */
														start_scale_factor_set = 0;
														l = merge_info->number_of_scale_factor_sets;
														number_in_scale_factor_set =
															merge_info->numbers_in_scale_factor_sets;
														scale_factor_set_identifier =
															merge_info->scale_factor_set_identifiers;
														while ((l > 0) && (*scale_factor_set_identifier !=
															*new_scale_factor_set_identifier))
														{
															start_scale_factor_set +=
																*number_in_scale_factor_set;
															scale_factor_set_identifier++;
															number_in_scale_factor_set++;
															l--;
														}
														if ((*node == new_node) &&
															((!number_in_scale_factor_set) || (
																(*scale_factor_set_identifier ==
																	*new_scale_factor_set_identifier) &&
																(*number_in_scale_factor_set ==
																	*new_number_in_scale_factor_set))) &&
															(*standard_node_map =
																CREATE(Standard_node_to_element_map)(node_index,
																	k)))
														{
															value_index =
																(*standard_node_map)->nodal_value_indices;
															scale_factor_index =
																(*standard_node_map)->scale_factor_indices;
															l = start_scale_factor_set -
																start_new_scale_factor_set;
															while (k > 0)
															{
																*value_index = *new_value_index;
																*scale_factor_index =
																	(*new_scale_factor_index) + l;
																value_index++;
																new_value_index++;
																scale_factor_index++;
																new_scale_factor_index++;
																k--;
															}
															standard_node_map++;
															new_standard_node_map++;
															j--;
														}
														else
														{
															display_message(ERROR_MESSAGE,
																"merge_FE_element_field_into_list.  "
																"Invalid node or scale factor information");
															return_code = 0;
														}
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"merge_FE_element_field_into_list.  "
															"Node index out of range");
														return_code = 0;
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  "
														"Invalid standard node to element map");
													return_code = 0;
												}
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"merge_FE_element_field_into_list.  "
												"Could not create element field component");
											return_code = 0;
										}
									} break;
									case GENERAL_NODE_TO_ELEMENT_MAP:
									{
										if ((new_general_node_map=(*new_component)->map.
											general_node_based.node_to_element_maps)&&
											((j=(*new_component)->map.general_node_based.
												number_of_nodes)>0)&&
											(*component=CREATE(FE_element_field_component)(
												GENERAL_NODE_TO_ELEMENT_MAP,j,(*new_component)->basis,
												(*new_component)->modify)))
										{
											general_node_map=(*component)->map.general_node_based.
												node_to_element_maps;
											while (return_code&&(j>0))
											{
												if ((*new_general_node_map)&&
													((k=(*new_general_node_map)->
														number_of_nodal_values)>0)&&(new_element_value=
															(*new_general_node_map)->element_values))
												{
													/* determine the node index */
													node = merge_info->nodes;
													new_node = source_info->nodes
														[(*new_general_node_map)->node_index];
													node_index=0;
													while ((node_index < merge_info->number_of_nodes) &&
														(*node != new_node))
													{
														node_index++;
														node++;
													}
													if ((*node==new_node)&&(*general_node_map=CREATE(
														General_node_to_element_map)(node_index,k)))
													{
														element_value=(*general_node_map)->element_values;
														while (return_code&&(k>0))
														{
															if ((*new_element_value)&&
																((l=(*new_element_value)->
																	number_of_global_values)>0)&&(new_value_index=
																		(*new_element_value)->global_value_indices)&&
																(new_scale_factor_index=(*new_element_value)->
																	coefficient_indices)&&(*element_value=CREATE(
																		Linear_combination_of_global_values)(l)))
															{
																value_index=(*element_value)->
																	global_value_indices;
																scale_factor_index=
																	(*element_value)->coefficient_indices;
																/* determine the new scale factor set */
																start_new_scale_factor_set=0;
																m=source_info->number_of_scale_factor_sets;
																new_number_in_scale_factor_set=
																	source_info->numbers_in_scale_factor_sets;
																new_scale_factor_set_identifier=
																	source_info->scale_factor_set_identifiers;
																while ((m>0)&&(*new_scale_factor_index>=
																	start_new_scale_factor_set+
																	(*new_number_in_scale_factor_set)))
																{
																	start_new_scale_factor_set +=
																		*new_number_in_scale_factor_set;
																	new_scale_factor_set_identifier++;
																	new_number_in_scale_factor_set++;
																	m--;
																}
																/* determine the element scale factor set */
																start_scale_factor_set=0;
																m=merge_info->number_of_scale_factor_sets;
																number_in_scale_factor_set=
																	merge_info->numbers_in_scale_factor_sets;
																scale_factor_set_identifier=
																	merge_info->scale_factor_set_identifiers;
																while ((m>0)&&(*scale_factor_set_identifier!=
																	*new_scale_factor_set_identifier))
																{
																	start_scale_factor_set +=
																		*number_in_scale_factor_set;
																	scale_factor_set_identifier++;
																	number_in_scale_factor_set++;
																	m--;
																}
																if ((*scale_factor_set_identifier==
																	*new_scale_factor_set_identifier)&&
																	(*number_in_scale_factor_set==
																		*new_number_in_scale_factor_set))
																{
																	m=start_scale_factor_set-
																		start_new_scale_factor_set;
																	while (l>0)
																	{
																		*value_index= *new_value_index;
																		*scale_factor_index=
																			(*new_scale_factor_index)+m;
																		value_index++;
																		new_value_index++;
																		scale_factor_index++;
																		new_scale_factor_index++;
																		l--;
																	}
																	element_value++;
																	new_element_value++;
																	k--;
																}
																else
																{
																	display_message(ERROR_MESSAGE,
																		"merge_FE_element_field_into_list.  "
																		"Invalid scale factor set");
																	return_code = 0;
																}
															}
															else
															{
																display_message(ERROR_MESSAGE,
																	"merge_FE_element_field_into_list.  "
																	"Could not create linear combination");
																return_code = 0;
															}
														}
														if (return_code)
														{
															general_node_map++;
															new_general_node_map++;
															j--;
														}
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"merge_FE_element_field_into_list.  "
															"Could not create general node to element map");
														return_code = 0;
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  "
														"Invalid general node to element map");
													return_code = 0;
												}
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"merge_FE_element_field_into_list.  "
												"Could not create element field component");
											return_code = 0;
										}
									} break;
									case FIELD_TO_ELEMENT_MAP:
									{
										if ((new_element_value=(*new_component)->map.field_based.
											element_values)&&((j=(*new_component)->map.field_based.
												number_of_element_values)>0)&&(*component=CREATE(
													FE_element_field_component)(FIELD_TO_ELEMENT_MAP,j,
														(*new_component)->basis,(*new_component)->modify)))
										{
											element_value=(*general_node_map)->element_values;
											while (return_code&&(j>0))
											{
												if ((*new_element_value)&&((k=(*new_element_value)->
													number_of_global_values)>0)&&(new_value_index=
														(*new_element_value)->global_value_indices)&&
													(new_scale_factor_index=(*new_element_value)->
														coefficient_indices)&&(*element_value=
															CREATE(Linear_combination_of_global_values)(k)))
												{
													value_index=(*element_value)->global_value_indices;
													scale_factor_index=(*element_value)->
														coefficient_indices;
													/* determine the new scale factor set */
													start_new_scale_factor_set=0;
													l=source_info->number_of_scale_factor_sets;
													new_number_in_scale_factor_set=
														source_info->numbers_in_scale_factor_sets;
													new_scale_factor_set_identifier=
														source_info->scale_factor_set_identifiers;
													while ((l>0)&&(*new_scale_factor_index>=
														start_new_scale_factor_set+
														(*new_number_in_scale_factor_set)))
													{
														start_new_scale_factor_set +=
															*new_number_in_scale_factor_set;
														new_scale_factor_set_identifier++;
														new_number_in_scale_factor_set++;
														l--;
													}
													/* determine the element scale factor set */
													start_scale_factor_set=0;
													l=merge_info->number_of_scale_factor_sets;
													number_in_scale_factor_set=
														merge_info->numbers_in_scale_factor_sets;
													scale_factor_set_identifier=
														merge_info->scale_factor_set_identifiers;
													while ((m>0)&&(*scale_factor_set_identifier!=
														*new_scale_factor_set_identifier))
													{
														start_scale_factor_set +=
															*number_in_scale_factor_set;
														scale_factor_set_identifier++;
														number_in_scale_factor_set++;
														l--;
													}
													if ((*scale_factor_set_identifier==
														*new_scale_factor_set_identifier)&&
														(*number_in_scale_factor_set==
															*new_number_in_scale_factor_set))
													{
														l=start_scale_factor_set-
															start_new_scale_factor_set;
														while (k>0)
														{
															*value_index= *new_value_index;
															*scale_factor_index=
																(*new_scale_factor_index)+m;
															value_index++;
															new_value_index++;
															scale_factor_index++;
															new_scale_factor_index++;
															k--;
														}
														element_value++;
														new_element_value++;
														j--;
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"merge_FE_element_field_into_list.  "
															"Invalid scale factor set");
														return_code = 0;
													}
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"merge_FE_element_field_into_list.  "
														"Could not create field to element map");
													return_code = 0;
												}
											}
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"merge_FE_element_field_into_list.  "
												"Could not create element field component");
											return_code = 0;
										}
									} break;
									case ELEMENT_GRID_MAP:
									{
										int size;

										if (*component = CREATE(FE_element_field_component)(
											ELEMENT_GRID_MAP, 1, (*new_component)->basis,
											(*new_component)->modify))
										{
											number_in_xi =
												((*component)->map).element_grid_based.number_in_xi;
											new_number_in_xi =
												((*new_component)->map).element_grid_based.number_in_xi;
											number_of_values = 1;
											for (j = ((*component)->basis->type)[0]; j > 0; j--)
											{
												*number_in_xi = *new_number_in_xi;
												number_of_values *= (*number_in_xi) + 1;
												number_in_xi++;
												new_number_in_xi++;
											}
											size = get_Value_storage_size(
												field->value_type, (struct FE_time_sequence *)NULL);
											new_values_storage_size = size*number_of_values;
											ADJUST_VALUE_STORAGE_SIZE(new_values_storage_size);
											/* point the component to new space after the current
												 data->values_storage_size */
											((*component)->map).element_grid_based.value_index =
												data->values_storage_size;
											/* increase the data->values_storage_size to fit */
											data->values_storage_size += new_values_storage_size;
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"merge_FE_element_field_into_list.  "
												"Could not create element field component");
											return_code = 0;
										}
									} break;
									default:
									{
										display_message(ERROR_MESSAGE,
											"merge_FE_element_field_into_list.  "
											"Invalid global to element map type");
										return_code = 0;
									} break;
								}
								component++;
								new_component++;
								i--;
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"merge_FE_element_field_into_list.  "
									"Invalid element field component");
								return_code = 0;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"merge_FE_element_field_into_list.  "
							"Missing merge or source node field info");
						return_code = 0;
					}
				}
				if ((!return_code) ||
					(!ADD_OBJECT_TO_LIST(FE_element_field)(element_field, data->list)))
				{
					display_message(ERROR_MESSAGE, "merge_FE_element_field_into_list.  "
						"Could not add element field to list");
					return_code = 0;
					DESTROY(FE_element_field)(&element_field);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"merge_FE_element_field_into_list.  Could not create element field");
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_FE_element_field_into_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_element_field_into_list */

#if defined (OLD_CODE)
static int check_FE_element_field_dimension(
	struct FE_element_field *element_field,void *dimension_address)
/*******************************************************************************
LAST MODIFIED : 2 October 1995

DESCRIPTION :
Checks that the <element_field> has the specified dimension.
==============================================================================*/
{
	int dimension,i,return_code;
	struct FE_element_field_component **component;

	ENTER(check_FE_element_field_dimension);
	/* check the arguments */
	if (element_field&&(element_field->field)&&
		(component=element_field->components)&&dimension_address)
	{
		dimension= *(int *)dimension_address;
		return_code=1;
		i=element_field->field->number_of_components;
		while (return_code&&(i>0))
		{
			if ((*component)&&((*component)->basis)&&
				(dimension== *((*component)->basis->type)))
			{
				i--;
				component++;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"check_FE_element_field_dimension.  Inconsistent element field");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"check_FE_element_field_dimension.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* check_FE_element_field_dimension */
#endif /* defined (OLD_CODE) */

int calculate_grid_field_offsets(int element_dimension,
	int top_level_element_dimension,int *top_level_number_in_xi,
	FE_value *element_to_top_level,int *number_in_xi,int *base_grid_offset,
	int *grid_offset_in_xi)
/*******************************************************************************
LAST MODIFIED : 13 June 2000

DESCRIPTION :
Calculates the factors for converting a grid position on a element of
<element_dimension> to a top_level_element of <top_level_element_dimension>
with <top_level_number_in_xi>, given affine transformation
<element_to_top_level> which has as many rows as <top_level_element_dimension>
and 1 more column than <element_dimension>, converting xi from element to
top_level as follows:
top_level_xi = b + A xi, with b the first column.
The <number_in_xi> of the element is returned, as is the <base_grid_offset> and
the <grid_offset_in_xi> which make up the grid point number conversion:
eg. top_level_grid_point_number = base_grid_offset +
grid_offset_in_xi[i]*grid_number_in_xi[i] (i summed over element_dimension).
Sets values appropriately if element_dimension = top_level_element_dimension.
==============================================================================*/
{
	FE_value *temp_element_to_top_level;
	int i,return_code,top_level_grid_offset_in_xi[MAXIMUM_ELEMENT_XI_DIMENSIONS],
		xi_number;

	ENTER(calculate_grid_field_offsets);
	if ((0<element_dimension)&&(element_dimension<=top_level_element_dimension)&&
		(top_level_element_dimension<=MAXIMUM_ELEMENT_XI_DIMENSIONS)&&
		top_level_number_in_xi&&((element_dimension==top_level_element_dimension)||
			element_to_top_level)&&number_in_xi&&base_grid_offset&&grid_offset_in_xi)
	{
		return_code=1;
		/* clear offsets */
		*base_grid_offset = 0;
		for (i=0;i<element_dimension;i++)
		{
			grid_offset_in_xi[i]=0;
		}
		/* calculate offset in grid_point_number for adjacent points in each xi
			 direction on the top_level_element */
		if (top_level_number_in_xi[0] > 0)
		{
			top_level_grid_offset_in_xi[0]=1;
		}
		else
		{
			top_level_grid_offset_in_xi[0]=0;
		}
		for (i=1;i<top_level_element_dimension;i++)
		{
			if (top_level_number_in_xi[i] > 0)
			{
				top_level_grid_offset_in_xi[i]=
					top_level_grid_offset_in_xi[i-1]*(top_level_number_in_xi[i-1]+1);
			}
			else
			{
				top_level_grid_offset_in_xi[i]=
					top_level_grid_offset_in_xi[i-1]*(top_level_number_in_xi[i-1]);
			}
		}
		if (element_dimension == top_level_element_dimension)
		{
			for (i=0;i<top_level_element_dimension;i++)
			{
				grid_offset_in_xi[i]=top_level_grid_offset_in_xi[i];
				number_in_xi[i]=top_level_number_in_xi[i];
			}
		}
		else
		{
			temp_element_to_top_level=element_to_top_level;
			for (i=0;i<top_level_element_dimension;i++)
			{
				/* a number in the first column indicates either xi decreasing
					 or the direction this is a face/line on */
				if (*temp_element_to_top_level)
				{
					*base_grid_offset +=
						top_level_number_in_xi[i]*top_level_grid_offset_in_xi[i];
				}
				/* find out how (if at all) element xi changes with this
					 field_element xi */
				for (xi_number=0;xi_number<element_dimension;xi_number++)
				{
					if (temp_element_to_top_level[xi_number+1])
					{
						number_in_xi[xi_number] = top_level_number_in_xi[i];
						if (0<temp_element_to_top_level[xi_number+1])
						{
							grid_offset_in_xi[xi_number] = top_level_grid_offset_in_xi[i];
						}
						else
						{
							grid_offset_in_xi[xi_number] = -top_level_grid_offset_in_xi[i];
						}
					}
				}
				temp_element_to_top_level += (element_dimension+1);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_grid_field_offsets.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* calculate_grid_field_offsets */

int FE_element_field_values_are_for_element_and_time(
	struct FE_element_field_values *element_field_values,
	struct FE_element *element,FE_value time,struct FE_element *field_element)
/*******************************************************************************
LAST MODIFIED : 3 December 2001

DESCRIPTION :
Returns true if the <element_field_values> originated from <element>, either
directly or inherited from <field_element>. If <field_element> is NULL no match
is required with the field_element in the <element_field_values>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_values_are_for_element_and_time);
	if (element_field_values&&element)
	{
		return_code=(element_field_values->element==element)&&
			((!field_element)||(element_field_values->field_element==field_element))
			&&((!element_field_values->time_dependent)||
		   (element_field_values->time==time));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_values_are_for_element_and_time.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_values_are_for_element_and_time */

int FE_element_field_values_have_derivatives_calculated(
	struct FE_element_field_values *element_field_values)
/*******************************************************************************
LAST MODIFIED : 10 March 2003

DESCRIPTION :
Returns true if the <element_field_values> are valid for calculating derivatives.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_values_have_derivatives_calculated);
	if (element_field_values)
	{
		if (element_field_values->derivatives_calculated)
		{
 			return_code = 1;
		}
		else
		{
 			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_values_have_derivatives_calculated.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_values_have_derivatives_calculated */

int standard_basis_function_is_monomial(Standard_basis_function *function,
	void *arguments_void)
/*******************************************************************************
LAST MODIFIED : 12 June 2002

DESCRIPTION :
Returns true if the standard basis function is a monomial.
==============================================================================*/
{
	int *arguments,return_code;

	ENTER(standard_basis_function_is_monomial);
	return_code=0;
	if ((monomial_basis_functions==function)&&(arguments=(int *)arguments_void)&&
		(1<=arguments[0]))
	{
		return_code=1;
	}
	LEAVE;

	return (return_code);
} /* standard_basis_function_is_monomial */

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_element_field, field, \
	struct FE_field *, compare_FE_field)

DECLARE_INDEXED_LIST_FUNCTIONS(FE_element_field)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_element_field, field, \
	struct FE_field *, compare_FE_field)

struct FE_element_field_copy_with_equivalent_field_data
/*******************************************************************************
LAST MODIFIED : 27 November 2002

DESCRIPTION :
Data for passing to FE_element_field_copy_with_equivalent_field.
==============================================================================*/
{
	struct LIST(FE_field) *fe_field_list;
	struct LIST(FE_element_field) *element_field_list;
};

static int FE_element_field_copy_with_equivalent_field(
	struct FE_element_field *element_field, void *data_void)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Creates a copy of <element_field> using the same named field in <fe_field_list>
and adds it to <element_field_list>. Checks fields are equivalent.
<data_void> points at a struct FE_element_field_copy_with_equivalent_field_data.
==============================================================================*/
{
	int i, return_code;
	struct FE_field *equivalent_field;
	struct FE_element_field *copy_element_field;
	struct FE_element_field_copy_with_equivalent_field_data *data;
	struct FE_element_field_component **component, **copy_component;

	ENTER(FE_element_field_copy_with_equivalent_field);
	if (element_field && element_field->field && (data =
		(struct FE_element_field_copy_with_equivalent_field_data *)data_void))
	{
		return_code = 1;
		if (equivalent_field = FIND_BY_IDENTIFIER_IN_LIST(FE_field,name)(
			element_field->field->name, data->fe_field_list))
		{
			if (FE_fields_match_fundamental(element_field->field, equivalent_field))
			{
				if (copy_element_field = CREATE(FE_element_field)(equivalent_field))
				{
					component = element_field->components;
					copy_component = copy_element_field->components;
					for (i = get_FE_field_number_of_components(equivalent_field);
						(0 < i) && return_code; i--)
					{
						if (*component)
						{
							if (!(*copy_component =
								copy_create_FE_element_field_component(*component)))
							{
								return_code = 0;
							}
						}
						component++;
						copy_component++;
					}
					if (return_code)
					{
						if (!ADD_OBJECT_TO_LIST(FE_element_field)(copy_element_field,
							data->element_field_list))
						{
							return_code = 0;
						}
					}
					if (!return_code)
					{
						display_message(ERROR_MESSAGE,
							"FE_element_field_copy_with_equivalent_field.  "
							"Could not copy element field component");
						DESTROY(FE_element_field)(&copy_element_field);
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_element_field_copy_with_equivalent_field.  "
						"Could not create element field");
					return_code = 0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_copy_with_equivalent_field.  "
					"Fields not equivalent");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_copy_with_equivalent_field.  No equivalent field");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_copy_with_equivalent_field.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_copy_with_equivalent_field */

struct LIST(FE_element_field) *
	FE_element_field_list_clone_with_FE_field_list(
		struct LIST(FE_element_field) *element_field_list,
		struct LIST(FE_field) *fe_field_list)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Returns a new FE_element_field list that is identical to <element_field_list>
except that it references equivalent same-name fields from <fe_field_list>.
It is an error if an equivalent FE_field is not found.
==============================================================================*/
{
	struct LIST(FE_element_field) *return_element_field_list;
	struct FE_element_field_copy_with_equivalent_field_data data;

	ENTER(FE_element_field_list_clone_with_FE_field_list);
	return_element_field_list = (struct LIST(FE_element_field) *)NULL;
	if (element_field_list && fe_field_list)
	{
		data.fe_field_list = fe_field_list;
		data.element_field_list = CREATE(LIST(FE_element_field))();
		if (FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
			FE_element_field_copy_with_equivalent_field, (void *)&data,
			element_field_list))
		{
			return_element_field_list = data.element_field_list;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_list_clone_with_FE_field_list.  Failed");
			DESTROY(LIST(FE_element_field))(&data.element_field_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_list_clone_with_FE_field_list.  Invalid argument(s)");
	}
	LEAVE;

	return (return_element_field_list);
} /* FE_element_field_list_clone_with_FE_field_list */

struct FE_element_field_info *CREATE(FE_element_field_info)(
	struct FE_region *fe_region, 
	struct LIST(FE_element_field) *fe_element_field_list)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Creates a struct FE_element_field_info with a pointer to <fe_region> and a copy
of the <fe_element_field_list>.
Fails if more than one FE_element_field in the list references the same field.
If <fe_element_field_list> is omitted, an empty list is assumed.
Note:
This should only be called by FE_region functions, and the FE_region must be
its own master. The returned object is added to the list of
FE_element_field_info in the FE_region and is therefore owned by the FE_region.
It maintains a non-ACCESSed pointer to its owning FE_region which the FE_region
will clear before it is destroyed. If it becomes necessary to have other owners
of these objects, the common parts of it and FE_region should be extracted to a
common object.
==============================================================================*/
{
	struct FE_element_field_info *fe_element_field_info;

	ENTER(CREATE(FE_element_field_info));
	fe_element_field_info = (struct FE_element_field_info *)NULL;
	if (fe_region)
	{
		if (ALLOCATE(fe_element_field_info, struct FE_element_field_info, 1))
		{						
			fe_element_field_info->element_field_list =
				CREATE(LIST(FE_element_field)());
			/* maintain pointer to the the FE_region this information belongs to.
				 It is not ACCESSed since FE_region is the owning object and it
				 would prevent the FE_region from being destroyed. */
			fe_element_field_info->fe_region = fe_region;
			fe_element_field_info->access_count = 0;

			if (!(fe_element_field_info->element_field_list &&
				((!fe_element_field_list) ||
					FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
						FE_element_field_add_to_list_no_field_duplication,
						(void *)fe_element_field_info->element_field_list,
						fe_element_field_list))))
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_element_field_info).  Unable to build element field list");
				DESTROY(FE_element_field_info)(&fe_element_field_info);
				fe_element_field_info = (struct FE_element_field_info *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_element_field_info).  Not enough memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field_info).  Invalid argument(s)");
	}
	LEAVE;

	return (fe_element_field_info);
} /* CREATE(FE_element_field_info) */

int DESTROY(FE_element_field_info)(
	struct FE_element_field_info **fe_element_field_info_address)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Destroys the FE_element_field_info at *<element_field_info_address>. Frees the
memory for the information and sets <*element_field_info_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_info *fe_element_field_info;

	ENTER(DESTROY(FE_element_field_info));
	if ((fe_element_field_info_address) &&
		(fe_element_field_info = *fe_element_field_info_address))
	{
		if (0 == fe_element_field_info->access_count)
		{	
			DESTROY(LIST(FE_element_field))(
				&(fe_element_field_info->element_field_list));
			DEALLOCATE(*fe_element_field_info_address);
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_element_field_info).  Non-zero access count");
			return_code = 0;
		}
		*fe_element_field_info_address = (struct FE_element_field_info *)NULL;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(FE_element_field_info).  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field_info) */

DECLARE_ACCESS_OBJECT_FUNCTION(FE_element_field_info)

PROTOTYPE_DEACCESS_OBJECT_FUNCTION(FE_element_field_info)
/*******************************************************************************
LAST MODIFIED : 29 January 2003

DESCRIPTION :
Special version of DEACCESS which if the FE_element_field_info access_count
reaches 1 and it has an fe_region member, calls
FE_region_remove_FE_element_field_info.
Since the FE_region accesses the info once, this indicates no other object is
using it so it should be flushed from the FE_region. When the owning FE_region
deaccesses the info, it is destroyed in this function.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_info *object;

	ENTER(DEACCESS(FE_element_field_info));
	if (object_address && (object = *object_address))
	{
		(object->access_count)--;
		return_code = 1;
		if (object->access_count <= 1)
		{
			if (1 == object->access_count)
			{
				if (object->fe_region)
				{
					return_code =
						FE_region_remove_FE_element_field_info(object->fe_region, object);
				}
			}
			else
			{
				return_code = DESTROY(FE_element_field_info)(object_address);
			}
		}
		*object_address = (struct FE_element_field_info *)NULL;
	}
	else
	{
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DEACCESS(FE_element_field_info) */

PROTOTYPE_REACCESS_OBJECT_FUNCTION(FE_element_field_info)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Special version of REACCESS which if the FE_element_field_info access_count
reaches 1 and it has an fe_region member, calls
FE_region_remove_FE_element_field_info.
Since the FE_region accesses the info once, this indicates no other object is
using it so it should be flushed from the FE_region. When the owning FE_region
deaccesses the info, it is destroyed in this function.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_info *current_object;

	ENTER(REACCESS(FE_element_field_info));
	if (object_address)
	{
		return_code = 1;
		if (new_object)
		{
			/* access the new object */
			(new_object->access_count)++;
		}
		if (current_object = *object_address)
		{
			/* deaccess the current object */
			(current_object->access_count)--;
			if (current_object->access_count <= 1)
			{
				if (1 == current_object->access_count)
				{
					if (current_object->fe_region)
					{
						return_code = FE_region_remove_FE_element_field_info(
							current_object->fe_region, current_object);
					}
				}
				else
				{
					return_code = DESTROY(FE_element_field_info)(object_address);
				}
			}
		}
		/* point to the new object */
		*object_address = new_object;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"REACCESS(FE_element_field_info).  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* REACCESS(FE_element_field_info) */

DECLARE_LIST_FUNCTIONS(FE_element_field_info)

int FE_element_field_info_clear_FE_region(
	struct FE_element_field_info *element_field_info, void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Clears the pointer to FE_region in <element_field_info>.
Private function only to be called by destroy_FE_region.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_info_clear_FE_region);
	USE_PARAMETER(dummy_void);
	if (element_field_info)
	{
		element_field_info->fe_region = (struct FE_region *)NULL;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_info_clear_FE_region.  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_info_clear_FE_region */

int FE_element_field_info_has_FE_field(
	struct FE_element_field_info *element_field_info, void *fe_field_void)
/*******************************************************************************
LAST MODIFIED : 4 March 2003

DESCRIPTION :
Returns true if <element_field_info> has an element field for <fe_field>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_info_has_FE_field);
	if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
		(struct FE_field *)fe_field_void, element_field_info->element_field_list))
	{
		return_code = 1;
	}
	else
	{
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_info_has_FE_field */

int FE_element_field_info_has_empty_FE_element_field_list(
	struct FE_element_field_info *element_field_info, void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Returns true if <element_field_info> has no element fields.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_info_has_empty_FE_element_field_list);
	USE_PARAMETER(dummy_void);
	if (element_field_info)
	{
		if (0 == NUMBER_IN_LIST(FE_element_field)(
			element_field_info->element_field_list))
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_info_has_empty_FE_element_field_list.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_info_has_empty_FE_element_field_list */

int FE_element_field_info_has_matching_FE_element_field_list(
	struct FE_element_field_info *element_field_info,
	void *element_field_list_void)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Returns true if <element_field_info> has a FE_element_field_list containing all
the same FE_element_fields as <element_field_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element_field) *element_field_list;

	ENTER(FE_element_field_info_has_matching_FE_element_field_list);
	if (element_field_info && (element_field_list =
		(struct LIST(FE_element_field) *)element_field_list_void))
	{
		if ((NUMBER_IN_LIST(FE_element_field)(element_field_list) ==
			NUMBER_IN_LIST(FE_element_field)(element_field_info->element_field_list)))
		{
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
				FE_element_field_not_in_list,
				(void *)(element_field_info->element_field_list),
				element_field_list))
			{
				return_code = 0;
			}
			else
			{
				return_code = 1;
			}
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_info_has_matching_FE_element_field_list.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_info_has_matching_FE_element_field_list */

struct LIST(FE_element_field) *FE_element_field_info_get_element_field_list(
	struct FE_element_field_info *fe_element_field_info)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Returns the element field list contained in the <element_field_info>.
==============================================================================*/
{
	struct LIST(FE_element_field) *element_field_list;

	ENTER(FE_element_field_info_get_element_field_list);
	if (fe_element_field_info)
	{
		element_field_list = fe_element_field_info->element_field_list;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_info_get_element_field_list.  Invalid argument(s)");
		element_field_list = (struct LIST(FE_element_field) *)NULL;
	}
	LEAVE;

	return (element_field_list);
} /* FE_element_field_info_get_element_field_list */

static int FE_element_field_log_FE_field_change(
	struct FE_element_field *element_field, void *fe_field_change_log_void)
/*******************************************************************************
LAST MODIFIED : 17 February 2003

DESCRIPTION :
Logs the field in <element_field> as RELATED_OBJECT_CHANGED
in <fe_field_change_log>.
==============================================================================*/
{
	int return_code;
	struct CHANGE_LOG(FE_field) *fe_field_change_log;

	ENTER(FE_element_field_log_FE_field_change);
	if (element_field && (fe_field_change_log =
		(struct CHANGE_LOG(FE_field) *)fe_field_change_log_void))
	{
		return_code = CHANGE_LOG_OBJECT_CHANGE(FE_field)(fe_field_change_log,
			element_field->field, CHANGE_LOG_RELATED_OBJECT_CHANGED(FE_field));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_log_FE_field_change.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_log_FE_field_change */

int FE_element_field_info_log_FE_field_changes(
	struct FE_element_field_info *fe_element_field_info,
	struct CHANGE_LOG(FE_field) *fe_field_change_log)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Marks each FE_field in <fe_element_field_info> as RELATED_OBJECT_CHANGED
in <fe_field_change_log>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_info_log_FE_field_changes);
	if (fe_element_field_info && fe_field_change_log)
	{
		return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
			FE_element_field_log_FE_field_change, (void *)fe_field_change_log,
			fe_element_field_info->element_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_info_log_FE_field_changes.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_info_log_FE_field_changes */

struct FE_element_field_copy_values_storage_data
{
	int dimension;
	Value_storage *new_values_storage;
	struct LIST(FE_element_field) *old_element_field_list;
	Value_storage *old_values_storage;
	struct LIST(FE_element_field) *add_element_field_list;
	Value_storage *add_values_storage;
}; /* FE_element_field_copy_values_storage_data */

static int FE_element_field_copy_values_storage(
	struct FE_element_field *new_element_field,	void *copy_data_void)
/*******************************************************************************
LAST MODIFIED : 6 May 2003

DESCRIPTION :
If <new_element_field> uses values storage then:

... when <add_element_field_list> and <add_values_storage> provided:
Finds the equivalent element field in the <old_element_field_list> or
<add_element_field_list>, and copies values giving precedence to the latter.
If the element fields have times, the time arrays are allocated once, then the
old values are copied followed by the add values to correctly mere the times.

... when <add_element_field_list> and <add_values_storage> not provided:
Copies the values for <new_element_field> into <new_values_storage> from the
<old_values_storage> with the equivalent element field in
<old_element_field_list>.

Notes:
Assumes <new_values_storage> is already allocated to the appropriate size.
Assumes the only differences between equivalent element fields are in time
version; no checks on this are made here.
<copy_data_void> points at a struct FE_element_field_copy_values_storage_data.

???RC Ignore references to times in the above since not yet implemented; once
they are, should follow pattern of FE_node_field_copy_values_storage.
==============================================================================*/
{	
 	enum Value_type value_type;
	int i, *number_in_xi, number_of_values, return_code;
	struct FE_field *field;
	struct FE_element_field *add_element_field, *old_element_field;
	struct FE_element_field_component *add_component, *component, *old_component;
	struct FE_element_field_copy_values_storage_data *copy_data;
	Value_storage *destination, *source;

	ENTER(FE_element_field_copy_values_storage);
	if (new_element_field && (field = new_element_field->field) &&
		((GENERAL_FE_FIELD != field->fe_field_type) ||
			(new_element_field->components &&
				(component = *(new_element_field->components)))) &&
		(copy_data =
			(struct FE_element_field_copy_values_storage_data *)copy_data_void))
	{
		return_code = 1;
		/* only GENERAL_FE_FIELD with ELEMENT_GRID_MAP has element values */
		if ((GENERAL_FE_FIELD == field->fe_field_type) &&
			(ELEMENT_GRID_MAP == component->type))
		{
			old_element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				field, copy_data->old_element_field_list);
			if (copy_data->add_element_field_list)
			{
				add_element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
					field, copy_data->add_element_field_list);
			}
			else
			{
				add_element_field = (struct FE_element_field *)NULL;
			}
			if (old_element_field || add_element_field)
			{
				if (copy_data->new_values_storage)
				{
					/* destination in new_values_storage according to new_element_field */
					destination = copy_data->new_values_storage +
						component->map.element_grid_based.value_index;
					value_type = field->value_type;
					/* assume number of values for components are equal and consecutive */
					number_in_xi = component->map.element_grid_based.number_in_xi;
					number_of_values = get_FE_field_number_of_components(field);
					for (i = 0; i < copy_data->dimension; i++)
					{
						number_of_values *= (number_in_xi[i] + 1);
					}
					if (add_element_field)
					{
						if (copy_data->add_values_storage &&
							add_element_field->components &&
							(add_component = *(add_element_field->components)))
						{
							/* source in add_values_storage according to add_element_field */
							source = copy_data->add_values_storage +
								add_component->map.element_grid_based.value_index;
							return_code = copy_value_storage_array(destination, value_type,
								(struct FE_time_sequence *)NULL, (struct FE_time_sequence *)NULL,
								number_of_values, source);
						}
						else
						{
							return_code = 0;
						}
					}
					else
					{
						if (copy_data->old_values_storage &&
							old_element_field->components &&
							(old_component = *(old_element_field->components)))
						{
							/* source in old_values_storage according to old_element_field */
							source = copy_data->old_values_storage +
								old_component->map.element_grid_based.value_index;
							return_code = copy_value_storage_array(destination, value_type,
								(struct FE_time_sequence *)NULL, (struct FE_time_sequence *)NULL,
								number_of_values, source);
						}
						else
						{
							return_code = 0;
						}
					}
				}
				else
				{
					return_code = 0;
				}
				if (!return_code)
				{
					display_message(ERROR_MESSAGE,
						"FE_element_field_copy_values_storage.  Unable to copy values");
					return_code = 0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE, "FE_element_field_copy_values_storage.  "
					"Could not find equivalent existing element field");
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_copy_values_storage.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_copy_values_storage */

static int copy_FE_element_values_storage(struct FE_element *element,
	Value_storage *values_storage,
	struct LIST(FE_element_field) *new_element_field_list,
	struct FE_element *add_element)
/*******************************************************************************
LAST MODIFIED: 4 November 2002

DESCRIPTION:
For each field in <new_element_field_list> requiring values storage, finds the
equivalent element field in either <element>, <add_element> or both. If only one
of <element> or <add_element> contains an equivalent element field, those values
are copied. If there is an equivalent element field in both, behaviour depends
on whether the element fields have times:
* if the element fields have no times, values are taken from <add_element>.
* if the element fields have times, the times arrays are allocated, then the
values at times in <element> are copied, followed by those in <add_element>.
Hence, the values in <add_element> take preference over those in <element>.
Notes:
* must be an equivalent element field at either <element> or <add_element>;
* <add_element> is optional and used only buy merge_FE_element. If NULL then an
element field must be found in <element>;
* Values_storage must already be allocated to the appropriate size but is not
assumed to contain any information prior to being filled here;
* Any objects or arrays referenced in the values_storage are accessed or
allocated in the new <values_storage> so <element> and <add_element> are
unchanged.
* It is up to the calling function to have checked that the element fields in
<element>, <add_element> and <new_element_field_list> are compatible.
???RC Ignore references to times in the above since not yet implemented; once
they are, should follow pattern of merge_FE_node_values_storage.
==============================================================================*/
{
	int dimension, return_code;
	struct FE_element_field_copy_values_storage_data copy_data;

	ENTER(copy_FE_element_values_storage);
	if (element && (dimension = get_FE_element_dimension(element)) &&
		element->fields && new_element_field_list &&
		((!add_element) || (add_element->fields &&
			(get_FE_element_dimension(add_element) == dimension))))
	{
		copy_data.dimension = dimension;
		copy_data.new_values_storage = values_storage;
		copy_data.old_element_field_list = element->fields->element_field_list;
		if (element->information)
		{
			copy_data.old_values_storage = element->information->values_storage;
		}
		else
		{
			copy_data.old_values_storage = (Value_storage *)NULL;
		}
		if (add_element)
		{
			copy_data.add_element_field_list =
				add_element->fields->element_field_list;
			if (add_element->information)
			{
				copy_data.add_values_storage = add_element->information->values_storage;
			}
			else
			{
				copy_data.add_values_storage = (Value_storage *)NULL;
			}
		}
		else
		{
			copy_data.add_element_field_list = (struct LIST(FE_element_field) *)NULL;
			copy_data.add_values_storage = (Value_storage *)NULL;
		}
		return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
			FE_element_field_copy_values_storage, (void *)(&copy_data),
			new_element_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_FE_element_values_storage.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;
	
	return (return_code);
} /* copy_FE_element_values_storage */

static struct FE_element_node_scale_field_info
	*CREATE(FE_element_node_scale_field_info)(void)
/*******************************************************************************
LAST MODIFIED : 30 October 2002

DESCRIPTION :
Creates a blank FE_element_node_scale_field_info.
Static constructor to be called by specialised constructors.
==============================================================================*/
{
	struct FE_element_node_scale_field_info *node_scale_field_info;

	ENTER(CREATE(FE_element_node_scale_field_info));
	if (ALLOCATE(node_scale_field_info,
		struct FE_element_node_scale_field_info, 1))
	{
		node_scale_field_info->values_storage_size = 0;
		node_scale_field_info->values_storage = (Value_storage *)NULL;
		node_scale_field_info->number_of_nodes = 0;
		node_scale_field_info->nodes = (struct FE_node **)NULL;
		node_scale_field_info->number_of_scale_factor_sets = 0;
		node_scale_field_info->scale_factor_set_identifiers = (void **)NULL;
		node_scale_field_info->numbers_in_scale_factor_sets = (int *)NULL;
		node_scale_field_info->number_of_scale_factors = 0;
		node_scale_field_info->scale_factors = (FE_value *)NULL;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_node_scale_field_info).  "
			"Could not allocate structure");
	}
	LEAVE;

	return (node_scale_field_info);
} /* CREATE(FE_element_node_scale_field_info) */

static int FE_element_node_scale_field_info_set_number_of_nodes(
	struct FE_element_node_scale_field_info *element_node_scale_field_info,
	int number_of_nodes)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
==============================================================================*/
{
	int i, return_code;

	ENTER(FE_element_node_scale_field_info_set_number_of_nodes);
	if (element_node_scale_field_info && (0 <= number_of_nodes))
	{
		if (element_node_scale_field_info->nodes)
		{
			display_message(ERROR_MESSAGE,
				"FE_element_node_scale_field_info_set_number_of_nodes.  "
				"Number of nodes is already set");
			return_code = 0;
		}
		else
		{
			if (0 < number_of_nodes)
			{
				if (ALLOCATE(element_node_scale_field_info->nodes, struct FE_node *,
					number_of_nodes))
				{
					for (i = 0; i < number_of_nodes; i++)
					{
						element_node_scale_field_info->nodes[i] = (struct FE_node *)NULL;
					}
					element_node_scale_field_info->number_of_nodes = number_of_nodes;
					return_code = 1;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_element_node_scale_field_info_set_number_of_nodes.  "
						"Could not allocate space for nodes");
					return_code = 0;
				}
			}
			else
			{
				return_code = 1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_node_scale_field_info_set_number_of_nodes.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_node_scale_field_info_set_number_of_nodes */

static int FE_element_node_scale_field_info_set_node(
	struct FE_element_node_scale_field_info *element_node_scale_field_info,
	int node_number, struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 13 May 2003

DESCRIPTION :
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_node_scale_field_info_set_node);
	if (element_node_scale_field_info &&
		element_node_scale_field_info->nodes && (0 <= node_number) &&
		(node_number < element_node_scale_field_info->number_of_nodes))
	{
		return_code = REACCESS(FE_node)(
			&(element_node_scale_field_info->nodes[node_number]), node);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_node_scale_field_info_set_node.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_node_scale_field_info_set_node */

int DESTROY(FE_element_node_scale_field_info)(
	struct FE_element_node_scale_field_info
	**element_node_scale_field_info_address)
/*******************************************************************************
LAST MODIFIED : 13 May 2003

DESCRIPTION :
Frees the memory for the node, scale and field information and sets
<*element_node_scale_field_info_address> to NULL.
Note that this function is unable to clean up any dynamic values stored within
the values_storage; call clean_up_FE_element_node_scale_field_info if there is
values_storage allocated.
==============================================================================*/
{
	int i, return_code;
	struct FE_element_node_scale_field_info *node_scale_field_info;
	struct FE_node **node;

	ENTER(DESTROY(FE_element_node_scale_field_info));
	if ((element_node_scale_field_info_address) &&
		(node_scale_field_info = *element_node_scale_field_info_address))
	{
		/* free values_storage for grid-based fields, if any */
		if (node_scale_field_info->values_storage)
		{
			DEALLOCATE(node_scale_field_info->values_storage);
		}
		i = node_scale_field_info->number_of_nodes;
		node = node_scale_field_info->nodes;
		while (i > 0)
		{
			if (*node)
			{
				DEACCESS(FE_node)(node);
			}
			node++;
			i--;
		}
		DEALLOCATE(node_scale_field_info->nodes);
		DEALLOCATE(node_scale_field_info->scale_factor_set_identifiers);
		DEALLOCATE(node_scale_field_info->numbers_in_scale_factor_sets);
		DEALLOCATE(node_scale_field_info->scale_factors);
		DEALLOCATE(*element_node_scale_field_info_address);
		*element_node_scale_field_info_address =
			(struct FE_element_node_scale_field_info *)NULL;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(FE_element_node_scale_field_info).  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_node_scale_field_info) */

static int free_element_grid_map_values_storage(
	struct FE_element_field *element_field, void *values_storage_void)
/*******************************************************************************
LAST MODIFIED : 18 October 1999

DESCRIPTION :
If the <element_field> is grid based, finds where the values for its components
are stored in <values_storage> and frees any accesses and dynamic allocations
in them. Only certain value types, eg. arrays, strings, element_xi require this.
==============================================================================*/
{
 	enum Value_type value_type;
	int i,j,*number_in_xi,number_of_values,return_code,value_index;
	struct FE_element_field_component **component;
	Value_storage *values_storage;

	ENTER(free_element_grid_map_values_storage);
	if (element_field&&element_field->field&&
		(values_storage=(Value_storage *)values_storage_void))
	{
		return_code=1;
		/* only GENERAL_FE_FIELD has components and can be grid-based */
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			value_type = element_field->field->value_type;
			component=element_field->components;
			for (i=element_field->field->number_of_components;(0<i)&&return_code;i--)
			{
				if (ELEMENT_GRID_MAP==(*component)->type)
				{
					number_in_xi=((*component)->map).element_grid_based.number_in_xi;
					number_of_values=1;
					for (j=((*component)->basis->type)[0];j>0;j--)
					{
						number_of_values *= (*number_in_xi)+1;
						number_in_xi++;
					}
					value_index=((*component)->map).element_grid_based.value_index;
					return_code=free_value_storage_array(
						values_storage+value_index,value_type,
						(struct FE_time_sequence *)NULL,number_of_values);
				}
				component++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"free_element_grid_map_values_storage.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* free_element_grid_map_values_storage */

int clean_up_FE_element_node_scale_field_info(
	struct FE_element_node_scale_field_info
	**element_node_scale_field_info_address,
	struct FE_element_field_info *element_field_info)
/*******************************************************************************
LAST MODIFIED : 4 November 2002

DESCRIPTION :
Frees the memory for the node, scale and field information and sets
<*element_node_scale_field_info_address> to NULL.
Cleans up any dynamic allocations in the values_storage described in
<element_field_info> then calls destroy_FE_element_node_scale_field_info.
==============================================================================*/
{
	int return_code;
	struct FE_element_node_scale_field_info *node_scale_field_info;

	ENTER(clean_up_FE_element_node_scale_field_info);
	if ((element_node_scale_field_info_address) &&
		(node_scale_field_info= *element_node_scale_field_info_address) &&
		element_field_info)
	{
		/* free values_storage for grid-based fields, if any */
		if (node_scale_field_info->values_storage)
		{
			FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				free_element_grid_map_values_storage,
				(void *)node_scale_field_info->values_storage,
				element_field_info->element_field_list);
		}
		return_code = DESTROY(FE_element_node_scale_field_info)(
			element_node_scale_field_info_address);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"clean_up_FE_element_node_scale_field_info.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* clean_up_FE_element_node_scale_field_info */

static struct FE_element_node_scale_field_info
	*copy_create_FE_element_node_scale_field_info(
		struct FE_element_node_scale_field_info *source_info)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Static function used exclusively in merge_FE_element.
Creates a copy of <source_info> except that values_storage_size and
values_storage are set to zero and NULL, respectively.
==============================================================================*/
{
	int i, number_of_nodes, number_of_scale_factor_sets, number_of_scale_factors,
		return_code;
	struct FE_element_node_scale_field_info *node_scale_field_info;

	ENTER(copy_create_FE_element_node_scale_field_info);
	node_scale_field_info = (struct FE_element_node_scale_field_info *)NULL;
	if (source_info)
	{
		if (node_scale_field_info = CREATE(FE_element_node_scale_field_info)())
		{
			number_of_nodes = source_info->number_of_nodes;
			if (FE_element_node_scale_field_info_set_number_of_nodes(
				node_scale_field_info, number_of_nodes))
			{
				for (i = 0; i < number_of_nodes; i++)
				{
					FE_element_node_scale_field_info_set_node(
						node_scale_field_info, i, source_info->nodes[i]);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"copy_create_FE_element_node_scale_field_info.  "
					"Could not allocate nodes");
				return_code = 0;
			}
			number_of_scale_factor_sets = source_info->number_of_scale_factor_sets;
			number_of_scale_factors = source_info->number_of_scale_factors;
			if (0 < number_of_scale_factor_sets)
			{
				if (ALLOCATE(node_scale_field_info->scale_factor_set_identifiers,
					void *, number_of_scale_factor_sets) &&
					ALLOCATE(node_scale_field_info->numbers_in_scale_factor_sets, int,
						number_of_scale_factor_sets) &&
					((0 == number_of_scale_factors) ||
						ALLOCATE(node_scale_field_info->scale_factors, FE_value,
							number_of_scale_factors)))
				{
					/* copy the scale factor sets */
					for (i = 0; i < number_of_scale_factor_sets; i++)
					{
						node_scale_field_info->scale_factor_set_identifiers[i] =
							source_info->scale_factor_set_identifiers[i];
						node_scale_field_info->numbers_in_scale_factor_sets[i] =
							source_info->numbers_in_scale_factor_sets[i];
					}
					/* copy the scale factors */
					if (0 < number_of_scale_factors)
					{
						memcpy(node_scale_field_info->scale_factors,
							source_info->scale_factors,
							number_of_scale_factors*sizeof(FE_value));
					}
					node_scale_field_info->number_of_scale_factor_sets =
						number_of_scale_factor_sets;
					node_scale_field_info->number_of_scale_factors =
						number_of_scale_factors;
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"copy_create_FE_element_node_scale_field_info.  "
						"Could not allocate scale factor sets");
					return_code = 0;
				}
			}
			if (!return_code)
			{
				DESTROY(FE_element_node_scale_field_info)(&node_scale_field_info);
				node_scale_field_info =
					(struct FE_element_node_scale_field_info *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"copy_create_FE_element_node_scale_field_info.  Could not create info");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_create_FE_element_node_scale_field_info.  Invalid argument(s)");
	}
	LEAVE;

	return (node_scale_field_info);
} /* copy_create_FE_element_node_scale_field_info */

static struct FE_element_node_scale_field_info
	*merge_create_FE_element_node_scale_field_info(
		struct FE_element_node_scale_field_info *destination_info,
		struct FE_element_node_scale_field_info *source_info,
		int *number_of_changed_existing_scale_factor_sets_address,
		void ***changed_existing_scale_factor_set_identifiers_address)
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
Static function used exclusively in merge_FE_element.
Creates a new FE_element_node_scale_field_info that contains all the nodes and
scale factors from <destination_info> and in the same sequence, plus any new
ones added from <source_info>. Checks that the same number of scale factors are
used for any scale factor sets in common.
values_storage_size and values_storage are set to zero and NULL, respectively,
under the expectation that they will be constructed by merge_FE_element.
On successful return there will be a non-negative number placed in
<number_of_changed_existing_scale_factor_sets_address> and a correspondingly
sized allocated array of void* identifiers placed at
<changed_existing_scale_factor_set_identifiers_address>.
It is up to the calling function to propagate appropriate change messages for
all fields using these scale factors sets, and to DEALLOCATE the returned array.
Note 0 and NULL are legal return values for the last two arguments.
On a failed return no such array is allocated and returned.
==============================================================================*/
{
	FE_value *scale_factor_position, *source_scale_factor_position;
	int copy_scale_factors, destination_number_of_nodes,
		destination_number_of_scale_factor_sets,
		destination_number_of_scale_factors, i, j, number_of_nodes,
		number_of_scale_factor_sets, number_of_scale_factors, return_code,
		source_number_in_scale_factor_set, source_number_of_nodes,
		source_number_of_scale_factor_sets, *tmp_numbers_in_scale_factors_sets;
	struct FE_element_node_scale_field_info *node_scale_field_info;
	struct FE_node *node, **tmp_node;
	void *scale_factor_set_identifier, **tmp_scale_factor_set_identifier,
		**changed_existing_scale_factor_set_identifiers;

	ENTER(merge_create_FE_element_node_scale_field_info);
	node_scale_field_info = (struct FE_element_node_scale_field_info *)NULL;
	if (destination_info && source_info &&
		number_of_changed_existing_scale_factor_sets_address &&
		changed_existing_scale_factor_set_identifiers_address)
	{
		*number_of_changed_existing_scale_factor_sets_address = 0;
		*changed_existing_scale_factor_set_identifiers_address = (void **)NULL;
		return_code = 1;
		/* get the total number of nodes, starting with those in destination_info */
		destination_number_of_nodes = destination_info->number_of_nodes;
		source_number_of_nodes = source_info->number_of_nodes;
		number_of_nodes = destination_number_of_nodes;
		for (i = 0; i < source_number_of_nodes; i++)
		{
			node = source_info->nodes[i];
			tmp_node = destination_info->nodes;
			j = destination_number_of_nodes;
			while (j && (node != *tmp_node))
			{
				tmp_node++;
				j--;
			}
			if (!j)
			{
				number_of_nodes++;
			}
		}
		/* get the total number of scale factor sets and scale factors, starting
			 with those in destination_info. Checks numbers_in_scale_factor_sets */
		destination_number_of_scale_factor_sets =
			destination_info->number_of_scale_factor_sets;
		source_number_of_scale_factor_sets =
			source_info->number_of_scale_factor_sets;
		number_of_scale_factor_sets = destination_number_of_scale_factor_sets;
		destination_number_of_scale_factors =
			destination_info->number_of_scale_factors;
		number_of_scale_factors = destination_number_of_scale_factors;
		for (i = 0; i < source_number_of_scale_factor_sets; i++)
		{
			scale_factor_set_identifier =
				source_info->scale_factor_set_identifiers[i];
			tmp_scale_factor_set_identifier =
				destination_info->scale_factor_set_identifiers;
			j = destination_number_of_scale_factor_sets;
			while (j && (scale_factor_set_identifier !=
				*tmp_scale_factor_set_identifier))
			{
				tmp_scale_factor_set_identifier++;
				j--;
			}
			if (j)
			{
				if (destination_info->numbers_in_scale_factor_sets
					[destination_number_of_scale_factor_sets - j] !=
					source_info->numbers_in_scale_factor_sets[i])
				{
					display_message(ERROR_MESSAGE,
						"merge_create_FE_element_node_scale_field_info.  "
						"Incompatability in scale factor set");
					return_code = 0;
				}
			}
			else
			{
				number_of_scale_factor_sets++;
				number_of_scale_factors += source_info->numbers_in_scale_factor_sets[i];
			}
		}
		if (return_code)
		{
			if (node_scale_field_info = CREATE(FE_element_node_scale_field_info)())
			{
				if (FE_element_node_scale_field_info_set_number_of_nodes(
					node_scale_field_info, number_of_nodes))
				{
					for (j = 0; j < destination_number_of_nodes; j++)
					{
						FE_element_node_scale_field_info_set_node(
							node_scale_field_info, j, destination_info->nodes[j]);
					}
					if (destination_number_of_nodes < number_of_nodes)
					{
						/* extract the new nodes from the source */
						number_of_nodes = destination_number_of_nodes;
						for (i = 0; i < source_number_of_nodes; i++)
						{
							node = source_info->nodes[i];
							tmp_node = destination_info->nodes;
							j = destination_number_of_nodes;
							while (j && (node != *tmp_node))
							{
								tmp_node++;
								j--;
							}
							if (!j)
							{
								FE_element_node_scale_field_info_set_node(
									node_scale_field_info, number_of_nodes, node);
								number_of_nodes++;
							}
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"merge_create_FE_element_node_scale_field_info.  "
						"Could not set number of nodes");
					return_code = 0;
				}
				if (0 < number_of_scale_factor_sets)
				{
					if (ALLOCATE(node_scale_field_info->scale_factor_set_identifiers,
						void *, number_of_scale_factor_sets) &&
						ALLOCATE(node_scale_field_info->numbers_in_scale_factor_sets, int,
							number_of_scale_factor_sets) &&
						((0 == number_of_scale_factors) ||
							ALLOCATE(node_scale_field_info->scale_factors, FE_value,
								number_of_scale_factors)))
					{
						/* copy the scale factor sets from destination_info */
						for (j = 0; j < destination_number_of_scale_factor_sets; j++)
						{
							node_scale_field_info->scale_factor_set_identifiers[j] =
								destination_info->scale_factor_set_identifiers[j];
							node_scale_field_info->numbers_in_scale_factor_sets[j] =
								destination_info->numbers_in_scale_factor_sets[j];
						}
						/* copy the scale factors from destination_info, even though many
							 will be overwritten by matching sets from source_info */
						if (0 < destination_number_of_scale_factors)
						{
							memcpy(node_scale_field_info->scale_factors,
								destination_info->scale_factors,
								destination_number_of_scale_factors*sizeof(FE_value));
						}
						/* incorporate new scale factor sets from source_info.
							 Compare old and new scale factors for existing sets and if
							 changing, use values from the source_info and remember the
							 scale factor set identifier */
						number_of_scale_factor_sets =
							destination_number_of_scale_factor_sets;
						number_of_scale_factors = destination_number_of_scale_factors;
						source_scale_factor_position = source_info->scale_factors;
						for (i = 0; i < source_number_of_scale_factor_sets; i++)
						{
							scale_factor_set_identifier =
								source_info->scale_factor_set_identifiers[i];
							tmp_scale_factor_set_identifier =
								node_scale_field_info->scale_factor_set_identifiers;
							tmp_numbers_in_scale_factors_sets =
								node_scale_field_info->numbers_in_scale_factor_sets;
							source_number_in_scale_factor_set =
								source_info->numbers_in_scale_factor_sets[i];
							scale_factor_position = node_scale_field_info->scale_factors;
							j = destination_number_of_scale_factor_sets;
							while (j && (scale_factor_set_identifier !=
								*tmp_scale_factor_set_identifier))
							{
								scale_factor_position += *tmp_numbers_in_scale_factors_sets;
								tmp_numbers_in_scale_factors_sets++;
								tmp_scale_factor_set_identifier++;
								j--;
							}
							copy_scale_factors = (0 < source_number_in_scale_factor_set);
							if (j)
							{
								if (0 < source_number_in_scale_factor_set)
								{
									/* scale factors only transfered if different if changed */
									if (memcmp(scale_factor_position,
										source_scale_factor_position,
										source_number_in_scale_factor_set*sizeof(FE_value)))
									{
										/* remember ID of changed scale factor set so all fields
											 using it can be noted as changed -- not just those
											 defined on the element using source_info */
										if (REALLOCATE(changed_existing_scale_factor_set_identifiers,
											*changed_existing_scale_factor_set_identifiers_address,
											void *,
											*number_of_changed_existing_scale_factor_sets_address + 1))
										{
											changed_existing_scale_factor_set_identifiers[
												*number_of_changed_existing_scale_factor_sets_address]
												= scale_factor_set_identifier;
											*changed_existing_scale_factor_set_identifiers_address =
												changed_existing_scale_factor_set_identifiers;
											(*number_of_changed_existing_scale_factor_sets_address)++;
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"merge_create_FE_element_node_scale_field_info.  Could not "
												"reallocate changed existing scale factor set identifiers");
											return_code = 0;
										}
									}
									else
									{
										copy_scale_factors = 0;
									}
								}
							}
							else
							{
								/* position for new scale factors must be at the end of
									 the currently set list */
								scale_factor_position = node_scale_field_info->scale_factors +
									number_of_scale_factors;
								node_scale_field_info->scale_factor_set_identifiers
									[number_of_scale_factor_sets] = scale_factor_set_identifier;
								node_scale_field_info->numbers_in_scale_factor_sets
									[number_of_scale_factor_sets] =
									source_number_in_scale_factor_set;
								number_of_scale_factor_sets++;
								number_of_scale_factors +=
									source_number_in_scale_factor_set;
							}
							/* copy scale factors from source_info */
							if (copy_scale_factors)
							{
								memcpy(scale_factor_position, source_scale_factor_position,
									source_number_in_scale_factor_set*sizeof(FE_value));
							}
							source_scale_factor_position +=
								source_number_in_scale_factor_set;
						}
						node_scale_field_info->number_of_scale_factor_sets =
							number_of_scale_factor_sets;
						node_scale_field_info->number_of_scale_factors =
							number_of_scale_factors;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"merge_create_FE_element_node_scale_field_info.  "
							"Could not allocate scale factor sets");
						return_code = 0;
					}
				}
				if (!return_code)
				{
					DESTROY(FE_element_node_scale_field_info)(&node_scale_field_info);
					node_scale_field_info =
						(struct FE_element_node_scale_field_info *)NULL;
					if (*changed_existing_scale_factor_set_identifiers)
					{
						/* on failure, caller does not need to deallocate identifiers */
						DEALLOCATE(*changed_existing_scale_factor_set_identifiers);
						*changed_existing_scale_factor_set_identifiers = (void **)NULL;
						*number_of_changed_existing_scale_factor_sets_address = 0;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"merge_create_FE_element_node_scale_field_info.  "
					"Could not create info");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"merge_create_FE_element_node_scale_field_info.  Invalid argument(s)");
	}
	LEAVE;

	return (node_scale_field_info);
} /* merge_create_FE_element_node_scale_field_info */

struct Copy_element_grid_map_data
{
	Value_storage *destination_values_storage,*source_values_storage;
}; /* struct Copy_element_grid_map_data */

static int copy_element_grid_map_values_storage(
	struct FE_element_field *element_field,void *copy_element_grid_map_data_void)
/*******************************************************************************
LAST MODIFIED : 18 October 1999

DESCRIPTION :
If the <element_field> is grid based, finds where the values for its components
are stored in <source_values_storage> and copies them to the same location in
<destination_values_storage>. Assumes <destination_values_storage> has already
been allocated but is uninitialised.
==============================================================================*/
{
 	enum Value_type value_type;
	int i,j,*number_in_xi,number_of_values,return_code,value_index;
	struct Copy_element_grid_map_data *copy_data;
	struct FE_element_field_component **component;

	ENTER(copy_element_grid_map_values_storage);
	if (element_field&&element_field->field&&(copy_data=
		(struct Copy_element_grid_map_data *)copy_element_grid_map_data_void))
	{
		return_code=1;
		/* only GENERAL_FE_FIELD has components and can be grid-based */
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			value_type = element_field->field->value_type;
			component=element_field->components;
			for (i=element_field->field->number_of_components;(0<i)&&return_code;i--)
			{
				if (ELEMENT_GRID_MAP==(*component)->type)
				{
					number_in_xi=((*component)->map).element_grid_based.number_in_xi;
					number_of_values=1;
					for (j=((*component)->basis->type)[0];j>0;j--)
					{
						number_of_values *= (*number_in_xi)+1;
						number_in_xi++;
					}
					value_index=((*component)->map).element_grid_based.value_index;
					if (copy_data->destination_values_storage&&
						copy_data->source_values_storage)
					{
						return_code=copy_value_storage_array(
							copy_data->destination_values_storage+value_index,
							value_type,(struct FE_time_sequence *)NULL,
							(struct FE_time_sequence *)NULL,number_of_values,
							copy_data->source_values_storage+value_index);
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"copy_element_grid_map_values_storage.  "
							"Missing source or destination values_storage");
						return_code=0;
					}
				}
				component++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"copy_element_grid_map_values_storage.  Invalid arguments");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* copy_element_grid_map_values_storage */

struct FE_element_node_scale_field_info
	*create_FE_element_node_scale_field_info_from_contents(
		int values_storage_size,
	Value_storage *values_storage,int number_of_nodes,struct FE_node **nodes,
	int number_of_scale_factor_sets,void **scale_factor_set_identifiers,
	int *numbers_in_scale_factor_sets,int number_of_scale_factors,
	FE_value *scale_factors, struct FE_element_field_info *field_info)
/*******************************************************************************
LAST MODIFIED : 24 March 2003

DESCRIPTION :
Allocates memory and assigns fields for an element's node, scale factor and
field information structure.  Note that the arguments are duplicated.
???RC Made it possible to have no scale factor sets.
<field_info> is supplied to allow values_storage to be copied.
==============================================================================*/
{
	FE_value *scale_factor;
	int i,j,*number_in_scale_factor_set;
	struct Check_element_grid_map_values_storage_data check_grid_data;
	struct Copy_element_grid_map_data copy_element_grid_map_data;
	struct FE_element_node_scale_field_info *node_scale_field_info;
	Value_storage *temp_values_storage;
	void **scale_factor_set_identifier;

	ENTER(create_FE_element_node_scale_field_info_from_contents);
	if ((((0 == values_storage_size) && (!values_storage)) ||
		((0 < values_storage_size) && values_storage)) &&
		(((0 == number_of_nodes) && (!nodes)) ||
			((0 < number_of_nodes) && nodes)) &&
		((0 == number_of_scale_factor_sets) || ((0 < number_of_scale_factor_sets) &&
		scale_factor_set_identifiers && numbers_in_scale_factor_sets &&
		(0 < number_of_scale_factors) && scale_factors && field_info)))
	{
		/* check the grid based fields */
		check_grid_data.check_sum=0;
		check_grid_data.values_storage_size=values_storage_size;
		if (FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
			check_element_grid_map_values_storage,(void *)&check_grid_data,
			field_info->element_field_list)&&
			(values_storage_size==check_grid_data.check_sum))
		{
			j=0;
			for (i=0;i<number_of_scale_factor_sets;i++)
			{
				j += numbers_in_scale_factor_sets[i];
			}
			if (j==number_of_scale_factors)
			{
				node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
				temp_values_storage=(Value_storage *)NULL;
				scale_factor_set_identifier=(void *)NULL;
				number_in_scale_factor_set=(int *)NULL;
				scale_factor=(FE_value *)NULL;
				if ((node_scale_field_info =
					CREATE(FE_element_node_scale_field_info)()) &&
					(!values_storage||ALLOCATE(temp_values_storage,Value_storage,
						values_storage_size))&&
					FE_element_node_scale_field_info_set_number_of_nodes(
						node_scale_field_info, number_of_nodes) &&
					((0==number_of_scale_factor_sets)||
						(ALLOCATE(scale_factor_set_identifier,void *,
							number_of_scale_factor_sets)&&
							ALLOCATE(number_in_scale_factor_set,int,
								number_of_scale_factor_sets)&&
							ALLOCATE(scale_factor,FE_value,number_of_scale_factors))))
				{
					node_scale_field_info->values_storage_size=values_storage_size;
					node_scale_field_info->values_storage=temp_values_storage;
					/* copy values_storage from field_info to node_scale_field_info */
					copy_element_grid_map_data.destination_values_storage=
						node_scale_field_info->values_storage;
					copy_element_grid_map_data.source_values_storage=values_storage;
					FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
						copy_element_grid_map_values_storage,
						&copy_element_grid_map_data,field_info->element_field_list);
					for (i = 0; i < number_of_nodes; i++)
					{
						FE_element_node_scale_field_info_set_node(
							node_scale_field_info, i, nodes[i]);
					}
					node_scale_field_info->number_of_scale_factor_sets=
						number_of_scale_factor_sets;
					node_scale_field_info->scale_factor_set_identifiers=
						scale_factor_set_identifier;
					node_scale_field_info->numbers_in_scale_factor_sets=
						number_in_scale_factor_set;
					node_scale_field_info->number_of_scale_factors=
						number_of_scale_factors;
					for (i=0;i<number_of_scale_factor_sets;i++)
					{
						scale_factor_set_identifier[i]=scale_factor_set_identifiers[i];
						number_in_scale_factor_set[i]=numbers_in_scale_factor_sets[i];
					}
					node_scale_field_info->number_of_scale_factors=
						number_of_scale_factors;
					node_scale_field_info->scale_factors=scale_factor;
					for (i=0;i<number_of_scale_factors;i++)
					{
						scale_factor[i]=scale_factors[i];
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"create_FE_element_node_scale_field_info_from_contents.  "
						"Insufficient memory");
					DEALLOCATE(temp_values_storage);
					DEALLOCATE(scale_factor_set_identifier);
					DEALLOCATE(number_in_scale_factor_set);
					DEALLOCATE(scale_factor);
					DESTROY(FE_element_node_scale_field_info)(&node_scale_field_info);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"create_FE_element_node_scale_field_info_from_contents.  "
					"Inconsistent scale factors");
				node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"create_FE_element_node_scale_field_info_from_contents.  "
				"Inconsistent element values");
			node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"create_FE_element_node_scale_field_info_from_contents.  "
			"Invalid argument(s)");
		node_scale_field_info=(struct FE_element_node_scale_field_info *)NULL;
	}
	LEAVE;

	return (node_scale_field_info);
} /* create_FE_element_node_scale_field_info_from_contents */

struct FE_element_shape *CREATE(FE_element_shape)(int dimension,int *type,
	struct FE_region *fe_region)
/*******************************************************************************
LAST MODIFIED : 8 July 2003

DESCRIPTION :
Searchs the <element_shape_list> for a shape with the specified <dimension> and 
<type>.  If one is not found, a shape is created (with <type> duplicated) and 
added to the list.  The shape is returned.
<type> is analogous to the basis type array, except that the entries are 0 or 1.
If <type> is omitted an "unspecified" shape of the given <dimension> is
returned. An element with such a shape may not have fields defined on it until
it is given a proper shape.
==============================================================================*/
{
	FE_value *face_to_element, *face_normals, weight;
	int dimension_2,*face,i,j,k,k_set,l,linked_coordinate,linked_k,linked_offset,
		*linked_offsets,no_error,number_of_faces,number_of_polygon_verticies,offset,
		*shape_type,simplex_coordinate,simplex_dimension,temp_int,*type_entry,
		xi_coordinate;
	struct FE_element_shape *shape;

	ENTER(CREATE(FE_element_shape));
	shape = (struct FE_element_shape *)NULL;
/*???debug */
/*printf("enter CREATE(FE_element_shape)\n");*/
	if (dimension > 0)
	{
		/* check if the shape already exists */
		if (!(shape = find_FE_element_shape_in_list(dimension, type,
			FE_region_get_FE_element_shape_list(fe_region))))
		{
			if (ALLOCATE(shape, struct FE_element_shape, 1))
			{
				/* make an unspecified shape = no type array or faces */
				shape->dimension = dimension;
				shape->type = type;
				shape->number_of_faces = 0;
				shape->faces = (int *)NULL;
				shape->face_normals = (FE_value *)NULL;
				shape->face_to_element = (FE_value *)NULL;
				shape->access_count = 0;
			}
			shape_type = (int *)NULL;
			linked_offsets = (int *)NULL;
			if (type)
			{
				ALLOCATE(shape_type,int,(dimension*(dimension+1))/2);
				/* offsets is working storage used within this function */
				ALLOCATE(linked_offsets,int,dimension);
			}
			if (shape && shape_type && linked_offsets)
			{
				shape->type = shape_type;
				if (1==dimension)
				{
					if ((LINE_SHAPE == *type) ||
						(UNSPECIFIED_SHAPE == *type))
					{
						*(shape_type) = *type;
						shape->number_of_faces = 0;
						shape->faces = (int *)NULL;
						shape->face_to_element = (FE_value *)NULL;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_element_shape).  Invalid shape type");
						shape=(struct FE_element_shape *)NULL;
					}
				}
				else
				{
					/* copy the type */
					type_entry=type;
					for (i=(dimension*(dimension+1))/2;i>0;i--)
					{
						*shape_type= *type_entry;
						shape_type++;
						type_entry++;
					}
					/* check that the type is valid and calculate the number of faces */
					no_error=1;
					number_of_faces=0;
					xi_coordinate=0;
					shape_type=shape->type;
					while (no_error&&(xi_coordinate<dimension))
					{
						linked_offsets[xi_coordinate]=0;
						xi_coordinate++;
						switch (*shape_type)
						{
							case UNSPECIFIED_SHAPE:
							{
								/* unspecified */
								number_of_faces = 0;
								/* check that not connected to anything else */
								i = dimension - xi_coordinate;
								shape_type++;
								while (no_error && (i>0))
								{
									if (0 != *shape_type)
									{
										no_error = 0;
									}
									shape_type++;
									i--;
								}
							} break;
							case LINE_SHAPE:
							{
								/* line */
								number_of_faces += 2;
								/* check that not connected to anything else */
								i=dimension-xi_coordinate;
								shape_type++;
								while (no_error&&(i>0))
								{
									if (0!= *shape_type)
									{
										no_error=0;
									}
									shape_type++;
									i--;
								}
							} break;
							case POLYGON_SHAPE:
							{
								/* polygon */
								/* check if the other polygon coordinate is before */
								type_entry=shape_type;
								i=xi_coordinate-1;
								j=dimension-xi_coordinate;
								number_of_polygon_verticies=0;
								while (no_error&&(i>0))
								{
									j++;
									type_entry -= j;
									if (*type_entry)
									{
										if (number_of_polygon_verticies)
										{
											no_error=0;
										}
										else
										{
											number_of_polygon_verticies= *type_entry;
											if (number_of_polygon_verticies>=3)
											{
												linked_offsets[xi_coordinate-1]=i-xi_coordinate;
											}
											else
											{
												no_error=0;
											}
										}
									}
									i--;
								}
								if (no_error)
								{
									if (number_of_polygon_verticies)
									{
										/* other polygon coordinate is before */
										/* check that not connected to anything else */
										i=dimension-xi_coordinate;
										shape_type++;
										while (no_error&&(i>0))
										{
											if (0!= *shape_type)
											{
												no_error=0;
											}
											shape_type++;
											i--;
										}
									}
									else
									{
										/* check if the other polygon coordinate is after */
										shape_type++;
										i=dimension-xi_coordinate;
										number_of_polygon_verticies=0;
										while (no_error&&(i>0))
										{
											if (*shape_type)
											{
												if (number_of_polygon_verticies)
												{
													no_error=0;
												}
												else
												{
													number_of_polygon_verticies= *shape_type;
													if (3<=number_of_polygon_verticies)
													{
														linked_offset=dimension-xi_coordinate+1-i;
														if (POLYGON_SHAPE==shape_type[(linked_offset*
															(2*(dimension-xi_coordinate+1)-linked_offset+1))/
															2-linked_offset])
														{
															linked_offsets[xi_coordinate-1]=linked_offset;
															number_of_faces += number_of_polygon_verticies;
														}
														else
														{
															no_error=0;
														}
													}
													else
													{
														no_error=0;
													}
												}
											}
											shape_type++;
											i--;
										}
										if (number_of_polygon_verticies<3)
										{
											no_error=0;
										}
									}
								}
							} break;
							case SIMPLEX_SHAPE:
							{
								/* simplex */
								/* check preceding dimensions */
								type_entry=shape_type;
								i=xi_coordinate-1;
								j=dimension-xi_coordinate;
								while (no_error&&(i>0))
								{
									j++;
									type_entry -= j;
									if (*type_entry)
									{
										if (SIMPLEX_SHAPE== *(type_entry-(xi_coordinate-i)))
										{
											linked_offsets[xi_coordinate-1]=i-xi_coordinate;
										}
										else
										{
											no_error=0;
										}
									}
									i--;
								}
								if (0==linked_offsets[xi_coordinate-1])
								{
									/* this is first simplex coordinate */
									number_of_faces++;
								}
								else
								{
									/* check intermediary links */
									/* calculate first simplex coordinate */
									i=xi_coordinate+linked_offsets[xi_coordinate-1];
									type_entry=(shape->type)+((i-1)*(2*dimension-i+2))/2;
									j=dimension-i;
									k=xi_coordinate-i;
									i++;
									while (no_error&&(i<xi_coordinate))
									{
										j--;
										k += j;
										type_entry++;
										if (((0== *type_entry)&&(0!=type_entry[k]))||
											((0!= *type_entry)&&(0==type_entry[k])))
										{
											no_error=0;
										}
										i++;
									}
#if defined (OLD_CODE)
									type_entry=shape_type+((i-1)*(2*dimension-i+2))/2;
									j=dimension-xi_coordinate+1;
									k=shape_type-type_entry;
									type_entry=shape_type;
									i++;
									while (no_error&&(i<xi_coordinate))
									{
										j++;
										k -= j;
										type_entry++;
										if (((0== *type_entry)&&(0!=type_entry[k]))||
											((0!= *type_entry)&&(0==type_entry[k])))
										{
											no_error=0;
										}
										i++;
									}
#endif /* defined (OLD_CODE) */
								}
								number_of_faces++;
								/* check succeeding dimensions */
								shape_type++;
								i=dimension-xi_coordinate;
								while (no_error&&(i>0))
								{
									if (*shape_type)
									{
										linked_offset=dimension-xi_coordinate+1-i;
										if (SIMPLEX_SHAPE==shape_type[(linked_offset*
											(2*(dimension-xi_coordinate+1)-linked_offset+1))/
											2-linked_offset])
										{
											if (linked_offsets[xi_coordinate-1]<=0)
											{
												linked_offsets[xi_coordinate-1]=linked_offset;
											}
										}
										else
										{
											no_error=0;
										}
									}
									shape_type++;
									i--;
								}
								if (0==linked_offsets[xi_coordinate-1])
								{
									no_error=0;
								}
							} break;
							default:
							{
								no_error=0;
							} break;
						}
					}
					if (no_error)
					{
						dimension_2=dimension*dimension;
						if (ALLOCATE(face,int,number_of_faces)&&
							ALLOCATE(face_normals,FE_value,number_of_faces*dimension)&&
							ALLOCATE(face_to_element,FE_value,number_of_faces*dimension_2))
						{
							shape->number_of_faces=number_of_faces;
							shape->faces=face;
							shape->face_normals=face_normals;
							shape->face_to_element=face_to_element;
							for (i=number_of_faces*dimension_2;i>0;i--)
							{
								*face_to_element=0;
								face_to_element++;
							}
							face_to_element=shape->face_to_element;
							for (i=number_of_faces;i>0;i--)
							{
								*face=0;
								face++;
							}
							face=shape->faces;
							for (i=number_of_faces*dimension;i>0;i--)
							{
								*face_normals=0.0;
								face_normals++;
							}
							face_normals=shape->face_normals;
							shape_type=shape->type;
							offset=1;
							/* loop over the coordinates calculating the face matrices
								(number dependent on <*shape_type>) for each */
							for (xi_coordinate=0;xi_coordinate<dimension;xi_coordinate++)
							{
								switch (*shape_type)
								{
									case LINE_SHAPE:
									{
										/* line */
										/* two faces for this coordinate */
										offset *= 2;
										*face=offset;
										face++;
										*face=offset+1;
										face++;
										*(face_normals + xi_coordinate) = -1.0;
										face_normals += dimension;
										*(face_normals + xi_coordinate) = 1.0;
										face_normals += dimension;
										face_to_element[dimension_2+xi_coordinate*dimension]=1;
#define CALCULATE_K_SET() \
k_set=k; \
if (POLYGON_SHAPE== *type_entry) \
{ \
	linked_offset=linked_offsets[j]; \
	/* for when *shape_type is POLYGON_SHAPE */ \
	if (xi_coordinate!=j+linked_offset) \
	{ \
		if (0<linked_offset) \
		{ \
			/* first polygon coordinate */ \
			linked_k=k; \
			if (linked_k<=xi_coordinate) \
			{ \
				linked_k--; \
			} \
			linked_k += linked_offset; \
			if (linked_k>=dimension) \
			{ \
				linked_k -= dimension; \
			} \
			if (linked_k<xi_coordinate) \
			{ \
				linked_k++; \
			} \
			if (linked_k<k) \
			{ \
				k_set=linked_k; \
			} \
		} \
		else \
		{ \
			/* second polygon coordinate */ \
			linked_k=k; \
			if (linked_k<=xi_coordinate) \
			{ \
				linked_k--; \
			} \
			linked_k -= linked_offset; \
			if (linked_k>=dimension) \
			{ \
				linked_k -= dimension; \
			} \
			if (linked_k<xi_coordinate) \
			{ \
				linked_k++; \
			} \
			if (k<linked_k) \
			{ \
				k_set=linked_k; \
			} \
		} \
	} \
}
										k=xi_coordinate+1;
										if (k>=dimension)
										{
											k=1;
										}
										type_entry=shape->type;
										for (j=0;j<dimension;j++)
										{
											if (j!=xi_coordinate)
											{
												CALCULATE_K_SET();
												face_to_element[k_set]=1;
												face_to_element[dimension_2+k_set]=1;
												k++;
												if (k>=dimension)
												{
													k=1;
												}
											}
											face_to_element += dimension;
											type_entry += dimension-j;
										}
										face_to_element += dimension_2;
									} break;
									case POLYGON_SHAPE:
									{
										/* polygon */
										/* <number_of_polygon_verticies>+1 faces in total for the
											two polygon dimension */
										if (0<(linked_offset=linked_offsets[xi_coordinate]))
										{
											/* first polygon dimension */
											number_of_polygon_verticies=shape_type[linked_offset];
											offset *= number_of_polygon_verticies;
											linked_offset += xi_coordinate;
											for (i=0;i<number_of_polygon_verticies;i++)
											{
												*face=offset;
												face++;
												offset++;
												*(face_normals + linked_offset) = 1.0;
												face_normals += dimension;
												k=xi_coordinate+1;
												if (k>=dimension)
												{
													k=1;
												}
												type_entry=shape->type;
												j=0;
												while (j<xi_coordinate)
												{
													CALCULATE_K_SET();
													face_to_element[k_set]=1;
													k++;
													if (k>=dimension)
													{
														k=1;
													}
													type_entry += dimension-j;
													j++;
													face_to_element += dimension;
												}
												*face_to_element=
													(FE_value)i/(FE_value)number_of_polygon_verticies;
												face_to_element[k]=
													1./(FE_value)number_of_polygon_verticies;
												k++;
												if (k>=dimension)
												{
													k=1;
												}
												type_entry += dimension-j;
												j++;
												face_to_element += dimension;
												while (j<linked_offset)
												{
													CALCULATE_K_SET();
													face_to_element[k_set]=1;
													k++;
													if (k>=dimension)
													{
														k=1;
													}
													type_entry += dimension-j;
													j++;
													face_to_element += dimension;
												}
												*face_to_element=1;
												face_to_element += dimension;
												type_entry += dimension-j;
												j++;
												while (j<dimension)
												{
													CALCULATE_K_SET();
													face_to_element[k_set]=1;
													k++;
													if (k>=dimension)
													{
														k=1;
													}
													type_entry += dimension-j;
													j++;
													face_to_element += dimension;
												}
											}
										}
									} break;
									case SIMPLEX_SHAPE:
									{
										offset *= 2;
										*face=offset;
										face++;
										*(face_normals + xi_coordinate) = -1.0;
										face_normals += dimension;
										simplex_dimension=0;
										/* calculate the simplex dimension */
										simplex_coordinate=xi_coordinate;
										do
										{
											simplex_coordinate += linked_offsets[simplex_coordinate];
											simplex_dimension++;
										} while (simplex_coordinate!=xi_coordinate);
										simplex_coordinate=xi_coordinate;
										linked_offset=simplex_dimension;
										if (0<linked_offsets[xi_coordinate])
										{
											do
											{
												simplex_coordinate +=
													linked_offsets[simplex_coordinate];
												linked_offset--;
											} while (linked_offsets[simplex_coordinate]>0);
											face[simplex_coordinate-xi_coordinate] += offset;
										}
										else
										{
											/* last simplex dimension */
											*face += offset+1;
											face++;
											weight = 1.0/sqrt((double)simplex_dimension);
											simplex_coordinate=xi_coordinate;
											for (j=simplex_dimension;j>0;j--)
											{
												face_normals[simplex_coordinate]=weight;
												simplex_coordinate += linked_offsets[simplex_coordinate];
											}
											face_normals += dimension;
											simplex_coordinate=xi_coordinate;
										}
										linked_offset--;
										simplex_coordinate += linked_offsets[simplex_coordinate];
										linked_coordinate=simplex_coordinate;
										for (j=simplex_dimension-linked_offset;j>0;j--)
										{
											linked_coordinate += linked_offsets[linked_coordinate];
										}
										k=xi_coordinate+1;
										if (k>=dimension)
										{
											k=1;
										}
										if (simplex_dimension<dimension)
										{
											/* make sure that k is not in the simplex containing
												xi_coordinate */
											i=1;
											do
											{
												if (k>xi_coordinate)
												{
													i=k;
												}
												else
												{
													i=k-1;
												}
												if (0==linked_offsets[i])
												{
													i=0;
												}
												else
												{
													l=i;
													do
													{
														l += linked_offsets[l];
													} while ((l!=i)&&(l!=xi_coordinate));
													if (l==xi_coordinate)
													{
														k++;
														if (k>=dimension)
														{
															k=1;
														}
														i=1;
													}
													else
													{
														i=0;
													}
												}
											} while (1==i);
										}
										/* start with
											- simplex_coordinate being the first simplex coordinate
											- (simplex_dimension-linked_offset)-1 being the
												coordinate in the simplex of the xi_coordinate
											- linked_coordinate being the coordinate after
												xi_coordinate in the simplex
											*/
										type_entry=shape->type;
										for (j=0;j<dimension;j++)
										{
											if (j==simplex_coordinate)
											{
												simplex_coordinate +=
													linked_offsets[simplex_coordinate];
												linked_offset--;
												if (j!=xi_coordinate)
												{
													if (0==linked_offset)
													{
														face_to_element[0]=1;
														temp_int=xi_coordinate+
															linked_offsets[xi_coordinate];
														while (xi_coordinate<temp_int)
														{
															face_to_element[temp_int]= -1;
															temp_int += linked_offsets[temp_int];
														}
														while (temp_int<xi_coordinate)
														{
															face_to_element[temp_int+1]= -1;
															temp_int += linked_offsets[temp_int];
														}
													}
													else
													{
														if (linked_coordinate<xi_coordinate)
														{
															face_to_element[linked_coordinate+1]=1;
														}
														else
														{
															if (xi_coordinate<linked_coordinate)
															{
																face_to_element[linked_coordinate]=1;
															}
														}
														linked_coordinate +=
															linked_offsets[linked_coordinate];
													}
												}
												else
												{
													linked_coordinate +=
														linked_offsets[linked_coordinate];
												}
											}
											else
											{
												if (j!=xi_coordinate)
												{
													CALCULATE_K_SET();
													face_to_element[k_set]=1;
													k++;
													if (k>=dimension)
													{
														k=1;
													}
													if (simplex_dimension<dimension)
													{
														/* make sure that k is not in the simplex containing
															xi_coordinate */
														i=1;
														do
														{
															if (k>xi_coordinate)
															{
																i=k;
															}
															else
															{
																i=k-1;
															}
															if (0==linked_offsets[i])
															{
																i=0;
															}
															else
															{
																l=i;
																do
																{
																	l += linked_offsets[l];
																} while ((l!=i)&&(l!=xi_coordinate));
																if (l==xi_coordinate)
																{
																	k++;
																	if (k>=dimension)
																	{
																		k=1;
																	}
																	i=1;
																}
																else
																{
																	i=0;
																}
															}
														} while (1==i);
													}
												}
											}
											face_to_element += dimension;
											type_entry += dimension-j;
										}
										if (linked_offsets[xi_coordinate]<0)
										{
											/* last simplex dimension */
											linked_offset=simplex_dimension;
											simplex_coordinate=xi_coordinate+
												linked_offsets[xi_coordinate];
											linked_coordinate=simplex_coordinate;
											k=xi_coordinate+1;
											if (k>=dimension)
											{
												k=1;
											}
											if (simplex_dimension<dimension)
											{
												/* make sure that k is not in the simplex containing
													xi_coordinate */
												i=1;
												do
												{
													if (k>xi_coordinate)
													{
														i=k;
													}
													else
													{
														i=k-1;
													}
													if (0==linked_offsets[i])
													{
														i=0;
													}
													else
													{
														l=i;
														do
														{
															l += linked_offsets[l];
														} while ((l!=i)&&(l!=xi_coordinate));
														if (l==xi_coordinate)
														{
															k++;
															if (k>=dimension)
															{
																k=1;
															}
															i=1;
														}
														else
														{
															i=0;
														}
													}
												} while (1==i);
											}
											type_entry=shape->type;
											for (j=0;j<dimension;j++)
											{
												if (j==simplex_coordinate)
												{
													simplex_coordinate +=
														linked_offsets[simplex_coordinate];
													linked_offset--;
													if (0==linked_offset)
													{
														face_to_element[0]=1;
														temp_int=xi_coordinate+
															linked_offsets[xi_coordinate];
														while (xi_coordinate<temp_int)
														{
															face_to_element[temp_int]= -1;
															temp_int += linked_offsets[temp_int];
														}
														while (temp_int<xi_coordinate)
														{
															face_to_element[temp_int+1]= -1;
															temp_int += linked_offsets[temp_int];
														}
													}
													else
													{
														if (linked_coordinate<xi_coordinate)
														{
															face_to_element[linked_coordinate+1]=1;
														}
														else
														{
															if (xi_coordinate<linked_coordinate)
															{
																face_to_element[linked_coordinate]=1;
															}
														}
														linked_coordinate +=
															linked_offsets[linked_coordinate];
													}
												}
												else
												{
													if (j!=xi_coordinate)
													{
														CALCULATE_K_SET();
														face_to_element[k_set]=1;
														k++;
														if (k>=dimension)
														{
															k=1;
														}
														if (simplex_dimension<dimension)
														{
															/* make sure that k is not in the simplex
																containing xi_coordinate */
															i=1;
															do
															{
																if (k>xi_coordinate)
																{
																	i=k;
																}
																else
																{
																	i=k-1;
																}
																if (0==linked_offsets[i])
																{
																	i=0;
																}
																else
																{
																	l=i;
																	do
																	{
																		l += linked_offsets[l];
																	} while ((l!=i)&&(l!=xi_coordinate));
																	if (l==xi_coordinate)
																	{
																		k++;
																		if (k>=dimension)
																		{
																			k=1;
																		}
																		i=1;
																	}
																	else
																	{
																		i=0;
																	}
																}
															} while (1==i);
														}
													}
												}
												face_to_element += dimension;
												type_entry += dimension-j;
											}
										}
#if defined (OLD_CODE)
/*???DB.  Didn't make sure that k wasn't indexing a coordinate in the simplex */
										if (0<(linked_offset=linked_offsets[xi_coordinate]))
										{
											while (linked_offsets[xi_coordinate+linked_offset]>0)
											{
												linked_offset +=
													linked_offsets[xi_coordinate+linked_offset];
											}
											face[linked_offset] += offset;
										}
										else
										{
											/* last simplex dimension */
											*face += offset+1;
											face++;
										}
										k=xi_coordinate+1;
										if (k>=dimension)
										{
											k=1;
										}
										for (j=0;j<dimension;j++)
										{
											if (j!=xi_coordinate)
											{
												face_to_element[k]=1;
												k++;
												if (k>=dimension)
												{
													k=1;
												}
											}
											face_to_element += dimension;
										}
										if (linked_offset<0)
										{
											/* last simplex dimension */
											k=xi_coordinate+1;
											if (k>=dimension)
											{
												k=1;
											}
											for (j=0;j<dimension;j++)
											{
												if (j==xi_coordinate)
												{
													face_to_element[0]=1;
													do
													{
														face_to_element[xi_coordinate+1+linked_offset]= -1;
														linked_offset +=
															linked_offsets[xi_coordinate+linked_offset];
													} while
														(0<linked_offsets[xi_coordinate+linked_offset]);
												}
												else
												{
													face_to_element[k]=1;
													k++;
													if (k>=dimension)
													{
														k=1;
													}
												}
												face_to_element += dimension;
											}
										}
#endif /* defined (OLD_CODE) */
									} break;
								}
								shape_type += dimension-xi_coordinate;
							}
#if defined (DEBUG)
							/*???debug */
							face_to_element=shape->face_to_element;
							face=shape->faces;
							for (i=1;i<=number_of_faces;i++)
							{
								printf("face %d %d:\n",i,*face);
								face++;
								for (j=dimension;j>0;j--)
								{
									for (k=dimension;k>0;k--)
									{
										printf(" %g",*face_to_element);
										face_to_element++;
									}
									printf("\n");
								}
							}
#endif /* defined (DEBUG) */
						}
						else
						{
							display_message(ERROR_MESSAGE,
							"CREATE(FE_element_shape).  Could not allocate memory for faces");
							DEALLOCATE(shape);
							DEALLOCATE(shape_type);
							DEALLOCATE(face);
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"CREATE(FE_element_shape).  Invalid shape type");
						DEALLOCATE(shape->type);
						DEALLOCATE(shape);
					}
				}
			}
			else
			{
				/* unspecified shape creator ends up here legitimately */
				if (type || (!shape))
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_element_shape).  Could not allocate memory for shape");
					DEALLOCATE(shape);
					DEALLOCATE(shape_type);
				}
			}
			if (shape)
			{
				/* add the shape to the list of all shapes */
				if (!ADD_OBJECT_TO_LIST(FE_element_shape)(shape,
					FE_region_get_FE_element_shape_list(fe_region)))
				{
					display_message(ERROR_MESSAGE, "CREATE(FE_element_shape).  "
						"Could not add shape to the list of all shapes");
					DEALLOCATE(shape->type);
					DEALLOCATE(shape->faces);
					DEALLOCATE(shape->face_to_element);
					DEALLOCATE(shape);
				}
#if defined (DEBUG)
				printf("Created shape: %p\n", shape);
				printf("  shape->dimension: %d\n", shape->dimension);
				printf("  shape->type:");
				for (i = 0 ; i < (shape->dimension*(shape->dimension+1))/2 ; i++)
				{
					printf(" %d", shape->type[i]);
				}
				printf("\n");
				printf("  shape->number_of_faces: %d\n", shape->number_of_faces);
				printf("  shape->faces:");
				for (i = 0 ; i < shape->number_of_faces ; i++)
				{
					printf(" %d (", shape->faces[i]);
					for (j = 0 ; j < shape->dimension ; j++)
					{
						printf("%f,", shape->face_normals[j + i * shape->dimension]);
					}
					printf(")\n");
				}
#endif /* defined (DEBUG) */				
			}
			if (linked_offsets)
			{
				DEALLOCATE(linked_offsets);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_shape).  Invalid argument");
	}
/*???debug */
/*printf("leave CREATE(FE_element_shape)\n");*/
	LEAVE;

	return (shape);
} /* CREATE(FE_element_shape) */

int DESTROY(FE_element_shape)(struct FE_element_shape **element_shape_address)
/*******************************************************************************
LAST MODIFIED : 24 September 1995

DESCRIPTION :
Remove the shape from the list of all shapes.  Free the memory for the shape and
sets <*element_shape_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_element_shape *shape;

	ENTER(DESTROY(FE_element_shape));
	/* check the arguments */
	if ((element_shape_address)&&(shape= *element_shape_address))
	{
		if (0==shape->access_count)
		{
			DEALLOCATE(shape->type);
			DEALLOCATE(shape->faces);
			DEALLOCATE(shape->face_normals);
			DEALLOCATE(shape->face_to_element);
			DEALLOCATE(*element_shape_address);
			return_code=1;
		}
		else
		{
			return_code=1;
			*element_shape_address=(struct FE_element_shape *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_shape) */

DECLARE_OBJECT_FUNCTIONS(FE_element_shape)
DECLARE_LIST_FUNCTIONS(FE_element_shape)

int FE_element_shape_is_unspecified(struct FE_element_shape *element_shape)
/*******************************************************************************
LAST MODIFIED : 18 November 2002

DESCRIPTION :
Returns true if the only thing know about <element_shape> is its dimension.
==============================================================================*/
{
	int return_code;
	
	ENTER(FE_element_shape_is_unspecified);
	return_code = 0;
	if (element_shape)
	{
		if ((int *)NULL == element_shape->type)
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_shape_is_unspecified.  Missing shape");
	}
	LEAVE;

	return (return_code);
} /* FE_element_shape_is_unspecified */

int FE_element_shape_is_line(struct FE_element_shape *element_shape)
/*******************************************************************************
LAST MODIFIED : 12 March 2003

DESCRIPTION :
Returns true if the <element_shape> has only LINE_SHAPE in each dimension.
==============================================================================*/
{
	int return_code;
	
	ENTER(FE_element_shape_is_line);
	return_code = 0;
	if (element_shape)
	{
		if (element_shape->type)
		{
			return_code = (element_shape->type[0] == LINE_SHAPE) && (
				 (1 == element_shape->dimension) ||
				((2 == element_shape->dimension) &&
					(element_shape->type[2] == LINE_SHAPE)) ||
				((3 == element_shape->dimension) &&
					(element_shape->type[3] == LINE_SHAPE) &&
					(element_shape->type[5] == LINE_SHAPE)));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_shape_is_line.  Missing shape");
	}
	LEAVE;

	return (return_code);
} /* FE_element_shape_is_line */

struct FE_element_shape *get_FE_element_shape_of_face(
	struct FE_element_shape *shape,int face_number, struct FE_region *fe_region)
/*******************************************************************************
LAST MODIFIED : 7 July 2003

DESCRIPTION :
From the parent <shape> returns the FE_element_shape for its face <face_number>.
The <shape> must be of dimension 2 or 3. Faces of 2-D elements are always lines.
==============================================================================*/
{
	int face_code,face_type[3],line_xi_bit,number_of_polygon_vertices,
		polygon_face;
	struct FE_element_shape *face_shape;

	ENTER(get_FE_element_shape_of_face);
	face_shape = (struct FE_element_shape *)NULL;
	if (shape&&(0<=face_number)&&(face_number<shape->number_of_faces)&&
		shape->type&&shape->faces)
	{
		switch (shape->dimension)
		{
			case 2:
			{
				/* faces of 2-D shapes are always lines */
				face_type[0]=LINE_SHAPE;
				face_shape=CREATE(FE_element_shape)(/*dimension*/1,face_type,
					fe_region);
			} break;
			case 3:
			{
				/* if all shape types on main diagonal are the same, then it is either
					 a square block or a tetrahedron. Sub-triangle of shape->type is then
					 valid for any of its faces */
				if (((shape->type)[0]==(shape->type)[3])&&
					((shape->type)[0]==(shape->type)[5]))
				{
					face_shape=CREATE(FE_element_shape)(/*dimension*/2,shape->type+3,
						fe_region);
				}
				else if ((POLYGON_SHAPE==(shape->type)[0])||
					(POLYGON_SHAPE==(shape->type)[3])||
					(POLYGON_SHAPE==(shape->type)[5]))
				{
					/* 2 out of 3 xi directions must be linked in a polygon: hence need
						to determine if face is a polygon or a square */
					face_code=shape->faces[face_number];
					/* work out number_of_polygon_vertices */
					polygon_face=0;
					if (POLYGON_SHAPE==(shape->type)[0])
					{
						if (POLYGON_SHAPE==(shape->type)[3])
						{
							number_of_polygon_vertices=(shape->type)[1];
							/* polygon-polygon-line */
							if (face_code>=number_of_polygon_vertices*2)
							{
								polygon_face=1;
							}
						}
						else
						{
							number_of_polygon_vertices=(shape->type)[2];
							/* polygon-line-polygon */
							if (face_code>=number_of_polygon_vertices*2)
							{
								polygon_face=1;
							}
						}
					}
					else
					{
						number_of_polygon_vertices=(shape->type)[4];
						/* line-polygon-polygon */
						if (face_code<number_of_polygon_vertices*2)
						{
							polygon_face=1;
						}
					}
#if defined (OLD_CODE)
					face_code /= number_of_polygon_vertices;
					if (face_code & 2)
#endif /* defined (OLD_CODE) */
					if (polygon_face)
					{
						/* face has a polygon shape */
						face_type[0]=POLYGON_SHAPE;
						face_type[1]=number_of_polygon_vertices;
						face_type[2]=POLYGON_SHAPE;
					}
					else
					{
						/* face has a square shape */
						face_type[0]=LINE_SHAPE;
						face_type[1]=0;
						face_type[2]=LINE_SHAPE;
					}
					face_shape=CREATE(FE_element_shape)(/*dimension*/2,face_type,
						fe_region);
				}
				else if ((SIMPLEX_SHAPE==(shape->type)[0])||
					(SIMPLEX_SHAPE==(shape->type)[3])||
					(SIMPLEX_SHAPE==(shape->type)[5]))
				{
					/* 2 out of 3 xi directions must be linked in a triangle: hence need
						 to determine if face is a triangle or a square */
					face_code=shape->faces[face_number];
					/* work out which xi direction is not SIMPLEX_SHAPE (=LINE_SHAPE) */
					if (SIMPLEX_SHAPE==(shape->type)[0])
					{
						if (SIMPLEX_SHAPE==(shape->type)[3])
						{
							line_xi_bit=8;
						}
						else
						{
							line_xi_bit=4;
						}
					}
					else
					{
						line_xi_bit=2;
					}
					if (face_code & line_xi_bit)
					{
						/* face has a triangle shape */
						face_type[0]=SIMPLEX_SHAPE;
						face_type[1]=1;
						face_type[2]=SIMPLEX_SHAPE;
					}
					else
					{
						/* face has a square shape */
						face_type[0]=LINE_SHAPE;
						face_type[1]=0;
						face_type[2]=LINE_SHAPE;
					}
					face_shape=CREATE(FE_element_shape)(/*dimension*/2,face_type,
						fe_region);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_shape_of_face.  Unknown element shape");
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_shape_of_face.  Invalid dimension");
			} break;
		}
		if (!face_shape)
		{
			display_message(ERROR_MESSAGE,"get_FE_element_shape_of_face.  Failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_shape_of_face.  Invalid argument(s)");
	}
	LEAVE;

	return (face_shape);
} /* get_FE_element_shape_of_face */

int get_FE_element_shape_dimension(struct FE_element_shape *element_shape,
	int *dimension_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the dimension of <element_shape>.
If fails, puts zero at <dimension_address>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_shape_dimension);
	if (element_shape && dimension_address)
	{
		*dimension_address = element_shape->dimension;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_shape_dimension.  Invalid argument(s)");
		if (dimension_address)
		{
			*dimension_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_shape_dimension */

int FE_element_shape_find_face_number_for_xi(struct FE_element_shape *shape, 
	FE_value *xi, int *face_number)
/*******************************************************************************
LAST MODIFIED : 11 June 1999

DESCRIPTION :
This function checks to see if the given <xi> location (of dimension 
<shape>->dimension) specifys a location on a face.  If it does then the function
returns 1 and <face_number> is set.  Otherwise the function returns 0.
SAB Doesn't work for polygons at the moment.
==============================================================================*/
{
	int bit, i, j, return_code;
	float sum;

	ENTER(FE_element_shape_find_face_number_for_xi);

	if (shape&&face_number)
	{
		return_code = 0;
		for (i = 0 ; (!return_code) && (i < shape->number_of_faces) ; i++)
		{
			sum = 0.0;
			bit = 2;
			for (j = 0 ; j < shape->dimension ; j++)
			{
				if (shape->faces[i] & bit)
				{
					sum += xi[j];
				}
				bit *= 2;
			}
			if (shape->faces[i] & 1)
			{
				if (sum >= 1.0)
				{
					*face_number = i;
					return_code = 1;
				}
			}
			else
			{
				if (sum <= 0.0)
				{
					*face_number = i;
					return_code = 1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"find_face_number_of_face_type.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_shape_find_face_number_for_xi */

int get_FE_element_shape_xi_linkage_number(
	struct FE_element_shape *element_shape, int xi_number1, int xi_number2,
	int *xi_linkage_number_address)
/*******************************************************************************
LAST MODIFIED : 13 March 2003

DESCRIPTION :
Returns a number indicating how the dimension <xi_number1> and <xi_number2> are
linked in <element_shape>.
If they are linked in a simplex, a non-zero return indicates they are linked.
If they are linked in a polygon, the returned number is the number of sides in
the polygon.
A value of zero indicates the dimensions are not linked.
Note the first xi_number is 0.
==============================================================================*/
{
	int i, offset, return_code, tmp;

	ENTER(get_FE_element_shape_xi_linkage_number);
	if (element_shape && element_shape->type && xi_linkage_number_address &&
		(0 <= xi_number1) && (xi_number1 < element_shape->dimension) &&
		(0 <= xi_number2) && (xi_number2 < element_shape->dimension) &&
		(xi_number1 != xi_number2))
	{
		/* make sure xi_number1 < xi_number2 */
		if (xi_number2 < xi_number1)
		{
			tmp = xi_number1;
			xi_number1 = xi_number2;
			xi_number2 = tmp;
		}
		offset = 0;
		for (i = 0; i < xi_number1; i++)
		{
			offset += element_shape->dimension - i;
		}
		*xi_linkage_number_address =
			element_shape->type[offset + xi_number2 - xi_number1];
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_shape_xi_linkage_number.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_shape_xi_linkage_number */

int get_FE_element_shape_xi_shape_type(struct FE_element_shape *element_shape,
	int xi_number, enum FE_element_shape_type *shape_type_address)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Returns the shape type of <element_shape> on <xi_number> -- on main diagonal of
type array. The first xi_number is 0.
==============================================================================*/
{
	int i, offset, return_code;

	ENTER(get_FE_element_shape_xi_shape_type);
	if (element_shape && element_shape->type && (0 <= xi_number) &&
		(xi_number < element_shape->dimension) && shape_type_address)
	{
		offset = 0;
		for (i = 0; i < xi_number; i++)
		{
			offset += element_shape->dimension - i;
		}
		*shape_type_address =
			(enum FE_element_shape_type)(element_shape->type[offset]);
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_shape_xi_shape_type.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_shape_xi_shape_type */

int get_FE_element_shape_next_linked_xi_number(
	struct FE_element_shape *element_shape, int xi_number,
	int *next_xi_number_address, int *xi_link_number_address)
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Returns in <next_xi_number_address> the next xi number higher than <xi_number>
which is linked in shape with it, plus in <xi_link_number_address> the number
denoting how it is linked; currently used only for polygon shapes to denote the
number of polygon sides.
If there is no remaining linked dimension, 0 is returned in both addresses.
<xi_number> is from 0 to one less than the shape dimension.
Also checks that the linked xi numbers have the same shape type.
==============================================================================*/
{
	enum FE_element_shape_type shape_type;
	int i, limit, offset, return_code;

	ENTER(get_FE_element_shape_next_linked_xi_number);
	if (element_shape && element_shape->type &&
		(0 <= xi_number) && (xi_number < element_shape->dimension) &&
		next_xi_number_address && xi_link_number_address)
	{
		return_code = 1;
		offset = 0;
		for (i = 0; i < xi_number; i++)
		{
			offset += element_shape->dimension - i;
		}
		shape_type = (enum FE_element_shape_type)(element_shape->type[offset]);
		limit = element_shape->dimension - xi_number;
		offset++;
		for (i = 1; (i < limit) && (0 == element_shape->type[offset]); i++)
		{
			offset++;
		}
		if (i < limit)
		{
			*next_xi_number_address = i + xi_number;
			*xi_link_number_address = element_shape->type[offset];
			/* finally check the shape type matches */
			offset = 0;
			for (i = 0; i < *next_xi_number_address; i++)
			{
				offset += element_shape->dimension - i;
			}
			if ((enum FE_element_shape_type)element_shape->type[offset] != shape_type)
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_shape_next_linked_xi_number.  "
					"Shape has linked xi directions with different shape type");
				return_code = 0;
			}
		}
		else
		{
			*next_xi_number_address = 0;
			*xi_link_number_address = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_shape_next_linked_xi_number.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_shape_next_linked_xi_number */

int FE_element_shape_limit_xi_to_element(struct FE_element_shape *shape,
	FE_value *xi, FE_value tolerance)
/*******************************************************************************
LAST MODIFIED : 12 March 2003

DESCRIPTION :
Checks that the <xi> location is valid for elements with <shape>.
The <tolerance> allows the location to go slightly outside.  If the values for
<xi> location are further than <tolerance> outside the element then the values
are modified to put it on the nearest face.  
==============================================================================*/
{
	int i, return_code, simplex_dimensions, 
		simplex_direction[MAXIMUM_ELEMENT_XI_DIMENSIONS];
	FE_value delta;

	ENTER(FE_element_shape_limit_xi_to_element);
	if (shape && xi)
	{
		return_code = 1;
		/* determine whether the element is simplex to limit xi space */
		simplex_dimensions = 0;
		switch (shape->dimension)
		{
			case 2:
			{
				if (SIMPLEX_SHAPE == shape->type[0])
				{
					simplex_dimensions = 2;
					simplex_direction[0] = 0;
					simplex_direction[1] = 1;
				}
			} break;
			case 3:
			{
				if (SIMPLEX_SHAPE == shape->type[0])
				{
					if (LINE_SHAPE == shape->type[3])
					{
						simplex_dimensions = 2;
						simplex_direction[0] = 0;
						simplex_direction[1] = 2;
					}
					else if (LINE_SHAPE == shape->type[5])
					{
						simplex_dimensions = 2;
						simplex_direction[0] = 0;
						simplex_direction[1] = 1;
					}
					else
					{
						/* tetrahedron */
						simplex_dimensions = 3;
						simplex_direction[0] = 0;
						simplex_direction[1] = 1;
						simplex_direction[2] = 2;
					}
				}
				else if (SIMPLEX_SHAPE == shape->type[3])
				{
					simplex_dimensions = 2;
					simplex_direction[0] = 1;
					simplex_direction[1] = 2;
				}
			} break;
		}
		/* keep xi within simplex bounds plus tolerance */
		if (simplex_dimensions)
		{
			/* calculate distance out of element in xi space */
			delta = -1.0 - tolerance;
			for (i = 0; i < simplex_dimensions; i++)
			{
				delta += xi[simplex_direction[i]];
			}
			if (delta > 0.0)
			{
				/* subtract delta equally from all directions */
				delta /= simplex_dimensions;
				for (i = 0; i < simplex_dimensions; i++)
				{
					xi[simplex_direction[i]] -= delta;
				}
			}
		}
		/* keep xi within 0.0 to 1.0 bounds plus tolerance */
		for (i = 0; i < shape->dimension; i++)
		{
			if (xi[i] < -tolerance)
			{
				xi[i] = -tolerance;
			}
			else if (xi[i] > 1.0 + tolerance)
			{
				xi[i] = 1.0 + tolerance;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_shape_limit_xi_to_element.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_shape_limit_xi_to_element */

struct FE_element_parent *CREATE(FE_element_parent)(struct FE_element *parent,
	int face_number)
/*******************************************************************************
LAST MODIFIED : 23 April 1999

DESCRIPTION :
Creates element parent structure and assigns the fields.
==============================================================================*/
{
	struct FE_element_parent *element_parent;

	ENTER(CREATE(FE_element_parent));
	if (parent&&(0<=face_number)&&(parent->shape)&&
		(face_number<parent->shape->number_of_faces))
	{
		/* create new field */
		if (ALLOCATE(element_parent,struct FE_element_parent,1))
		{
			/* do not use access_FE_element so that can destroy element without
				destroying faces - FE_element_parent structures pointing to parent
				element are destroyed when the parent element is destroyed. */
			element_parent->parent = parent;
			element_parent->face_number=face_number;
			element_parent->access_count=0;
		}
		else
		{
			display_message(ERROR_MESSAGE,
		"CREATE(FE_element_parent).  Could not allocate memory for element parent");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_parent).  Invalid argument(s)");
		element_parent=(struct FE_element_parent *)NULL;
	}
	LEAVE;

	return (element_parent);
} /* CREATE(FE_element_parent) */

int DESTROY(FE_element_parent)(
	struct FE_element_parent **element_parent_address)
/*******************************************************************************
LAST MODIFIED : 23 April 1999

DESCRIPTION :
Frees the memory for the element parent structure and sets
<*element_parent_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent *element_parent;

	ENTER(DESTROY(FE_element_parent));
	if ((element_parent_address)&&(element_parent= *element_parent_address))
	{
		if (0==element_parent->access_count)
		{
			/* do not use deaccess_FE_element so that can destroy element without
				destroying faces - FE_element_parent structures pointing to parent
				element are destroyed when the parent element is destroyed. */
			DEALLOCATE(*element_parent_address);
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,"DESTROY(FE_element_parent).  "
				"Non-zero access_count %d",element_parent->access_count);
			return_code=0;
			*element_parent_address=(struct FE_element_parent *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_parent) */

DECLARE_OBJECT_FUNCTIONS(FE_element_parent)

DECLARE_LIST_FUNCTIONS(FE_element_parent)

DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_element_parent,parent, \
	struct FE_element *,compare_FE_element_parent_parent)

DECLARE_FIND_BY_IDENTIFIER_IN_LIST_FUNCTION(FE_element_parent,face_number,int, \
	compare_FE_element_parent_face_number)

static int FE_element_parent_element_matches_recursive(
	struct FE_element_parent *element_parent,void *match_element_void)
/*******************************************************************************
LAST MODIFIED : 29 June 1999

DESCRIPTION :
Returns true if the element referred to by <element_parent> or one of the
elements referred to by its parents matches the <match_element>. Called by
FE_element_get_top_level_element_conversion to check that a suggested
top_level_element is in fact valid.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_parent_element_matches_recursive);
	if (element_parent&&element_parent->parent&&match_element_void)
	{
		if ((element_parent->parent==(struct FE_element *)match_element_void)||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				match_element_void,element_parent->parent->parent_list))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_element_matches_recursive.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_element_matches_recursive */

static int FE_element_parent_is_exterior(
	struct FE_element_parent *element_parent, void *dummy_user_data)
/*******************************************************************************
LAST MODIFIED : 14 March 2003

DESCRIPTION :
Returns true if <element_parent> is an exterior surface (ie. has exactly one
parent).
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_parent_is_exterior);
	if (element_parent&&!dummy_user_data)
	{
		return_code=(1 == NUMBER_IN_LIST(FE_element_parent)(
			element_parent->parent->parent_list));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_is_exterior.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_is_exterior */

int FE_element_parent_has_face_number(struct FE_element_parent *element_parent,
	void *void_face_number)
/*******************************************************************************
LAST MODIFIED : 12 August 1997

DESCRIPTION :
Returns true if <element_parent> (a 2-D surface) has no parents itself, or
it is a face, with the given face_number, of one of its parent.
==============================================================================*/
{
	int face_number,return_code;
	struct FE_element *element;

	ENTER(FE_element_parent_has_face_number);
	if (element_parent&&(element=element_parent->parent))
	{
		face_number= *((int *)void_face_number);
		return_code=(
			(0<NUMBER_IN_LIST(FE_element_parent)(element->parent_list))&&
			((FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,face_number)(face_number,
				element->parent_list))));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_face_number.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_has_face_number */

static int FE_element_parent_is_in_list(
	struct FE_element_parent *element_parent, void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 1 June 2001

DESCRIPTION :
Returns true if the parent element referred to by the <element_parent> is in the
<element_list>. Note this is not recursive; it does not check parents' parents.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_parent_is_in_list);
	if (element_parent &&
		(element_list = (struct LIST(FE_element) *)element_list_void))
	{
		if (IS_OBJECT_IN_LIST(FE_element)(element_parent->parent, element_list))
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_is_in_list.  Invalid argument(s)");
		return_code = 0;
	}

	return (return_code);
} /* FE_element_parent_is_in_list */

static int FE_element_parent_element_in_list(
	struct FE_element_parent *element_parent,void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Returns true if the element referred to by <element_parent> is in the given
<element_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_parent_element_in_list);
	if (element_parent && element_parent->parent &&
		(element_list = (struct LIST(FE_element) *)element_list_void))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element_parent->parent->identifier,element_list))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_element_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_element_in_list */

struct FE_element_parent_face_of_element_in_list_data
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Used by FE_element_parent_face_of_element_in_list.
==============================================================================*/
{
	int face_number;
	struct LIST(FE_element) *element_list;
}; /* struct FE_element_parent_face_of_element_in_list_data */

static int FE_element_parent_face_of_element_in_list(
	struct FE_element_parent *element_parent,void *face_in_list_data_void)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Returns true if the <element_parent> refers to the given <face_number> of the
parent element AND the parent element is also in the <element_list>.
Conditional function for determining if a 1-D or 2-D element is on a particular
face of a 3-D element in the given element_list. Recursive to handle 1-D case.
If the element list is omitted, no check is made on membership in it.
Now also handles case of 2-D top-level elements.
==============================================================================*/
{
	int return_code;
	struct FE_element *parent;
	struct FE_element_parent_face_of_element_in_list_data *face_in_list_data;

	ENTER(FE_element_parent_face_of_element_in_list);
	if (element_parent && (parent = element_parent->parent) && parent->shape &&
		(face_in_list_data=(struct FE_element_parent_face_of_element_in_list_data *)
			face_in_list_data_void))
	{
		if ((2 == parent->shape->dimension) &&
			((struct FE_element_parent *)NULL !=
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					(LIST_CONDITIONAL_FUNCTION(FE_element_parent) *)NULL, (void *)NULL,
					parent->parent_list)))
		{
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_face_of_element_in_list,
				face_in_list_data_void,parent->parent_list))
			{
				return_code = 1;
			}
			else
			{
				return_code = 0;
			}
		}
		else
		{
			return_code =
				(element_parent->face_number == face_in_list_data->face_number) &&
				(!(face_in_list_data->element_list) ||
					FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
						parent->identifier, face_in_list_data->element_list));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_face_of_element_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_face_of_element_in_list */

int inherit_FE_element_field(struct FE_element *element,struct FE_field *field,
	struct FE_element_field **element_field_address,
	struct FE_element **field_element_address,
	FE_value **coordinate_transformation_address,
	struct FE_element *top_level_element);
/*******************************************************************************
LAST MODIFIED : 25 February 2003

DESCRIPTION :
Forward declaration.
==============================================================================*/

struct Field_defined_for_parent_data
{
	FE_value *coordinate_transformation;
	struct FE_element *field_element,*top_level_element;
	struct FE_element_field *element_field;
	struct FE_field *field;
}; /* struct Field_defined_for_parent_data */

static int field_defined_for_parent(struct FE_element_parent *parent,
	void *field_defined_for_parent_data)
/*******************************************************************************
LAST MODIFIED : 1 July 1999

DESCRIPTION :
Checks if the field is defined for the element referred to be the <parent>.
Now tries to inherit from a given <top_level_element>, if specified.
==============================================================================*/
{
	int return_code;
	struct Field_defined_for_parent_data *field_data;

	ENTER(field_defined_for_parent);
	if (parent&&(field_data=(struct Field_defined_for_parent_data *)
		field_defined_for_parent_data))
	{
		if ((!(field_data->top_level_element))||
			((parent->parent == field_data->top_level_element)||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				(void *)field_data->top_level_element,parent->parent->parent_list)))
		{
			if (return_code=inherit_FE_element_field(parent->parent,field_data->field,
				&(field_data->element_field),&(field_data->field_element),
				&(field_data->coordinate_transformation),field_data->top_level_element))
			{
				if (field_data->element_field)
				{
					return_code=1;
				}
				else
				{
					return_code=0;
				}
			}
			else
			{
				return_code=0;
			}
		}
		else
		{
			/* not inheriting from the given top_level_element */
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"field_defined_for_parent.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* field_defined_for_parent */

char *CM_element_type_string(enum CM_element_type cm_element_type)
/*******************************************************************************
LAST MODIFIED : 26 August 1999

DESCRIPTION :
Returns a static string describing the <cm_element_type>, eg. CM_LINE = 'line'.
Returned string must not be deallocated!
==============================================================================*/
{
	char *return_string;

	ENTER(CM_element_type_string);
	switch (cm_element_type)
	{
		case CM_ELEMENT:
		{
			return_string="element";
		} break;
		case CM_FACE:
		{
			return_string="face";
		} break;
		case CM_LINE:
		{
			return_string="line";
		} break;
		default:
		{
			display_message(ERROR_MESSAGE,
				"CM_element_type_string.  Unknown CM element type");
			return_string=(char *)NULL;
		} break;
	}
	LEAVE;

	return (return_string);
} /* CM_element_type_string */

int FE_element_to_element_string(struct FE_element *element,char **name_ptr)
/*******************************************************************************
LAST MODIFIED : 19 March 2003

DESCRIPTION :
Writes the cm.number of <element> into a newly allocated string and
points <*name_ptr> at it.
==============================================================================*/
{
	char temp_string[30];
	int return_code;

	ENTER(FE_element_to_element_string);
	if (element&&name_ptr)
	{
		sprintf(temp_string,"%d",element->cm.number);
		*name_ptr=duplicate_string(temp_string);
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_to_element_string.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_to_element_string */

struct FE_element *element_string_to_FE_element(char *name,
	struct LIST(FE_element) *element_list)
/*******************************************************************************
LAST MODIFIED : 19 March 2003

DESCRIPTION :
Converts the <name> into a CM_element_information.number sets 
CM_element_information.type to CM_ELEMENT, finds
and returns the element in the <element_list> with that CM_element_information.
==============================================================================*/
{
	struct FE_element *element;
	struct CM_element_information cm;

	ENTER(element_string_to_FE_element);
	if (name && element_list)
	{
		cm.number = atoi(name);
		cm.type = CM_ELEMENT;
		element = FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			&cm,element_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"element_string_to_FE_element.  Invalid argument(s)");
		element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (element);
} /* element_string_to_FE_element */

int FE_element_to_any_element_string(struct FE_element *element,
	char **name_ptr)
/*******************************************************************************
LAST MODIFIED : 19 March 2003

DESCRIPTION :
Writes the element as an allocated string containing TYPE NUMBER. Now does not
write element for CM_ELEMENT types.
==============================================================================*/
{
	char temp_string[30];
	int return_code;

	ENTER(FE_element_to_any_element_string);
	if (element&&name_ptr)
	{
		if (CM_ELEMENT==element->cm.type)
		{
			sprintf(temp_string,"%d",element->cm.number);
		}
		else
		{
			sprintf(temp_string,"%s %d",CM_element_type_string(element->cm.type),
				element->cm.number);
		}
		*name_ptr=duplicate_string(temp_string);
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_to_any_element_string.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_to_any_element_string */

struct FE_element *any_element_string_to_FE_element(char *name,
	struct LIST(FE_element) *element_list)
/*******************************************************************************
LAST MODIFIED : 19 March 2003

DESCRIPTION :
Converts name string of format "TYPE NUMBER" to a CM_element_information and
returns the element in the <element_list> with that CM_element_information.
==============================================================================*/
{
	char *number_string, *type_string;
	struct FE_element *element;
	struct CM_element_information cm;

	ENTER(any_element_string_to_FE_element);
	element = (struct FE_element *)NULL;
	if (name && element_list)
	{
		if (type_string = strpbrk(name,"eEfFlL"))
		{
			if (('l' == *type_string)||('L' == *type_string))
			{
				cm.type = CM_LINE;
			}
			else if (('f' == *type_string)||('F' == *type_string))
			{
				cm.type = CM_FACE;
			}
			else
			{
				cm.type = CM_ELEMENT;
			}
		}
		else
		{
			cm.type = CM_ELEMENT;
		}
		if (number_string = strpbrk(name,"+-0123456789"))
		{
			cm.number = atoi(number_string);
			element = FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
				&cm, element_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"any_element_string_to_FE_element.  Invalid argument(s)");
	}
	LEAVE;

	return (element);
} /* any_element_string_to_FE_element */

static int set_FE_element_shape(struct FE_element *element,
	struct FE_element_shape *shape)
/*******************************************************************************
LAST MODIFIED : 11 October 2002

DESCRIPTION :
Sets the <shape> of <element>. Note that the element must not currently have a
shape in order for this to be set, ie. just created. Allocates and clears the
faces array in the element, so this must be clear too.
Only called by CREATE FE_element.
==============================================================================*/
{
	int i,return_code;
	struct FE_element **faces;

	ENTER(set_FE_element_shape);
	return_code=0;
	if (element&&shape&&(0<=shape->number_of_faces))
	{
		if (element->shape||element->faces)
		{
			display_message(ERROR_MESSAGE,
				"set_FE_element_shape.  Element already has shape/faces");
		}
		else
		{
			faces=(struct FE_element **)NULL;
			if ((0==shape->number_of_faces)||
				ALLOCATE(faces,struct FE_element *,shape->number_of_faces))
			{
				/* clear the faces */
				for (i=0;i<shape->number_of_faces;i++)
				{
					faces[i] = (struct FE_element *)NULL;
				}
				element->faces=faces;
				element->shape=ACCESS(FE_element_shape)(shape);
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_element_shape.  Not enough memory for faces");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_shape.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_shape */

struct FE_element *CREATE(FE_element)(struct CM_element_information *cm,
	struct FE_element_shape *element_shape,
	struct FE_region *fe_region, struct FE_element *template_element)
/*******************************************************************************
LAST MODIFIED : 20 February 2003

DESCRIPTION :
Creates and returns an element with the specified <cm> identifier.
If <fe_region> is supplied a blank element with the given identifier but no
fields is returned. If <template_element> is supplied, a copy of it, including
all fields and values but with the new identifier, is returned.
Exactly one of <fe_region> or <template_element> must be supplied.
The <element_shape> is required unless a <template_element> is supplied.
The new element is set to belong to the ultimate master FE_region of <fe_region>
if supplied, or to the same master FE_region as <template_element> if supplied.
Note that the element number in <cm> must be non-negative.
==============================================================================*/
{
	int i, number_of_faces, return_code;
	struct FE_element *element;

	ENTER(CREATE(FE_element));
	element = (struct FE_element *)NULL;
	if (cm && (0 <= cm->number) && ((template_element && (!fe_region)) ||
		((!template_element) && fe_region && element_shape)))
	{
		if (ALLOCATE(element, struct FE_element, 1))
		{
			return_code = 1;
			/* clear the new element so we can destroy it if anything fails */
			element->cm.type = cm->type;
			element->cm.number = cm->number;
			/* used for find_by_identifier function */
			element->identifier = &(element->cm);
			element->shape = (struct FE_element_shape *)NULL;
			element->faces = (struct FE_element **)NULL;
			element->fields = (struct FE_element_field_info *)NULL;
			element->information = (struct FE_element_node_scale_field_info *)NULL;
			if (!(element->parent_list = CREATE(LIST(FE_element_parent))()))
			{
				display_message(ERROR_MESSAGE,
					"CREATE(FE_element).  Could not create parent list");
				return_code = 0;
			}
			element->access_count = 0;
			if (template_element)
			{
				if (set_FE_element_shape(element, template_element->shape))
				{
					if (0 < (number_of_faces =
						template_element->shape->number_of_faces))
					{
						if (template_element->faces)
						{
							for (i = 0; (i < number_of_faces) && return_code; i++)
							{
								if (template_element->faces[i])
								{
									if (!set_FE_element_face(element, i,
										template_element->faces[i]))
									{
										display_message(ERROR_MESSAGE, "CREATE(FE_element).  "
											"Could not set face from template element");
										return_code = 0;
									}
								}
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"CREATE(FE_element).  Invalid faces in template element");
							return_code = 0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_element).  Could not set shape from template element");
					return_code = 0;
				}
				if (!(element->fields =
					ACCESS(FE_element_field_info)(template_element->fields)))
				{
					display_message(ERROR_MESSAGE, "CREATE(FE_element).  "
						"Could not set field info from template element");
					return_code = 0;
				}
				if (template_element->information)
				{
					if (!(element->information =
						create_FE_element_node_scale_field_info_from_contents(
							template_element->information->values_storage_size,
							template_element->information->values_storage,
							template_element->information->number_of_nodes,
							template_element->information->nodes,
							template_element->information->number_of_scale_factor_sets,
							template_element->information->scale_factor_set_identifiers,
							template_element->information->numbers_in_scale_factor_sets,
							template_element->information->number_of_scale_factors,
							template_element->information->scale_factors,
							template_element->fields)))
					{
						display_message(ERROR_MESSAGE,"CREATE(FE_element).  "
							"Could not copy node scale field info from template element");
						return_code = 0;
					}
				}
			}
			else
			{
				if (!set_FE_element_shape(element, element_shape))
				{
					display_message(ERROR_MESSAGE,
						"CREATE(FE_element).  Could not set element shape");
					return_code = 0;
				}
				if (!(element->fields = ACCESS(FE_element_field_info)(
					FE_region_get_FE_element_field_info(fe_region,
						(struct LIST(FE_element_field) *)NULL))))
				{
					display_message(ERROR_MESSAGE, "CREATE(FE_element).  "
						"FE_region could not supply element field info");
					return_code = 0;
				}
			}
			if (!return_code)
			{
				DESTROY(FE_element)(&element);
				element = (struct FE_element *)NULL;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"CREATE(FE_element).  Could not allocate memory for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE, "CREATE(FE_element).  Invalid argument(s)");
	}
	LEAVE;

	return (element);
} /* CREATE(FE_element) */

int DESTROY(FE_element)(struct FE_element **element_address)
/*******************************************************************************
LAST MODIFIED : 24 March 2003

DESCRIPTION :
Frees the memory for the element, sets <*element_address> to NULL.
==============================================================================*/
{
	int i,return_code;
	struct FE_element *element,**face;
	struct FE_element_parent *face_parent;

	ENTER(DESTROY(FE_element));
	if ((element_address)&&(element= *element_address))
	{
		if (0 == element->access_count)
		{
			if (face=element->faces)
			{
				for (i=element->shape->number_of_faces;i>0;i--)
				{
					if (*face)
					{
						if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
							parent)(element,(*face)->parent_list))
						{
							REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
								(*face)->parent_list);
						}
						(void)DEACCESS(FE_element)(face);
					}
					face++;
				}
			}
			DEALLOCATE(element->faces);
			DEACCESS(FE_element_shape)(&(element->shape));
			if (element->information)
			{
				clean_up_FE_element_node_scale_field_info(&(element->information),
					element->fields);
			}
			DEACCESS(FE_element_field_info)(&(element->fields));
			/* parent_list should be an empty list */
			DESTROY_LIST(FE_element_parent)(&(element->parent_list));
			/* free the memory associated with the element */
			DEALLOCATE(*element_address);
			return_code = 1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"DESTROY(FE_element).  Element has non-zero access count %d",
				element->access_count);
			*element_address=(struct FE_element *)NULL;
		}
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element) */

#if defined (OLD_CODE)
PROTOTYPE_COPY_OBJECT_FUNCTION(FE_element)
/*******************************************************************************
LAST MODIFIED : 9 February 1999

DESCRIPTION :
Creates an EXACT copy of the element.
==============================================================================*/
{
	int i,number_of_faces,return_code;
	struct FE_element **element_face,**face;
	struct FE_element_parent *face_parent;

	ENTER(COPY(FE_element));
	return_code=0;
	/* check the arguments */
	if (source&&destination)
	{
		if (destination->shape)
		{
			/* free the old element values */
			face=destination->faces;
			for (i=destination->shape->number_of_faces;i>0;i--)
			{
				if (*face)
				{
					if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
						parent)(destination,(*face)->parent_list))
					{
						REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
							(*face)->parent_list);
					}
					(void)DEACCESS(FE_element)(face);
				}
				face++;
			}
			DEALLOCATE(destination->faces);
			(void)DEACCESS(FE_element_shape)(&(destination->shape));
		}
		(void)clean_up_FE_element_node_scale_field_info(
			&(destination->information), destination->fields);
		/* copy the new */
		destination->cm.number=source->cm.number;
		destination->cm.type=source->cm.type;

		destination->shape=ACCESS(FE_element_shape)(source->shape);
		/* duplicate the element information */
		if (!(destination->information=source->information)||
			(destination->information=create_FE_element_node_scale_field_info_from_contents(
			source->information->values_storage_size,
			source->information->values_storage,
			source->information->number_of_nodes,
			source->information->nodes,
			source->information->number_of_scale_factor_sets,
			source->information->scale_factor_set_identifiers,
			source->information->numbers_in_scale_factor_sets,
			source->information->number_of_scale_factors,
			source->information->scale_factors,
			source->fields)))
		{
			/* add the faces */
			if ((number_of_faces=source->shape->number_of_faces)>0)
			{
				if (ALLOCATE(element_face,struct FE_element *,number_of_faces))
				{
					destination->faces=element_face;
					face=source->faces;
					i=0;
					while ((destination->faces)&&(i<number_of_faces))
					{
						if (*face)
						{
							if (face_parent=CREATE(FE_element_parent)(destination,i))
							{
								if (ADD_OBJECT_TO_LIST(FE_element_parent)(face_parent,
									(*face)->parent_list))
								{
									(*element_face)=ACCESS(FE_element)(*face);
									element_face++;
									face++;
									i++;
								}
								else
								{
									display_message(ERROR_MESSAGE,
								"COPY(FE_element).  Could not add element to face parent list");
									DESTROY(FE_element_parent)(&face_parent);
									while (i>0)
									{
										element_face--;
										i--;
										if (face_parent=
											FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
											parent)(destination,(*element_face)->parent_list))
										{
											REMOVE_OBJECT_FROM_LIST(FE_element_parent)(
												face_parent,(*element_face)->parent_list);
										}
										DEACCESS(FE_element)(element_face);
									}
									DEALLOCATE(destination->faces);
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"COPY(FE_element).  Could not create face parent");
								while (i>0)
								{
									element_face--;
									i--;
									if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(
										FE_element_parent,parent)(destination,
										(*element_face)->parent_list))
									{
										REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
											(*element_face)->parent_list);
									}
									DEACCESS(FE_element)(element_face);
								}
								DEALLOCATE(destination->faces);
							}
						}
						else
						{
							*element_face=(struct FE_element *)NULL;
							element_face++;
							face++;
							i++;
						}
					}
					if (destination->faces)
					{
						return_code=1;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"COPY(FE_element).  Could not allocate memory for faces");
				}
			}
			else
			{
				destination->faces=(struct FE_element **)NULL;
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"COPY(FE_element).  Could not create element information");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"COPY(FE_element).  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* COPY(FE_element) */
#endif /* defined (OLD_CODE) */

DECLARE_OBJECT_FUNCTIONS(FE_element)

DECLARE_INDEXED_LIST_FUNCTIONS(FE_element)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_element, \
	identifier,struct CM_element_information *, \
	compare_CM_element_information)
DECLARE_INDEXED_LIST_IDENTIFIER_CHANGE_FUNCTIONS(FE_element,identifier)

DECLARE_CHANGE_LOG_FUNCTIONS(FE_element)

#if defined (OLD_CODE)
PROTOTYPE_MANAGER_COPY_WITH_IDENTIFIER_FUNCTION(FE_element,identifier)
{
	int return_code;

	ENTER(MANAGER_COPY_WITH_IDENTIFIER(FE_element,identifier));
	if (source&&destination)
	{
		if (return_code=MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,
			identifier)(destination,source))
		{
			destination->cm.type=source->cm.type;
			destination->cm.number=source->cm.number;	
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
"MANAGER_COPY_WITH_IDENTIFIER(FE_element,identifier).  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITH_IDENTIFIER(FE_element,identifier) */

PROTOTYPE_MANAGER_COPY_WITHOUT_IDENTIFIER_FUNCTION(FE_element,identifier)
{
	int i,number_of_faces,return_code;
	struct FE_element **element_face,**face;
	struct FE_element_parent *face_parent;

	ENTER(MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier));
	return_code=0;
	if (destination&&source&&(destination != source))
	{
		if (destination->shape)
		{
			/* free the old element values */
			face=destination->faces;
			for (i=destination->shape->number_of_faces;i>0;i--)
			{
				if (*face)
				{
					if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
						parent)(destination,(*face)->parent_list))
					{
						REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
							(*face)->parent_list);
					}
					(void)DEACCESS(FE_element)(face);
				}
				face++;
			}
			DEALLOCATE(destination->faces);
			(void)DEACCESS(FE_element_shape)(&(destination->shape));
		}
		(void)clean_up_FE_element_node_scale_field_info(
			&(destination->information), destination->fields);
		/* copy the new */
		destination->shape=ACCESS(FE_element_shape)(source->shape);
		/* duplicate the element information */
		if (!(destination->information=source->information)||
			(destination->information=create_FE_element_node_scale_field_info_from_contents(
			source->information->values_storage_size,
			source->information->values_storage,
			source->information->number_of_nodes,
			source->information->nodes,
			source->information->number_of_scale_factor_sets,
			source->information->scale_factor_set_identifiers,
			source->information->numbers_in_scale_factor_sets,
			source->information->number_of_scale_factors,
			source->information->scale_factors,
			source->fields)))
		{
			/* add the faces */
			if ((number_of_faces=source->shape->number_of_faces)>0)
			{
				if (ALLOCATE(element_face,struct FE_element *,number_of_faces))
				{
					destination->faces=element_face;
					face=source->faces;
					i=0;
					while ((destination->faces)&&(i<number_of_faces))
					{
						if (*face)
						{
							if (face_parent=CREATE(FE_element_parent)(destination,i))
							{
								if (ADD_OBJECT_TO_LIST(FE_element_parent)(face_parent,
									(*face)->parent_list))
								{
									(*element_face)=ACCESS(FE_element)(*face);
									element_face++;
									face++;
									i++;
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
										"Could not add element to face parent list");
									DESTROY(FE_element_parent)(&face_parent);
									while (i>0)
									{
										element_face--;
										i--;
										if (face_parent=
											FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
											parent)(destination,(*element_face)->parent_list))
										{
											REMOVE_OBJECT_FROM_LIST(FE_element_parent)(
												face_parent,(*element_face)->parent_list);
										}
										DEACCESS(FE_element)(element_face);
									}
									DEALLOCATE(destination->faces);
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
									"Could not create face parent");
								while (i>0)
								{
									element_face--;
									i--;
									if (face_parent=
										FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,parent)(
											destination,(*element_face)->parent_list))
									{
										REMOVE_OBJECT_FROM_LIST(FE_element_parent)(face_parent,
											(*element_face)->parent_list);
									}
									DEACCESS(FE_element)(element_face);
								}
								DEALLOCATE(destination->faces);
							}
						}
						else
						{
							*element_face=(struct FE_element *)NULL;
							element_face++;
							face++;
							i++;
						}
					}
					if (destination->faces)
					{
						return_code=1;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
						"Could not allocate memory for faces");
				}
			}
			else
			{
				destination->faces=(struct FE_element **)NULL;
				return_code=1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
				"Could not create element information");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier).  "
			"Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* MANAGER_COPY_WITHOUT_IDENTIFIER(FE_element,identifier) */
#endif /* defined (OLD_CODE) */

int inherit_FE_element_field(struct FE_element *element,struct FE_field *field,
	struct FE_element_field **element_field_address,
	struct FE_element **field_element_address,
	FE_value **coordinate_transformation_address,
	struct FE_element *top_level_element)
/*******************************************************************************
LAST MODIFIED : 23 November 2001

DESCRIPTION :
If <field> is NULL, element values are calculated for the coordinate field.
The optional <top_level_element> forces inheritance from it as needed.
If the dimension of <element> is less than that of the <field_element> from
which the field is inherited, then a <coordinate_transformation> is returned.
This consist of a matrix of dimension(field_element) rows X dimension(element)+1
columns. This represents an affine transformation, b + A xi for calculating the
field_element xi coordinates from those of <element>, where b is the first
column of the <coordinate_transformation> matrix.
==============================================================================*/
{
	FE_value *coordinate_transformation,*coordinate_transformation_value,
		*face_to_element,*face_to_element_value,*new_coordinate_transformation,
		*new_coordinate_transformation_value;
	int dimension,dimension_minus_1,face_number,field_element_dimension,i,j,k,
		return_code,transformation_size;
	struct FE_element *field_element,*parent;
	struct FE_element_field *element_field;
	struct FE_element_field_info *field_info;
	struct FE_element_parent *element_parent;
	struct Field_defined_for_parent_data field_defined_for_parent_data;
#if defined (DOUBLE_FOR_DOT_PRODUCT)
	double sum;
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
	FE_value sum;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */

	ENTER(inherit_FE_element_field);
#if defined (DEBUG)
	/*???debug */
	printf("enter inherit_FE_element_field\n");
#endif /* defined (DEBUG) */
	/* check the arguments */
	if (element&&(element->shape)&&element_field_address&&field_element_address&&
		coordinate_transformation_address)
	{
		/* initialize values to be returned on success */
		element_field=(struct FE_element_field *)NULL;
		field_element=(struct FE_element *)NULL;
		coordinate_transformation=(FE_value *)NULL;
#if defined (DEBUG)
		/*???debug */
		printf("element %d \n",element->cm.number);
#endif /* defined (DEBUG) */
		/* check if the field is defined for the element */
		if ((field_info = element->fields) && element->information)
		{
			if (field)
			{
				element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,
					field)(field,field_info->element_field_list);
				return_code=1;
			}
			else
			{
				/* if <field> is NULL check for a coordinate field */
				element_field=FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
					FE_element_field_is_coordinate_field,(void *)NULL,
					field_info->element_field_list);
				return_code=1;
			}
		}
		else
		{
			element_field=(struct FE_element_field *)NULL;
			return_code=1;
		}
		if (return_code)
		{
			if (element_field)
			{
				coordinate_transformation=(FE_value *)NULL;
				field_element=element;
			}
			else
			{
				/* check if the field is defined for any of the element's parents */
				field_defined_for_parent_data.field=field;
				field_defined_for_parent_data.field_element=(struct FE_element *)NULL;
				field_defined_for_parent_data.element_field=
					(struct FE_element_field *)NULL;
				field_defined_for_parent_data.coordinate_transformation=
					(FE_value *)NULL;
				/*???RC  Begin change to allow inheriting off given top_level_element */
				field_defined_for_parent_data.top_level_element=top_level_element;
				/*???RC  End change to allow inheriting off given top_level_element */
				if (element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					field_defined_for_parent,(void *)(&field_defined_for_parent_data),
					element->parent_list))
				{
					element_field=field_defined_for_parent_data.element_field;
					field_element=field_defined_for_parent_data.field_element;
					coordinate_transformation=
						field_defined_for_parent_data.coordinate_transformation;
					parent=element_parent->parent;
					face_number=element_parent->face_number;
					dimension=parent->shape->dimension;
					field_element_dimension=field_element->shape->dimension;
#if defined (DEBUG)
					/*???debug */
					printf("shape %p\n",parent->shape);
					face_to_element_value=(parent->shape->face_to_element);
					printf("face_number = %d\n",face_number);
					for (i=0;i<parent->shape->number_of_faces;i++)
					{
						printf("face %d\n",i);
						for (j=dimension;j>0;j--)
						{
							for (k=dimension;k>0;k--)
							{
								printf(" %g",*face_to_element_value);
								face_to_element_value++;
							}
							printf("\n");
						}
					}
#endif /* defined (DEBUG) */
					if (coordinate_transformation)
					{
						if (ALLOCATE(new_coordinate_transformation,FE_value,
							field_element_dimension*dimension))
						{
							/* incorporate the face to element map in the coordinate
								transformation */
							face_to_element=(parent->shape->face_to_element)+
								(face_number*dimension*dimension);
#if defined (DEBUG)
							/*???debug */
							printf("face to element:\n");
							face_to_element_value=face_to_element;
							for (i=dimension;i>0;i--)
							{
								for (j=dimension;j>0;j--)
								{
									printf(" %g",*face_to_element_value);
									face_to_element_value++;
								}
								printf("\n");
							}
#endif /* defined (DEBUG) */
#if defined (DEBUG)
							/*???debug */
							printf("new coordinate transformation:\n");
#endif /* defined (DEBUG) */
							coordinate_transformation_value=coordinate_transformation;
							new_coordinate_transformation_value=
								new_coordinate_transformation;
							dimension_minus_1=dimension-1;
							for (i=field_element_dimension;i>0;i--)
							{
								/* calculate b entry for this row */
#if defined (DOUBLE_FOR_DOT_PRODUCT)
								sum=(double)(*coordinate_transformation_value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
								sum= *coordinate_transformation_value;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
								coordinate_transformation_value++;
								face_to_element_value=face_to_element;
								for (k=dimension;k>0;k--)
								{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
									sum += (double)(*coordinate_transformation_value)*
										(double)(*face_to_element_value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									sum += (*coordinate_transformation_value)*
										(*face_to_element_value);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									coordinate_transformation_value++;
									face_to_element_value += dimension;
								}
								*new_coordinate_transformation_value=(FE_value)sum;
#if defined (DEBUG)
								/*???debug */
								printf(" %g",sum);
#endif /* defined (DEBUG) */
								new_coordinate_transformation_value++;
								/* calculate A entries for this row */
								for (j=dimension_minus_1;j>0;j--)
								{
									face_to_element++;
									face_to_element_value=face_to_element;
									coordinate_transformation_value -= dimension;
									sum=0;
									for (k=dimension;k>0;k--)
									{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
										sum += (double)(*coordinate_transformation_value)*
											(double)(*face_to_element_value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
										sum += (*coordinate_transformation_value)*
											(*face_to_element_value);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
										coordinate_transformation_value++;
										face_to_element_value += dimension;
									}
									*new_coordinate_transformation_value=(FE_value)sum;
#if defined (DEBUG)
									/*???debug */
									printf(" %g",sum);
#endif /* defined (DEBUG) */
									new_coordinate_transformation_value++;
								}
#if defined (DEBUG)
								/*???debug */
								printf("\n");
#endif /* defined (DEBUG) */
								face_to_element -= dimension_minus_1;
							}
							DEALLOCATE(coordinate_transformation);
							coordinate_transformation=new_coordinate_transformation;
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"inherit_FE_element_field.  Insufficient memory");
							DEALLOCATE(coordinate_transformation);
							return_code=0;
						}
					}
					else
					{
#if defined (DEBUG)
						/*???debug */
						printf("new coordinate transformation %d %d :\n",dimension,
							field_element_dimension);
#endif /* defined (DEBUG) */
						/* use the face to element map as the transformation */
						transformation_size=field_element_dimension*dimension;
						if (ALLOCATE(coordinate_transformation,FE_value,
							transformation_size))
						{
							coordinate_transformation_value=coordinate_transformation;
							face_to_element_value=(parent->shape->face_to_element)+
								(face_number*transformation_size);
							while (transformation_size>0)
							{
								*coordinate_transformation_value= *face_to_element_value;
#if defined (DEBUG)
								/*???debug */
								printf(" %g",*face_to_element_value);
#endif /* defined (DEBUG) */
								coordinate_transformation_value++;
								face_to_element_value++;
								transformation_size--;
#if defined (DEBUG)
								/*???debug */
								if (0==transformation_size%dimension)
								{
									printf("\n");
								}
#endif /* defined (DEBUG) */
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"inherit_FE_element_field.  Insufficient memory");
							return_code=0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"inherit_FE_element_field.  Field not defined for parent");
					return_code=0;
				}
			}
		}
		if (return_code)
		{
			/* guarantee this function returns element_field and field_element */
			if (element_field&&field_element)
			{
				*element_field_address=element_field;
				*field_element_address=field_element;
				*coordinate_transformation_address=coordinate_transformation;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"inherit_FE_element_field.  No element_field or field_element");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"inherit_FE_element_field.  Invalid argument(s)");
		return_code=0;
	}
#if defined (DEBUG)
	/*???debug */
	printf("leave inherit_FE_element_field\n");
#endif /* defined (DEBUG) */
	LEAVE;

	return (return_code);
} /* inherit_FE_element_field */

struct Adjacent_element_data
{
	struct FE_element *element;
	int number_of_adjacent_elements;
	struct FE_element **adjacent_elements;
};

static int FE_element_parent_adjacent_elements(struct FE_element_parent *parent,
	void *adjacent_element_data_void)
/*******************************************************************************
LAST MODIFIED : 27 October 2000

DESCRIPTION :
Adds the element to the adjacent_elements array in the data if the 
<parent> element is not the element.
==============================================================================*/
{
	int return_code;
	struct Adjacent_element_data *data;
	struct FE_element **new_array;

	ENTER(FE_element_parent_adjacent_elements);
	if (parent&&(data = (struct Adjacent_element_data *)adjacent_element_data_void)
		&& data->element)
	{
		return_code = 1;
		if (parent->parent!=data->element)
		{
			if (REALLOCATE(new_array, data->adjacent_elements,
				struct FE_element *, data->number_of_adjacent_elements + 1))
			{
				new_array[data->number_of_adjacent_elements] = parent->parent;
				data->adjacent_elements = new_array;
				data->number_of_adjacent_elements++;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_parent_adjacent_elements.  Unable to reallocate array");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_adjacent_elements.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_adjacent_elements */

int adjacent_FE_element(struct FE_element *element,
	int face_number, int *number_of_adjacent_elements, 
	struct FE_element ***adjacent_elements)
/*******************************************************************************
LAST MODIFIED : 27 October 2000

DESCRIPTION :
Returns the list of <adjacent_elements> not including <element> which share the 
face indicated by <face_number>.  <adjacent_elements> is ALLOCATED to the 
correct size and should be DEALLOCATED when finished with.
==============================================================================*/
{
	int return_code;
	struct Adjacent_element_data data;

	ENTER(adjacent_FE_element);
	if (element&&(element->shape)&&(element->faces))
	{
		if ((0<=face_number)&&(face_number<element->shape->number_of_faces)&&
			 ((element->faces)[face_number]))
		{
			data.element = element;
			data.number_of_adjacent_elements = 0;
			data.adjacent_elements = (struct FE_element **)NULL;
			if (FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
				FE_element_parent_adjacent_elements,(void *)&data,
				((element->faces)[face_number])->parent_list))
			{
				if (data.number_of_adjacent_elements)
				{
					*adjacent_elements=data.adjacent_elements;
					*number_of_adjacent_elements = data.number_of_adjacent_elements;
					return_code = 1;
				}
				else
				{
					return_code = 0;
				}
			}
			else
			{
				return_code = 0;
			}
		}
		else
		{
			/* In the generic heart mesh there are elements that
				do not have faces defined this isn't an error */
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"adjacent_FE_element.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* adjacent_FE_element */

struct FE_element_parent_log_FE_field_changes_data
/*******************************************************************************
LAST MODIFIED : 14 April 2003

DESCRIPTION :
Data for passing to FE_element_parent_log_FE_field_changes.
==============================================================================*/
{
	struct CHANGE_LOG(FE_field) *fe_field_change_log;
	struct FE_element_field_info **last_fe_element_field_info_address;
};

static int FE_element_parent_log_FE_field_changes(
	struct FE_element_parent *element_parent, void *parent_data_void)
/*******************************************************************************
LAST MODIFIED : 14 April 2003

DESCRIPTION :
Calls FE_element_log_FE_field_changes for the <element_parent>.
If the element in <element_parent> is in <element_list>, increments <count>.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_log_FE_field_changes_data *parent_data;

	ENTER(FE_element_parent_log_FE_field_changes);
	if (element_parent && (parent_data =
		(struct FE_element_parent_log_FE_field_changes_data *)parent_data_void))
	{
		return_code = FE_element_log_FE_field_changes(element_parent->parent,
			parent_data->fe_field_change_log,
			parent_data->last_fe_element_field_info_address);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_log_FE_field_changes.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_log_FE_field_changes */

int FE_element_log_FE_field_changes(struct FE_element *element,
	struct CHANGE_LOG(FE_field) *fe_field_change_log,
	struct FE_element_field_info **last_fe_element_field_info_address)
/*******************************************************************************
LAST MODIFIED : 14 April 2003

DESCRIPTION :
Marks each FE_field defined in <element> as RELATED_OBJECT_CHANGED in
<fe_field_change_log>. Recursively calls the same for each parent element.
For efficiency, maintains in <last_fe_element_field_info_address> the last
FE_element_field_info which had fields in it and was output. The last such
output FE_element_field_info is expected to be at this address too.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_log_FE_field_changes_data parent_data;

	ENTER(FE_element_log_FE_field_changes);
	if (element && element->fields && fe_field_change_log &&
		last_fe_element_field_info_address)
	{
		return_code = 1;
		/* log fields in this element, if any, and if different set from last */
		if (element->fields != (*last_fe_element_field_info_address))
		{
			if (0 < NUMBER_IN_LIST(FE_element_field)(
				element->fields->element_field_list))
			{
				if (!FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
					FE_element_field_log_FE_field_change, (void *)fe_field_change_log,
					element->fields->element_field_list))
				{
					return_code = 0;
				}
				*last_fe_element_field_info_address = element->fields;
			}
		}
		/* log fields in parent elements */
		parent_data.fe_field_change_log = fe_field_change_log;
		parent_data.last_fe_element_field_info_address =
			last_fe_element_field_info_address;
		if (!FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
			FE_element_parent_log_FE_field_changes, (void *)&parent_data,
			element->parent_list))
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_log_FE_field_changes.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_log_FE_field_changes */

int FE_element_meets_topological_criteria(struct FE_element *element,
	int dimension, enum CM_element_type cm_element_type, int exterior,
	int face_number, struct LIST(FE_element) *element_list)
/*******************************************************************************
LAST MODIFIED : 14 March 2003

DESCRIPTION :
Returns true if <element> meets all the supplied criteria:
- it has the given <dimension> OR <cm_element_type>;
- it is an exterior face or line of its contiguous mesh if <exterior> set;
- it is on the <face_number> of a parent element if <face_number> non-negative,
  and if <element_list> is supplied the parent element must be in it as well.
Note that <exterior> and <face_number> requirements are ignored if they make no
sense for the element, eg. for n-D elements in an n-D mesh.
???RC Only complete up to 3-D.
==============================================================================*/
{
	int number_of_parents, return_code;
	struct FE_element_parent_face_of_element_in_list_data face_in_list_data;

	ENTER(FE_element_meets_topological_criteria);
	return_code = 0;
	if (element)
	{
		if ((dimension == get_FE_element_dimension(element)) ||
			(cm_element_type == element->cm.type))
		{
			return_code = 1;
			if ((0 < (number_of_parents =
				NUMBER_IN_LIST(FE_element_parent)(element->parent_list))))
			{
				if (3 > dimension)
				{
					/* test for exterior element */
					if (exterior)
					{
						if (!((1 == number_of_parents) ||
							((1 == dimension) && FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
								FE_element_parent_is_exterior, (void *)NULL,
								element->parent_list))))
						{
							return_code = 0;
						}
					}
					/* test for on correct face */
					if (return_code && (0 <= face_number))
					{
						face_in_list_data.face_number = face_number;
						face_in_list_data.element_list = element_list;
						if (!FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
							FE_element_parent_face_of_element_in_list,
							(void *)&face_in_list_data, element->parent_list))
						{
							return_code = 0;
						}
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_meets_topological_criteria.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_meets_topological_criteria */

struct FE_element_field_values *CREATE(FE_element_field_values)(void)
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
Creates a blank struct FE_element_field_values which can be passed to
calculate_FE_element_field_values. The structure can be restored to its
blank state by calling clear_FE_element_field_values; this should be done
before calling calculate_FE_element_field_values again, and if leaving the
structure unused for some time so it is not accessing objects.
==============================================================================*/
{
	struct FE_element_field_values *element_field_values;

	ENTER(CREATE(FE_element_field_values));
	if (ALLOCATE(element_field_values, struct FE_element_field_values, 1))
	{
		/* clear the contents of the structure */
		element_field_values->field = (struct FE_field *)NULL;
		element_field_values->element = (struct FE_element *)NULL;
		element_field_values->field_element = (struct FE_element *)NULL;
		element_field_values->time_dependent = 0;
		element_field_values->time = 0.0;
		element_field_values->number_in_xi = (int *)NULL;
		element_field_values->derivatives_calculated = 0;
		element_field_values->no_modify = (char)0;
		element_field_values->destroy_standard_basis_arguments = 0;
		element_field_values->number_of_components = 0;
		element_field_values->component_number_of_values = (int *)NULL;
		element_field_values->component_grid_values_storage =
			(Value_storage **)NULL;
		element_field_values->base_grid_offset = 0;
		element_field_values->grid_offset_in_xi = (int *)NULL;
		element_field_values->element_value_offsets = (int *)NULL;
		element_field_values->component_values = (FE_value **)NULL;
		element_field_values->component_standard_basis_functions =
			(Standard_basis_function **)NULL;
		element_field_values->component_standard_basis_function_arguments =
			(void *)NULL;
		element_field_values->basis_function_values = (FE_value *)NULL;
		element_field_values->access_count = 0;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_element_field_values).  Could not allocate structure");
	}
	LEAVE;

	return (element_field_values);
} /* CREATE(FE_element_field_values) */

int calculate_FE_element_field_values(struct FE_element *element,
	struct FE_field *field, FE_value time, char calculate_derivatives,
	struct FE_element_field_values *element_field_values,
	struct FE_element *top_level_element)
/*******************************************************************************
LAST MODIFIED : 10 April 2008

DESCRIPTION :
If <field> is NULL, element values are calculated for the coordinate field.  The
function fills in the fields of the <element_field_values> structure, but does
not allocate memory for the structure.
The optional <top_level_element> forces inheritance from it as needed.
???DB.  I think that the field=NULL special case should be removed.
==============================================================================*/
{
	FE_element_field_component_modify modify;
	FE_value *basis_function_values,*blending_matrix,*coordinate_transformation,
		*derivative_value,*inherited_value,*inherited_values,scalar,
		*second_derivative_value,*transformation,*value,**values_address;
	int *basis_type,component_number,*component_number_in_xi,element_dimension,
		*element_value_offsets,field_element_dimension,*grid_offset_in_xi,i,
		j,k,maximum_number_of_values,*number_in_xi,number_of_components,
		number_of_inherited_values,number_of_polygon_verticies,number_of_values,
		*number_of_values_address,offset,order,*orders,polygon_offset,power,
		return_code,row_size,**standard_basis_arguments_address;
	Standard_basis_function **standard_basis_address;
	struct FE_basis *previous_basis;
	struct FE_element *field_element;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;
	Value_storage **values_storage_address;
#if defined (DOUBLE_FOR_DOT_PRODUCT)
	double sum;
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
	FE_value sum;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */

	ENTER(calculate_FE_element_field_values);
#if defined (DEBUG)
	/*???debug */
	printf("enter calculate_FE_element_field_values\n");
#endif /* defined (DEBUG) */
	/* check the arguments */
	if (element&&(element->shape)&&element_field_values)
	{
		/* retrieve the element field from which this element inherits the field
			and calculate the affine transformation from the element xi coordinates
			to the xi coordinates for the element field */
		element_field=(struct FE_element_field *)NULL;
		field_element=(struct FE_element *)NULL;
		coordinate_transformation=(FE_value *)NULL;
		if (inherit_FE_element_field(element,field,&element_field,&field_element,
			&coordinate_transformation,top_level_element))
		{
			return_code=1;
#if defined (DEBUG)
			/*???debug */
			printf("element : %d \n",element->cm.number);
			printf("field element : %d \n",field_element->cm.number);
#endif /* defined (DEBUG) */
			element_dimension=element->shape->dimension;
			field_element_dimension=field_element->shape->dimension;
			number_of_components=element_field->field->number_of_components;
#if defined (DEBUG)
			/*???debug */
			printf("coordinate_transformation: %p\n",coordinate_transformation);
			if (value=coordinate_transformation)
			{
				for (i=field_element_dimension;i>0;i--)
				{
					for (j=element_dimension+1;j>0;j--)
					{
						printf(" %g",*value);
						value++;
					}
					printf("\n");
				}
			}
			printf("%d #components=%d\n",field_element_dimension,
				number_of_components);
#endif /* defined (DEBUG) */
			switch (field->fe_field_type)
			{
				case CONSTANT_FE_FIELD:
				{
					/* constant fields do not use the values except to remember the
						 element and field they are for */
					element_field_values->field=ACCESS(FE_field)(field);
					element_field_values->element=ACCESS(FE_element)(element);
					/* store field_element since we are now able to suggest through the
						 top_level_element clue which one we get. Must compare element
						 and field_element to ensure field values are still valid for
						 a given line or face. */
					element_field_values->field_element=
						ACCESS(FE_element)(field_element);
					element_field_values->number_in_xi=(int *)NULL;
					/* derivatives will be calculated in calculate_FE_element_field */
					/*???DB.  Assuming linear */
					element_field_values->derivatives_calculated=1;
					element_field_values->destroy_standard_basis_arguments=0;
					element_field_values->number_of_components=number_of_components;
					element_field_values->component_number_of_values=(int *)NULL;
					element_field_values->component_grid_values_storage=
						(Value_storage **)NULL;
					element_field_values->base_grid_offset=0;
					element_field_values->grid_offset_in_xi=(int *)NULL;
					element_field_values->element_value_offsets=(int *)NULL;
					/* clear arrays not used for grid-based fields */
					element_field_values->component_values=(FE_value **)NULL;
					element_field_values->component_standard_basis_functions=
						(Standard_basis_function **)NULL;
					element_field_values->component_standard_basis_function_arguments=
						(void *)NULL;
					element_field_values->basis_function_values=(FE_value *)NULL;
					element_field_values->time_dependent = 0;
					element_field_values->time = time;
				} break;
				case INDEXED_FE_FIELD:
				{
					if (calculate_FE_element_field_values(element,field->indexer_field,
						time,calculate_derivatives,element_field_values,top_level_element))
					{
						/* restore pointer to original field - has the indexer_field in
							 it anyway */
						REACCESS(FE_field)(&(element_field_values->field),field);
					}
					else
					{
						display_message(ERROR_MESSAGE,"calculate_FE_element_field_values.  "
							"Cannot calculate element field values for indexer field");
						return_code=0;
					}
				} break;
				case GENERAL_FE_FIELD:
				{
					/* allocate memory for components */
					if (ELEMENT_GRID_MAP==(*(element_field->components))->type)
					{
						/* grid based element field */
						/* check that components are linear and consistent */
						component=element_field->components;
						number_in_xi=((*component)->map).element_grid_based.number_in_xi;
						component_number=0;
						return_code=1;
						while (return_code&&(component_number<number_of_components))
						{
							if (ELEMENT_GRID_MAP==(*component)->type)
							{
								i=0;
								while ((i<field_element_dimension)&&(number_in_xi[i]==
									(((*component)->map).element_grid_based.number_in_xi)[i]))
								{
									i++;
								}
								if (i>=field_element_dimension)
								{
									basis_type=(*component)->basis->type;
									i=field_element_dimension;
									while (return_code&&(i>0))
									{
										i--;
										basis_type++;
										if (LINEAR_LAGRANGE== *basis_type)
										{
											j=i;
											while (return_code&&(j>0))
											{
												j--;
												basis_type++;
												if (0!= *basis_type)
												{
													return_code=0;
												}
											}
										}
										else
										{
											return_code=0;
										}
									}
									if (!return_code)
									{
										display_message(ERROR_MESSAGE,
											"calculate_FE_element_field_values.  "
											"Grid based components must be linear");
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  "
										"Inconsistent sub-divisions for grid based components");
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_values.  "
									"Cannot mix grid based and non grid based components");
								return_code=0;
							}
							component++;
							component_number++;
						}
						if (return_code)
						{
							maximum_number_of_values=element_dimension+1;
							for (i=element_dimension;i>0;i--)
							{
								maximum_number_of_values *= 2;
							}
							ALLOCATE(values_storage_address,Value_storage *,
								number_of_components);
							ALLOCATE(number_in_xi,int,element_dimension);
							/* need space for basis function for value and derivatives */
							ALLOCATE(basis_function_values,FE_value,
								(element_dimension+1)*maximum_number_of_values);
							ALLOCATE(grid_offset_in_xi,int,element_dimension);
							ALLOCATE(element_value_offsets,int,maximum_number_of_values);
							if (values_storage_address&&number_in_xi&&basis_function_values&&
								grid_offset_in_xi&&element_value_offsets)
							{
								element_field_values->number_in_xi=number_in_xi;
								element_field_values->field=
									ACCESS(FE_field)(element_field->field);
								element_field_values->element=ACCESS(FE_element)(element);
								/* store field_element since we are now able to suggest through
									the top_level_element clue which one we get. Must compare
									element and field_element to ensure field values are still
									valid for a given line or face. */
								element_field_values->field_element=
									ACCESS(FE_element)(field_element);
								/* derivatives will be calculated in
									calculate_FE_element_field */
								/*???DB.  Assuming linear */
								element_field_values->derivatives_calculated=1;
								element_field_values->number_of_components=number_of_components;
								element_field_values->component_number_of_values=(int *)NULL;
								element_field_values->component_grid_values_storage=
									values_storage_address;
								element_field_values->base_grid_offset=0;
								element_field_values->grid_offset_in_xi=grid_offset_in_xi;
								element_field_values->element_value_offsets=
									element_value_offsets;
								/* clear arrays not used for grid-based fields */
								element_field_values->component_values=(FE_value **)NULL;
								element_field_values->component_standard_basis_functions=
									(Standard_basis_function **)NULL;
								element_field_values->time_dependent = 
									FE_field_has_multiple_times(element_field_values->field);
								element_field_values->time = time;
								element_field_values->
									component_standard_basis_function_arguments=(void *)NULL;
								element_field_values->basis_function_values=
									basis_function_values;
								element_field_values->destroy_standard_basis_arguments=0;
								/* get convenient lookup into position in values_storage where
									 values for each component are stored */
								component=element_field->components;
								for (component_number=0;
									(component_number<number_of_components)&&return_code;
									component_number++)
								{
									*values_storage_address=
										(field_element->information->values_storage)+
										(((*component)->map).element_grid_based.value_index);
									values_storage_address++;
									component++;
								}
								element_field_values->destroy_standard_basis_arguments=0;
								if (MAXIMUM_ELEMENT_XI_DIMENSIONS >= field_element_dimension)
								{
									component=element_field->components;
									component_number_in_xi=
										((*component)->map).element_grid_based.number_in_xi;
									if (!calculate_grid_field_offsets(element_dimension,
										field_element_dimension,component_number_in_xi,
										coordinate_transformation,number_in_xi,
										&(element_field_values->base_grid_offset),
										grid_offset_in_xi))
									{
										display_message(ERROR_MESSAGE,
											"calculate_FE_element_field_values.  "
											"Could not calculate grid field offsets");
										return_code=0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  "
										"Dimension out of range: %d",field_element_dimension);
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_values.  "
									"Could not allocate grid calculation information");
								DEALLOCATE(values_storage_address);
								DEALLOCATE(number_in_xi);
								DEALLOCATE(basis_function_values);
								DEALLOCATE(grid_offset_in_xi);
								DEALLOCATE(element_value_offsets);
							}
						}
					}
					else
					{
						/* not grid based element field */
						element_field_values->number_in_xi=(int *)NULL;
						ALLOCATE(number_of_values_address,int,number_of_components);
						ALLOCATE(values_address,FE_value *,number_of_components);
						ALLOCATE(standard_basis_address,Standard_basis_function *,
							number_of_components);
						if (ALLOCATE(standard_basis_arguments_address,int *,
							number_of_components))
						{
							/* clear these addresses since allocated by other functions */
							for (i=0;i<number_of_components;i++)
							{
								standard_basis_arguments_address[i]=(int *)NULL;
							}
						}
						blending_matrix=(FE_value *)NULL;
						if (number_of_values_address&&values_address&&
							standard_basis_address&&standard_basis_arguments_address)
						{
							element_field_values->field=
								ACCESS(FE_field)(element_field->field);
							element_field_values->element=ACCESS(FE_element)(element);
							/* store field_element since we are now able to suggest through
								 the top_level_element clue which one we get. Must compare
								 element and field_element to ensure field values are still
								 valid for a given line or face. */
							element_field_values->field_element=
								ACCESS(FE_element)(field_element);
							element_field_values->time_dependent = 
								FE_field_has_multiple_times(element_field_values->field);
							element_field_values->time = time;
							element_field_values->derivatives_calculated=
								calculate_derivatives;
							if (coordinate_transformation)
							{
								element_field_values->destroy_standard_basis_arguments=1;
							}
							else
							{
								element_field_values->destroy_standard_basis_arguments=0;
							}
							element_field_values->number_of_components=number_of_components;
							element_field_values->component_number_of_values=
								number_of_values_address;
							/* clear arrays only used for grid-based fields */
							element_field_values->component_grid_values_storage=
								(Value_storage **)NULL;
							element_field_values->grid_offset_in_xi=(int *)NULL;
							element_field_values->element_value_offsets=(int *)NULL;

							element_field_values->component_values=values_address;
							element_field_values->component_standard_basis_functions=
								standard_basis_address;
							element_field_values->component_standard_basis_function_arguments=
								(void *)standard_basis_arguments_address;
							/* for each component */
							component=element_field->components;
							previous_basis=(struct FE_basis *)NULL;
							component_number=0;
							return_code=1;
							maximum_number_of_values=0;
							while (return_code&&(component_number<number_of_components))
							{
								if (ELEMENT_GRID_MAP!=(*component)->type)
								{
									modify=(FE_element_field_component_modify)NULL;
									if ((element_field_values->no_modify)&&element_field&&
										(element_field->components)[component_number]&&(modify=
										(element_field->components)[component_number]->modify))
									{
										(element_field->components)[component_number]->modify=
											(FE_element_field_component_modify)NULL;
									}
									/* calculate element values for the element field component */
									if (global_to_element_map_values(field_element,element_field,
										time,component_number,number_of_values_address,
										values_address))
									{
										if (modify)
										{
											(element_field->components)[component_number]->modify=
												modify;
											modify=(FE_element_field_component_modify)NULL;
										}
#if defined (DEBUG)
										/*???debug */
										printf("component_number %d\n",component_number);
#endif /* defined (DEBUG) */
#if defined (DEBUG)
										/*???debug */
										{
											FE_value *value;
											int i;

											i= *number_of_values_address;
											printf("component=%d, #values=%d\n",component_number,i);
											value= *values_address;
											while (i>0)
											{
												printf("%.10g ",*value);
												i--;
												value++;
											}
											printf("\n");
										}
#endif /* defined (DEBUG) */
										if (previous_basis==(*component)->basis)
										{
											*standard_basis_address= *(standard_basis_address-1);
											*standard_basis_arguments_address=
												*(standard_basis_arguments_address-1);
										}
										else
										{
											previous_basis=(*component)->basis;
											if (blending_matrix)
											{
												/* SAB We don't want to keep the old one */
												DEALLOCATE(blending_matrix);
												blending_matrix=NULL;
											}
											*standard_basis_address=previous_basis->standard_basis;
											if (coordinate_transformation)
											{
												return_code=calculate_standard_basis_transformation(
													previous_basis,coordinate_transformation,
													element_dimension,standard_basis_arguments_address,
													&number_of_inherited_values,standard_basis_address,
													&blending_matrix);
											}
											else
											{
												/* standard basis transformation is just a big identity matrix, so don't compute */
												/* also use the real basis arguments */
												*standard_basis_arguments_address=(int*)(previous_basis->arguments);
											}
										}
										if (return_code)
										{
											if (!coordinate_transformation)
											{
												/* values already correct regardless of basis, but must make space for derivatives if needed */
												if (calculate_derivatives)
												{
													if (REALLOCATE(inherited_values,*values_address,FE_value,
														(element_dimension+1)*(*number_of_values_address)))
													{
														*values_address=inherited_values;
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"calculate_FE_element_field_values.  Could not reallocate values");
														return_code=0;
													}
												}
											}
											else if ((monomial_basis_functions== *standard_basis_address)||
												(polygon_basis_functions== *standard_basis_address))
											{
												/* project the field_element values onto the lower-dimension element
													 using the affine transformation */
												/* allocate memory for the element values */
												if (calculate_derivatives)
												{
													ALLOCATE(inherited_values,FE_value,
														(element_dimension+1)*number_of_inherited_values);
												}
												else
												{
													ALLOCATE(inherited_values,FE_value,
														number_of_inherited_values);
												}
												if (inherited_values)
												{
													row_size= *number_of_values_address;
													inherited_value=inherited_values;
													for (j=0;j<number_of_inherited_values;j++)
													{
														sum=0;
														value= *values_address;
														transformation=blending_matrix+j;
														for (i=row_size;i>0;i--)
														{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
															sum += (double)(*transformation)*(double)(*value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
															sum += (*transformation)*(*value);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
															value++;
															transformation += number_of_inherited_values;
														}
														*inherited_value=(FE_value)sum;
														inherited_value++;
													}
													DEALLOCATE(*values_address);
													*values_address=inherited_values;
													*number_of_values_address=number_of_inherited_values;
												}
												else
												{
													display_message(ERROR_MESSAGE,
														"calculate_FE_element_field_values.  "
														"Insufficient memory for inherited_values");
													DEALLOCATE(*values_address);
													return_code=0;
												}
											}
											else
											{
												display_message(ERROR_MESSAGE,
													"calculate_FE_element_field_values.  Invalid basis");
												return_code=0;
											}
											if (return_code)
											{
#if defined (DEBUG)
												/*???debug */
												printf("number of values=%d\n",
													*number_of_values_address);
												printf("inherited values :");
												value= *values_address;
												for (i= *number_of_values_address;i>0;i--)
												{
													printf(" %g",*value);
													value++;
												}
												printf("\n");
												printf("inherited arguments :");
												orders= *standard_basis_arguments_address;
												for (i=element_dimension;i>=0;i--)
												{
													printf(" %d",*orders);
													orders++;
												}
												printf("\n");
#endif /* defined (DEBUG) */
												if (calculate_derivatives)
												{
													/* calculate the derivatives with respect to the xi
														 coordinates */
													if (monomial_basis_functions==
														*standard_basis_address)
													{
														number_of_values= *number_of_values_address;
														value= *values_address;
														derivative_value=value+number_of_values;
														orders= *standard_basis_arguments_address;
														offset=1;
														for (i=element_dimension;i>0;i--)
														{
															orders++;
															order= *orders;
															for (j=0;j<number_of_values;j++)
															{
																/* calculate derivative value */
																power=(j/offset)%(order+1);
																if (order==power)
																{
																	*derivative_value=0;
																}
																else
																{
																	*derivative_value=
																		(FE_value)(power+1)*value[j+offset];
																}
																/* move to the next derivative value */
																derivative_value++;
															}
															offset *= (order+1);
														}
													}
													else if (polygon_basis_functions==
														*standard_basis_address)
													{
														number_of_values= *number_of_values_address;
														value= *values_address;
														derivative_value=value+number_of_values;
														orders= *standard_basis_arguments_address;
														offset=1;
														for (i=element_dimension;i>0;i--)
														{
															orders++;
															order= *orders;
															if (order<0)
															{
																/* polygon */
																order= -order;
																if (order%2)
																{
																	/* calculate derivatives with respect to
																		both polygon coordinates */
																	order /= 2;
																	polygon_offset=order%element_dimension;
																	order /= element_dimension;
																	number_of_polygon_verticies=
																		(-orders[polygon_offset])/2;
																	/* first polygon coordinate is
																		circumferential */
																	second_derivative_value=derivative_value+
																		(polygon_offset*number_of_values);
																	order=4*number_of_polygon_verticies;
																	scalar=
																		(FE_value)number_of_polygon_verticies;
																	for (j=0;j<number_of_values;j++)
																	{
																		/* calculate derivative values */
																		k=(j/offset)%order;
																		switch (k/number_of_polygon_verticies)
																		{
																			case 0:
																			{
																				*derivative_value=scalar*value[j+
																					number_of_polygon_verticies*offset];
																				*second_derivative_value=value[j+
																					2*number_of_polygon_verticies*
																					offset];
																			} break;
																			case 1:
																			{
																				*derivative_value=0;
																				*second_derivative_value=value[j+
																					2*number_of_polygon_verticies*
																					offset];
																			} break;
																			case 2:
																			{
																				*derivative_value=scalar*value[j+
																					number_of_polygon_verticies*offset];
																				*second_derivative_value=0;
																			} break;
																			case 3:
																			{
																				*derivative_value=0;
																				*second_derivative_value=0;
																			} break;
																		}
																		/* move to the next derivative value */
																		derivative_value++;
																		second_derivative_value++;
																	}
																	offset *= order;
																}
																else
																{
																	/* second polgon xi.  Derivatives already
																		calculated */
																	derivative_value += number_of_values;
																}
															}
															else
															{
																/* not polygon */
																for (j=0;j<number_of_values;j++)
																{
																	/* calculate derivative value */
																	power=(j/offset)%(order+1);
																	if (order==power)
																	{
																		*derivative_value=0;
																	}
																	else
																	{
																		*derivative_value=
																			(FE_value)(power+1)*value[j+offset];
																	}
																	/* move to the next derivative value */
																	derivative_value++;
																}
																offset *= (order+1);
															}
														}
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"calculate_FE_element_field_values.  "
															"Invalid basis");
														DEALLOCATE(*values_address);
														return_code=0;
													}
												}
#if defined (DEBUG)
												/*???debug */
												number_of_values= *number_of_values_address;
												for (i=0;i<3;i++)
												{
													printf("%d :",i);
													for (j=0;j<number_of_values;j++)
													{
														printf(" %g",value[i*number_of_values+j]);
													}
													printf("\n");
												}
#endif /* defined (DEBUG) */
											}
										}
										if (*number_of_values_address>maximum_number_of_values)
										{
											maximum_number_of_values= *number_of_values_address;
										}
										component_number++;
										component++;
										number_of_values_address++;
										values_address++;
										standard_basis_address++;
										standard_basis_arguments_address++;
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"calculate_FE_element_field_values.  "
											"Could not calculate values");
										return_code=0;
										if (modify)
										{
											(element_field->components)[component_number]->modify=
												modify;
											modify=(FE_element_field_component_modify)NULL;
										}
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  "
										"Cannot mix grid based and non grid based components");
									return_code=0;
								}
							}
							if (return_code)
							{
								if (!((maximum_number_of_values>0)&&
									(ALLOCATE(element_field_values->basis_function_values,
									FE_value,maximum_number_of_values))))
								{
									display_message(ERROR_MESSAGE,
										"calculate_FE_element_field_values.  "
										"Could not allocate basis_function_values");
									return_code=0;
								}
							}
							if (!return_code)
							{
								/* free the memory that has been allocated */
								while (component_number>0)
								{
									component_number--;
									values_address--;
									standard_basis_arguments_address--;
									DEALLOCATE(*values_address);
									if (coordinate_transformation)
									{
										DEALLOCATE(*standard_basis_arguments_address);
									}
								}
								DEALLOCATE(element_field_values->component_number_of_values);
								DEALLOCATE(element_field_values->component_values);
								DEALLOCATE(
									element_field_values->component_standard_basis_functions);
								DEALLOCATE(element_field_values->
									component_standard_basis_function_arguments);
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"calculate_FE_element_field_values.  Insufficient memory");
							DEALLOCATE(number_of_values_address);
							DEALLOCATE(values_address);
							DEALLOCATE(standard_basis_address);
							DEALLOCATE(standard_basis_arguments_address);
							return_code=0;
						}
						if (blending_matrix)
						{
							DEALLOCATE(blending_matrix);
						}
						if (coordinate_transformation)
						{
							DEALLOCATE(coordinate_transformation);
						}
					}
				} break;
				default:
				{
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_values.  Unknown field type");
					return_code=0;
				} break;
			} /* switch (field->fe_field_type) */
		}
		else
		{
			if (field)
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_values.  %s not defined for (%d)",
					field->name,(element->cm).number);
			}
			else
			{
				display_message(ERROR_MESSAGE,"calculate_FE_element_field_values.  "
					"No coordinate fields defined for (%d)",
					(element->cm).number);
			}
			return_code=0;
#if defined (DEBUG)
			/*???debug*/
			printf("BAD coordinate_transformation=%p\n",coordinate_transformation);
#endif /* defined (DEBUG) */
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_values.  Invalid argument(s)");
		return_code=0;
	}
#if defined (DEBUG)
	/*???debug */
	printf("leave calculate_FE_element_field_values %d\n",return_code);
#endif /* defined (DEBUG) */
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_values */

int FE_element_field_values_differentiate(
	struct FE_element_field_values *element_field_values, int xi_index)
/*******************************************************************************
LAST MODIFIED : 9 May 2007

DESCRIPTION :
Modifies the calculated values for an FE_field so that it will calculate
derivatives wrt xi_index for the original field.  The <element_field_values>
must have already been calculated.  Currently only implemented for monomials.
==============================================================================*/
{
	FE_value *derivative_value, *value;
	int element_dimension, i, j, k, number_of_values, offset, order,
		*orders, power, return_code;

	ENTER(FE_element_field_values_differentiate);
	if (element_field_values && element_field_values->derivatives_calculated)
	{
		return_code = 1;
		element_dimension=element_field_values->element->shape->dimension;
		for (k = 0 ; k < element_field_values->number_of_components ; k++)
		{
			if (monomial_basis_functions==
				element_field_values->component_standard_basis_functions[k])
			{
				number_of_values = element_field_values->component_number_of_values[k];
				value = element_field_values->component_values[k];

				/* Copy the specified derivative back into the values */
				derivative_value = value + number_of_values * (xi_index + 1);
 				for (j=0;j<number_of_values;j++)
				{
					*value = *derivative_value;
					value++;
					derivative_value++;
				}

				/* Now differentiate the values monomial as we did to calculate them above */
				
				value = element_field_values->component_values[k];
				derivative_value = value + number_of_values;

				orders= ((int**)element_field_values->component_standard_basis_function_arguments)[k];
				offset = 1;

				for (i=element_dimension;i>0;i--)
				{
					orders++;
					order= *orders;
					for (j=0;j<number_of_values;j++)
					{
						/* calculate derivative value */
						power=(j/offset)%(order+1);
						if (order==power)
						{
							*derivative_value=0;
						}
						else
						{
							*derivative_value=
								(FE_value)(power+1)*value[j+offset];
						}
						/* move to the next derivative value */
						derivative_value++;
					}
					offset *= (order+1);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_values_differentiate.  Unsupported basis type");
				return_code=0;
				break;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_values_differentiate.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_values_differentiate */

int clear_FE_element_field_values(
	struct FE_element_field_values *element_field_values)
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
Frees the memory for the fields of the <element_field_values> structure.
Restores <element_field_values> to the blank state it was created with. This
function must be called before calling calculate_FE_element_field_values again.
==============================================================================*/
{
	FE_value **component_values;
	int i,return_code;
	void **component_standard_basis_function_arguments;

	ENTER(clear_FE_element_field_values);
	return_code=0;
	if (element_field_values)
	{
		return_code=1;
		DEACCESS(FE_field)(&(element_field_values->field));
		DEACCESS(FE_element)(&(element_field_values->element));
		DEACCESS(FE_element)(&(element_field_values->field_element));
		if (element_field_values->number_in_xi)
		{
			DEALLOCATE(element_field_values->number_in_xi);
		}
		if (element_field_values->component_number_of_values)
		{
			DEALLOCATE(element_field_values->component_number_of_values);
		}
		if (element_field_values->component_grid_values_storage)
		{
			DEALLOCATE(element_field_values->component_grid_values_storage);
		}
		if (element_field_values->grid_offset_in_xi)
		{
			DEALLOCATE(element_field_values->grid_offset_in_xi);
		}
		if (element_field_values->element_value_offsets)
		{
			DEALLOCATE(element_field_values->element_value_offsets);
		}
		if (element_field_values->component_values)
		{
			component_values=element_field_values->component_values;
			for (i=element_field_values->number_of_components;i>0;i--)
			{
				DEALLOCATE(*component_values);
				component_values++;
			}
			DEALLOCATE(element_field_values->component_values);
		}
		if (element_field_values->component_standard_basis_function_arguments)
		{
			if (element_field_values->destroy_standard_basis_arguments)
			{
				component_standard_basis_function_arguments=
					(void **)(element_field_values->
					component_standard_basis_function_arguments);
				for (i=element_field_values->number_of_components;i>0;i--)
				{
					if (*component_standard_basis_function_arguments&&(1==i)||
						(*component_standard_basis_function_arguments!=
							component_standard_basis_function_arguments[1]))
					{
						DEALLOCATE(*component_standard_basis_function_arguments);
					}
					component_standard_basis_function_arguments++;
				}
			}
			DEALLOCATE(element_field_values->
				component_standard_basis_function_arguments);
		}
		if (element_field_values->component_standard_basis_functions)
		{
			DEALLOCATE(element_field_values->component_standard_basis_functions);
		}
		if (element_field_values->basis_function_values)
		{
			DEALLOCATE(element_field_values->basis_function_values);
		}
		element_field_values->no_modify=(char)0;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"clear_FE_element_field_values.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* clear_FE_element_field_values */

int DESTROY(FE_element_field_values)(
	struct FE_element_field_values **element_field_values_address)
/*******************************************************************************
LAST MODIFIED : 4 March 2003

DESCRIPTION :
Destroys the element_field_values at *<element_field_info_address>. Frees the
memory for the information and sets <*element_field_info_address> to NULL.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_values *element_field_values;

	ENTER(DESTROY(FE_element_field_values));
	if ((element_field_values_address) &&
		(element_field_values = *element_field_values_address))
	{
		clear_FE_element_field_values(element_field_values);
		DEALLOCATE(*element_field_values_address);
		*element_field_values_address = (struct FE_element_field_values *)NULL;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"DESTROY(FE_element_field_values).  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_field_values) */

DECLARE_OBJECT_FUNCTIONS(FE_element_field_values)

DECLARE_INDEXED_LIST_MODULE_FUNCTIONS(FE_element_field_values, element, \
	struct FE_element *, compare_pointer)

DECLARE_INDEXED_LIST_FUNCTIONS(FE_element_field_values)

DECLARE_FIND_BY_IDENTIFIER_IN_INDEXED_LIST_FUNCTION(FE_element_field_values, element, \
	struct FE_element *, compare_pointer)

int FE_element_field_values_set_no_modify(
	struct FE_element_field_values *element_field_values)
/*******************************************************************************
LAST MODIFIED : 1 May 2003

DESCRIPTION :
Sets the FE_element_field_values no_modify flag.  When an element field values
structure is created, the no_modify flag is unset.
clear_FE_element_field_values also unsets the no_modify flag.

When calculate_FE_element_field_values is called, if the no_modify flag is set
then the field component modify function, if present, is not called.

???DB.  This was added to fix calculating nodal value derivatives for computed
	variables.  It was added as a set function because it is specialized and
	will hopefully be replaced (either by a specialized function for calculating
	nodal value derivatives instead of calculate_FE_element_field_values or a
	better way of doing the modify).
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_values_set_no_modify);
	return_code=0;
	if (element_field_values)
	{
		element_field_values->no_modify=(char)1;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_field_values_set_no_modify.  "
			"Missing <element_field_values>");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_values_set_no_modify */

int FE_element_field_values_get_component_values(
	struct FE_element_field_values *element_field_values,int component_number,
	int *number_of_component_values_address,FE_value **component_values_address)
/*******************************************************************************
LAST MODIFIED : 1 June 2004

DESCRIPTION :
Allocates and returns to <component_values_address> the component values for
<component_number> in <element_field_values>. The number of values is returned
in <number_of_component_values>.
It is up to the calling function to deallocate any returned component values.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_values_get_component_values);
	return_code=0;
	if (element_field_values&&(element_field_values->element)&&
		(0<=component_number)&&
		(component_number<element_field_values->number_of_components)&&
		number_of_component_values_address&&component_values_address)
	{
		if ((element_field_values->component_number_of_values)&&
			(0<(*number_of_component_values_address=
			element_field_values->component_number_of_values[component_number]))&&
			(element_field_values->component_values)&&
			element_field_values->component_values[component_number]&&
			ALLOCATE(*component_values_address,FE_value,
				*number_of_component_values_address))
		{
			memcpy(*component_values_address,
				element_field_values->component_values[component_number],
				(*number_of_component_values_address)*sizeof(FE_value));
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_values_get_component_values.  "
				"Component has no values");
		}
	}
	else
	{
		if (element_field_values)
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_values_get_component_values.  "
				"Invalid argument(s).  %p %p %d %d %p %p",element_field_values,
				element_field_values->element,component_number,
				element_field_values->number_of_components,
				number_of_component_values_address,component_values_address);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_values_get_component_values.  "
				"Invalid argument(s).  %p %d %p %p",element_field_values,
				component_number,number_of_component_values_address,
				component_values_address);
		}
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_values_get_component_values */

int FE_element_field_values_get_monomial_component_info(
	struct FE_element_field_values *element_field_values,int component_number,
	int *monomial_info)
/*******************************************************************************
LAST MODIFIED : 21 May 2004

DESCRIPTION :
If <component_number> in the <element_field_values> is monomial, integer values
describing the monomial basis are returned. The first number is the dimension,
the following numbers are the order of the monomial in each direction, where
3=cubic, for example.
<monomial_info> should point to a block of memory big enough to take
1 + MAXIMUM_ELEMENT_XI_DIMENSIONS integers.
==============================================================================*/
{
	int i, return_code, *source_monomial_info;

	ENTER(FE_element_field_values_get_monomial_component_info);
	return_code=0;
	if (element_field_values&&element_field_values->element&&
		(0<=component_number)&&
		(component_number<element_field_values->number_of_components)&&
		monomial_info)
	{
		if ((element_field_values->component_standard_basis_function_arguments)&&
			(source_monomial_info=((int **)(element_field_values->
			component_standard_basis_function_arguments))[component_number])&&
			standard_basis_function_is_monomial(element_field_values->
			component_standard_basis_functions[component_number],
			(void *)source_monomial_info))
		{
			*monomial_info= *source_monomial_info;
			for (i=1;i<= *monomial_info;i++)
			{
				monomial_info[i]=source_monomial_info[i];
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_values_get_monomial_component_info.  "
				"Component is not monomial");
		}
	}
	else
	{
		if (element_field_values)
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_values_get_monomial_component_info.  "
				"Invalid argument(s).  %p %p %d %d %p",element_field_values,
				element_field_values->element,component_number,
				element_field_values->number_of_components,monomial_info);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_values_get_monomial_component_info.  "
				"Invalid argument(s).  %p %d %p",element_field_values,component_number,
				monomial_info);
		}
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_values_get_monomial_component_info */

int calculate_FE_element_field_nodes(struct FE_element *element,
	struct FE_field *field,int *number_of_element_field_nodes_address,
	struct FE_node ***element_field_nodes_array_address,
	struct FE_element *top_level_element)
/*******************************************************************************
LAST MODIFIED : 12 February 2003

DESCRIPTION :
If <field> is NULL, element nodes are calculated for the coordinate field.  The
function allocates an array, <*element_field_nodes_array_address> to store the
pointers to the ACCESS'd element nodes.  Components that are not node-based are 
ignored.  The element nodes are ordered by increasing xi (fastest in xi1, next 
fastest in xi2 and so on).
The optional <top_level_element> forces inheritance from it as needed.
NB.  The nodes need to be DEACCESS'd before the nodes array is DEALLOCATE'd.
==============================================================================*/
{
	FE_value *blending_matrix,*combined_blending_matrix,
		*coordinate_transformation,*row,*column,*transformation;
	int add,component_number,element_dimension,i,*inherited_basis_arguments,j,k,
		number_of_components,number_of_element_values,number_of_element_field_nodes,
		number_of_inherited_values,number_of_standard_basis_functions,
		previous_number_of_element_values,return_code;
	struct FE_basis *basis,*previous_basis;
	struct FE_element *field_element;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component,**component_address;
	struct FE_node **element_field_nodes_array,**element_value,**element_values,
		**previous_element_values,**temp_element_field_nodes_array;
	Standard_basis_function *standard_basis_function;
#if defined (DOUBLE_FOR_DOT_PRODUCT)
	double sum;
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
	FE_value sum;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */

	ENTER(calculate_FE_element_field_nodes);
	return_code=0;
	/* check the arguments */
	if (element&&(element->shape)&&number_of_element_field_nodes_address&&
		element_field_nodes_array_address)
	{
		/* retrieve the element field from which this element inherits the field
			and calculate the affine transformation from the element xi coordinates
			to the xi coordinates for the element field */
		coordinate_transformation=(FE_value *)NULL;
		if (inherit_FE_element_field(element,field,&element_field,&field_element,
			&coordinate_transformation,top_level_element)&&element_field)
		{
			return_code=1;
			number_of_element_field_nodes=0;
			element_field_nodes_array=(struct FE_node **)NULL;
			element_dimension=element->shape->dimension;		
			number_of_components=element_field->field->number_of_components;
			/* for each component */
			component_address=element_field->components;
			previous_basis=(struct FE_basis *)NULL;
			previous_number_of_element_values= -1;
			previous_element_values=(struct FE_node **)NULL;
			component_number=0;
			while (return_code&&(component_number<number_of_components))
			{
				component= *component_address;
				if ((STANDARD_NODE_TO_ELEMENT_MAP==component->type)||
					(GENERAL_NODE_TO_ELEMENT_MAP==component->type))
				{
					/* calculate the nodes used by the component in the field_element */
					if (global_to_element_map_nodes(component,field_element,
						element_field->field,&number_of_element_values,&element_values))
					{
						/* check that there is a valid basis */
						if ((basis=component->basis)&&
							(number_of_element_values==basis->number_of_basis_functions)&&
							(basis->standard_basis)&&((number_of_standard_basis_functions=
							basis->number_of_standard_basis_functions)>0))
						{
							if ((i=number_of_element_values)==
								previous_number_of_element_values)
							{
								i--;
								while ((i>=0)&&(element_values[i]==previous_element_values[i]))
								{
									i--;
								}
							}
							if ((i>=0)||(basis!=previous_basis))
							{
								DEALLOCATE(previous_element_values);
								previous_element_values=element_values;
								previous_number_of_element_values=number_of_element_values;
								previous_basis=basis;
								if (calculate_standard_basis_transformation(basis,
									coordinate_transformation,element_dimension,
									&inherited_basis_arguments,&number_of_inherited_values,
									&standard_basis_function,&blending_matrix))
								{
									if (basis->blending_matrix)
									{
										if (ALLOCATE(combined_blending_matrix,FE_value,
											number_of_element_values*number_of_inherited_values))
										{
											transformation=combined_blending_matrix;
											for (i=0;i<number_of_element_values;i++)
											{
												for (j=0;j<number_of_inherited_values;j++)
												{
													sum=0;
													row=(basis->blending_matrix)+
														(i*number_of_standard_basis_functions);
													column=blending_matrix+j;
													for (k=number_of_standard_basis_functions;k>0;k--)
													{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
														sum += (double)(*row)*(double)(*column);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
														sum += (*row)*(*column);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
														row++;
														column += number_of_inherited_values;
													}
													*transformation=(FE_value)sum;
													transformation++;
												}
											}
											DEALLOCATE(blending_matrix);
											blending_matrix=combined_blending_matrix;
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"calculate_FE_element_field_nodes.  "
												"Could not allocate combined_blending_matrix");
											return_code=0;
										}
									}
									if (return_code)
									{
										transformation=blending_matrix;
										element_value=element_values;
										i=number_of_element_values;
										while (return_code&&(i>0))
										{
											add=0;
											j=number_of_inherited_values;
											while (!add&&(j>0))
											{
												if (1.e-8<fabs(*transformation))
												{
													add=1;
												}
												transformation++;
												j--;
											}
											transformation += j;
											if (add)
											{
												k=0;
												while ((k<number_of_element_field_nodes)&&
													(*element_value!=element_field_nodes_array[k]))
												{
													k++;
												}
												if (k>=number_of_element_field_nodes)
												{
													if (REALLOCATE(temp_element_field_nodes_array,
														element_field_nodes_array,struct FE_node *,
														number_of_element_field_nodes+1))
													{
														element_field_nodes_array=
															temp_element_field_nodes_array;
														element_field_nodes_array[
															number_of_element_field_nodes]=
															ACCESS(FE_node)(*element_value);
														number_of_element_field_nodes++;
													}
													else
													{
														display_message(ERROR_MESSAGE,
															"calculate_FE_element_field_nodes.  "
															"Could not REALLOCATE element_field_nodes_array");
														return_code=0;
													}
												}
											}
											element_value++;
											i--;
										}
									}
									DEALLOCATE(blending_matrix);
									DEALLOCATE(inherited_basis_arguments);
								}
								else
								{
									return_code=0;
								}
							}
							else
							{
								DEALLOCATE(element_values);
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"calculate_FE_element_field_nodes.  Invalid basis");
							DEALLOCATE(element_values);
							return_code=0;
						}
					}
				}
				component_number++;
				component_address++;
			}
			DEALLOCATE(previous_element_values);
			if (return_code)
			{
				*number_of_element_field_nodes_address=number_of_element_field_nodes;
				*element_field_nodes_array_address=element_field_nodes_array;
			}
			else
			{
				for (i=0;i<number_of_element_field_nodes;i++)
				{
					DEACCESS(FE_node)(element_field_nodes_array+i);
				}
				DEALLOCATE(element_field_nodes_array);
			}
		}
		else
		{
			if (field)
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_nodes.  %s not defined for (%d )",
					field->name,(element->cm).number);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_nodes.  No coordinate fields defined for (%d )",
					(element->cm).number);
			}
			return_code=0;
		}
		DEALLOCATE(coordinate_transformation);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_nodes.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_nodes */

int calculate_FE_element_field(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	FE_value *values,FE_value *jacobian)
/*******************************************************************************
LAST MODIFIED : 5 August 2001

DESCRIPTION :
Calculates the <values> of the field specified by the <element_field_values> at
the <xi_coordinates>.  The storage for the <values> should have been allocated
outside the function.  The <jacobian> will be calculated if it is not NULL (and
the derivatives values have been calculated).  Only the <component_number>+1
component will be calculated if 0<=component_number<number of components.  For a
single component, the value will be put in the first position of <values> and
the derivatives will start at the first position of <jacobian>.
==============================================================================*/
{
	int comp_no,*component_number_of_values,components_to_calculate,
		*element_value_offset,*element_value_offsets,i,j,k,l,m,*number_in_xi,
		number_of_values,number_of_xi_coordinates,offset,return_code,size,xi_offset;
	FE_value *basis_function_values,*basis_value,*calculated_value,
		**component_values,*derivative,*element_value,temp,xi_coordinate;
	Standard_basis_function *current_standard_basis_function,
		**component_standard_basis_function;
	struct FE_field *field;
	void **component_standard_basis_function_arguments,
		**current_standard_basis_function_arguments;
	Value_storage **component_grid_values_storage,*element_values_storage;
#if defined (DOUBLE_FOR_DOT_PRODUCT)
	double sum;
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
	FE_value sum;
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */

	ENTER(calculate_FE_element_field);
	return_code=0;
	if (element_field_values&&xi_coordinates&&values&&
		(!jacobian||(jacobian&&(element_field_values->derivatives_calculated)))&&
		(field=element_field_values->field)&&
		((GENERAL_FE_FIELD != field->fe_field_type)||
			(basis_function_values=element_field_values->basis_function_values)))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			comp_no=component_number;
			components_to_calculate=1;
		}
		else
		{
			comp_no=0;
			components_to_calculate=field->number_of_components;
		}
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				return_code=1;
				for (i=0;(i<components_to_calculate)&&return_code;i++)
				{
					if (!get_FE_field_FE_value_value(field,comp_no,&values[i]))
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field.  "
							"Could not get values for constant field %s",field->name);
						return_code=0;
					}
					comp_no++;
				}
				if (jacobian)
				{
					/* derivatives are zero for constant fields */
					derivative=jacobian;
					for (i=(field->number_of_components)*
						element_field_values->element->shape->dimension;0<i;i--)
					{
						*derivative = 0.0;
						derivative++;
					}
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index,value_no;

				REACCESS(FE_field)(&(element_field_values->field),field->indexer_field);
				if (calculate_FE_element_field_int_values(/*component_number*/0,
					element_field_values,xi_coordinates,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						return_code=1;
						value_no = index-1 + comp_no*field->number_of_indexed_values;
						for (i=0;(i<components_to_calculate)&&return_code;i++)
						{
							if (!get_FE_field_FE_value_value(field,value_no,&values[i]))
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field.  "
									"Could not get values for constant field %s",field->name);
								return_code=0;
							}
							value_no += field->number_of_indexed_values;
						}
						if (jacobian)
						{
							/* derivatives are zero for indexed fields */
							derivative=jacobian;
							for (i=(field->number_of_components)*
								element_field_values->element->shape->dimension;0<i;i--)
							{
								*derivative = 0.0;
								derivative++;
							}
						}
					}
					else
					{	
						display_message(ERROR_MESSAGE,"calculate_FE_element_field.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,"calculate_FE_element_field.  "
						"Could not calculate index field %s for field %s at %s %",
						field->indexer_field->name,field->name,
						CM_element_type_string(element_field_values->element->cm.type),
						element_field_values->element->cm.number);
				}
				REACCESS(FE_field)(&(element_field_values->field),field);
			} break;
			case GENERAL_FE_FIELD:
			{
				if (number_in_xi=element_field_values->number_in_xi)
				{
					/* grid based */
					number_of_xi_coordinates=
						element_field_values->element->shape->dimension;
					number_of_values=1;
					for (i=number_of_xi_coordinates;i>0;i--)
					{
						number_of_values *= 2;
					}
					/* element_value_offsets now pre-allocated for <number_of_values>
						 ints in calculate_FE_element_field_values */
					if ((element_value_offsets=
						element_field_values->element_value_offsets)&&
						element_field_values->grid_offset_in_xi)
					{
						return_code=1;
						i=0;
						offset=element_field_values->base_grid_offset;
						*basis_function_values=1;
						*element_value_offsets=0;
						m=1;
						while (return_code&&(i<number_of_xi_coordinates))
						{
							xi_coordinate=xi_coordinates[i];
							if (0>xi_coordinate)
							{
								xi_coordinate = 0.0;
							}
							if (xi_coordinate>1)
							{
								xi_coordinate = 1.0;
							}
								/* get xi_offset = lower grid number for cell in xi_coordinate
									 i, and xi_coordinate = fractional xi value in grid cell */
								if (1==xi_coordinate)
								{
									if (number_in_xi[i] > 0)
									{
										xi_offset=number_in_xi[i]-1;
									}
									else
									{
										xi_offset=0;
									}
								}
								else
								{
									xi_coordinate *= (FE_value)(number_in_xi[i]);
									xi_offset=(int)floor((double)xi_coordinate);
									xi_coordinate -= (FE_value)xi_offset;
								}
								offset += xi_offset*element_field_values->grid_offset_in_xi[i];
								/* add grid_offset in xi_coordinate i for neighbouring grid
									 points around the linear cell */
								element_value_offset=element_value_offsets;
								for (l=m;l>0;l--)
								{
									element_value_offset[m]=(*element_value_offset)+
										element_field_values->grid_offset_in_xi[i];
									element_value_offset++;
								}
								temp=1-xi_coordinate;
								basis_value=basis_function_values;
								if (jacobian)
								{
									for (j=1;j<=i;j++)
									{
										basis_value=basis_function_values+(j*number_of_values+m);
										for (l=m;l>0;l--)
										{
											basis_value--;
											basis_value[m]=(*basis_value)*xi_coordinate;
											*basis_value *= temp;
										}
									}
									j=(i+1)*number_of_values;
									basis_value=basis_function_values+m;
									for (l=m;l>0;l--)
									{
										basis_value--;
										basis_value[j]= -(*basis_value);
										basis_value[j+m]= *basis_value;
									}
								}
								basis_value=basis_function_values+m;
								for (l=m;l>0;l--)
								{
									basis_value--;
									basis_value[m]=(*basis_value)*xi_coordinate;
									*basis_value *= temp;
								}
								m *= 2;
							
							i++;
						}
						if (return_code)
						{
							size=get_Value_storage_size(field->value_type,
								(struct FE_time_sequence *)NULL);
							component_grid_values_storage=
								element_field_values->component_grid_values_storage;
							calculated_value=values;
							derivative=jacobian;
							component_grid_values_storage += comp_no;
							for (i=0;i<components_to_calculate;i++)
							{
								element_values_storage=
									(*component_grid_values_storage)+size*offset;
								basis_value=basis_function_values;
								sum=0;
								element_value_offset=element_value_offsets;
								for (j=number_of_values;j>0;j--)
								{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
									sum += (double)(*basis_value)*(double)(*((FE_value *)(
										element_values_storage+size*(*element_value_offset))));
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									sum += (*basis_value)*(*((FE_value *)(
										element_values_storage+size*(*element_value_offset))));
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									element_value_offset++;
									basis_value++;
								}
								*calculated_value=(FE_value)sum;
								if (jacobian)
								{
									for (k=number_of_xi_coordinates;k>0;k--)
									{
										sum=0;
										element_value_offset=element_value_offsets;
										for (j=number_of_values;j>0;j--)
										{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
											sum += (double)(*basis_value)*(double)(*((FE_value *)(
												element_values_storage+size*(*element_value_offset))));
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
											sum += (*basis_value)*(*((FE_value *)(
												element_values_storage+size*(*element_value_offset))));
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
											element_value_offset++;
											basis_value++;
										}
										*derivative=(FE_value)sum;
										derivative++;
									}
								}
								calculated_value++;
								component_grid_values_storage++;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field.  Missing element_value_offsets");
					}
				}
				else
				{
					/* not grid based */
					/* calculate the value for the element field */
					return_code=1;
					/* calculate a value for each component */
					current_standard_basis_function=(Standard_basis_function *)NULL;
					current_standard_basis_function_arguments=(void *)NULL;
					component_number_of_values=
						element_field_values->component_number_of_values;
					component_values=element_field_values->component_values;
					component_standard_basis_function=
						element_field_values->component_standard_basis_functions;
					component_standard_basis_function_arguments=
						element_field_values->component_standard_basis_function_arguments;
					calculated_value=values;
					if (element_field_values->derivatives_calculated)
					{
						derivative=jacobian;
					}
					else
					{
						derivative=(FE_value *)NULL;
					}
					component_number_of_values += comp_no;
					component_values += comp_no;
					component_standard_basis_function += comp_no;
					component_standard_basis_function_arguments += comp_no;
					number_of_xi_coordinates=
						element_field_values->element->shape->dimension;
					for (i=0;(i<components_to_calculate)&&return_code;i++)
					{
						/* save calculation when all components use the same basis */
						/*???DB.  Only good when consecutive components have the same basis.
							Can do better ? */
						if ((*component_standard_basis_function!=
							current_standard_basis_function)||
							(*component_standard_basis_function_arguments!=
								current_standard_basis_function_arguments))
						{
							current_standard_basis_function=
								*component_standard_basis_function;
							current_standard_basis_function_arguments=
								*component_standard_basis_function_arguments;
							number_of_values= *component_number_of_values;
							/* calculate the values for the standard basis functions */
							if (!(current_standard_basis_function)(
								current_standard_basis_function_arguments,xi_coordinates,
								basis_function_values))
							{
								display_message(ERROR_MESSAGE,"calculate_FE_element_field.  "
									"Error calculating standard basis");
								return_code=0;
							}
						}
						/* calculate the element field value as a dot product of the element
							 values and the basis function values */
						basis_value=basis_function_values;
						element_value= *component_values;
						sum=0;
						for (j=number_of_values;j>0;j--)
						{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
							sum += (double)(*element_value)*(double)(*basis_value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
							sum += (*element_value)*(*basis_value);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
							basis_value++;
							element_value++;
						}
						*calculated_value=(FE_value)sum;
						if (derivative)
						{
							for (k=number_of_xi_coordinates;k>0;k--)
							{
								sum=0;
								basis_value=basis_function_values;
								for (j=number_of_values;j>0;j--)
								{
#if defined (DOUBLE_FOR_DOT_PRODUCT)
									sum += (double)(*element_value)*(double)(*basis_value);
#else /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									sum += (*element_value)*(*basis_value);
#endif /* defined (DOUBLE_FOR_DOT_PRODUCT) */
									basis_value++;
									element_value++;
								}
								*derivative=(FE_value)sum;
								derivative++;
							}
						}
						component_number_of_values++;
						component_values++;
						component_standard_basis_function++;
						component_standard_basis_function_arguments++;
						calculated_value++;
					}
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field.  Unknown field type");
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field.  Invalid argument(s)\n"
			"element_field_values %p, xi_coordinates %p, values %p, jacobian %p",
			element_field_values,xi_coordinates,values,jacobian);
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field */

int calculate_FE_element_field_as_string(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	char **string)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Calculates the values of element field specified by the <element_field_values>
at the <xi_coordinates> and returns them as the allocated <string>. Only the
<component_number>+1 component will be calculated if
0<=component_number<number of components. If more than 1 component is calculated
then values are comma separated. Derivatives are not included in the string,
even if calculated for the <element_field_values>.
It is up to the calling function to DEALLOCATE the returned string.
==============================================================================*/
{
	char temp_string[40];
	int components_to_calculate,error,i,return_code;
	struct FE_field *field;

	ENTER(calculate_FE_element_field_as_string);
	return_code=0;
	(*string)=(char *)NULL;
	if (element_field_values&&xi_coordinates&&string&&
		(field=element_field_values->field))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			components_to_calculate=1;
		}
		else
		{
			components_to_calculate=field->number_of_components;
		}
		switch (field->value_type)
		{
			case FE_VALUE_VALUE:
			{
				FE_value *values;

				if (ALLOCATE(values,FE_value,components_to_calculate))
				{
					if (calculate_FE_element_field(component_number,
						element_field_values,xi_coordinates,values,
						/*jacobian*/(FE_value *)NULL))
					{
						error=0;
						for (i=0;i<components_to_calculate;i++)
						{
							if (0<i)
							{
								sprintf(temp_string,",%g",values[i]);
							}
							else
							{
								sprintf(temp_string,"%g",values[i]);
							}
							append_string(string,temp_string,&error);
						}
						return_code= !error;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_as_string.  "
							"Could not calculate FE_value values");
					}
					DEALLOCATE(values);
				}
			} break;
			case INT_VALUE:
			{
				int *values;

				if (ALLOCATE(values,int,components_to_calculate))
				{
					if (calculate_FE_element_field_int_values(component_number,
						element_field_values,xi_coordinates,values))
					{
						error=0;
						for (i=0;i<components_to_calculate;i++)
						{
							if (0<i)
							{
								sprintf(temp_string,",%d",values[i]);
							}
							else
							{
								sprintf(temp_string,"%d",values[i]);
							}
							append_string(string,temp_string,&error);
						}
						return_code= !error;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_as_string.  "
							"Could not calculate int values");
					}
					DEALLOCATE(values);
				}
			} break;
			case STRING_VALUE:
			{
				char **values;

				if (ALLOCATE(values,char *,components_to_calculate))
				{
					if (calculate_FE_element_field_string_values(component_number,
						element_field_values,xi_coordinates,values))
					{
						error=0;
						for (i=0;i<components_to_calculate;i++)
						{
							if (0<i)
							{
								append_string(string,",",&error);
							}
							append_string(string,values[i],&error);
						}
						for (i=0;i<components_to_calculate;i++)
						{
							DEALLOCATE(values[i]);
						}
						return_code= !error;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_as_string.  "
							"Could not calculate string values");
					}
					DEALLOCATE(values);
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_as_string.  Unknown value type %s",
					Value_type_string(field->value_type));
			} break;
		}
		if (!return_code)
		{
			display_message(ERROR_MESSAGE,
				"calculate_FE_element_field_as_string.  Failed");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_as_string.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_as_string */

int calculate_FE_element_field_int_values(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	int *values)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Calculates the <values> of the integer field specified by the
<element_field_values> at the <xi_coordinates>. The storage for the <values>
should have been allocated outside the function. Only the <component_number>+1
component will be calculated if 0<=component_number<number of components. For a
single component, the value will be put in the first position of <values>.
==============================================================================*/
{
	int comp_no,components_to_calculate,i,*number_in_xi,number_of_xi_coordinates,
		offset,return_code,size,xi_offset;
	int *calculated_value;
	FE_value xi_coordinate;
	struct FE_field *field;
	Value_storage **component_grid_values_storage,*element_values_storage;

	ENTER(calculate_FE_element_field_int_values);
	return_code=0;
	if (element_field_values&&xi_coordinates&&values&&
		(field=element_field_values->field)&&(INT_VALUE==field->value_type))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			comp_no=component_number;
			components_to_calculate=1;
		}
		else
		{
			comp_no=0;
			components_to_calculate=field->number_of_components;
		}
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				return_code=1;
				for (i=0;(i<components_to_calculate)&&return_code;i++)
				{
					if (!get_FE_field_int_value(field,comp_no,&values[i]))
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_int_values.  "
							"Could not get values for constant field %s",field->name);
						return_code=0;
					}
					comp_no++;
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index,value_no;

				REACCESS(FE_field)(&(element_field_values->field),field->indexer_field);
				if (calculate_FE_element_field_int_values(/*component_number*/0,
					element_field_values,xi_coordinates,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						return_code=1;
						value_no = index-1 + comp_no*field->number_of_indexed_values;
						for (i=0;(i<components_to_calculate)&&return_code;i++)
						{
							if (!get_FE_field_int_value(field,value_no,&values[i]))
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_int_values.  "
									"Could not get values for constant field %s",field->name);
								return_code=0;
							}
							value_no += field->number_of_indexed_values;
						}
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_int_values.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_int_values.  "
						"Could not calculate index field %s for field %s at %s %",
						field->indexer_field->name,field->name,
						CM_element_type_string(element_field_values->element->cm.type),
						element_field_values->element->cm.number);
				}
				REACCESS(FE_field)(&(element_field_values->field),field);
			} break;
			case GENERAL_FE_FIELD:
			{
				if (number_in_xi=element_field_values->number_in_xi)
				{
					/* grid based - get nearest value for INT_VALUE */
					number_of_xi_coordinates=
						element_field_values->element->shape->dimension;
					if (element_field_values->grid_offset_in_xi)
					{
						return_code=1;
						offset=element_field_values->base_grid_offset;
						for (i=0;(i<number_of_xi_coordinates)&&return_code;i++)
						{
							xi_coordinate=xi_coordinates[i];
							if ((0<=xi_coordinate)&&(xi_coordinate<=1))
							{
								/* get nearest xi_offset */
								xi_offset=(int)floor(
									(double)number_in_xi[i]*(double)xi_coordinate+0.5);
								offset += xi_offset*element_field_values->grid_offset_in_xi[i];
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_int_values.  "
									"Xi must be from 0 to 1");
								return_code=0;
							}
						}
						if (return_code)
						{
							size=get_Value_storage_size(field->value_type,
								(struct FE_time_sequence *)NULL);
							component_grid_values_storage=
								element_field_values->component_grid_values_storage;
							calculated_value=values;
							component_grid_values_storage += comp_no;
							for (i=0;i<components_to_calculate;i++)
							{
								element_values_storage=
									(*component_grid_values_storage)+size*offset;
								*calculated_value = *((int *)element_values_storage);
								calculated_value++;
								component_grid_values_storage++;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_int_values.  "
							"Missing grid_offset_in_xi");
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_int_values.  "
						"Integers only supported for grid-based fields");
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_int_values.  Unknown field type");
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_int_values.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_int_values */

int calculate_FE_element_field_string_values(int component_number,
	struct FE_element_field_values *element_field_values,FE_value *xi_coordinates,
	char **values)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Returns allocated copies of the string values of the field specified by the
<element_field_values> at the <xi_coordinates>. <values> must be allocated with
enough space for the number_of_components strings, but the strings themselves
are allocated here. Only the <component_number>+1 component will be calculated
if 0<=component_number<number of components. For a single component, the value
will be put in the first position of <values>.
It is up to the calling function to deallocate the returned string values.
==============================================================================*/
{
	int comp_no,components_to_calculate,i,j,return_code;
	struct FE_field *field;

	ENTER(calculate_FE_element_field_string_values);
	return_code=0;
	if (element_field_values&&xi_coordinates&&values&&
		(field=element_field_values->field)&&(STRING_VALUE==field->value_type))
	{
		if ((0<=component_number)&&(component_number<field->number_of_components))
		{
			comp_no=component_number;
			components_to_calculate=1;
		}
		else
		{
			comp_no=0;
			components_to_calculate=field->number_of_components;
		}
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				return_code=1;
				for (i=0;(i<components_to_calculate)&&return_code;i++)
				{
					if (!get_FE_field_string_value(field,comp_no,&values[i]))
					{
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_string_values.  "
							"Could not get values for constant field %s",field->name);
						return_code=0;
						for (j=0;j<i;j++)
						{
							DEALLOCATE(values[j]);
						}
					}
					comp_no++;
				}
			} break;
			case INDEXED_FE_FIELD:
			{
				int index,value_no;

				REACCESS(FE_field)(&(element_field_values->field),field->indexer_field);
				if (calculate_FE_element_field_int_values(/*component_number*/0,
					element_field_values,xi_coordinates,&index))
				{
					/* index numbers start at 1 */
					if ((1<=index)&&(index<=field->number_of_indexed_values))
					{
						return_code=1;
						value_no = index-1 + comp_no*field->number_of_indexed_values;
						for (i=0;(i<components_to_calculate)&&return_code;i++)
						{
							if (!get_FE_field_string_value(field,value_no,&values[i]))
							{
								display_message(ERROR_MESSAGE,
									"calculate_FE_element_field_string_values.  "
									"Could not get values for constant field %s",field->name);
								return_code=0;
								for (j=0;j<i;j++)
								{
									DEALLOCATE(values[j]);
								}
							}
							value_no += field->number_of_indexed_values;
						}
					}
					else
					{	
						display_message(ERROR_MESSAGE,
							"calculate_FE_element_field_string_values.  "
							"Index field %s gave out-of-range index %d in field %s",
							field->indexer_field->name,index,field->name);
					}
				}
				else
				{	
					display_message(ERROR_MESSAGE,
						"calculate_FE_element_field_string_values.  "
						"Could not calculate index field %s for field %s at %s %",
						field->indexer_field->name,field->name,
						CM_element_type_string(element_field_values->element->cm.type),
						element_field_values->element->cm.number);
				}
				REACCESS(FE_field)(&(element_field_values->field),field);
			} break;
			case GENERAL_FE_FIELD:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_string_values.  "
					"General fields not supported");
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_element_field_string_values.  Unknown field type");
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_field_string_values.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_field_string_values */

int calculate_FE_element_anatomical(
	struct FE_element_field_values *coordinate_element_field_values,
	struct FE_element_field_values *anatomical_element_field_values,
	FE_value *xi_coordinates,FE_value *x,FE_value *y,FE_value *z,FE_value a[3],
	FE_value b[3],FE_value c[3],FE_value *dx_dxi)
/*******************************************************************************
LAST MODIFIED : 30 August 2001

DESCRIPTION :
Calculates the cartesian coordinates (<x>, <y> and <z>), and the fibre (<a>),
cross-sheet (<b>) and sheet-normal (<c>) vectors from a coordinate element field
and an anatomical element field.  The storage for the <x>, <y>, <z>, <a>, <b>
and <c> should have been allocated outside the function.
If later conversion of a, b and c to vectors in xi space is required, the
optional <dx_dxi> parameter should be supplied and point to a enough memory to
contain the nine derivatives of x,y,z w.r.t. three xi. These are returned in the
order dx/dxi1, dx/dxi2, dx/dxi3, dy/dxi1 etc. Note that there will always be
nine values returned, regardless of the element dimension.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;
	FE_value anatomical_result[3],a_x,a_y,a_z,b_x,b_y,b_z,coordinates[3],
		cos_alpha,cos_beta,cos_gamma,c_x,c_y,c_z,derivative_xi[9],distance,d_xi1_0,
		d_xi1_1,d_xi1_2,d_xi2_0,d_xi2_1,d_xi2_2,d_xi3_0,d_xi3_1,d_xi3_2,f11,
		f12,f13,f21,f22,f23,f31,f32,f33,jacobian[9],sin_alpha,sin_beta,sin_gamma;
	int return_code;
	struct FE_element *element;

	ENTER(calculate_FE_element_anatomical);
	/* check the arguments */
	if (coordinate_element_field_values&&anatomical_element_field_values&&
		xi_coordinates&&x&&y&&z&&a&&b&&c&&(coordinate_element_field_values->field)&&
		(CM_COORDINATE_FIELD==
		coordinate_element_field_values->field->cm_field_type)&&
		(anatomical_element_field_values->field)&&
		(CM_ANATOMICAL_FIELD==
		anatomical_element_field_values->field->cm_field_type)&&
		(FIBRE==anatomical_element_field_values->field->coordinate_system.type)&&
		(3>=anatomical_element_field_values->field->number_of_components)&&
		(element=coordinate_element_field_values->element)&&
		(element==anatomical_element_field_values->element)&&(element->shape)&&
		((2==element->shape->dimension)||(3==element->shape->dimension))&&
		/* must have at least as many components as xi directions! */
		(element->shape->dimension<=
		coordinate_element_field_values->field->number_of_components))
	{
		coordinate_system = get_FE_field_coordinate_system(
			 coordinate_element_field_values->field);
#if defined (OLD_CODE)
		/* set up storage for the basis function values */
		basis_function_values=preallocated_basis_function_values;
		if (!basis_function_values)
		{
			i=coordinate_element_field_values->number_of_components-1;
			component_number_of_values=
				coordinate_element_field_values->component_number_of_values;
			max_basis_function_values= *component_number_of_values;
			while (i>0)
			{
				i--;
				component_number_of_values++;
				if (*component_number_of_values>max_basis_function_values)
				{
					max_basis_function_values= *component_number_of_values;
				}
			}
			i=anatomical_element_field_values->number_of_components;
			component_number_of_values=
				anatomical_element_field_values->component_number_of_values;
			while (i>0)
			{
				if (*component_number_of_values>max_basis_function_values)
				{
					max_basis_function_values= *component_number_of_values;
				}
				component_number_of_values++;
				i--;
			}
			if (max_basis_function_values>0)
			{
				ALLOCATE(basis_function_values,FE_value,max_basis_function_values);
			}
		}
		if (basis_function_values)
		{
#endif /* defined (OLD_CODE) */
			/* calculate the coordinate field */
			if (calculate_FE_element_field(-1,coordinate_element_field_values,
				xi_coordinates,coordinates,derivative_xi))
			{
				return_code=1;
				/* calculate the fibre field coordinate vectors - f1 (f), f2 (g) and
					f3 (h) - in rectangular cartesian coordinates*/
				/* calculate the base vectors for xi1 and xi2 in rectangular
					cartesian coordinates (use f1 and f2 as temporary storage) */
				switch (element->shape->dimension)
				{
					case 2:
					{
						d_xi1_0=derivative_xi[0];
						d_xi1_1=derivative_xi[2];
						d_xi2_0=derivative_xi[1];
						d_xi2_1=derivative_xi[3];
						if (2==coordinate_element_field_values->field->number_of_components)
						{
							/* clear z components of 2-component, 2-D elements */
							coordinates[2]=0;
							d_xi1_2=0.0;
							d_xi1_2=0.0;
						}
						else
						{
							d_xi1_2=derivative_xi[4];
							d_xi2_2=derivative_xi[5];
						}
						/* need d_xi3_d* for returning dx_dxi */
						d_xi3_0=0.0;
						d_xi3_1=0.0;
						d_xi3_2=0.0;
					} break;
					case 3:
					{
						d_xi1_0=derivative_xi[0];
						d_xi1_1=derivative_xi[3];
						d_xi1_2=derivative_xi[6];
						d_xi2_0=derivative_xi[1];
						d_xi2_1=derivative_xi[4];
						d_xi2_2=derivative_xi[7];
						/* need d_xi3_d* for returning dx_dxi */
						d_xi3_0=derivative_xi[2];
						d_xi3_1=derivative_xi[5];
						d_xi3_2=derivative_xi[8];
					} break;
				}
				if (RECTANGULAR_CARTESIAN!=coordinate_system->type)
				{
					switch (coordinate_system->type)
					{
						case CYLINDRICAL_POLAR:
						{
							cylindrical_polar_to_cartesian(coordinates[0],
								coordinates[1],coordinates[2],x,y,z,jacobian);
						} break;
						case SPHERICAL_POLAR:
						{
							spherical_polar_to_cartesian(coordinates[0],
								coordinates[1],coordinates[2],x,y,z,jacobian);
						} break;
						case PROLATE_SPHEROIDAL:
						{
							prolate_spheroidal_to_cartesian(coordinates[0],
								coordinates[1],coordinates[2],
								coordinate_system->parameters.focus,x,y,z,jacobian);
						} break;
						default:
						{
							display_message(ERROR_MESSAGE,
	"create_fibre_field_from_FE_element.  Invalid coordinate system");
							return_code=0;
						} break;
					}
					if (return_code)
					{
						f11=jacobian[0]*d_xi1_0+jacobian[1]*d_xi1_1+jacobian[2]*d_xi1_2;
						f12=jacobian[3]*d_xi1_0+jacobian[4]*d_xi1_1+jacobian[5]*d_xi1_2;
						f13=jacobian[6]*d_xi1_0+jacobian[7]*d_xi1_1+jacobian[8]*d_xi1_2;
						f21=jacobian[0]*d_xi2_0+jacobian[1]*d_xi2_1+jacobian[2]*d_xi2_2;
						f22=jacobian[3]*d_xi2_0+jacobian[4]*d_xi2_1+jacobian[5]*d_xi2_2;
						f23=jacobian[6]*d_xi2_0+jacobian[7]*d_xi2_1+jacobian[8]*d_xi2_2;
						/* need f3* for returning dx_dxi */
						f31=jacobian[0]*d_xi3_0+jacobian[1]*d_xi3_1+jacobian[2]*d_xi3_2;
						f32=jacobian[3]*d_xi3_0+jacobian[4]*d_xi3_1+jacobian[5]*d_xi3_2;
						f33=jacobian[6]*d_xi3_0+jacobian[7]*d_xi3_1+jacobian[8]*d_xi3_2;
					}
				}
				else
				{
					*x=coordinates[0];
					*y=coordinates[1];
					*z=coordinates[2];
					f11=d_xi1_0;
					f12=d_xi1_1;
					f13=d_xi1_2;
					f21=d_xi2_0;
					f22=d_xi2_1;
					f23=d_xi2_2;
					/* need f3* for returning dx_dxi */
					f31=d_xi3_0;
					f32=d_xi3_1;
					f33=d_xi3_2;
				}
				if (dx_dxi)
				{
					/* return the dx/dxi vectors to the calling function */
					dx_dxi[0]=f11;
					dx_dxi[1]=f21;
					dx_dxi[2]=f31;
					dx_dxi[3]=f12;
					dx_dxi[4]=f22;
					dx_dxi[5]=f32;
					dx_dxi[6]=f13;
					dx_dxi[7]=f23;
					dx_dxi[8]=f33;
				}
				/* f3 is normal to the xi1-xi2 plane */
				f31=f12*f23-f22*f13;
				f32=f13*f21-f23*f11;
				f33=f11*f22-f21*f12;
#if defined (OLD_CODE)
				switch (coordinate_system->type)
				{
					case CYLINDRICAL_POLAR:
					case SPHERICAL_POLAR:
					{
						/* f1 is the intersection of the xi1-xi2 plane with the
							x-y plane, with f1.(xi1 base vector) positive */
						if (0<f11*f33-f13*f31)
						{
							f11=f32;
							f12= -f31;
							f13=0;
						}
						else
						{
							f11= -f32;
							f12=f31;
							f13=0;
						}
					} break;
					case RECTANGULAR_CARTESIAN:
					case PROLATE_SPHEROIDAL:
					{
						/* f1 is the intersection of the xi1-xi2 plane with the
							y-z plane, with f1.(xi1 base vector) positive */
						if (0<f12*f33-f13*f32)
						{
							f11=0;
							f12=f33;
							f13= -f32;
						}
						else
						{
							f11=0;
							f12= -f33;
							f13=f32;
						}
					} break;
				}
#endif /* defined (OLD_CODE) */
				/* f1 is in the xi1 direction */
				/* f2 is in the xi1-xi2 plane normal to f1 */
				f21=f32*f13-f12*f33;
				f22=f33*f11-f13*f31;
				f23=f31*f12-f11*f32;
				/* normalize */
				if (0<(distance=f11*f11+f12*f12+f13*f13))
				{
					distance=sqrt(distance);
					f11 /= distance;
					f12 /= distance;
					f13 /= distance;
				}
				if (0<(distance=f21*f21+f22*f22+f23*f23))
				{
					distance=sqrt(distance);
					f21 /= distance;
					f22 /= distance;
					f23 /= distance;
				}
				if (0<(distance=f31*f31+f32*f32+f33*f33))
				{
					distance=sqrt(distance);
					f31 /= distance;
					f32 /= distance;
					f33 /= distance;
				}
				/* calculate the fibre field */
				if (calculate_FE_element_field(-1,anatomical_element_field_values,
					xi_coordinates,anatomical_result,(FE_value *)NULL))
				{
					sin_alpha=sin(anatomical_result[0]);
					cos_alpha=cos(anatomical_result[0]);
					if (1<anatomical_element_field_values->field->number_of_components)
					{
						sin_beta=sin(anatomical_result[1]);
						cos_beta=cos(anatomical_result[1]);
						/*???RC following was if (1<an...) Was this an error?!? */
						if (2<anatomical_element_field_values->field->number_of_components)
						{
							sin_gamma=sin(anatomical_result[2]);
							cos_gamma=cos(anatomical_result[2]);
						}
						else
						{
#if defined (OLD_CODE)
							/* default gamma is pi/2 */
							sin_gamma=1;
							cos_gamma=0;
#endif /* defined (OLD_CODE) */
							/* default gamma is 0 */
							sin_gamma=0;
							cos_gamma=1;
						}
					}
					else
					{
						/* default beta is 0 */
						sin_beta=0;
						cos_beta=1;
#if defined (OLD_CODE)
						/* default gamma is pi/2 */
						sin_gamma=1;
						cos_gamma=0;
#endif /* defined (OLD_CODE) */
						/* default gamma is 0 */
						sin_gamma=0;
						cos_gamma=1;
					}
					/* calculate the fibre vector */
					a_x=cos_alpha*f11+sin_alpha*f21;
					a_y=cos_alpha*f12+sin_alpha*f22;
					a_z=cos_alpha*f13+sin_alpha*f23;
					b_x= -sin_alpha*f11+cos_alpha*f21;
					b_y= -sin_alpha*f12+cos_alpha*f22;
					b_z= -sin_alpha*f13+cos_alpha*f23;
					f11=a_x;
					f12=a_y;
					f13=a_z;
					f21=b_x;
					f22=b_y;
					f23=b_z;
					/* as per KATs change 30Nov00 in back-end function ROT_COORDSYS,
						rotate anticlockwise about axis2, not -axis2 */
#if defined (OLD_CODE)
					a_x=cos_beta*f11+sin_beta*f31;
					a_y=cos_beta*f12+sin_beta*f32;
					a_z=cos_beta*f13+sin_beta*f33;
					c_x= -sin_beta*f11+cos_beta*f31;
					c_y= -sin_beta*f12+cos_beta*f32;
					c_z= -sin_beta*f13+cos_beta*f33;
#endif /* defined (OLD_CODE) */
					c_x=cos_beta*f31+sin_beta*f11;
					c_y=cos_beta*f32+sin_beta*f12;
					c_z=cos_beta*f33+sin_beta*f13;
					a_x= -sin_beta*f31+cos_beta*f11;
					a_y= -sin_beta*f32+cos_beta*f12;
					a_z= -sin_beta*f33+cos_beta*f13;
					f31=c_x;
					f32=c_y;
					f33=c_z;
#if defined (OLD_CODE)
					/* note rearrangement of sin/cos to give equivalent rotation of
						gamma - PI/2.  Note we will probably remove the -PI/2 factor at some
						stage */
					b_x=sin_gamma*f21-cos_gamma*f31;
					b_y=sin_gamma*f22-cos_gamma*f32;
					b_z=sin_gamma*f23-cos_gamma*f33;
					c_x=cos_gamma*f21+sin_gamma*f31;
					c_y=cos_gamma*f22+sin_gamma*f32;
					c_z=cos_gamma*f23+sin_gamma*f33;
#endif /* defined (OLD_CODE) */
					b_x=cos_gamma*f21+sin_gamma*f31;
					b_y=cos_gamma*f22+sin_gamma*f32;
					b_z=cos_gamma*f23+sin_gamma*f33;
					c_x= -sin_gamma*f21+cos_gamma*f31;
					c_y= -sin_gamma*f22+cos_gamma*f32;
					c_z= -sin_gamma*f23+cos_gamma*f33;
					a[0]=a_x;
					a[1]=a_y;
					a[2]=a_z;
					b[0]=b_x;
					b[1]=b_y;
					b[2]=b_z;
					c[0]=c_x;
					c[1]=c_y;
					c[2]=c_z;
				}
				else
				{
					display_message(ERROR_MESSAGE,
				"calculate_FE_element_anatomical.  Error calculating anatomical field");
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
				"calculate_FE_element_anatomical.  Error calculating coordinate field");
				return_code=0;
			}
#if defined (OLD_CODE)
			if (!preallocated_basis_function_values)
			{
				DEALLOCATE(basis_function_values);
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
	"calculate_FE_element_anatomical.  Could not allocate basis_function_values");
			return_code=0;
		}
#endif /* defined (OLD_CODE) */
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"calculate_FE_element_anatomical.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_element_anatomical */

int equivalent_FE_field_in_elements(struct FE_field *field,
	struct FE_element *element_1, struct FE_element *element_2)
/*******************************************************************************
LAST MODIFIED : 24 March 2003

DESCRIPTION :
Returns true if <field> is equivalently listed in the field information for
<element_1> and <element_2>. If neither element has field information or if they
do but the field is not defined in either, this is also equivalent.
==============================================================================*/
{
	int return_code;
	struct FE_element_field *element_field_1, *element_field_2;

	ENTER(equivalent_FE_field_in_elements);
	return_code = 0;
	if (field && element_1 && element_1->fields && element_2 && element_2->fields)
	{
		if (element_1->fields == element_2->fields)
		{
			return_code = 1;
		}
		else
		{
			element_field_1 = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field, field)(
				field, element_1->fields->element_field_list);
			element_field_2 = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field, field)(
				field, element_2->fields->element_field_list);
			return_code = ((!element_field_1) && (!element_field_2)) || (
				element_field_1 && element_1->information &&
				element_field_2 && element_2->information &&
				FE_element_fields_match(element_field_1, element_1->information,
					/*global_node_list1*/(struct LIST(FE_node) *)NULL,
					element_field_2, element_2->information,
					/*ignore_field_and_time_sequence*/0, /*differences_are_errors*/0));
		}
	}
	LEAVE;

	return (return_code);
} /* equivalent_FE_field_in_elements */

int equivalent_FE_fields_in_elements(struct FE_element *element_1,
	struct FE_element *element_2)
/*******************************************************************************
LAST MODIFIED : 6 November 2002

DESCRIPTION :
Returns true if all fields are defined in the same way at the two elements.
==============================================================================*/
{
	int return_code;

	ENTER(equivalent_FE_fields_in_elements);
	if (element_1 && element_2)
	{
		return_code = (element_1->fields == element_2->fields);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"equivalent_FE_fields_in_elements.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* equivalent_FE_fields_in_elements */

int get_FE_element_dimension(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 4 November 1999

DESCRIPTION :
Returns the dimension of the <element> or an error if it does not have a shape.
==============================================================================*/
{
	int dimension;

	ENTER(get_FE_element_dimension);
	dimension=0;
	if (element)
	{
		if (element->shape)
		{
			dimension=element->shape->dimension;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_dimension.  Element must have a shape");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_dimension.  Missing element");
	}
	LEAVE;

	return (dimension);
} /* get_FE_element_dimension */

int FE_element_get_cm_number(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 13 March 2003

DESCRIPTION :
Returns the cm number of the <element> or an error if it does not have a shape.
==============================================================================*/
{
	int cm_number;

	ENTER(FE_element_get_cm_number);
	cm_number=0;
	if (element)
	{
		cm_number=element->cm.number;
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_get_cm_number.  Missing element");
	}
	LEAVE;

	return (cm_number);
} /* FE_element_get_cm_number */

int get_FE_element_identifier(struct FE_element *element,
	struct CM_element_information *identifier)
/*******************************************************************************
LAST MODIFIED : 29 October 2002

DESCRIPTION :
Fills in the <identifier> of <element>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_identifier);
	if (element && identifier)
	{
		identifier->type = element->cm.type;
		identifier->number = element->cm.number;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_identifier.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_identifier */

int set_FE_element_identifier(struct FE_element *element,
	struct CM_element_information *identifier)
/*******************************************************************************
LAST MODIFIED : 16 January 2003

DESCRIPTION :
Changes the identifier of <element> to <identifier>.
Caution! Should only call for elements that are NOT in indexed lists;
Must wrap in LIST_BEGIN_IDENTIFIER_CHANGE/LIST_END_IDENTIFIER_CHANGE to ensure
element is temporarily removed from all the indexed lists it is in and re-added
afterwards. FE_region should be the only object that needs to call this.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_element_identifier);
	if (element && identifier && (0 < identifier->number))
	{
		element->cm.type = identifier->type;
		element->cm.number = identifier->number;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_identifier.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_identifier */

struct FE_element_parent_changed_data
{
	struct CHANGE_LOG(FE_element) *fe_element_change_log;
	struct CHANGE_LOG(FE_node) *fe_node_change_log;
};

static int FE_element_parent_changed(
	struct FE_element_parent *element_parent,void *data_void)
/*******************************************************************************
LAST MODIFIED : 11 February 2003

DESCRIPTION :
FE_element_parent conditional version of FE_element_or_parent_changed.
<data_void> points at a struct FE_element_parent_changed_data.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_changed_data *data;

	ENTER(FE_element_parent_changed);
	if (element_parent &&
		(data = (struct FE_element_parent_changed_data *)data_void))
	{
		return_code = FE_element_or_parent_changed(element_parent->parent,
			data->fe_element_change_log, data->fe_node_change_log);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_changed.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_changed */

int FE_element_or_parent_changed(struct FE_element *element,
	struct CHANGE_LOG(FE_element) *fe_element_change_log,
	struct CHANGE_LOG(FE_node) *fe_node_change_log)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Returns true if <element> or any of its parent elements is listed in the
<fe_element_change_log> with any of OBJECT_IDENTIFIER_CHANGED,
OBJECT_NOT_IDENTIFIER_CHANGED or OBJECT_REMOVED.
Since element fields depend on node fields, the element is also considered as
changed if it or any of its parents uses a node listed in the
<fe_node_change_log> with OBJECT_IDENTIFIER_CHANGED and/or
OBJECT_NOT_IDENTIFIER_CHANGED.
==============================================================================*/
{
	enum CHANGE_LOG_CHANGE(FE_element) element_change;
	enum CHANGE_LOG_CHANGE(FE_node) node_change;
	int i, number_of_nodes, return_code;
	struct FE_element_parent_changed_data data;
	struct FE_node *node, **nodes;

	ENTER(FE_element_or_parent_changed);
	return_code = 0;
	if (element && fe_element_change_log && fe_node_change_log)
	{
		if (CHANGE_LOG_QUERY(FE_element)(fe_element_change_log, element,
			&element_change) && (element_change & (
				CHANGE_LOG_OBJECT_NOT_IDENTIFIER_CHANGED(FE_element) |
				CHANGE_LOG_OBJECT_IDENTIFIER_CHANGED(FE_element) |
				CHANGE_LOG_OBJECT_REMOVED(FE_element))))
		{
			return_code = 1;
		}
		else
		{
			/* check nodes, if any; try to make as efficient as possible */
			if (element->information && (nodes = element->information->nodes))
			{
				number_of_nodes = element->information->number_of_nodes;
				for (i = 0; (i < number_of_nodes) && (!return_code); i++)
				{
					if ((node = nodes[i]) &&
						CHANGE_LOG_QUERY(FE_node)(fe_node_change_log, node, &node_change) &&
						(node_change & (
							CHANGE_LOG_OBJECT_NOT_IDENTIFIER_CHANGED(FE_node) |
							CHANGE_LOG_OBJECT_IDENTIFIER_CHANGED(FE_node))))
					{
						return_code = 1;
					}
				}
			}
			if (!return_code)
			{
				/* try parents */
				data.fe_element_change_log = fe_element_change_log;
				data.fe_node_change_log = fe_node_change_log;
				if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_changed, (void *)&data, element->parent_list))
				{
					return_code = 1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_changed.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_or_parent_changed */

int get_FE_element_number_of_fields(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 4 November 2002

DESCRIPTION :
Returns the number of fields defined at <element>.
Does not include fields inherited from parent elements.
==============================================================================*/
{
	int number_of_fields;

	ENTER(get_FE_element_number_of_fields);
	if (element && element->fields)
	{
		number_of_fields =
			NUMBER_IN_LIST(FE_element_field)(element->fields->element_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_number_of_fields.  Missing element");
		number_of_fields = 0;
	}
	LEAVE;

	return (number_of_fields);
} /* get_FE_element_number_of_fields */

int get_FE_element_number_of_parents(struct FE_element *element,
	int *number_of_parents_address)
/*******************************************************************************
LAST MODIFIED : 14 January 2003

DESCRIPTION :
Returns the number of parents of <element>.
Can be used to determine if a face is in use by more than one parent elements.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_number_of_parents);
	if (element && number_of_parents_address)
	{
		*number_of_parents_address =
			NUMBER_IN_LIST(FE_element_parent)(element->parent_list);
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_number_of_parents.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_number_of_parents */

struct FE_element_parent_count_if_element_in_list_data
/*******************************************************************************
LAST MODIFIED : 14 January 2003

DESCRIPTION :
Data for passing to FE_element_parent_count_if_element_in_list.
==============================================================================*/
{
	int count;
	struct LIST(FE_element) *element_list;
};

static int FE_element_parent_count_if_element_in_list(
	struct FE_element_parent *element_parent, void *count_data_void)
/*******************************************************************************
LAST MODIFIED : 14 January 2003

DESCRIPTION :
If the element in <element_parent> is in <element_list>, increments <count>.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_count_if_element_in_list_data *count_data;

	ENTER(FE_element_parent_count_if_element_in_list);
	if (element_parent && (count_data =
		(struct FE_element_parent_count_if_element_in_list_data *)count_data_void))
	{
		if (IS_OBJECT_IN_LIST(FE_element)(element_parent->parent,
			count_data->element_list))
		{
			(count_data->count)++;
		}
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_count_if_element_in_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_count_if_element_in_list */

int get_FE_element_number_of_parents_in_list(struct FE_element *element,
	struct LIST(FE_element) *element_list, int *number_of_parents_address)
/*******************************************************************************
LAST MODIFIED : 14 January 2003

DESCRIPTION :
Returns the number of parents of <element> that are in <element_list>.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_count_if_element_in_list_data count_data;

	ENTER(get_FE_element_number_of_parents_in_list);
	if (element && element_list && number_of_parents_address)
	{
		count_data.count = 0;
		count_data.element_list = element_list;
		return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
			FE_element_parent_count_if_element_in_list, (void *)&count_data,
			element->parent_list);
		*number_of_parents_address = count_data.count;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_number_of_parents_in_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_number_of_parents_in_list */

int FE_element_get_first_parent(struct FE_element *element,
	struct FE_element **parent_element_address, int *face_number_address)
/*******************************************************************************
LAST MODIFIED : 7 April 2003

DESCRIPTION :
Returns the first <parent_element> of <element> and the <face_number> it is at.
If there is no parent, a true return_code is returned but with a NULL
<parent_element>.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent *element_parent;

	ENTER(FE_element_get_first_parent);
	if (element && parent_element_address && face_number_address)
	{
		if (element_parent = FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
			(LIST_CONDITIONAL_FUNCTION(FE_element_parent) *)NULL, (void *)NULL,
			element->parent_list))
		{
			*parent_element_address = element_parent->parent;
			*face_number_address = element_parent->face_number;
		}
		else
		{
			*parent_element_address = (struct FE_element *)NULL;
			*face_number_address = 0;
		}
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_first_parent.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_get_first_parent */

int get_FE_element_shape(struct FE_element *element,
	struct FE_element_shape **shape)
/*******************************************************************************
LAST MODIFIED : 12 October 1999

DESCRIPTION :
Returns the <shape> of the <element>, if any. Only newly created blank elements
should have no shape.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_shape);
	if (element&&shape)
	{
		*shape = element->shape;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_shape.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_shape */

int get_FE_element_number_of_faces(struct FE_element *element,
	int *number_of_faces_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the number of faces of <element>.
If fails, puts zero at <number_of_faces_address>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_number_of_faces);
	if (element && element->shape && number_of_faces_address)
	{
		*number_of_faces_address = element->shape->number_of_faces;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_number_of_faces.  Invalid element");
		if (number_of_faces_address)
		{
			*number_of_faces_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_number_of_faces */

int get_FE_element_face(struct FE_element *element,int face_number,
	struct FE_element **face_element)
/*******************************************************************************
LAST MODIFIED : 12 October 1999

DESCRIPTION :
Returns the <face_element> for face <face_number> of <element>, where NULL means
there is no face. Element must have a shape and face.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_face);
	if (element&&element->shape&&element->faces&&(0<=face_number)&&
		(face_number<element->shape->number_of_faces)&&face_element)
	{
		*face_element=element->faces[face_number];
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_face.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_face */

int set_FE_element_face(struct FE_element *element,int face_number,
	struct FE_element *face_element)
/*******************************************************************************
LAST MODIFIED : 7 October 1999

DESCRIPTION :
Sets face <face_number> of <element> to <face_element>, ensuring the
<face_element> has <element> as a parent. <face_element> may be NULL = no face.
Must have set the shape with set_FE_element_shape first.
Should only be called for unmanaged elements.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent *face_parent;

	ENTER(set_FE_element_face);
	return_code=0;
	if (element&&element->shape&&element->faces&&(0<=face_number)&&
		(face_number<element->shape->number_of_faces))
	{
		return_code=1;
		/* check correct face not already established - otherwise following logic
			 will fail! */
		if (element->faces[face_number] != face_element)
		{
			if (face_element)
			{
				/* set up new face/parent relationship */
				if (face_parent=CREATE(FE_element_parent)(element,face_number))
				{
					if (!ADD_OBJECT_TO_LIST(FE_element_parent)(face_parent,
						face_element->parent_list))
					{
						display_message(ERROR_MESSAGE,
							"set_FE_element_face.  Could not set element as parent of face");
						DESTROY(FE_element_parent)(&face_parent);
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"set_FE_element_face.  Could not create face_parent");
					return_code=0;
				}
			}
			if (return_code)
			{
				if (element->faces[face_number])
				{
					/* remove existing face/parent connection */
					if (face_parent=FIND_BY_IDENTIFIER_IN_LIST(FE_element_parent,
						parent)(element,element->faces[face_number]->parent_list))
					{
						REMOVE_OBJECT_FROM_LIST(FE_element_parent)(
							face_parent,element->faces[face_number]->parent_list);
					}
				}
				/* set the new face */
				REACCESS(FE_element)(&(element->faces[face_number]),face_element);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_face.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_face */

int set_FE_element_number_of_nodes(struct FE_element *element,
	int number_of_nodes)
/*******************************************************************************
LAST MODIFIED : 11 February 2003

DESCRIPTION :
Establishes storage for <number_of_nodes> in <element>.
May only be set once; should only be called for unmanaged elements.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_element_number_of_nodes);
	if (element && (0 <= number_of_nodes))
	{
		if (element->information ||
			(element->information = CREATE(FE_element_node_scale_field_info)()))
		{
			return_code = FE_element_node_scale_field_info_set_number_of_nodes(
				element->information, number_of_nodes);
		}
		else
		{
			display_message(ERROR_MESSAGE, "set_FE_element_number_of_nodes.  "
				"Could not create node_scale_field_info");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_number_of_nodes.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_number_of_nodes */

int get_FE_element_number_of_nodes(struct FE_element *element,
	int *number_of_nodes_address)
/*******************************************************************************
LAST MODIFIED : 19 December 2002

DESCRIPTION :
Returns the number of nodes directly referenced by <element>; does not include
nodes used by fields inherited from parent elements.
If fails, puts zero at <number_of_nodes_address>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_number_of_nodes);
	if (element && number_of_nodes_address)
	{
		if (element->information)
		{
			*number_of_nodes_address = element->information->number_of_nodes;
		}
		else
		{
			*number_of_nodes_address = 0;
		}
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_number_of_nodes.  Invalid argument(s)");
		if (number_of_nodes_address)
		{
			*number_of_nodes_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_number_of_nodes */

int FE_element_has_FE_node(struct FE_element *element, void *node_void)
/*******************************************************************************
LAST MODIFIED : 13 May 2003

DESCRIPTION :
Returns true if <element> references the <node>.
==============================================================================*/
{
	int i, number_of_nodes, return_code;
	struct FE_node *node, **nodes;

	ENTER(FE_element_has_FE_node);
	return_code = 0;
	if (element && (node = (struct FE_node *)node_void))
	{
		if (element->information && (nodes = element->information->nodes) &&
			(0 < (number_of_nodes = element->information->number_of_nodes)))
		{
			for (i = 0; i < number_of_nodes; i++)
			{
				if (nodes[i] == node)
				{
					return_code = 1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_FE_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_FE_node */

int get_FE_element_node(struct FE_element *element,int node_number,
	struct FE_node **node)
/*******************************************************************************
LAST MODIFIED : 13 May 2003

DESCRIPTION :
Gets node <node_number>, from 0 to number_of_nodes-1 of <element> in <node>.
<element> must already have a shape and node_scale_field_information.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_node);
	if (element && element->information &&
		element->information->nodes&&(0<=node_number)&&
		(node_number<element->information->number_of_nodes)&&node)
	{
		*node=element->information->nodes[node_number];
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,"get_FE_element_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_node */

int set_FE_element_node(struct FE_element *element,int node_number,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 11 February 2003

DESCRIPTION :
Sets node <node_number>, from 0 to number_of_nodes-1 of <element> to <node>.
<element> must already have a shape and node_scale_field_information.
Should only be called for unmanaged elements.
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_element_node);
	if (element && node)
	{
		return_code = FE_element_node_scale_field_info_set_node(
			element->information, node_number, node);
	}
	else
	{
		display_message(ERROR_MESSAGE,"set_FE_element_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_node */

int set_FE_element_number_of_scale_factor_sets(struct FE_element *element,
	int number_of_scale_factor_sets, void **scale_factor_set_identifiers,
	int *numbers_in_scale_factor_sets)
/*******************************************************************************
LAST MODIFIED : 24 March 2003

DESCRIPTION :
Establishes storage for <number_of_scale_factor_sets> in <element>, each
containing <numbers_in_scale_factor_sets> and identifier by
<scale_factor_set_identifiers>.
May only be set once; should only be called for unmanaged elements.
==============================================================================*/
{
	int i, number_of_scale_factors, return_code;

	ENTER(set_FE_element_number_of_scale_factor_sets);
	if (element && (0 <= number_of_scale_factor_sets) &&
		((0 == number_of_scale_factor_sets) || (scale_factor_set_identifiers &&
			numbers_in_scale_factor_sets)))
	{
		return_code = 1;
		/* check scale factor set identifiers and numbers and count number of
			 scale factors */
		number_of_scale_factors = 0;
		for (i = 0; (i < number_of_scale_factor_sets) && return_code; i++)
		{
			if (scale_factor_set_identifiers[i] &&
				(0 <= numbers_in_scale_factor_sets[i]))
			{
				number_of_scale_factors += numbers_in_scale_factor_sets[i];
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"set_FE_element_number_of_scale_factor_sets.  "
					"Invalid scale factor set identifier or number");
				return_code = 0;
			}
		}
		if (element->information)
		{
			if (0 < element->information->number_of_scale_factor_sets)
			{
				display_message(ERROR_MESSAGE,
					"set_FE_element_number_of_scale_factor_sets.  "
					"Number of scale factor sets is already set");
				return_code = 0;
			}
		}
		else
		{
			if (!(element->information = CREATE(FE_element_node_scale_field_info)()))
			{
				display_message(ERROR_MESSAGE,
					"set_FE_element_number_of_scale_factor_sets.  "
					"Could not create node_scale_field_info");
				return_code = 0;
			}
		}
		if (return_code && (0 < number_of_scale_factor_sets))
		{
			if (ALLOCATE(element->information->scale_factor_set_identifiers, void *,
				number_of_scale_factor_sets) &&
				ALLOCATE(element->information->numbers_in_scale_factor_sets, int,
					number_of_scale_factor_sets) &&
				((0 == number_of_scale_factors) ||
					ALLOCATE(element->information->scale_factors, FE_value,
						number_of_scale_factors)))
			{
				for (i = 0; i < number_of_scale_factor_sets; i++)
				{
					element->information->scale_factor_set_identifiers[i] =
						scale_factor_set_identifiers[i];
					element->information->numbers_in_scale_factor_sets[i] =
						numbers_in_scale_factor_sets[i];
				}
				for (i = 0; i < number_of_scale_factors; i++)
				{
					element->information->scale_factors[i] = FE_VALUE_INITIALIZER;
				}
				element->information->number_of_scale_factor_sets =
					number_of_scale_factor_sets;
				element->information->number_of_scale_factors = number_of_scale_factors;
			}
			else
			{
				display_message(ERROR_MESSAGE, "set_FE_element_number_of_nodes.  "
					"Could not allocate space for scale factor sets");
				DEALLOCATE(element->information->numbers_in_scale_factor_sets);
				DEALLOCATE(element->information->scale_factor_set_identifiers);
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_number_of_scale_factor_sets.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_number_of_scale_factor_sets */

int get_FE_element_number_of_scale_factor_sets(struct FE_element *element,
	int *number_of_scale_factor_sets_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the number of scale factor_sets in <element>.
If fails, puts zero at <number_of_scale_factor_sets_address>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_number_of_scale_factor_sets);
	if (element && number_of_scale_factor_sets_address)
	{
		if (element->information)
		{
			*number_of_scale_factor_sets_address =
				element->information->number_of_scale_factor_sets;
		}
		else
		{
			*number_of_scale_factor_sets_address = 0;
		}
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_number_of_scale_factor_sets.  Invalid element");
		if (number_of_scale_factor_sets_address)
		{
			*number_of_scale_factor_sets_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_number_of_scale_factor_sets */

int get_FE_element_numbers_in_scale_factor_set(struct FE_element *element,
	int scale_factor_set_number, int *numbers_in_scale_factor_set_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the number of scale factors in <scale_factor_set_number> of <element>,
where <scale_factor_set_number> is from 0 to one less than the number of sets.
If fails, puts zero in *<numbers_in_scale_factor_set_address> if supplied.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_numbers_in_scale_factor_set);
	if (element && element->information && (0 <= scale_factor_set_number) &&
		(scale_factor_set_number <
			element->information->number_of_scale_factor_sets) &&
		numbers_in_scale_factor_set_address)
	{
		*numbers_in_scale_factor_set_address = element->information->
			numbers_in_scale_factor_sets[scale_factor_set_number];
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_numbers_in_scale_factor_set.  Invalid argument(s)");
		if (numbers_in_scale_factor_set_address)
		{
			*numbers_in_scale_factor_set_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_numbers_in_scale_factor_set */

int get_FE_element_scale_factor_set_identifier(struct FE_element *element,
	int scale_factor_set_number, void **scale_factor_set_identifier_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the identifier of <scale_factor_set_number> of <element>,
where <scale_factor_set_number> is from 0 to one less than the number of sets.
If fails, puts NULL in *<scale_factor_set_identifier_address> if supplied.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_scale_factor_set_identifier);
	if (element && element->information && (0 <= scale_factor_set_number) &&
		(scale_factor_set_number <
			element->information->number_of_scale_factor_sets) &&
		scale_factor_set_identifier_address)
	{
		*scale_factor_set_identifier_address = element->information->
			scale_factor_set_identifiers[scale_factor_set_number];
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_scale_factor_set_identifier.  Invalid argument(s)");
		if (scale_factor_set_identifier_address)
		{
			*scale_factor_set_identifier_address = (void *)NULL;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_scale_factor_set_identifier */

int get_FE_element_number_of_scale_factors(struct FE_element *element,
	int *number_of_scale_factors_address)
/*******************************************************************************
LAST MODIFIED : 5 November 2002

DESCRIPTION :
Returns the number of scale factors stored with <element>.
If fails, puts zero at <number_of_scale_factors_address>.
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_number_of_scale_factors);
	if (element && number_of_scale_factors_address)
	{
		if (element->information)
		{
			*number_of_scale_factors_address =
				element->information->number_of_scale_factors;
		}
		else
		{
			*number_of_scale_factors_address = 0;
		}
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_number_of_scale_factors.  Invalid element");
		if (number_of_scale_factors_address)
		{
			*number_of_scale_factors_address = 0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_number_of_scale_factors */

int get_FE_element_scale_factor(struct FE_element *element,
	int scale_factor_number, FE_value *scale_factor_address)
/*******************************************************************************
LAST MODIFIED : 13 May 2003

DESCRIPTION :
Gets scale_factor <scale_factor_number>, from 0 to number_of_scale_factors-1 of
<element> to <scale_factor>.
<element> must already have a shape and node_scale_field_information.
If fails, sets *<scale_factor_address> to 0.0;
==============================================================================*/
{
	int return_code;

	ENTER(get_FE_element_scale_factor);
	if (element && element->information &&
		element->information->scale_factors && (0 <= scale_factor_number) &&
		(scale_factor_number < element->information->number_of_scale_factors) &&
		scale_factor_address)
	{
		*scale_factor_address =
			element->information->scale_factors[scale_factor_number];
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_scale_factor.  Invalid argument(s)");
		if (scale_factor_address)
		{
			*scale_factor_address = 0.0;
		}
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_scale_factor */

int set_FE_element_scale_factor(struct FE_element *element,
	int scale_factor_number,FE_value scale_factor)
/*******************************************************************************
LAST MODIFIED : 13 May 2003

DESCRIPTION :
Sets scale_factor <scale_factor_number>, from 0 to number_of_scale_factors-1 of
<element> to <scale_factor>.
<element> must already have a shape and node_scale_field_information.
Should only be called for unmanaged elements.
This function is a bit naughty. Should really use 
FE_element_set_scale_factor_for_nodal_value . 
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_element_scale_factor);
	if (element && element->information&&
		element->information->scale_factors&&(0<=scale_factor_number)&&
		(scale_factor_number<element->information->number_of_scale_factors))
	{
		return_code=1;
		element->information->scale_factors[scale_factor_number]=scale_factor;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_scale_factor.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_scale_factor */

int define_FE_field_at_element(struct FE_element *element,
	struct FE_field *field, struct FE_element_field_component **components)
/*******************************************************************************
LAST MODIFIED : 2 April 2003

DESCRIPTION :
Defines <field> at <element> using the given <components>. <element> must
already have a shape and node_scale_field_information.
Checks the range of nodes, scale factors etc. referred to by the components are
within the range of the node_scale_field_information, and that the basis
functions are compatible with the element shape.
If the components indicate the field is grid-based, checks that all the
components are grid-based with same number_in_xi and value_index=0.
Value types other than FE_VALUE_VALUE are only supported for grid-based element
fields and constant and indexed FE_fields.
The <components> are duplicated by this functions, so the calling function must
destroy them.
Should only be called for unmanaged elements.
???RC Should have more checks for STANDARD_NODE_TO_ELEMENT_MAP etc.
==============================================================================*/
{
	int dimension, i, j, *last_number_in_xi, number_of_components,
		number_of_grid_based_components, number_of_values, old_values_storage_size,
		return_code, *this_number_in_xi;
	struct FE_element_field *element_field;
	struct FE_element_field_component **component;
	struct FE_element_field_info *existing_element_field_info,
		*new_element_field_info;
	struct FE_element_field_lists_merge_data merge_data;
	struct FE_region *fe_region;
	struct LIST(FE_element_field) *element_field_list;
	Value_storage *values_storage;

	ENTER(define_FE_field_at_element);
	return_code = 0;
	if (element && (dimension = get_FE_element_dimension(element)) &&
		field && (fe_region = FE_field_get_FE_region(field)) &&
		(existing_element_field_info = element->fields) &&
		(existing_element_field_info->fe_region = fe_region) &&
		element->information &&
		(0 < (number_of_components = get_FE_field_number_of_components(field))) &&
		components)
	{
		return_code = 1;
		/* check if the field is already defined at the element */
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(field,
			existing_element_field_info->element_field_list))
		{
			display_message(ERROR_MESSAGE,
				"define_FE_field_at_element.  Field %s already defined at %s %d",
				field->name, CM_element_type_string(element->cm.type),
				element->cm.number);
			return_code = 0;
		}
		switch (field->fe_field_type)
		{
			case CONSTANT_FE_FIELD:
			{
				/* nothing to check */
			} break;
			case INDEXED_FE_FIELD:
			{
				/* no longer perform this check since it prevents us from reading in
					 indexed fields when the indexer is not in the same header */
#if defined (OLD_CODE)
				/* check that the indexer field is defined at the element */
				if (!FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
					field->indexer_field,
					existing_element_field_info->element_field_list))
				{
					display_message(ERROR_MESSAGE, "define_FE_field_at_element.  "
						"Indexer field %s for field %s not defined at %s %d",
						field->indexer_field->name,field->name,
						CM_element_type_string(element->cm.type), element->cm.number);
					return_code = 0;
				}
#endif /* defined (OLD_CODE) */
			} break;
			case GENERAL_FE_FIELD:
			{
				/* check the components are all there, and if grid-based ensure they
					 have consistent number_in_xi and all have value_index set to 0 */
				number_of_grid_based_components = 0;
				number_of_values = 0;
				last_number_in_xi = (int *)NULL;
				component = components;
				for (i = 0; (i < number_of_components) && return_code; i++)
				{
					if (*component)
					{
						if (ELEMENT_GRID_MAP == (*component)->type)
						{
							number_of_grid_based_components++;
							this_number_in_xi =
								(*component)->map.element_grid_based.number_in_xi;
							if (last_number_in_xi)
							{
								for (j = 0; (j < dimension) && return_code; j++)
								{
									if (this_number_in_xi[j] != last_number_in_xi[j])
									{
										display_message(ERROR_MESSAGE,
											"define_FE_field_at_element.  Grid-map components must "
											"have same number of cells in xi");
										return_code = 0;
									}
								}
							}
							else
							{
								last_number_in_xi = this_number_in_xi;
								number_of_values = 1;
								for (j = 0; (j < dimension) && return_code; j++)
								{
									if (0 <= this_number_in_xi[j])
									{
										number_of_values *= (this_number_in_xi[j] + 1);
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"define_FE_field_at_element.  "
											"Grid-map components number of cells in xi < 1");
										number_of_values = 0;
										return_code = 0;
									}
								}
							}
							/* check value_index is 0 for all components, ie. pointing at
								 start of values_storage allocated below */
							if ((*component)->map.element_grid_based.value_index != 0)
							{
								display_message(ERROR_MESSAGE,"define_FE_field_at_element.  "
									"Grid-map components must have 0 value_index");
								return_code = 0;
							}
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"define_FE_field_at_element.  Missing component");
						return_code = 0;
					}
					component++;
				}
				if (!((0 == number_of_grid_based_components) ||
					(number_of_grid_based_components == number_of_components)))
				{
					display_message(ERROR_MESSAGE,
						"define_FE_field_at_element.  Only some components are grid-based");
					return_code=0;
				}
				/* only FE_VALUE_VALUE and SHORT_VALUE supported by general */
				if ((0 == number_of_grid_based_components) &&
					(FE_VALUE_VALUE != field->value_type) &&
					(SHORT_VALUE != field->value_type))
				{
					display_message(ERROR_MESSAGE,"define_FE_field_at_element.  "
						"%s type only supported for grid, constant and indexed fields",
						Value_type_string(field->value_type));
					return_code = 0;
				}
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"define_FE_field_at_element.  Unknown field type");
				return_code = 0;
			} break;
		}
		if (return_code)
		{
			if (element_field = CREATE(FE_element_field)(field))
			{
				ACCESS(FE_element_field)(element_field);
				/* make a copy of the element_field_list to put new element_field in */
				element_field_list = CREATE_LIST(FE_element_field)();
				if (COPY_LIST(FE_element_field)(element_field_list,
					existing_element_field_info->element_field_list))
				{
					if (GENERAL_FE_FIELD == field->fe_field_type)
					{
						/* put components in element_field for merge */
						for (i = 0; i < number_of_components; i++)
						{
							element_field->components[i] = components[i];
						}
						/* use merge_FE_element_field_into_list to add field to element */
						merge_data.list = element_field_list;
						merge_data.merge_info = element->information;
						merge_data.source_info = element->information;
						if (existing_element_field_info)
						{
							merge_data.values_storage_size =
								element->information->values_storage_size;
						}
						else
						{
							merge_data.values_storage_size = 0;
						}
						old_values_storage_size = merge_data.values_storage_size;
						if (merge_FE_element_field_into_list(element_field,
							(void *)&merge_data))
						{
							/* allocate and initialise any added values_storage */
							if (merge_data.values_storage_size > old_values_storage_size)
							{
								if (number_of_grid_based_components == number_of_components)
								{
									if (REALLOCATE(values_storage,
										element->information->values_storage,
										Value_storage, merge_data.values_storage_size))
									{
										element->information->values_storage = values_storage;
										if (initialise_value_storage_array(
											values_storage + old_values_storage_size,
											field->value_type, (struct FE_time_sequence *)NULL,
											number_of_values))
										{
											element->information->values_storage_size =
												merge_data.values_storage_size;
										}
										else
										{
											return_code = 0;
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"define_FE_field_at_element.  "
											"Could not reallocate values_storage");
										return_code = 0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"define_FE_field_at_element.  "
										"Element values_storage only used for grid fields");
									return_code = 0;
								}
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"define_FE_field_at_element.  Could not merge element field");
							return_code = 0;
						}
						/* clear the components from element_field since they are owned by
							 the calling function and do not want them destroyed here */
						for (i = 0; i < number_of_components; i++)
						{
							element_field->components[i] =
								(struct FE_element_field_component *)NULL;
						}
					}
					else
					{
						if (!ADD_OBJECT_TO_LIST(FE_element_field)(element_field,
							element_field_list))
						{
							display_message(ERROR_MESSAGE,
								"define_FE_field_at_element.  Could not add element field");
							return_code = 0;
						}
					}
					if (return_code)
					{
						if (new_element_field_info = FE_region_get_FE_element_field_info(
							fe_region, element_field_list))
						{
							REACCESS(FE_element_field_info)(&(element->fields),
								new_element_field_info);
						}
						else
						{
							display_message(ERROR_MESSAGE, "define_FE_field_at_element.  "
								"Could not get element field information");
							return_code = 0;
						}
					}
					DESTROY_LIST(FE_element_field)(&element_field_list);
				}
				else
				{
					display_message(ERROR_MESSAGE, "define_FE_field_at_element.  "
						"Could not duplicate element_field_list");
					return_code = 0;
				}
				DEACCESS(FE_element_field)(&element_field);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"define_FE_field_at_element.  Could not create element_field");
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"define_FE_field_at_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* define_FE_field_at_element */

static int FE_element_field_has_element_grid_map(
	struct FE_element_field *element_field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 19 October 1999

DESCRIPTION :
Returns true if <element_field> components are of type ELEMENT_GRID_MAP.
Only checks the first component since we assume all subsequent components have
the same basis and numbers of grid cells in xi.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_has_element_grid_map);
	USE_PARAMETER(dummy_void);
	return_code=0;
	if (element_field&&element_field->field)
	{
		if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
		{
			if (element_field->components)
			{
				if (ELEMENT_GRID_MAP == (*(element_field->components))->type)
				{
					return_code=1;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_has_element_grid_map.  Missing components");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_has_element_grid_map.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_has_element_grid_map */

int FE_element_has_grid_based_fields(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Returns true if any of the fields defined for element is grid-based.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_has_grid_based_fields);
	return_code = 0;
	if (element && element->fields)
	{
		/* would have to have values_storage to have a grid-based field */
		if (element->information && element->information->values_storage)
		{
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
				FE_element_field_has_element_grid_map, (void *)NULL,
				element->fields->element_field_list))
			{
				return_code = 1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_grid_based_fields.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_grid_based_fields */

int FE_element_field_is_standard_node_based(struct FE_element *element,
	struct FE_field *fe_field)
/*******************************************************************************
LAST MODIFIED : 12 March 2003

DESCRIPTION :
Returns true if <fe_field> is defined on <element> using a standard node to
element map for any element. Does not consider inherited fields.
==============================================================================*/
{
	int i, number_of_components, return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_component **components;

	ENTER(FE_element_field_is_standard_node_based);
	return_code = 0;
	if (element && element->fields && fe_field)
	{
		/* would have to have values_storage to have a grid-based field */
		if ((element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			fe_field, element->fields->element_field_list)) &&
			(number_of_components = get_FE_field_number_of_components(fe_field)) &&
			(components = element_field->components))
		{
			for (i = 0; (!return_code) && (i < number_of_components); i++)
			{
				if (components[i] &&
					(STANDARD_NODE_TO_ELEMENT_MAP == (components[i])->type))
				{
					return_code = 1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_is_standard_node_based.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_is_standard_node_based */

static int FE_element_field_has_FE_field_values(
	struct FE_element_field *element_field,void *dummy)
/*******************************************************************************
LAST MODIFIED: 19 October 1999

DESCRIPTION:
Returns true if <element_field> has a field with values_storage.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_has_FE_field_values);
	USE_PARAMETER(dummy);
	if (element_field&&element_field->field)
	{
		return_code=(0<element_field->field->number_of_values);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_has_FE_field_values.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_has_FE_field_values */

int FE_element_has_FE_field_values(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Returns true if any single field defined at <element> has values stored with
the field. Returns 0 without error if no field information at element.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_has_FE_field_values);
	return_code=0;
	if (element && element->fields)
	{
		return_code = ((struct FE_element_field *)NULL != 
			FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
				FE_element_field_has_FE_field_values, (void *)NULL,
				element->fields->element_field_list));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_FE_field_values.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_FE_field_values */

int FE_element_has_values_storage(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 24 October 2002

DESCRIPTION :
Returns true if <element> has values_storage, eg. for grid-based fields.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_has_values_storage);
	if (element)
	{
		if (element->information && element->information->values_storage)
		{
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_values_storage.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_values_storage */

int for_FE_field_at_element(struct FE_field *field,
	FE_element_field_iterator_function *iterator, void *user_data,
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 16 May 2003

DESCRIPTION :
If an <iterator> is supplied and the <field> is defined at the <element> then
the result of the <iterator> is returned.  Otherwise, if an <iterator> is not
supplied and the <field> is defined at the <element> then a non-zero is
returned. Otherwise, zero is returned.
???DB.  Multiple behaviour dangerous ?
==============================================================================*/
{
	int return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_iterator_and_data iterator_and_data;

	ENTER(for_FE_field_at_element);
	return_code = 0;
	if (field && element && element->fields)
	{
		if (element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field, element->fields->element_field_list))
		{
			if (iterator)
			{
				iterator_and_data.iterator = iterator;
				iterator_and_data.user_data = user_data;
				iterator_and_data.element = element;
				return_code = for_FE_field_at_element_iterator(element_field,
					&iterator_and_data);
			}
			else
			{
				return_code = 1;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"for_FE_field_at_element.  Field not defined at element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_FE_field_at_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* for_FE_field_at_element */

int for_each_FE_field_at_element(FE_element_field_iterator_function *iterator,
	void *user_data,struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Calls the <iterator> for each field defined at the <element> until the
<iterator> returns 0 or it runs out of fields.  Returns the result of the last
<iterator> called.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_element);
	if (iterator && element && element->fields)
	{
		iterator_and_data.iterator = iterator;
		iterator_and_data.user_data = user_data;
		iterator_and_data.element = element;	
		return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
			for_FE_field_at_element_iterator, &iterator_and_data,
			element->fields->element_field_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_element.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_element */

int for_each_FE_field_at_element_indexer_first(
	FE_element_field_iterator_function *iterator,void *user_data,
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Calls the <iterator> for each field defined at the <element> until the
<iterator> returns 0 or it runs out of fields.  Returns the result of the last
<iterator> called. This version insists that any field used as an indexer_field
for another field in the list is output first.
==============================================================================*/
{
	int return_code;
	struct FE_element_field_priority_iterator_and_data iterator_and_data;

	ENTER(for_each_FE_field_at_element_indexer_first);
	if (iterator && element)
	{
		if (iterator_and_data.priority_field_list = CREATE(LIST(FE_field))())
		{
			/* make priority list of indexer fields for fields defined at element */
			FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				FE_element_field_add_indexer_field_to_list,
				(void *)(iterator_and_data.priority_field_list),
				element->fields->element_field_list);
			iterator_and_data.iterator = iterator;
			iterator_and_data.user_data = user_data;
			iterator_and_data.element = element;
			/* call iterator function for fields in priority list */
			iterator_and_data.priority_on = 1;
			return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				for_FE_field_at_element_priority_iterator, &iterator_and_data,
				element->fields->element_field_list);
			/* call iterator function for fields not in priority list */
			iterator_and_data.priority_on=0;
			return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
				for_FE_field_at_element_priority_iterator, &iterator_and_data,
				element->fields->element_field_list);
			DESTROY(LIST(FE_field))(&(iterator_and_data.priority_field_list));
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"for_each_FE_field_at_element_indexer_first.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* for_each_FE_field_at_element_indexer_first */

struct FE_field *get_FE_element_default_coordinate_field(
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Returns the first coordinate field defined over <element>, recursively getting
it from its first parent if it has no node scale field information.
==============================================================================*/
{
	struct FE_element_field *element_field;
	struct FE_element_parent *element_parent;
	struct FE_field *field;

	ENTER(get_FE_element_default_coordinate_field);
	field = (struct FE_field *)NULL;
	if (element && element->fields)
	{
		if (element_field = FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
			FE_element_field_is_coordinate_field, (void *)NULL,
			element->fields->element_field_list))
		{
			field = element_field->field;
		}
		else
		{
			/* get first coordinate field of first parent element */
			if (element_parent = FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				(LIST_ITERATOR_FUNCTION(FE_element_parent) *)NULL, (void *)NULL,
				element->parent_list))
			{
				field = get_FE_element_default_coordinate_field(element_parent->parent);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_default_coordinate_field.  "
					"No coordinate field found");
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_default_coordinate_field.  Invalid argument(s)");
	}
	LEAVE;

	return (field);
} /* get_FE_element_default_coordinate_field */

int FE_element_find_default_coordinate_field_iterator(
	struct FE_element *element, void *fe_field_ptr_void)
/*******************************************************************************
LAST MODIFIED : 30 November 2001

DESCRIPTION :
An FE_element iterator that returns 1 when an appropriate default_coordinate
fe_field is found.  The fe_field found is returned as fe_field_void.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(FE_element_find_default_coordinate_field_iterator);
	if (element)
	{
		if (field = get_FE_element_default_coordinate_field(element))
		{
			*((struct FE_field **)fe_field_ptr_void) = field;
			return_code = 1;
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_find_default_coordinate_field_iterator.  Missing element");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_find_default_coordinate_field_iterator */

int FE_element_conditional_iterator(struct FE_element *element,
	void *data_void)
/*******************************************************************************
LAST MODIFIED : 15 January 2003

DESCRIPTION :
If <element> satisfies the <conditional_function> with <conditional_user_data>,
calls <iterator_function> with it and the <iterator_user_data>.
<data_void> points at a struct FE_element_conditional_iterator_data.
==============================================================================*/
{
	int return_code;
	struct FE_element_conditional_iterator_data *data;
	
	ENTER(FE_element_conditional_iterator);
	if (element &&
		(data = (struct FE_element_conditional_iterator_data *)data_void) &&
		data->conditional_function && data->iterator_function)
	{
		if ((data->conditional_function)(element, data->conditional_user_data))
		{
			return_code =
				(data->iterator_function)(element, data->iterator_user_data);
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_conditional_iterator.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_conditional_iterator */

int FE_element_of_CM_element_type_is_in_Multi_range(struct FE_element *element,
	void *element_type_ranges_data_void)
/*******************************************************************************
LAST MODIFIED : 1 March 2001

DESCRIPTION :
Conditional function returning true if <element> is of the given
<cm_element_type> and whose number is in the <multi_range>.
Second argument is a struct CM_element_type_Multi_range_data.
==============================================================================*/
{
	int return_code;
	struct CM_element_type_Multi_range_data *element_type_ranges_data;

	ENTER(FE_element_of_CM_element_type_is_in_Multi_range);
	if (element && (element_type_ranges_data =
		(struct CM_element_type_Multi_range_data *)element_type_ranges_data_void))
	{
		return_code =
			(element_type_ranges_data->cm_element_type == element->cm.type) &&
			Multi_range_is_value_in_range(element_type_ranges_data->multi_range,
				element->cm.number);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_of_CM_element_type_is_in_Multi_range.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;
	
	return (return_code);
} /* FE_element_of_CM_element_type_is_in_Multi_range */

int FE_element_of_CM_element_type_is_not_in_Multi_range(
	struct FE_element *element, void *element_type_ranges_data_void)
/*******************************************************************************
LAST MODIFIED : 1 March 2001

DESCRIPTION :
Conditional function returning true if <element> is of the given
<cm_element_type> and whose number is not in the <multi_range>.
Second argument is a struct CM_element_type_Multi_range_data.
==============================================================================*/
{
	int return_code;
	struct CM_element_type_Multi_range_data *element_type_ranges_data;

	ENTER(FE_element_of_CM_element_type_is_not_in_Multi_range);
	if (element && (element_type_ranges_data =
		(struct CM_element_type_Multi_range_data *)element_type_ranges_data_void))
	{
		return_code =
			(element_type_ranges_data->cm_element_type == element->cm.type) &&
			(!Multi_range_is_value_in_range(element_type_ranges_data->multi_range,
				element->cm.number));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_of_CM_element_type_is_not_in_Multi_range.  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;
	
	return (return_code);
} /* FE_element_of_CM_element_type_is_not_in_Multi_range */

int FE_element_of_CM_element_type_add_number_to_Multi_range(
	struct FE_element *element, void *element_type_ranges_data_void)
/*******************************************************************************
LAST MODIFIED : 1 March 2001

DESCRIPTION :
Iterator function which, if <element> is of the given <cm_element_type>, adds
its CMISS number to <multi_range>.
Second argument is a struct CM_element_type_Multi_range_data.
==============================================================================*/
{
	int return_code;
	struct CM_element_type_Multi_range_data *element_type_ranges_data;

	ENTER(FE_element_of_CM_element_type_add_number_to_Multi_range);
	if (element && (element_type_ranges_data =
		(struct CM_element_type_Multi_range_data *)element_type_ranges_data_void))
	{
		if (element->cm.type == element_type_ranges_data->cm_element_type)
		{
			return_code = Multi_range_add_range(element_type_ranges_data->multi_range,
				element->cm.number, element->cm.number);
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_of_CM_element_type_add_number_to_Multi_range.  "
			"Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_of_CM_element_type_add_number_to_Multi_range */

int FE_element_is_in_list(struct FE_element *element, void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 14 January 2003

DESCRIPTION :
Returns true if <element> is in <element_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_is_in_list);
	if (element && (element_list = (struct LIST(FE_element) *)element_list_void))
	{
		return_code = IS_OBJECT_IN_LIST(FE_element)(element,element_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_in_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_in_list */

int FE_element_is_not_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 14 January 2003

DESCRIPTION :
Returns true if <element> is not in <element_list>.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_is_not_in_list);
	if (element && (element_list = (struct LIST(FE_element) *)element_list_void))
	{
		return_code = !IS_OBJECT_IN_LIST(FE_element)(element, element_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_not_in_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_not_in_list */

static int FE_element_parent_is_not_wholly_within_list_tree(
	struct FE_element_parent *element_parent, void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 1 March 2001

DESCRIPTION :
Returns true if the parent element referred to by the <element_parent> is
not wholly within the <element_list> tree.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_parent_is_not_wholly_within_list_tree);
	if (element_parent &&
		(element_list = (struct LIST(FE_element) *)element_list_void))
	{
		return_code = !FE_element_is_wholly_within_element_list_tree(
			element_parent->parent, element_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_is_not_wholly_within_list_tree.  "
			"Invalid argument(s)");
		return_code = 0;
	}

	return (return_code);
} /* FE_element_parent_is_not_wholly_within_list_tree */

int FE_element_is_wholly_within_element_list_tree(
	struct FE_element *element, void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 1 March 2001

DESCRIPTION :
Returns true if <element> is either in <element_list> or has all its parents
directly or indirectly in the <element_list> tree. Used to check if elements
will be destroyed, since faces and lines are destroyed with their parents if
they are not also faces or lines of other elements not being destroyed.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(FE_element_is_wholly_within_element_list_tree);
	if (element && (element_list = (struct LIST(FE_element) *)element_list_void))
	{
		return_code = IS_OBJECT_IN_LIST(FE_element)(element, element_list) ||
			((struct FE_element_parent *)NULL ==
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_is_not_wholly_within_list_tree,
					(void *)element_list, element->parent_list));
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_wholly_within_element_list_tree.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_wholly_within_element_list_tree */

int FE_element_count_if_type(struct FE_element *element,
	void *count_data_void)
/*******************************************************************************
LAST MODIFIED : 15 January 2003

DESCRIPTION :
If <element> is of the given CM_type, increment number_of_elements.
<count_data_void> points at a struct FE_element_count_if_type_data.
==============================================================================*/
{
	int return_code;
	struct FE_element_count_if_type_data *count_data;

	ENTER(FE_element_count_if_type);
	if (element && (count_data =
		(struct FE_element_count_if_type_data *)count_data_void))
	{
		return_code = 1;
		if (element->cm.type == count_data->cm_type)
		{
			(count_data->number_of_elements)++;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_count_if_type.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_count_if_type */

int add_FE_element_and_faces_to_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 1 June 2001

DESCRIPTION :
Ensures <element>, its faces (and theirs etc.) are in <element_list>.
Note: this function is recursive.
==============================================================================*/
{
	int i, return_code;
	struct FE_element **face;
	struct LIST(FE_element) *element_list;

	ENTER(add_FE_element_and_faces_to_list);
	if (element && element->shape &&
		(element_list = (struct LIST(FE_element) *)element_list_void))
	{
		return_code = 1;
		if (face = element->faces)
		{
			for (i = element->shape->number_of_faces; (0 < i) && return_code; i--)
			{
				if (*face)
				{
					if (!add_FE_element_and_faces_to_list(*face, element_list_void))
					{
						display_message(ERROR_MESSAGE,
							"add_FE_element_and_faces_to_list.  Could not add face");
						return_code = 0;
					}
				}
				face++;
			}
		}
		if (return_code)
		{
			if (!IS_OBJECT_IN_LIST(FE_element)(element, element_list))
			{
				if (!ADD_OBJECT_TO_LIST(FE_element)(element, element_list))
				{
					display_message(ERROR_MESSAGE,
						"add_FE_element_and_faces_to_list.  Could not add element");
					return_code = 0;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_and_faces_to_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_and_faces_to_list */

int FE_element_add_faces_not_in_list(struct FE_element *element,
	void *data_void)
/*******************************************************************************
LAST MODIFIED : 17 February 2003

DESCRIPTION :
If any face of <element> is not in <current_element_list>, and not in
<add_element_list>, adds it to <add_element_list> and asks the same of all its
faces and their lines, etc.
<data_void> points at a struct FE_element_add_faces_not_in_list_data.
Note: this function is recursive.
==============================================================================*/
{
	int i, return_code;
	struct FE_element **face;
	struct FE_element_add_faces_not_in_list_data *data;

	ENTER(FE_element_add_faces_not_in_list);
	if (element && element->shape &&
		(data = (struct FE_element_add_faces_not_in_list_data *)data_void))
	{
		return_code = 1;
		if (face = element->faces)
		{
			for (i = element->shape->number_of_faces; (0 < i) && return_code; i--)
			{
				if (*face)
				{
					if (!IS_OBJECT_IN_LIST(FE_element)(*face, data->current_element_list))
					{
						if (!IS_OBJECT_IN_LIST(FE_element)(*face, data->add_element_list))
						{
							if (ADD_OBJECT_TO_LIST(FE_element)(*face, data->add_element_list))
							{
								if ((*face)->faces)
								{
									return_code =
										FE_element_add_faces_not_in_list(*face, data_void);
								}
							}
							else
							{
								return_code = 0;
							}
						}
					}
				}
				face++;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_add_faces_not_in_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_add_faces_not_in_list */

static int FE_element_parent_has_other_parent(
	struct FE_element_parent *element_parent,void *first_parent_void)
/*******************************************************************************
LAST MODIFIED : 18 January 2002

DESCRIPTION :
Returns true if the parent element referred to by the <element_parent> had
any ancestor of the same CM_element_type as <first_parent> but not the same.
==============================================================================*/
{
	int return_code;
	struct FE_element *first_parent;

	ENTER(FE_element_parent_has_other_parent);
	if (element_parent&&element_parent->parent&&
		(first_parent=(struct FE_element *)first_parent_void))
	{
		return_code = ((element_parent->parent->cm.type == first_parent->cm.type)&&
			(element_parent->parent != first_parent))||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_has_other_parent,first_parent_void,
				element_parent->parent->parent_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_other_parent.  Invalid argument(s)");
		return_code=0;
	}

	return (return_code);
} /* FE_element_parent_has_other_parent */

struct FE_element_parent_for_each_element_and_parent_data
/*******************************************************************************
LAST MODIFIED : 14 May 2003

DESCRIPTION :
Data for passing to FE_element_parent_for_each_element_and_parent.
==============================================================================*/
{
	LIST_ITERATOR_FUNCTION(FE_element) *iterator_function;
	void *user_data;
};

static int FE_element_parent_for_each_element_and_parent(
	struct FE_element_parent *element_parent, void *iterator_data_void)
/*******************************************************************************
LAST MODIFIED : 14 May 2003

DESCRIPTION :
Calls FE_element_for_each_element_and_parent with <iterator_function> and
<user_data> for the element in <element_parent>. <iterator_data_void> points
at a struct FE_element_parent_for_each_element_and_parent_data
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_for_each_element_and_parent_data *iterator_data;

	ENTER(FE_element_parent_for_each_element_and_parent);
	if (element_parent && (iterator_data =
		(struct FE_element_parent_for_each_element_and_parent_data *)
		iterator_data_void))
	{
		return_code = FE_element_for_each_element_and_parent(element_parent->parent,
			iterator_data->iterator_function, iterator_data->user_data);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_for_each_element_and_parent.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_for_each_element_and_parent */

int FE_element_for_each_element_and_parent(struct FE_element *element,
	LIST_ITERATOR_FUNCTION(FE_element) *iterator_function, void *user_data)
/*******************************************************************************
LAST MODIFIED : 14 May 2003

DESCRIPTION :
Iterates over <element> and all its parent elements and so on recursively,
calling <iterator_function> with <user_data> for each of them.
Note that parents of parent elements may be iterated over more than once since,
for example, lines can be in two faces of the same parent element.
Stops as soon as all parent elements have been iterated through, or the
iterator_function returns FALSE for any element.
This function is recursive.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_for_each_element_and_parent_data iterator_data;

	ENTER(FE_element_for_each_element_and_parent);
	return_code = 0;
	if (element && iterator_function)
	{
		if (return_code = (iterator_function)(element, user_data))
		{
			iterator_data.iterator_function = iterator_function;
			iterator_data.user_data = user_data;
			return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
				FE_element_parent_for_each_element_and_parent,
				(void *)&iterator_data, element->parent_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_for_each_element_and_parent.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_for_each_element_and_parent */

static int FE_element_shape_and_faces_match(struct FE_element *element1,
	struct LIST(FE_element) *global_element_list1,
	struct FE_element *element2)
/*******************************************************************************
LAST MODIFIED : 25 March 2003

DESCRIPTION :
Returns true if <element1> and <element2> have the same shape, and all of their
faces match. A face match is found if it is either:
- NULL on either or both of <element1> and <element2>;
- if <global_element_list1> is NOT supplied, the face pointer is the same;
- if <global_element_list1> is supplied, the face pointer in <element2> is the
same as the element from <global_element_list1>.
==============================================================================*/
{
	int i, number_of_faces, return_code;
	struct FE_element **face1, **face2;
	
	ENTER(FE_element_shape_and_faces_match);
	if (element1 && element1->shape && element2)
	{
		if (element1->shape == element2->shape)
		{
			return_code = 1;
			if (0 < (number_of_faces = element1->shape->number_of_faces))
			{
				if ((face1 = element1->faces) && (face2 = element2->faces))
				{
					for (i = number_of_faces; (0 < i) && return_code; i--)
					{
						if ((!(*face1)) || (!(*face2)) ||
							((!global_element_list1) && (*face1 == *face2)) ||
							(global_element_list1 &&
								(FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
									(*face1)->identifier, global_element_list1) == *face2)))
						{
							face1++;
							face2++;
						}
						else
						{
							return_code = 0;
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_element_shape_and_faces_match.  Missing face arrays");
					return_code = 0;
				}
			}
		}
		else
		{
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_shape_and_faces_match.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_shape_and_faces_match */

static int FE_element_field_add_FE_field_to_list(
	struct FE_element_field *element_field, void *fe_field_list_void)
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
FE_element_field iterator which adds its FE_field to the LIST pointed to by
<fe_field_list_void>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_add_FE_field_to_list);
	/*???RC try to make this as inexpensive as possible */
	if (element_field)
	{
		/* the field is not expected to be in the list already */
		return_code = ADD_OBJECT_TO_LIST(FE_field)(element_field->field,
			(struct LIST(FE_field) *)fe_field_list_void);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_add_FE_field_to_list.  Missing element_field");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_add_FE_field_to_list */

struct FE_element_field_FE_field_to_list_if_uses_scale_factor_set_data
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
Data for passing to function
FE_element_field_FE_field_to_list_if_uses_scale_factor_set
==============================================================================*/
{
	struct LIST(FE_field) *fe_field_list;
	void *scale_factor_set_identifier;
};

static int FE_element_field_FE_field_to_list_if_uses_scale_factor_set(
	struct FE_element_field *element_field, void *scale_factor_set_data_void)
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
FE_element_field iterator which ensures its FE_field is in <fe_field_list> if
it uses the <scale_factor_set_identifier>. In practise, the identifier has to
point to an FE_basis. <scale_factor_set_data_void> points at a struct
FE_element_field_FE_field_to_list_if_uses_scale_factor_set_data.
==============================================================================*/
{
	int field_uses_set, i, number_of_components, return_code;
	struct FE_element_field_FE_field_to_list_if_uses_scale_factor_set_data *scale_factor_set_data;
	struct FE_basis *fe_basis;

	ENTER(FE_element_field_FE_field_to_list_if_uses_scale_factor_set);
	/*???RC try to make this as inexpensive as possible */
	if (element_field && element_field->field && (scale_factor_set_data = (struct
		FE_element_field_FE_field_to_list_if_uses_scale_factor_set_data *)
		scale_factor_set_data_void))
	{
		return_code = 1;
		/* trivial rejection 1: must be a GENERAL_FE_FIELD to have a basis */
		if (GENERAL_FE_FIELD == element_field->field->fe_field_type)
		{
			/* trivial rejection 2: proceed only if FE_field not already in list */
			if (!IS_OBJECT_IN_LIST(FE_field)(element_field->field,
				scale_factor_set_data->fe_field_list))
			{
				number_of_components = element_field->field->number_of_components;
				field_uses_set = 0;
				for (i = 0; (i < number_of_components) && (!field_uses_set) &&
							 return_code; i++)
				{
					if (FE_element_field_private_get_component_FE_basis(
						element_field, /*component_number*/i, &fe_basis))
					{
						if ((void *)fe_basis ==
							scale_factor_set_data->scale_factor_set_identifier)
						{
							if (!ADD_OBJECT_TO_LIST(FE_field)(element_field->field,
								scale_factor_set_data->fe_field_list))
							{
								display_message(ERROR_MESSAGE,
									"FE_element_field_FE_field_to_list_if_uses_scale_factor_set.  Could not add field to list");
								return_code = 1;
							}
							field_uses_set = 1;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"FE_element_field_FE_field_to_list_if_uses_scale_factor_set.  Could not get basis");
						return_code = 0;
					}
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_FE_field_to_list_if_uses_scale_factor_set.  "
			"Missing element_field");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_FE_field_to_list_if_uses_scale_factor_set */

int merge_FE_element(struct FE_element *destination, struct FE_element *source,
	struct LIST(FE_field) *changed_fe_field_list)
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
Merges the fields from <source> into <destination>. Existing fields in the
<destination> keep the same element field description as before with new field
storage following them. Where existing fields in <destination> are passed in
<source>, values from <source> take precedence, but the element field structure
remains unchanged.
Function is atomic; <destination> is unchanged if <source> cannot be merged.
The <changed_fe_field_list> must be supplied. On return it contains the list
of FE_fields that have been changed or added to <destination>. Note it is not
sufficient to assume just the fields in <source> are changed since changes to
common scale factors affect different fields in <destination>; the
<change_fe_field_list> includes these fields.
Note <changed_fe_field_list> is emptied at the start of this function.
==============================================================================*/
{
	int i, number_of_changed_existing_scale_factor_sets, number_of_faces,
		return_code, values_storage_size;
	struct FE_element **source_face;
	struct FE_element_field_FE_field_to_list_if_uses_scale_factor_set_data scale_factor_set_data;
	struct FE_element_field_info *destination_fields, *element_field_info,
		*source_fields;
	struct FE_element_field_lists_merge_data merge_data;
	struct FE_element_node_scale_field_info *destination_info,
		*node_scale_field_info, *source_info;
	struct FE_region *fe_region;
	struct LIST(FE_element_field) *element_field_list;
	Value_storage *values_storage;
	void **changed_existing_scale_factor_set_identifiers;

	ENTER(merge_FE_element);
	if (destination && (destination_fields = destination->fields) &&
		(fe_region = destination_fields->fe_region) &&
		source && (source_fields = source->fields) &&
		(source_fields->fe_region == fe_region) && changed_fe_field_list)
	{
		return_code = 1;
		/* changed_fe_field_list should start with all the fields in <source> */
		REMOVE_ALL_OBJECTS_FROM_LIST(FE_field)(changed_fe_field_list);
		FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
			FE_element_field_add_FE_field_to_list, (void *)changed_fe_field_list,
			source_fields->element_field_list);

		if (!FE_element_shape_and_faces_match(source,
			/*global_element_list1*/(struct LIST(FE_element) *)NULL, destination))
		{
			display_message(ERROR_MESSAGE,
				"merge_FE_element.  Inconsistent or missing element shape(s)");
			return_code = 0;
		}

		/* make a merged element node scale field info without values_storage */
		node_scale_field_info = (struct FE_element_node_scale_field_info *)NULL;
		destination_info = destination->information;
		source_info = source->information;
		if (return_code)
		{
			if (destination_info)
			{
				if (source_info)
				{
					if (node_scale_field_info =
						merge_create_FE_element_node_scale_field_info(
							destination_info, source_info,
							&number_of_changed_existing_scale_factor_sets,
							&changed_existing_scale_factor_set_identifiers))
					{
						if (changed_existing_scale_factor_set_identifiers)
						{
							/* determine which destination fields are affected by changed
								 existing scale factor sets */
							scale_factor_set_data.fe_field_list = changed_fe_field_list;
							for (i = 0; i < number_of_changed_existing_scale_factor_sets; i++)
							{
								scale_factor_set_data.scale_factor_set_identifier =
									changed_existing_scale_factor_set_identifiers[i];
								if (!FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
									FE_element_field_FE_field_to_list_if_uses_scale_factor_set,
									(void *)&scale_factor_set_data,
									destination_fields->element_field_list))
								{
									display_message(ERROR_MESSAGE, "merge_FE_element.  Could not "
										"determine fields affected by changed scale factor");
									return_code = 0;
								}
							}
							DEALLOCATE(changed_existing_scale_factor_set_identifiers);
						}
					}
				}
				else
				{
					node_scale_field_info =
						copy_create_FE_element_node_scale_field_info(destination_info);
				}
			}
			else if (source_info)
			{
				node_scale_field_info =
					copy_create_FE_element_node_scale_field_info(source_info);
			}
			if ((destination_info || source_info) && (!node_scale_field_info))
			{
				display_message(ERROR_MESSAGE,
					"merge_FE_element.  Could not create node scale field info");
				return_code = 0;
			}
		}
		if (return_code)
		{
			/* construct an element field list containing the fields from
				 destination -- these remain unchanged */
			element_field_list = CREATE_LIST(FE_element_field)();
			if (COPY_LIST(FE_element_field)(element_field_list,
				destination_fields->element_field_list))
			{
				/* merge in the fields from source, putting any new fields using
					 values_storage after that for fields in destination */
				merge_data.list = element_field_list;
				merge_data.merge_info = node_scale_field_info;
				merge_data.source_info = source_info;
				if (destination_info)
				{
					merge_data.values_storage_size =
						destination_info->values_storage_size;
				}
				else
				{
					merge_data.values_storage_size = 0;
				}
				if (FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
					merge_FE_element_field_into_list, (void *)(&merge_data),
					source_fields->element_field_list))
				{
					values_storage_size = merge_data.values_storage_size;
					values_storage = (Value_storage *)NULL;
					if ((0 == values_storage_size) ||
						(ALLOCATE(values_storage, Value_storage, values_storage_size) &&
						copy_FE_element_values_storage(destination, values_storage,
							element_field_list, source)))
					{
						/* create an element field info for the combined list */
						if (element_field_info = FE_region_get_FE_element_field_info(
							fe_region, element_field_list))
						{
							/* merge the faces */
							number_of_faces = source->shape->number_of_faces;					
							source_face = source->faces;
							for (i = 0; i < number_of_faces; i++)
							{
								if (*source_face)
								{
									set_FE_element_face(destination, i, *source_face);
								}
								source_face++;
							}
							/* put values storage in node_scale_field_info */
							if (node_scale_field_info)
							{
								node_scale_field_info->values_storage_size =
									values_storage_size;
								node_scale_field_info->values_storage = values_storage;
							}
							/* clean up old destination information */
							if (destination_info)
							{
								clean_up_FE_element_node_scale_field_info(&destination_info,
									destination_fields);
							}
							/* insert new fields and information */
							REACCESS(FE_element_field_info)(&(destination->fields),
								element_field_info);
							destination->information = node_scale_field_info;
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"merge_FE_element.  Could not get element field info");
							/* do not bother to clean up dynamic contents of values_storage */
							DEALLOCATE(values_storage);
							return_code = 0;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"merge_FE_element.  Could not copy values_storage");
						/* cannot clean up dynamic contents of values_storage */
						DEALLOCATE(values_storage);
						return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"merge_FE_element.  Error merging element field list");
					return_code = 0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"merge_FE_element.  Could not copy element field list");
				return_code = 0;
			}
			DESTROY(LIST(FE_element_field))(&element_field_list);
		}
		if (!return_code && node_scale_field_info)
		{
			DESTROY(FE_element_node_scale_field_info)(&node_scale_field_info);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE, "merge_FE_element.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* merge_FE_element */

int list_FE_element_name(struct FE_element *element,void *dummy)
/*******************************************************************************
LAST MODIFIED : 26 August 1999

DESCRIPTION :
Outputs the name of the element as element/face/line #.
==============================================================================*/
{
	int return_code;

	ENTER(list_FE_element_name);
	USE_PARAMETER(dummy);
	if (element)
	{
		return_code=1;
		/* write the identifier */
		display_message(INFORMATION_MESSAGE,"%s %d\n",
			CM_element_type_string(element->cm.type),element->cm.number);
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_element_name.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element_name */

int list_FE_element(struct FE_element *element,void *dummy)
/*******************************************************************************
LAST MODIFIED : 01 April 2008

DESCRIPTION :
Outputs the information contained at the element.
==============================================================================*/
{
	char line[93];
	FE_value *scale_factor;
	int i,return_code;
	struct FE_element **face;
#if defined (DEBUG)
	/*???debug*/
	struct LIST(FE_node) *nodes_on_face;
#endif /* defined (DEBUG) */

	ENTER(list_FE_element);
	USE_PARAMETER(dummy);
	if (element)
	{
		return_code=1;
		/* write the identifier */
		display_message(INFORMATION_MESSAGE,"element : %d \n",element->cm.number);
		display_message(INFORMATION_MESSAGE,"  access count=%d\n",element->access_count);
		if (element->shape)
		{
			display_message(INFORMATION_MESSAGE,"  dimension=%d\n",element->shape->dimension);
			/* write the faces */
			if ((face=element->faces)&&
				(0<(i=element->shape->number_of_faces)))
			{
				display_message(INFORMATION_MESSAGE,"  #faces=%d\n",i);
				while (i>0)
				{
					if (*face)
					{
						display_message(INFORMATION_MESSAGE," (%d)",(*face)->cm.number);
					}
					else
					{
						display_message(INFORMATION_MESSAGE," (0 0 0)");
					}
					face++;
					i--;
				}
				display_message(INFORMATION_MESSAGE,"\n");
			}
			else
			{
				display_message(INFORMATION_MESSAGE,"  No faces\n");
			}
			/* write the parents */
			if (0<NUMBER_IN_LIST(FE_element_parent)(element->parent_list))
			{
				display_message(INFORMATION_MESSAGE,"  parents\n");
				*line='\0';
				FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(list_FE_element_parent,
					(void *)line,element->parent_list);
				if (0<strlen(line))
				{
					display_message(INFORMATION_MESSAGE,line);
					display_message(INFORMATION_MESSAGE,"\n");
				}
			}
			else
			{
				display_message(INFORMATION_MESSAGE,"  No parents\n");
			}
			if (element->fields)
			{
				if (0 < NUMBER_IN_LIST(FE_element_field)(
					element->fields->element_field_list))
				{
					display_message(INFORMATION_MESSAGE,"  Field information\n");				
					FOR_EACH_OBJECT_IN_LIST(FE_element_field)(list_FE_element_field,
						(void *)NULL, element->fields->element_field_list);
					if (element->information)
					{
						if ((scale_factor = element->information->scale_factors)&&
							(i=element->information->number_of_scale_factors))
						{
							display_message(INFORMATION_MESSAGE,"  #Scale factors=%d\n",i);
							strcpy(line,"    ");
							while (i>0)
							{
								sprintf(line+strlen(line),"%13g ",*scale_factor);
								if ((1==i) || (strlen(line)>=70))
								{
									strcat(line,"\n");
									display_message(INFORMATION_MESSAGE,line);
									strcpy(line,"    ");
								}
								i--;
								scale_factor++;
							}
						}
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,"list_FE_element.  Missing field info");
				return_code = 0;
			}
			/*???debug */
			{
				int i,number_of_nodes;
				struct FE_node **nodes_in_element;

				if (calculate_FE_element_field_nodes(element,(struct FE_field *)NULL,
					&number_of_nodes,&nodes_in_element,(struct FE_element *)NULL))
				{
					for (i=0;i<number_of_nodes;i++)
					{
						list_FE_node(nodes_in_element[i],(void *)NULL);
						DEACCESS(FE_node)(nodes_in_element+i);
					}
					DEALLOCATE(nodes_in_element);
				}
			}
		}
		else
		{
			display_message(INFORMATION_MESSAGE,"  Missing shape\n");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"list_FE_element.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* list_FE_element */

enum Modify_theta_in_xi1_mode
{
	MODIFY_THETA_CLOSEST_IN_XI1,
	MODIFY_THETA_DECREASING_IN_XI1,
	MODIFY_THETA_INCREASING_IN_XI1,
	MODIFY_THETA_NON_DECREASING_IN_XI1,
	MODIFY_THETA_NON_INCREASING_IN_XI1
};

static int modify_theta_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,FE_value time,
	int number_of_values,FE_value *values, enum Modify_theta_in_xi1_mode mode)
/*******************************************************************************
LAST MODIFIED : 1 February 2002

DESCRIPTION :
Modifies the already calculated <values>.
???DB.  Only for certain bases
==============================================================================*/
{
	char all_on_axis;
	enum Coordinate_system_type coordinate_system_type;
	FE_value *element_value,*element_value_2,offset_xi1_xi2,offset_xi2_xi3,
		value_xi1,value_xi2,value_xi3;
	int *basis_type,i,j,k,number_of_nodes_in_xi1,number_of_nodes_in_xi2,
		number_of_nodes_in_xi3,return_code,xi2_basis_type;
	struct FE_element_field *element_field;
	struct FE_element_field_component *axis_component;
	struct FE_node **node;
	struct Standard_node_to_element_map **node_to_element_map,
		**node_to_element_map_2;

	ENTER(modify_theta_in_xi1);
	if (component&&(STANDARD_NODE_TO_ELEMENT_MAP==component->type)&&
		(node_to_element_map=(component->map).standard_node_based.
		node_to_element_maps)&&(component->basis)&&
		(basis_type=component->basis->type)&&((1== *basis_type)||
		((2== *basis_type)&&(NO_RELATION==basis_type[2]))||
		((3== *basis_type)&&(NO_RELATION==basis_type[2])&&
		(NO_RELATION==basis_type[3])&&(NO_RELATION==basis_type[5])))&&
		element&&field&&(0<number_of_values)&&values)
	{
		coordinate_system_type=get_coordinate_system_type(
			get_FE_field_coordinate_system(field));
		if ((3==get_FE_field_number_of_components(field))&&
			((CYLINDRICAL_POLAR==coordinate_system_type)||
			(OBLATE_SPHEROIDAL==coordinate_system_type)||
			(PROLATE_SPHEROIDAL==coordinate_system_type)||
			(SPHERICAL_POLAR==coordinate_system_type)))
		{
			element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				field,element->fields->element_field_list);
			if (element_field)
			{
				switch (coordinate_system_type)
				{
					case CYLINDRICAL_POLAR:
					{
						if (component==(element_field->components)[1])
						{
							axis_component=(element_field->components)[0];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
					case OBLATE_SPHEROIDAL:
					case PROLATE_SPHEROIDAL:
					{
						if (component==(element_field->components)[2])
						{
							axis_component=(element_field->components)[1];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
					case SPHERICAL_POLAR:
					{
						if (component==(element_field->components)[1])
						{
							axis_component=(element_field->components)[2];
						}
						else
						{
							element_field=(struct FE_element_field *)NULL;
						}
					} break;
				}
			}
			if (element_field)
			{
				/* determine the number of nodes in the xi1 direction */
				switch (basis_type[1])
				{
					case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
						case HERMITE_LAGRANGE:
					{
						number_of_nodes_in_xi1=2;
					} break;
					case QUADRATIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=3;
					} break;
					case CUBIC_LAGRANGE:
					{
						number_of_nodes_in_xi1=4;
					} break;
				}
				/* determine the number of nodes in the xi2 direction */
				if (1== *basis_type)
				{
					number_of_nodes_in_xi2=1;
				}
				else
				{
					if (2== *basis_type)
					{
						xi2_basis_type=basis_type[3];
					}
					else
					{
						xi2_basis_type=basis_type[4];
					}
					switch (xi2_basis_type)
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi2=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi2=4;
						} break;
					}
				}
				/* determine the number of nodes in the xi3 direction */
				if (3== *basis_type)
				{
					switch (basis_type[6])
					{
						case LINEAR_LAGRANGE: case CUBIC_HERMITE: case LAGRANGE_HERMITE:
							case HERMITE_LAGRANGE:
						{
							number_of_nodes_in_xi3=2;
						} break;
						case QUADRATIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=3;
						} break;
						case CUBIC_LAGRANGE:
						{
							number_of_nodes_in_xi3=4;
						} break;
					}
				}
				else
				{
					number_of_nodes_in_xi3=1;
				}
				/* check for nodes on the z axis */
				node=element->information->nodes;
				/* xi2=0 face */
				if (1<number_of_nodes_in_xi2)
				{
					all_on_axis=1;
				}
				else
				{
					all_on_axis=0;
				}
				node_to_element_map=(axis_component->map).standard_node_based.
					node_to_element_maps;
				k=number_of_nodes_in_xi3;
				while (all_on_axis&&(k>0))
				{
					i=number_of_nodes_in_xi1;
					while (all_on_axis&&(i>0))
					{
						all_on_axis=node_on_axis(node[(*node_to_element_map)->node_index],
							field,time,coordinate_system_type);
						node_to_element_map++;
						i--;
					}
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k--;
				}
				if (all_on_axis)
				{
					element_value=values;
					node_to_element_map=(component->map).standard_node_based.
						node_to_element_maps;
					element_value_2=values;
					node_to_element_map_2=node_to_element_map;
					for (i=number_of_nodes_in_xi1;i>0;i--)
					{
						element_value_2 += (*node_to_element_map_2)->number_of_nodal_values;
						node_to_element_map_2++;
					}
					for (k=number_of_nodes_in_xi3;k>0;k--)
					{
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							*element_value= *element_value_2;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							node_to_element_map++;
							element_value_2 +=
								(*node_to_element_map_2)->number_of_nodal_values;
							node_to_element_map_2++;
						}
						if (k>1)
						{
							for (j=number_of_nodes_in_xi2;j>1;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
					}
				}
				else
				{
					/* xi2=1 face */
					if (1<number_of_nodes_in_xi2)
					{
						all_on_axis=1;
					}
					else
					{
						all_on_axis=0;
					}
					node_to_element_map=(axis_component->map).standard_node_based.
						node_to_element_maps;
					node_to_element_map +=
						(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
					k=number_of_nodes_in_xi3;
					while (all_on_axis&&(k>0))
					{
						i=number_of_nodes_in_xi1;
						while (all_on_axis&&(i>0))
						{
							all_on_axis=node_on_axis(node[(*node_to_element_map)->node_index],
								field,time,coordinate_system_type);
							node_to_element_map++;
							i--;
						}
						node_to_element_map +=
							(number_of_nodes_in_xi2-1)*number_of_nodes_in_xi1;
						k--;
					}
					if (all_on_axis)
					{
						element_value=values;
						node_to_element_map=(component->map).standard_node_based.
							node_to_element_maps;
						for (j=number_of_nodes_in_xi2;j>1;j--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
							}
						}
						element_value_2=element_value;
						node_to_element_map_2=node_to_element_map;
						for (i=number_of_nodes_in_xi1;i>0;i--)
						{
							node_to_element_map_2--;
							element_value_2 -=
								(*node_to_element_map_2)->number_of_nodal_values;
						}
						for (k=number_of_nodes_in_xi3;k>0;k--)
						{
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								*element_value= *element_value_2;
								element_value += (*node_to_element_map)->number_of_nodal_values;
								node_to_element_map++;
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							if (k>1)
							{
								for (j=number_of_nodes_in_xi2;j>1;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										element_value +=
											(*node_to_element_map)->number_of_nodal_values;
										node_to_element_map++;
										element_value_2 += (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2++;
									}
								}
							}
						}
					}
					else
					{
						/* xi3=0 face */
						if (1<number_of_nodes_in_xi3)
						{
							all_on_axis=1;
						}
						else
						{
							all_on_axis=0;
						}
						node_to_element_map=(axis_component->map).standard_node_based.
							node_to_element_maps;
						j=number_of_nodes_in_xi2;
						while (all_on_axis&&(j>0))
						{
							i=number_of_nodes_in_xi1;
							while (all_on_axis&&(i>0))
							{
								all_on_axis=node_on_axis(node[(*node_to_element_map)->
									node_index],field,time,coordinate_system_type);
								node_to_element_map++;
								i--;
							}
							j--;
						}
						if (all_on_axis)
						{
							element_value=values;
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							element_value_2=values;
							node_to_element_map_2=node_to_element_map;
							for (i=number_of_nodes_in_xi1;i>0;i--)
							{
								element_value_2 += (*node_to_element_map_2)->
									number_of_nodal_values;
								node_to_element_map_2++;
							}
							for (j=number_of_nodes_in_xi2;j>0;j--)
							{
								for (i=number_of_nodes_in_xi1;i>0;i--)
								{
									*element_value= *element_value_2;
									element_value +=
										(*node_to_element_map)->number_of_nodal_values;
									node_to_element_map++;
									element_value_2 += (*node_to_element_map_2)->
										number_of_nodal_values;
									node_to_element_map_2++;
								}
							}
						}
						else
						{
							/* xi3=1 face */
							if (1<number_of_nodes_in_xi3)
							{
								all_on_axis=1;
							}
							else
							{
								all_on_axis=0;
							}
							node_to_element_map=(component->map).standard_node_based.
								node_to_element_maps;
							node_to_element_map += (number_of_nodes_in_xi3-1)*
								number_of_nodes_in_xi2*number_of_nodes_in_xi1;
							j=number_of_nodes_in_xi2;
							while (all_on_axis&&(j>0))
							{
								i=number_of_nodes_in_xi1;
								while (all_on_axis&&(i>0))
								{
									all_on_axis=node_on_axis(node[(*node_to_element_map)->
										node_index],field,time,coordinate_system_type);
									node_to_element_map++;
									i--;
								}
								j--;
							}
							if (all_on_axis)
							{
								element_value=values;
								node_to_element_map=(component->map).standard_node_based.
									node_to_element_maps;
								for (k=number_of_nodes_in_xi3;k>1;k--)
								{
									for (j=number_of_nodes_in_xi2;j>0;j--)
									{
										for (i=number_of_nodes_in_xi1;i>0;i--)
										{
											element_value +=
												(*node_to_element_map)->number_of_nodal_values;
											node_to_element_map++;
										}
									}
								}
								element_value_2=element_value;
								node_to_element_map_2=node_to_element_map;
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										node_to_element_map_2--;
										element_value_2 -= (*node_to_element_map_2)->
											number_of_nodal_values;
									}
								}
								for (j=number_of_nodes_in_xi2;j>0;j--)
								{
									for (i=number_of_nodes_in_xi1;i>0;i--)
									{
										*element_value= *element_value_2;
										element_value += (*node_to_element_map)->
											number_of_nodal_values;
										node_to_element_map++;
										element_value_2 += (*node_to_element_map_2)->
											number_of_nodal_values;
										node_to_element_map_2++;
									}
								}
							}
						}
					}
				}
				element_value=values;
				node_to_element_map=(component->map).standard_node_based.
					node_to_element_maps;
				offset_xi1_xi2=0;
				offset_xi2_xi3=0;
				/* apply condition on xi1 and make sure smooth in xi2 & xi3 */
				for (k=number_of_nodes_in_xi3;k>0;k--)
				{
					value_xi3= *element_value;
					for (j=number_of_nodes_in_xi2;j>0;j--)
					{
						value_xi2= *element_value;
						for (i=number_of_nodes_in_xi1;i>1;i--)
						{
							value_xi1= *element_value;
							element_value += (*node_to_element_map)->number_of_nodal_values;
							*element_value += offset_xi1_xi2+offset_xi2_xi3;
							/*???DB.  <= needed for single prolate, but seems to cause
								problems for heart */
							switch (mode)
							{
								case MODIFY_THETA_CLOSEST_IN_XI1:
								{
									if (value_xi1 < (*element_value - PI))
									{
										*element_value -= 2*PI;
									}
									else if (value_xi1 > (*element_value + PI))
									{
										*element_value += 2*PI;
									}
								} break;
								case MODIFY_THETA_DECREASING_IN_XI1:
								{
									if (value_xi1 <= *element_value)
									{
										*element_value -= 2*PI;
									}
								} break;
								case MODIFY_THETA_INCREASING_IN_XI1:
								{
									if (value_xi1 >= *element_value)
									{
										*element_value += 2*PI;
									}
								} break;
								case MODIFY_THETA_NON_DECREASING_IN_XI1:
								{
									if (value_xi1 > *element_value)
									{
										*element_value += 2*PI;
									}
								} break;
								case MODIFY_THETA_NON_INCREASING_IN_XI1:
								{
									if (value_xi1 < *element_value)
									{
										*element_value -= 2*PI;
									}
								} break;
							}
							node_to_element_map++;
						}
						element_value += (*node_to_element_map)->number_of_nodal_values;
						node_to_element_map++;
						if (j>1)
						{
							value_xi1= *element_value;
							if (value_xi1>value_xi2+PI)
							{
								offset_xi1_xi2= -2*PI;
								*element_value += offset_xi1_xi2;
							}
							else
							{
								if (value_xi1<value_xi2-PI)
								{
									offset_xi1_xi2=2*PI;
									*element_value += offset_xi1_xi2;
								}
								else
								{
									offset_xi1_xi2=0;
								}
							}
						}
					}
					if (k>1)
					{
						offset_xi1_xi2=0;
						value_xi2= *element_value;
						if (value_xi2>value_xi3+PI)
						{
							offset_xi2_xi3= -2*PI;
							*element_value += offset_xi2_xi3;
						}
						else
						{
							if (value_xi2<value_xi3-PI)
							{
								offset_xi2_xi3=2*PI;
								*element_value += offset_xi2_xi3;
							}
							else
							{
								offset_xi2_xi3=0;
							}
						}
					}
				}
			}
		}
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"modify_theta_in_xi1.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* modify_theta_in_xi1 */

int theta_closest_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,FE_value time,
	int number_of_values,FE_value *values)
/*******************************************************************************
LAST MODIFIED : 1 February 2002

DESCRIPTION :
Calls modify_theta_in_xi1 with mode MODIFY_THETA_CLOSEST_IN_XI1.
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	int return_code;

	ENTER(theta_closest_in_xi1);
	return_code = modify_theta_in_xi1(component, element, field, time,
		number_of_values, values, MODIFY_THETA_CLOSEST_IN_XI1);
	LEAVE;

	return (return_code);
} /* theta_closest_in_xi1 */

int theta_decreasing_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,FE_value time,
	int number_of_values,FE_value *values)
/*******************************************************************************
LAST MODIFIED : 1 February 2002

DESCRIPTION :
Calls modify_theta_in_xi1 with mode MODIFY_THETA_DECREASING_IN_XI1.
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	int return_code;

	ENTER(theta_decreasing_in_xi1);
	return_code = modify_theta_in_xi1(component, element, field, time,
		number_of_values, values, MODIFY_THETA_DECREASING_IN_XI1);
	LEAVE;

	return (return_code);
} /* theta_decreasing_in_xi1 */

int theta_increasing_in_xi1(struct FE_element_field_component *component,
	struct FE_element *element,struct FE_field *field,FE_value time,
	int number_of_values,FE_value *values)
/*******************************************************************************
LAST MODIFIED : 1 February 2002

DESCRIPTION :
Calls modify_theta_in_xi1 with mode MODIFY_THETA_INCREASING_IN_XI1.
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	int return_code;

	ENTER(theta_increasing_in_xi1);
	return_code = modify_theta_in_xi1(component, element, field, time,
		number_of_values, values, MODIFY_THETA_INCREASING_IN_XI1);
	LEAVE;

	return (return_code);
} /* theta_increasing_in_xi1 */

int theta_non_decreasing_in_xi1(
	struct FE_element_field_component *component,struct FE_element *element,
	struct FE_field *field,FE_value time,int number_of_values,FE_value *values)
/*******************************************************************************
LAST MODIFIED : 1 February 2002

DESCRIPTION :
Calls modify_theta_in_xi1 with mode MODIFY_THETA_NON_DECREASING_IN_XI1.
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	int return_code;

	ENTER(theta_non_decreasing_in_xi1);
	return_code = modify_theta_in_xi1(component, element, field, time,
		number_of_values, values, MODIFY_THETA_NON_DECREASING_IN_XI1);
	LEAVE;

	return (return_code);
} /* theta_non_decreasing_in_xi1 */

int theta_non_increasing_in_xi1(
	struct FE_element_field_component *component,struct FE_element *element,
	struct FE_field *field,FE_value time,int number_of_values,FE_value *values)
/*******************************************************************************
LAST MODIFIED : 1 February 2002

DESCRIPTION :
Calls modify_theta_in_xi1 with mode MODIFY_THETA_NON_INCREASING_IN_XI1.
???RC.  Needs to be global to allow writing function in export_finite_element.
==============================================================================*/
{
	int return_code;

	ENTER(theta_non_increasing_in_xi1);
	return_code = modify_theta_in_xi1(component, element, field, time,
		number_of_values, values, MODIFY_THETA_NON_INCREASING_IN_XI1);
	LEAVE;

	return (return_code);
} /* theta_non_increasing_in_xi1 */

int calculate_FE_field(struct FE_field *field,int component_number,
	struct FE_node *node,struct FE_element *element,FE_value *xi_coordinates,
	FE_value time, FE_value *value)
/*******************************************************************************
LAST MODIFIED : 11 May 2003

DESCRIPTION :
Calculates the <value> of the <field> for the specified <node> or <element> and
<xi_coordinates>.  If 0<=component_number<=number_of_components, then only the
specified component is calculated, otherwise all components are calculated.  The
storage for the <value> should have been allocated outside the function.
???DB.  Picks up the first version for the node.
==============================================================================*/
{
	Value_storage *component_nodal_value,*nodal_values;
	int i,return_code;
	struct FE_element_field_values *element_field_values;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct FE_node_field_info *node_field_info;

	ENTER(calculate_FE_field);
	/* check the arguments */
	if (field&&((node&&!element&&!xi_coordinates)||
		(!node&&element&&xi_coordinates))&&value)
	{
		if (node)
		{
			/* calculate field for node */
			if ((nodal_values=node->values_storage)&&(node_field_info=node->fields))
			{
				if (node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
					field,node_field_info->node_field_list))
				{
					if (field->value_type == FE_VALUE_VALUE)
					{
						if (((i=field->number_of_components)>0)&&
							(node_field_component=node_field->components))
						{
							if ((0<=component_number)&&(component_number<i))
							{
								nodal_values += (node_field_component[component_number]).value;
								*value = *((FE_value *)nodal_values);
							}
							else
							{
								while (i>0)
								{	
									component_nodal_value=nodal_values+node_field_component->value;								
									*value = *((FE_value *)component_nodal_value);				
									node_field_component++;
									value++;
									i--;
								}					
								return_code=1;
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"calculate_FE_field.  Missing node field components");
							return_code=0;
						}
					}/* if (field->value_type == FE_VALUE_VALUE) */
					else
					{
						display_message(ERROR_MESSAGE,
								"calculate_FE_field. field->value_type must be FE_VALUE_VALUE ");
							return_code=0;
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"calculate_FE_field.  Field not defined for node");
					return_code=0;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_field.  Missing node values or fields");
				return_code=0;
			}
		}
		else	
		{
			/* calculate field for element */
			/* determine if the field is defined over the element */
			element_field_values=CREATE(FE_element_field_values)();
			if (calculate_FE_element_field_values(element,field,
				time,/*calculate_derivatives*/0,element_field_values,
				/*top_level_element*/(struct FE_element *)NULL))
			{
				/* calculate the value for the element field */
				return_code=calculate_FE_element_field(component_number,
					element_field_values,xi_coordinates,value,(FE_value *)NULL);
				clear_FE_element_field_values(element_field_values);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"calculate_FE_field.  Field not defined for element");
				return_code=0;
			}
			DESTROY(FE_element_field_values)(&element_field_values);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"calculate_FE_field.  Invalid argument(s)\n"
			"field %p, node %p, element %p, xi_coordinates %p, value %p",field,node,
			element,xi_coordinates,value);
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* calculate_FE_field */

struct FE_field *find_first_time_field_at_FE_node(struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 9 June 1999

Find the first time based field at a node
==============================================================================*/
{
	struct FE_field *time_field;
	struct FE_node_field *time_node_field;
	ENTER(find_first_time_field_at_FE_node);
	time_field = (struct FE_field *)NULL;
	time_node_field = (struct FE_node_field *)NULL;
	if (node)
	{
		if (time_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
			FE_node_field_has_time,(void *)(NULL),
			node->fields->node_field_list))
		{			
			time_field = time_node_field->field;			
		}
		else
		{
			display_message(ERROR_MESSAGE,"find_first_time_field_at_FE_node."
				" Failed to find time_field in node");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"find_first_time_field_at_FE_node."
				" Invalid arguments");
	}
	LEAVE;
	return (time_field);
} /* find_first_time_field_at_FE_node */

int FE_element_get_top_level_xi_number(struct FE_element *element,int xi_number)
/*******************************************************************************
LAST MODIFIED : 12 October 1998

DESCRIPTION :
Returns the xi_number of the parent or parent's parent that changes with the
<xi_number> (0..dimension-1) of <element>.  If there is no parent, then
<xi_number> is returned, or 0 if there is an error.
???RC Could stuff up for graphical finite elements if parent is not in same
element_group and xi directions are different for neighbouring elements.
==============================================================================*/
{
	FE_value *face_to_element;
	int dimension,face_number,top_level_xi_number;
	struct FE_element *parent;
	struct FE_element_parent *element_parent;

	ENTER(FE_element_get_top_level_xi_number);
	if (element&&(element->shape)&&(0<=xi_number)&&
		(xi_number<element->shape->dimension))
	{
		switch (element->shape->dimension)
		{
			case 1:
			{
				if ((element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					(LIST_ITERATOR_FUNCTION(FE_element_parent) *)NULL,(void *)NULL,
					element->parent_list))&&(parent=element_parent->parent))
				{
					face_number=element_parent->face_number;
					dimension=parent->shape->dimension;
					face_to_element=(parent->shape->face_to_element)+
						(face_number*dimension*dimension+1);
					if (*face_to_element)
					{
						top_level_xi_number=FE_element_get_top_level_xi_number(parent,0);
					}
					else
					{
						top_level_xi_number=FE_element_get_top_level_xi_number(parent,1);
					}
				}
				else
				{
					top_level_xi_number=0;
				}
			} break;
			case 2:
			{
				if ((element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					(LIST_ITERATOR_FUNCTION(FE_element_parent) *)NULL,(void *)NULL,
					element->parent_list))&&(parent=element_parent->parent))
				{
					face_number=element_parent->face_number;
					dimension=parent->shape->dimension;
					face_to_element=(parent->shape->face_to_element)+
						(face_number*dimension*dimension+1);
					/* look in column of face_to_element for this xi_number */
					if (face_to_element[xi_number])
					{
						top_level_xi_number=0;
					}
					else
					{
						if (face_to_element[dimension+xi_number])
						{
							top_level_xi_number=1;
						}
						else
						{
							top_level_xi_number=2;
						}
					}
				}
				else
				{
					/* no parents */
					top_level_xi_number=xi_number;
				}
			} break;
			case 3:
			{
				/* 3-D: no parents */
				top_level_xi_number=xi_number;
			} break;
			default:
			{
				display_message(ERROR_MESSAGE,
					"FE_element_get_top_level_xi_number.  Invalid dimension");
				top_level_xi_number=0;
			} break;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_top_level_xi_number.  Invalid argument(s)");
		top_level_xi_number=0;
	}
	LEAVE;

	return (top_level_xi_number);
} /* FE_element_get_top_level_xi_number */

struct FE_element_field_info *FE_element_get_FE_element_field_info(
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Returns the FE_element_field_info from <element>. Must not be modified!
==============================================================================*/
{
	struct FE_element_field_info *fe_element_field_info;

	ENTER(FE_element_get_FE_element_field_info);
	if (element)
	{
		fe_element_field_info = element->fields;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_FE_element_field_info.  Invalid argument(s)");
		fe_element_field_info = (struct FE_element_field_info *)NULL;
	}
	LEAVE;

	return (fe_element_field_info);
} /* FE_element_get_FE_element_field_info */

int FE_element_set_FE_element_field_info(struct FE_element *element,
	struct FE_element_field_info *fe_element_field_info)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Changes the FE_element_field_info at <element> to <fe_element_field_info>.
Note it is very important that the old and the new FE_element_field_info
structures describe the same data layout in the element information!
Private function only to be called by FE_region when merging FE_regions!
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_set_FE_element_field_info);
	if (element && fe_element_field_info)
	{
		return_code = REACCESS(FE_element_field_info)(&(element->fields),
			fe_element_field_info);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_set_FE_element_field_info.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_set_FE_element_field_info */

struct FE_region *FE_element_get_FE_region(struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 13 February 2003

DESCRIPTION :
Returns the FE_region that <element> belongs to.
==============================================================================*/
{
	struct FE_region *fe_region;

	ENTER(FE_element_get_FE_element_field_info);
	if (element && element->fields)
	{
		fe_region = element->fields->fe_region;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_FE_region.  Invalid argument(s)");
		fe_region = (struct FE_region *)NULL;
	}
	LEAVE;

	return (fe_region);
} /* FE_element_get_FE_region */

int FE_element_has_top_level_element(struct FE_element *element,
	void *top_level_element_void)
/*******************************************************************************
LAST MODIFIED : 8 June 2000

DESCRIPTION :
Returns true if <top_level_element> is indeed a top_level parent of <element>.
==============================================================================*/
{
	int return_code;
	struct FE_element *top_level_element;

	ENTER(FE_element_has_top_level_element);
	if (element&&(top_level_element=(struct FE_element *)top_level_element_void)&&
		(CM_ELEMENT==top_level_element->cm.type))
	{
		if ((element==top_level_element)||
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				top_level_element_void,element->parent_list))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_top_level_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_top_level_element */

int FE_element_or_parent_is_element(
	struct FE_element *element,void *match_element_void)
/*******************************************************************************
LAST MODIFIED : 21 June 2000

DESCRIPTION :
Returns true if <element> or any of its parents matches <match_element>.
==============================================================================*/
{
	int return_code;
	struct FE_element *match_element;

	ENTER(FE_element_or_parent_is_element);
	if (element&&(match_element=(struct FE_element *)match_element_void))
	{
		if ((element==match_element)||((struct FE_element_parent *)NULL !=
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_element_matches_recursive,
				match_element_void,element->parent_list)))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_is_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /*  FE_element_or_parent_is_element*/

int FE_element_is_top_level_parent_of_element(
	struct FE_element *top_level_element,void *element_void)
/*******************************************************************************
LAST MODIFIED : 8 June 2000

DESCRIPTION :
Returns true if <top_level_element> is a top_level parent of <element>.
==============================================================================*/
{
	int return_code;
	struct FE_element *element;

	ENTER(FE_element_is_top_level_parent_of_element);
	if (top_level_element&&(element=(struct FE_element *)element_void))
	{
		if ((CM_ELEMENT==top_level_element->cm.type)&&
			((element==top_level_element)||
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_element_matches_recursive,
					(void *)top_level_element,element->parent_list)))
		{
			return_code=1;
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_top_level_parent_of_element.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_top_level_parent_of_element */

struct FE_element *FE_element_get_top_level_element_conversion(
	struct FE_element *element,struct FE_element *check_top_level_element,
	struct LIST(FE_element) *element_list, int face_number,
	FE_value *element_to_top_level)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Returns the/a top level [ultimate parent] element for <element>. If supplied,
the function attempts to verify that the <check_top_level_element> is in
fact a valid top_level_element for <element>, otherwise it tries to find one in
the <element_list> and with <element> on its <face_number> (if positive), if
either are specified.

If the returned element is different to <element> (ie. is of higher dimension),
then this function also fills the matrix <element_to_top_level> with values for
converting the xi coordinates in <element> to those in the returned element.
<element_to_top_level> should be preallocated to store at least nine FE_values.

The use of the <element_to_top_level> matrix is similar to <face_to_element> in
FE_element_shape - in fact it is either a copy of it, or calculated from it.
It gives the transformation xi(top_level) = b + A xi(element), where b is in the
first column of the matrix, and the rest of the matrix is A. Its size depends
on the dimension of element:top_level, ie.,
1:2 First 4 values, in form of 2 row X 2 column matrix, used only.
1:3 First 6 values, in form of 3 row X 2 column matrix, used only.
2:3 First 9 values, in form of 3 row X 3 column matrix, used only.
NOTE: recursive to handle 1-D to 3-D case.
==============================================================================*/
{
	int i,size;
	FE_value *face_to_element;
	struct FE_element *parent,*top_level_element;
	struct FE_element_parent *element_parent,*first_element_parent;
	struct FE_element_parent_face_of_element_in_list_data face_in_list_data;

	ENTER(FE_element_get_top_level_element_conversion);
	if (element&&element_to_top_level)
	{
		if (first_element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
			(LIST_CONDITIONAL_FUNCTION(FE_element_parent) *)NULL,(void *)NULL,
			element->parent_list))
		{
			if (!(check_top_level_element&&(element_parent=
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_element_matches_recursive,
					(void *)check_top_level_element,element->parent_list))))
			{
				if (element_list)
				{
					if (0>face_number)
					{
						element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
							FE_element_parent_element_in_list,(void *)element_list,
							element->parent_list);
					}
					else
					{
						face_in_list_data.face_number = face_number;
						face_in_list_data.element_list = element_list;
						element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
							FE_element_parent_face_of_element_in_list,
							(void *)&face_in_list_data, element->parent_list);
					}
				}
				else
				{
					if (0>face_number)
					{
						element_parent=first_element_parent;
					}
					else
					{
						element_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
							FE_element_parent_has_face_number,(void *)&face_number,
							element->parent_list);
					}
				}
			}
			if ((element_parent||(element_parent=first_element_parent))&&
				(parent=element_parent->parent)&&parent->shape&&
				parent->shape->face_to_element&&
				(top_level_element=FE_element_get_top_level_element_conversion(
					parent,check_top_level_element,element_list,face_number,
					element_to_top_level)))
			{
				face_to_element=parent->shape->face_to_element +
					(element_parent->face_number*
						parent->shape->dimension*parent->shape->dimension);
				size=top_level_element->shape->dimension;
				if (parent == top_level_element)
				{
					/* element_to_top_level = face_to_element of appropriate face */
					for (i=size*size-1;0<=i;i--)
					{
						element_to_top_level[i]=face_to_element[i];
					}
				}
				else
				{
					/* multiply face_to_element of top_level_element (currently in
						 element_to_top_level) by face_to_element of parent */
					/* this is the 1:3 case */
#if defined (DEBUG)
					if (1==element->shape->dimension)
					{
						printf("\n");
						printf("f=[%6.3f %6.3f]\n",face_to_element[0],face_to_element[1]);
						printf("  [%6.3f %6.3f]\n",face_to_element[2],face_to_element[3]);
						printf("e=[%6.3f %6.3f %6.3f]\n",element_to_top_level[0],
							element_to_top_level[1],element_to_top_level[2]);
						printf("  [%6.3f %6.3f %6.3f]\n",element_to_top_level[3],
							element_to_top_level[4],element_to_top_level[5]);
						printf("  [%6.3f %6.3f %6.3f]\n",element_to_top_level[6],
							element_to_top_level[7],element_to_top_level[8]);
					}
#endif /* defined (DEBUG) */
					for (i=0;i<size;i++)
					{
						element_to_top_level[i*2  ] = element_to_top_level[i*size] +
							element_to_top_level[i*size+1]*face_to_element[0]+
							element_to_top_level[i*size+2]*face_to_element[2];
						element_to_top_level[i*2+1] =
							element_to_top_level[i*size+1]*face_to_element[1]+
							element_to_top_level[i*size+2]*face_to_element[3];
					}
				}
#if defined (DEBUG)
				/*???debug*/
				{
					FE_value *value;
					int a,b;

					value=element_to_top_level;
					for (b=0;b<top_level_element->shape->dimension;b++)
					{
						printf("[");
						for (a=0;a<=element->shape->dimension;a++)
						{
							printf(" %6.2f",*value);
							value++;
						}
						printf(" ]\n");
					}
					printf("\n");
				}
#endif /* defined (DEBUG) */
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_get_top_level_element_conversion.  Invalid parent");
				top_level_element=(struct FE_element *)NULL;
			}
		}
		else
		{
			/* no parents */
			top_level_element=element;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_top_level_element_conversion.  Invalid argument(s)");
		top_level_element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (top_level_element);
} /* FE_element_get_top_level_element_conversion */

int FE_element_get_top_level_element_and_xi(struct FE_element *element, 
	FE_value *xi, int element_dimension, struct FE_element **top_level_element,
	FE_value *top_level_xi, int *top_level_element_dimension)
/*******************************************************************************
LAST MODIFIED : 7 May 2003

DESCRIPTION :
Finds the <top_level_element>, <top_level_xi> and <top_level_element_dimension>
for the given <element> and <xi>.  If <top_level_element> is already set it 
is checked and the <top_level_xi> calculated.
==============================================================================*/
{
	FE_value element_to_top_level[9];
	int i,j,k,return_code;

	ENTER(FE_element_get_top_level_element_and_xi);
	if (element&&xi&&top_level_element&&top_level_xi&&top_level_element_dimension)
	{
		return_code = 1;
		if (CM_ELEMENT == element->cm.type)
		{
			*top_level_element = element;
			for (i=0;i<element_dimension;i++)
			{
				top_level_xi[i]=xi[i];
			}
			/* do not set element_to_top_level */
			*top_level_element_dimension=element_dimension;
		}
		else
		{
			/* check or get top_level element and xi coordinates for it */
			if (*top_level_element = FE_element_get_top_level_element_conversion(
				element,*top_level_element,(struct LIST(FE_element) *)NULL,
				-1,element_to_top_level))
			{
				/* convert xi to top_level_xi */
				*top_level_element_dimension = (*top_level_element)->shape->dimension;
				for (j=0;j<*top_level_element_dimension;j++)
				{
					top_level_xi[j] = element_to_top_level[j*(element_dimension+1)];
					for (k=0;k<element_dimension;k++)
					{
						top_level_xi[j] +=
							element_to_top_level[j*(element_dimension+1)+k+1]*xi[k];
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_get_top_level_element_and_xi.  "
					"No top-level element found to evaluate on");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_get_top_level_element_and_xi.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_get_top_level_element_and_xi */

int get_FE_element_discretization_from_top_level(struct FE_element *element,
	int *number_in_xi,struct FE_element *top_level_element,
	int *top_level_number_in_xi,FE_value *element_to_top_level)
/*******************************************************************************
LAST MODIFIED : 3 May 2001

DESCRIPTION :
Returns in <number_in_xi> the equivalent discretization of <element> for its
position - element, face or line - in <top_level_element>. Uses
<element_to_top_level> array for line/face conversion as returned by
FE_element_get_top_level_element_conversion.
<number_in_xi> must have space at lease MAXIMUM_ELEMENT_XI_DIMENSIONS integers,
as remaining values up to this size are cleared to zero.
==============================================================================*/
{
	int dimension,i,j,maximum_number_in_xi,return_code,top_level_dimension;

	ENTER(get_FE_element_discretization_from_top_level);
	if (element&&number_in_xi&&top_level_element&&top_level_number_in_xi)
	{
		return_code=1;
		dimension=get_FE_element_dimension(element);
		if (top_level_element==element)
		{
			for (i=0;i<dimension;i++)
			{
				number_in_xi[i]=top_level_number_in_xi[i];
			}
		}
		else if (element_to_top_level)
		{
			top_level_dimension=get_FE_element_dimension(top_level_element);
			/* use largest number_in_xi of any linked xi directions */
			for (i=0;(i<dimension)&&return_code;i++)
			{
				maximum_number_in_xi=0;
				number_in_xi[i]=0;
				for (j=0;j<top_level_dimension;j++)
				{
					if (0.0!=fabs(element_to_top_level[j*(dimension+1)+i+1]))
					{
						if (top_level_number_in_xi[j]>maximum_number_in_xi)
						{
							maximum_number_in_xi=top_level_number_in_xi[j];
						}
					}
				}
				number_in_xi[i] = maximum_number_in_xi;
				if (0==maximum_number_in_xi)
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_discretization_from_top_level.  "
						"Could not get discretization");
					return_code=0;
				}
			}
			for (i=dimension;i<MAXIMUM_ELEMENT_XI_DIMENSIONS;i++)
			{
				number_in_xi[i]=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_discretization_from_top_level.  "
				"Missing element_to_top_level matrix");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_discretization_from_top_level.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_discretization_from_top_level */

int get_FE_element_discretization(struct FE_element *element,
	struct LIST(FE_element) *element_list,int face_number,
	struct FE_field *native_discretization_field,
	int *top_level_number_in_xi,struct FE_element **top_level_element,
	int *number_in_xi)
/*******************************************************************************
LAST MODIFIED : 3 December 2002

DESCRIPTION :
Returns the discretization as <number_in_xi> for displaying graphics over
<element>, given its <element_list>, <face_number> and suggested
<*top_level_element>. If <native_discretization_field> is defined over the
element and is grid-based, it's native discretization is used in preference
to the <top_level_number_in_xi>.
<*top_level_element> can be NULL; final element used will be returned.
<top_level_number_in_xi> should be set by the caller as it will be used if there
is no native_discretization field or it is not defined over the element; in
either case the top_level_number_in_xi used is returned.
==============================================================================*/
{
	FE_value element_to_top_level[9];
	int return_code;

	ENTER(get_FE_element_discretization);
	if (element&&top_level_number_in_xi&&top_level_element&&number_in_xi)
	{
		if (*top_level_element=FE_element_get_top_level_element_conversion(
			element,*top_level_element,element_list,face_number,
			element_to_top_level))
		{
			/* get the discretization requested for top-level element, from native
				 discretization field if not NULL and is element based in element */
			if (native_discretization_field&&
				FE_element_field_is_grid_based(*top_level_element,
					native_discretization_field))
			{
				get_FE_element_field_grid_map_number_in_xi(*top_level_element,
					native_discretization_field,top_level_number_in_xi);
			}
			if (get_FE_element_discretization_from_top_level(element,number_in_xi,
				*top_level_element,top_level_number_in_xi,element_to_top_level))
			{
				return_code=1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_discretization.  Error getting discretization");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"get_FE_element_discretization.  "
				"Error getting top_level_element");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_discretization.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_discretization */

int FE_element_or_parent_contains_node(struct FE_element *element,
	void *node_void)
/*******************************************************************************
LAST MODIFIED : 25 May 2001

DESCRIPTION :
FE_element conditional function returning 1 if <element> or all of its parents
or parent's parents contains <node>.
==============================================================================*/
{
	int i,number_of_nodes,return_code;
	struct FE_node *node,**nodes;

	ENTER(FE_element_or_parent_contains_node);
	if (element && (node = (struct FE_node *)node_void))
	{
		return_code = 0;
		if (element->information)
		{
			if ((0 < (number_of_nodes = element->information->number_of_nodes)) &&
				(nodes = element->information->nodes))
			{
				i = number_of_nodes;
				while ((i > 0) && !return_code)
				{
					if (*nodes == node)
					{
						return_code = 1;
					}
					nodes++;
					i--;
				}
			}
		}
		if (!return_code)
		{
			/* return true if any parents (or their parents) contain the node */
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_contains_node, node_void, element->parent_list))
			{
				return_code = 1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_contains_node.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_or_parent_contains_node */

int FE_element_or_parent_contains_node_in_list(struct FE_element *element,
	void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 31 May 2001

DESCRIPTION :
FE_element conditional function returning 1 if <element> or all of its parents
or parent's parents contains nodes in <node_list>.
Routine is used with graphical finite elements to redraw only those elements
affected by a node change when the mesh is edited.
==============================================================================*/
{
	int i, number_of_nodes, return_code;
	struct FE_node **nodes;
	struct LIST(FE_node) *node_list;

	ENTER(FE_element_or_parent_contains_node_in_list);
	return_code = 0;
	if (element && (node_list = (struct LIST(FE_node) *)node_list_void))
	{
		if (element->information)
		{
			if ((0 < (number_of_nodes = element->information->number_of_nodes)) &&
				(nodes = element->information->nodes))
			{
				for (i = number_of_nodes; (0 < i) && (!return_code); i--)
				{
					if (IS_OBJECT_IN_LIST(FE_node)(*nodes, node_list))
					{
						return_code = 1;
					}
					nodes++;
				}
			}
		}
		if (!return_code)
		{
			/* return true if any parents (or their parents) contain node in list */
			if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_contains_node_in_list, node_list_void,
				element->parent_list))
			{
				return_code = 1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_contains_node_in_list.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_or_parent_contains_node_in_list */

struct FE_element_parent_find_inherit_elements
/*******************************************************************************
LAST MODIFIED : 12 February 2003

DESCRIPTION :
Data for FE_element_parent_find_inherit_elements.
==============================================================================*/
{
	/* no need to try elements in element_list */
	struct LIST(FE_element) *element_list;
	/* put parent elements with information in inherit_element_list */
	struct LIST(FE_element) *inherit_element_list;
};

static int FE_element_parent_find_inherit_elements(
	struct FE_element_parent *element_parent, void *data_void)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
If the parent element is in <element_list>, does nothing. If it is not,
adds it to <inherit_element_list> if it has information, and calls this function
for each of its parents.
<data_void> points at a struct FE_element_parent_find_inherit_elements.
==============================================================================*/
{
	int return_code;
	struct FE_element *element;
	struct FE_element_parent_find_inherit_elements *data;

	ENTER(FE_element_parent_find_inherit_elements);
	if (element_parent && (element = element_parent->parent) &&
		(data = (struct FE_element_parent_find_inherit_elements *)data_void))
	{
		return_code = 1;
		if (!IS_OBJECT_IN_LIST(FE_element)(element, data->element_list))
		{
			if (element->information)
			{
				return_code = ADD_OBJECT_TO_LIST(FE_element)(element,
					data->inherit_element_list);
			}
			if (return_code)
			{
				return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
					FE_element_parent_find_inherit_elements, data_void,
					element->parent_list);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_find_inherit_elements.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_find_inherit_elements */

int FE_element_add_nodes_to_list(struct FE_element *element, void *data_void)
/*******************************************************************************
LAST MODIFIED : 26 February 2003

DESCRIPTION :
Adds all the nodes used by <element> to the <node_list> in the data. Since it
is very inefficient to determine the nodes in use by faces or lines, the
<element_list> being iterated over is also passed to this function so that only
faces or lines with parents not in the <element_list> are checked, and only
nodes inherited from top level elements not in the list are considered.
The optional <intersect_node_list> restricts nodes added to <node_list> to also
be in it.
<data_void> points at a struct FE_element_add_nodes_to_list_data.
==============================================================================*/
{
	int i, number_of_nodes, return_code;
	struct FE_element *inherit_element;
	struct FE_element_add_nodes_to_list_data *data;
	struct FE_element_parent_find_inherit_elements inherit_data;
	struct FE_node **element_field_nodes, **nodes;

	ENTER(FE_element_add_nodes_to_list);
	if (element && (data = (struct FE_element_add_nodes_to_list_data *)data_void))
	{
		return_code = 1;
		if (element->information)
		{
			if ((0 < (number_of_nodes = element->information->number_of_nodes)) &&
				(nodes = element->information->nodes))
			{
				for (i = number_of_nodes; (0 < i) && return_code; i--)
				{
					if (*nodes)
					{
						if (!IS_OBJECT_IN_LIST(FE_node)(*nodes, data->node_list))
						{
							if ((!(data->intersect_node_list)) ||
								IS_OBJECT_IN_LIST(FE_node)(*nodes, data->intersect_node_list))
							{
								return_code =
									ADD_OBJECT_TO_LIST(FE_node)(*nodes, data->node_list);
							}
						}
					}
					nodes++;
				}
			}
		}
		if (return_code)
		{
			/* only look at parents if there are any not in element_list */
			if (!FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
				FE_element_parent_is_in_list, (void *)(data->element_list),
				element->parent_list))
			{
				/* get list of node-containing elements that are ancestors of this
					 element, are not themselves in the data->element_list and with
					 intermediate ancestors not in the data->element_list */
				inherit_data.element_list = data->element_list;
				inherit_data.inherit_element_list = CREATE(LIST(FE_element))();
				if (return_code = FOR_EACH_OBJECT_IN_LIST(FE_element_parent)(
					FE_element_parent_find_inherit_elements, (void *)&inherit_data,
					element->parent_list))
				{
					while (return_code && (inherit_element =
						FIRST_OBJECT_IN_LIST_THAT(FE_element)(
							(LIST_CONDITIONAL_FUNCTION(FE_element) *)NULL, (void *)NULL,
							inherit_data.inherit_element_list)))
					{
						if (return_code = REMOVE_OBJECT_FROM_LIST(FE_element)(
							inherit_element, inherit_data.inherit_element_list))
						{
							/*???RC Just handle first coordinate field for now -- later
								check ALL fields! */
							if (return_code = calculate_FE_element_field_nodes(element,
								(struct FE_field *)NULL, &number_of_nodes, &element_field_nodes,
								inherit_element))
							{
								if (nodes = element_field_nodes)
								{
									for (i = number_of_nodes; 0 < i; i--)
									{
										if (*nodes)
										{
											if (!IS_OBJECT_IN_LIST(FE_node)(*nodes, data->node_list))
											{
												if ((!(data->intersect_node_list)) ||
													IS_OBJECT_IN_LIST(FE_node)(*nodes,
														data->intersect_node_list))
												{
													if (!ADD_OBJECT_TO_LIST(FE_node)(*nodes,
														data->node_list))
													{
														return_code = 0;
													}
												}
											}
											DEACCESS(FE_node)(nodes);
										}
										nodes++;
									}
									DEALLOCATE(element_field_nodes);
								}
							}
						}
					}
				}
				DESTROY(LIST(FE_element))(&(inherit_data.inherit_element_list));
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_add_nodes_to_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_add_nodes_to_list */

int add_FE_element_using_node_list_to_list(struct FE_element *element,
	void *element_list_node_list_data_void)
/*******************************************************************************
LAST MODIFIED : 1 June 2001

DESCRIPTION :
If <element> has a parent already in <element_list>, or it or any of its parents
uses any nodes in <node_list>, then <element> is added to <element_list>.
Used to build up a list of elements [probably] affected by changes to the nodes
in <node_list>.
Note: for the sake of speed it is sometimes inaccurate for faces and lines. It
also relies on list being ordered with CM_ELEMENT first, then CM_FACE, then
CM_LINE for efficiency -- that's why it checks if any parents are in list first.
==============================================================================*/
{
	int return_code;
	struct FE_element_list_FE_node_list_data *element_list_node_list_data

	ENTER(add_FE_element_using_node_list_to_list);
	if (element && (element_list_node_list_data =
		(struct FE_element_list_FE_node_list_data *)
		element_list_node_list_data_void))
	{
		if ((((struct FE_element_parent *)NULL !=
			FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
				FE_element_parent_is_in_list,
				(void *)element_list_node_list_data->element_list,
				element->parent_list)) ||
			FE_element_or_parent_contains_node_in_list(element,
				(void *)element_list_node_list_data->node_list)) &&
			(!IS_OBJECT_IN_LIST(FE_element)(element,
				element_list_node_list_data->element_list)))
		{
			return_code = ADD_OBJECT_TO_LIST(FE_element)(element,
				element_list_node_list_data->element_list);
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_using_node_list_to_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_using_node_list_to_list */

int FE_element_is_dimension(struct FE_element *element,void *dimension_void)
/*******************************************************************************
LAST MODIFIED : 21 September 1998

DESCRIPTION :
Returns true if <element> is of the given <dimension>.
<dimension_void> must be a pointer to an int containing the dimension.
==============================================================================*/
{
	int *dimension,return_code;

	ENTER(FE_element_is_dimension);
	if (element&&element->shape&&(dimension=(int *)dimension_void))
	{
		return_code = (element->shape->dimension == *dimension);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_dimension.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_dimension */

int FE_element_is_dimension_3(struct FE_element *element,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 1 December 1999

DESCRIPTION :
Returns true if <element> is a 3-D element (ie. not a 2-D face or 1-D line).
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_is_dimension_3);
	USE_PARAMETER(dummy_void);
	if (element&&element->shape)
	{
		return_code=(3==element->shape->dimension);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_dimension_3.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_dimension_3 */

int FE_element_has_CM_element_type(struct FE_element *element,
	void *cm_element_type_void)
/*******************************************************************************
LAST MODIFIED : 28 November 2000

DESCRIPTION :
Returns true if <element> has the given CM_element_type: CM_ELEMENT, CM_FACE or
CM_LINE. Note the enum CM_element_type is directly cast to (void *).
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_has_CM_element_type);
	if (element)
	{
		return_code =
			((enum CM_element_type)cm_element_type_void == element->cm.type);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_has_CM_element_type.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_has_CM_element_type */

int FE_element_is_top_level(struct FE_element *element,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 1 December 1999

DESCRIPTION :
Returns true if <element> is a top-level element - CM_ELEMENT/no parents.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_is_top_level);
	USE_PARAMETER(dummy_void);
	if (element)
	{
		return_code=(CM_ELEMENT==element->cm.type);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_top_level.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_top_level */

int FE_element_is_not_top_level(struct FE_element *element,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 20 July 2000

DESCRIPTION :
Returns true if <element> is not a top-level element = CM_ELEMENT/no parents.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_is_not_top_level);
	USE_PARAMETER(dummy_void);
	if (element)
	{
		return_code=(CM_ELEMENT != element->cm.type);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_is_not_top_level.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_is_not_top_level */

static int FE_element_field_has_field_with_name(
	struct FE_element_field *element_field, void *field_name_void)
/*******************************************************************************
LAST MODIFIED : 18 November 2002

DESCRIPTION :
Returns true if the name of the field in <element_field> matches <field_name>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_field_has_field_with_name);
	return_code = 0;
	if (element_field && element_field->field && field_name_void)
	{
		if (0 == strcmp(element_field->field->name, (char *)field_name_void))
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_has_field_with_name.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_has_field_with_name */

struct FE_element_field_can_be_merged_data
/*******************************************************************************
LAST MODIFIED : 24 March 2003

DESCRIPTION :
Data for passing to FE_element_field_can_be_merged.
==============================================================================*/
{
	struct FE_element_node_scale_field_info *info, *other_info;
	struct LIST(FE_element_field) *other_element_field_list;
	/* optional global_node_list1 to be passed when the nodes in <info> are
		 non-global and need to be substituted with the global node of the same
		 identifier */
	struct LIST(FE_node) *global_node_list1;
};

static int FE_element_field_can_be_merged(
	struct FE_element_field *element_field, void *data_void)
/*******************************************************************************
LAST MODIFIED : 24 March 2003

DESCRIPTION :
Fetches an element_field with field of the same name as that in <element_field>
from <element_field_list>. Returns true if there is either no such element_field
in the list or the two element_fields are identically defined apart from the
field itself. Checks first that the FE_fields match.
<data_void> points at a struct FE_element_field_can_be_merged_data.
==============================================================================*/
{
	int return_code;
	struct FE_element_field *other_element_field;
	struct FE_element_field_can_be_merged_data *data;

	ENTER(FE_element_field_can_be_merged);
	return_code = 0;
	if (element_field && element_field->field &&
		(data = (struct FE_element_field_can_be_merged_data *)data_void))
	{
		if (other_element_field = FIRST_OBJECT_IN_LIST_THAT(FE_element_field)(
			FE_element_field_has_field_with_name, (void *)element_field->field->name,
			data->other_element_field_list))
		{
			if (FE_fields_match_fundamental(element_field->field,
				other_element_field->field))
			{
				if (FE_element_fields_match(element_field, data->info,
					data->global_node_list1, other_element_field, data->other_info,
					/*ignore_field_and_time_sequence*/1, /*differences_are_errors*/1))
				{
					return_code = 1;
				}
			}
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_can_be_merged.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_can_be_merged */

int FE_element_can_be_merged(struct FE_element *element, void *data_void)
/*******************************************************************************
LAST MODIFIED : 7 May 2003

DESCRIPTION :
Fetches an element with the same identifier as <element> from the <data>
<element_list>. Returns true if either:
1. There is no namesake element and <element> has a valid shape.
2. There is a namesake element and <element> has an "unspecified" shape of the
same dimension as it, but no fields.
3. There is a namesake element with the same valid shape and all element fields
in common with the same-named field are defined identically apart from field
pointer and times.
Since the element in question may refer to non-global nodes from a separate
region, the <global_node_list> is provided to substitute the appropriate
global node when comparing element field components. Note the nodes are
expected to have already passed their own "can be merged" check.
Additionally, each nodally-based field in <element> is checked for appropriate
definition of that field in the nodes in <element>, or if the field is
undefined there, of the same-named field of the same-numbered node in the
<global_node_list>.
After using the function, deallocate data->compatible_element_field_info!
<data_void> points at a struct FE_element_can_be_merged_data.
???RC Check on definition of node field has not been written.
==============================================================================*/
{
	int i, dimension, return_code, unspecified_element_shape;
	struct FE_element *global_element;
	struct FE_element_field_info **element_field_info;
	struct FE_element_can_be_merged_data *data;
	struct FE_element_field_can_be_merged_data field_merge_data;

	ENTER(FE_element_can_be_merged);
	return_code = 0;
	if (element && element->fields &&
		(data = (struct FE_element_can_be_merged_data *)data_void) &&
		data->global_element_list)
	{
		global_element = FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element->identifier, data->global_element_list);
		unspecified_element_shape = FE_element_shape_is_unspecified(element->shape);
		dimension = get_FE_element_dimension(element);
		if (unspecified_element_shape)
		{
			/* unspecified shape used to indicate a dummy element, mainly to indicate
				 element:xi values in elements not read in from the same file. Element
				 must have no fields and a global namesake of the same dimension */
			if (global_element &&
				(get_FE_element_dimension(global_element) == dimension) &&
				(0 == NUMBER_IN_LIST(FE_element_field)(
					element->fields->element_field_list)))
			{
				return_code = 1;
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"%s %d is not found in global element list",
					CM_element_type_string(element->cm.type), element->cm.number);
			}
		}
		else
		{
			if (global_element)
			{
				if (FE_element_shape_and_faces_match(element, data->global_element_list,
					global_element))
				{
					/* check consistency of definitions of fields of the same name in
						 element and global_element */
					/* fast path: check if the element_field_info have already been proved
						 compatible */
					element_field_info = data->compatible_element_field_info;
					for (i = 0; (i < data->number_of_compatible_element_field_info) &&
						(!return_code); i++)
					{
						if ((*element_field_info == element->fields) &&
							(*(element_field_info + 1) == global_element->fields))
						{
							return_code = 1;
						}
						element_field_info += 2;
					}
					if (!return_code)
					{
						field_merge_data.info = element->information;
						field_merge_data.other_info = global_element->information;
						field_merge_data.other_element_field_list =
							global_element->fields->element_field_list;
						field_merge_data.global_node_list1 = data->global_node_list;
						/* slow path: loop through element fields */
						if (FOR_EACH_OBJECT_IN_LIST(FE_element_field)(
							FE_element_field_can_be_merged, (void *)&field_merge_data,
							element->fields->element_field_list))
						{
							/* store combination of element field info in compatible list */
							if (REALLOCATE(element_field_info,
								data->compatible_element_field_info,
								struct FE_element_field_info *,
								2*(data->number_of_compatible_element_field_info + 1)))
							{
								element_field_info[
									data->number_of_compatible_element_field_info*2] =
									element->fields;
								element_field_info[
									data->number_of_compatible_element_field_info*2 + 1] =
									global_element->fields;
								data->compatible_element_field_info = element_field_info;
								data->number_of_compatible_element_field_info++;
								return_code = 1;
							}
							else
							{
								display_message(ERROR_MESSAGE, "FE_element_can_be_merged.  "
									"Could not reallocate compatible_element_field_info");
							}
						}
					}
					if (return_code)
					{
						/* check fields are appropriately defined on either nodes in
							 fe_region or nodes in global_fe_region */
						/*???RC Yet to be written! */
					}
				}
			}
			else
			{
				return_code = 1;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_can_be_merged.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_can_be_merged */

int ensure_FE_element_is_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 25 February 2000

DESCRIPTION :
Iterator function for adding <element> to <element_list> if not currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(ensure_FE_element_is_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if (!FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element->identifier,element_list))
		{
			return_code=ADD_OBJECT_TO_LIST(FE_element)(element,element_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_is_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_is_in_list */

int ensure_FE_element_is_in_list_conditional(struct FE_element *element,
	void *list_conditional_data_void)
/*******************************************************************************
LAST MODIFIED : 4 July 2000

DESCRIPTION :
Iterator function for adding <element> to a list - if not already in it - if a
conditional function with user_data is true.
The element_list, conditional function and user_data are passed in a
struct FE_element_list_conditional_data * in the second argument.
Warning: Must not be iterating over the list being added to!
==============================================================================*/
{
	int return_code;
	struct FE_element_list_conditional_data *list_conditional_data;

	ENTER(ensure_FE_element_is_in_list_conditional);
	if (element&&(list_conditional_data=
		(struct FE_element_list_conditional_data *)list_conditional_data_void)&&
		list_conditional_data->element_list&&list_conditional_data->function)
	{
		if ((list_conditional_data->function)(element,
			list_conditional_data->user_data))
		{
			if (!IS_OBJECT_IN_LIST(FE_element)(element,
				list_conditional_data->element_list))
			{
				return_code=ADD_OBJECT_TO_LIST(FE_element)(element,
					list_conditional_data->element_list);
			}
			else
			{
				return_code=1;
			}
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_is_in_list_conditional.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_is_in_list_conditional */

int ensure_FE_element_is_not_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 25 February 2000

DESCRIPTION :
Iterator function for removing <element> from <element_list> if currently in it.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(ensure_FE_element_is_not_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element->identifier,element_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_element)(element,element_list);
		}
		else
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_FE_element_is_not_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_FE_element_is_not_in_list */

int toggle_FE_element_in_list(struct FE_element *element,
	void *element_list_void)
/*******************************************************************************
LAST MODIFIED : 25 February 2000

DESCRIPTION :
If <element> is in <element_list> it is taken out, otherwise it is added.
==============================================================================*/
{
	int return_code;
	struct LIST(FE_element) *element_list;

	ENTER(toggle_FE_element_in_list);
	if (element&&(element_list=(struct LIST(FE_element) *)element_list_void))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element,identifier)(
			element->identifier,element_list))
		{
			return_code=REMOVE_OBJECT_FROM_LIST(FE_element)(element,element_list);
		}
		else
		{
			return_code=ADD_OBJECT_TO_LIST(FE_element)(element,element_list);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"toggle_FE_element_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* toggle_FE_element_in_list */

int add_FE_element_of_CM_element_type_to_list(struct FE_element *element,
	void *element_list_type_data_void)
/*******************************************************************************
LAST MODIFIED : 1 March 2001

DESCRIPTION :
Iterator function which, if <element> is of the given CM_element_type, adds it
to the element_list if not currently in it.
==============================================================================*/
{
	int return_code;
	struct FE_element_list_CM_element_type_data *element_list_type_data;

	ENTER(add_FE_element_of_CM_element_type_to_list);
	if (element && (element_list_type_data =
		(struct FE_element_list_CM_element_type_data *)element_list_type_data_void))
	{
		if ((element->cm.type == element_list_type_data->cm_element_type) &&
			(!IS_OBJECT_IN_LIST(FE_element)(element,
				element_list_type_data->element_list)))
		{
			return_code = ADD_OBJECT_TO_LIST(FE_element)(element,
				element_list_type_data->element_list);
		}
		else
		{
			return_code = 1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_element_of_CM_element_type_to_list.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_element_of_CM_element_type_to_list */

int ensure_top_level_FE_element_nodes_are_in_list(struct FE_element *element,
	void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
ensures all its nodes are added to the <node_list> if not currently in it.
==============================================================================*/
{
	int i,return_code;
	struct FE_node **node;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_top_level_FE_element_nodes_are_in_list);
	if (element&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code=1;
		/* only nodes in parentless elements need be added */
		/*???SAB Mark Sagar uses CM_FACE instead of CM_ELEMENT for his toplevel
		  elements in some meshes, hence we don't check for CM_ELEMENT here */
		if (element->information)
		{
			/* note that element may have no node-based fields */
			if (node=element->information->nodes)
			{
				for (i=element->information->number_of_nodes;(0<i)&&return_code;i--)
				{
					if ((*node)&&(!IS_OBJECT_IN_LIST(FE_node)(*node,node_list)))
					{
						if (!ADD_OBJECT_TO_LIST(FE_node)(*node,node_list))
						{
							display_message(ERROR_MESSAGE,
								"ensure_top_level_FE_element_nodes_are_in_list.  "
								"Could not add node to list");
							return_code=0;
						}
					}
					node++;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_top_level_FE_element_nodes_are_in_list.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_top_level_FE_element_nodes_are_in_list */

int ensure_top_level_FE_element_nodes_are_not_in_list(
	struct FE_element *element,void *node_list_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
Iterator function which, if <element> is top-level (ie. cm.type is CM_ELEMENT),
ensures none of its nodes are in <node_list>.
==============================================================================*/
{
	int i,return_code;
	struct FE_node **node;
	struct LIST(FE_node) *node_list;

	ENTER(ensure_top_level_FE_element_nodes_are_not_in_list);
	if (element&&(node_list=(struct LIST(FE_node) *)node_list_void))
	{
		return_code=1;
		/* only nodes in parentless elements need be added */
		if (CM_ELEMENT==element->cm.type)
		{
			if (element->information)
			{
				/* note that element may have no node-based fields */
				if (node=element->information->nodes)
				{
					for (i=element->information->number_of_nodes;(0<i)&&return_code;i--)
					{
						if ((*node)&&IS_OBJECT_IN_LIST(FE_node)(*node,node_list))
						{
							if (!REMOVE_OBJECT_FROM_LIST(FE_node)(*node,node_list))
							{
								display_message(ERROR_MESSAGE,
									"ensure_top_level_FE_element_nodes_are_not_in_list.  "
									"Could not remove node from list");
								return_code=0;
							}
						}
						node++;
					}
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"ensure_top_level_FE_element_nodes_are_not_in_list.  "
					"Missing node scale field information");
				return_code=0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"ensure_top_level_FE_element_nodes_are_not_in_list.  "
			"Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* ensure_top_level_FE_element_nodes_are_not_in_list */

struct FE_element_parent_has_field_data
/*******************************************************************************
LAST MODIFIED : 12 November 2002

DESCRIPTION :
Used by FE_element_parent_has_field.
==============================================================================*/
{
	struct FE_field *field;
	struct LIST(FE_element) *element_list;
}; /* struct FE_element_parent_has_field_data */

static int FE_element_parent_has_field(struct FE_element_parent *element_parent,
	void *element_has_field_data_void)
/*******************************************************************************
LAST MODIFIED : 12 November 2002

DESCRIPTION :
Calls FE_element_or_parent_has_field for <element_parent>->parent.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_has_field_data *element_has_field_data;

	ENTER(FE_element_parent_has_field);
	if (element_parent&&(element_has_field_data=
		(struct FE_element_parent_has_field_data *)element_has_field_data_void))
	{
		return_code = FE_element_or_parent_has_field(element_parent->parent,
			element_has_field_data->field, element_has_field_data->element_list);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_field.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_has_field */

int FE_element_or_parent_has_field(struct FE_element *element,
	struct FE_field *field, struct LIST(FE_element) *element_list)
/*******************************************************************************
LAST MODIFIED : 12 November 2002

DESCRIPTION :
Returns true if the <element> or any of its parents has the <field> defined
over it. By supplying an <element_list> this limits the test to elements that
are also in the list.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_has_field_data element_has_field_data;

	ENTER(FE_element_or_parent_has_field);
	return_code = 0;
	if (element && field && element->fields)
	{
		if ((!element_list) || IS_OBJECT_IN_LIST(FE_element)(element, element_list))
		{
			/* first try to find the field directly in the element's field list */
			if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(field,
				element->fields->element_field_list))
			{
				return_code = 1;
			}
			else
			{
				/* try the element's parents */
				element_has_field_data.field = field;
				element_has_field_data.element_list = element_list;
				if (FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_has_field, (void *)&element_has_field_data,
					element->parent_list))
				{
					return_code = 1;
				}
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_or_parent_has_field.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_or_parent_has_field */

#if defined (OLD_CODE)
int FE_node_get_field_components(struct FE_node *node,
	struct FE_field *field,int component_no,FE_value **components)
/*******************************************************************************
LAST MODIFIED : 25 August 1998

DESCRIPTION :
Returns the value - not derivatives - held for the given <component_no> of
<field>, or all components if <component_no> is negative. The return value of
the function is the number of components returned, while <*components> will be
set to point to an array containing the values, which the calling function must
deallocate.
???RC Does not handle multiple versions.
==============================================================================*/
{
	FE_value *node_values,*this_component;
	int first_component_no,i,number_of_components;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct FE_node_field_info *node_field_information;

	ENTER(FE_node_get_field_components);
	if (node&&(node_field_information=node->fields)&&(node_values=node->value)&&
		field&&(component_no<field->number_of_components)&&components)
	{
		if ((node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				field,node_field_information->node_field_list)))
		{
			if (component_no<0)
			{
				number_of_components=field->number_of_components;
				first_component_no=0;
			}
			else
			{
				number_of_components=1;
				first_component_no=component_no;
			}
			if (ALLOCATE(*components,FE_value,number_of_components))
			{
				this_component = *components;
				node_field_component = node_field->components + first_component_no;
				for (i=0;i<number_of_components;i++)
				{
					if (node_field_component)
					{
						*this_component = node_values[node_field_component->value];
						this_component++;
						node_field_component++;
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"FE_node_get_field_components.  Missing node field component");
						DEALLOCATE(*components);
						number_of_components=0;
					}
				}
			}
			else
			{
				number_of_components=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"FE_node_get_field_components.  "
				"Field '%s' not defined for node %d",field->name,node->cm_node_identifier);
			number_of_components=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_get_field_components.  Invalid argument(s)");
		number_of_components=0;
	}
	LEAVE;

	return (number_of_components);
} /* FE_node_get_field_components */
#endif /* defined (OLD_CODE) */

struct FE_field *FE_node_get_position_cartesian(struct FE_node *node,
	struct FE_field *coordinate_field,FE_value *node_x,FE_value *node_y,
	FE_value *node_z,FE_value *coordinate_jacobian)
/*******************************************************************************
LAST MODIFIED : 12 April 1999

DESCRIPTION :
Evaluates the supplied coordinate_field (or the first one in the node if NULL).
Sets non-present components to zero (eg if only had x and y, z would be set to
zero).  Converts to rectangular Cartesian coordinates: x,y,z.  If
<coordinate_jacobian>, then its is filled with the Jacobian for the
transformation from native coordinates to rectangular Cartesian.  Returns the
field it actually calculated.
???RC Does not handle multiple versions.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;
	FE_value node_1,node_2,node_3;	
	int number_of_coordinate_components;
	struct FE_field *return_field;	
	struct FE_node_field *coordinate_node_field;
	struct FE_node_field_info *node_field_information;

	ENTER(FE_node_get_position_cartesian);
	if (node&&node_x&&node_y&&node_z&&(node_field_information=node->fields))
	{
		if (coordinate_field)
		{
			coordinate_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				coordinate_field,node_field_information->node_field_list);
		}
		else
		{
			coordinate_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
				FE_node_field_is_coordinate_field,(void *)NULL,
				node_field_information->node_field_list);
		}
		if (coordinate_node_field)
		{
			if ( (coordinate_field=coordinate_node_field->field)&& 
				(coordinate_node_field->field->value_type==FE_VALUE_VALUE))
			{
				return_field=coordinate_node_field->field;
				number_of_coordinate_components=
					coordinate_node_field->field->number_of_components;

				coordinate_system=get_FE_field_coordinate_system(coordinate_node_field->field); 
				get_FE_nodal_FE_value_value(node,coordinate_field,/*component_number*/0,
					/*version*/0,FE_NODAL_VALUE,/*time*/0,&node_1);

				if (1<number_of_coordinate_components)
				{					
					get_FE_nodal_FE_value_value(node,coordinate_field,/*component_number*/1,
						/*version*/0,FE_NODAL_VALUE,/*time*/0,&node_2);

					if (2<number_of_coordinate_components)
					{						
						get_FE_nodal_FE_value_value(node,coordinate_field,/*component_number*/2,
							/*version*/0,FE_NODAL_VALUE,/*time*/0,&node_3);
					}
					else
					{
						node_3=0.;
					}
				}
				else
				{
					node_2=0.;
					node_3=0.;
				}
				/* transform points to cartesian coordinates */
				switch (coordinate_system->type)
				{
					case CYLINDRICAL_POLAR:
					{
						cylindrical_polar_to_cartesian(node_1,node_2,
							node_3,node_x,node_y,node_z,coordinate_jacobian);
					} break;
					case SPHERICAL_POLAR:
					{
						spherical_polar_to_cartesian(node_1,node_2,
							node_3,node_x,node_y,node_z,coordinate_jacobian);
					} break;
					case PROLATE_SPHEROIDAL:
					{

						prolate_spheroidal_to_cartesian(node_1,node_2,
							node_3,coordinate_system->parameters.focus,
							node_x,node_y,node_z,coordinate_jacobian);
					} break;
					case OBLATE_SPHEROIDAL:
					{

						oblate_spheroidal_to_cartesian(node_1,node_2,
							node_3,coordinate_system->parameters.focus,
							node_x,node_y,node_z,coordinate_jacobian);
					} break;
					default:
					{
						*node_x=node_1;
						*node_y=node_2;
						*node_z=node_3;
						if (coordinate_jacobian)
						{
							coordinate_jacobian[0]=1;
							coordinate_jacobian[1]=0;
							coordinate_jacobian[2]=0;
							coordinate_jacobian[3]=0;
							coordinate_jacobian[4]=1;
							coordinate_jacobian[5]=0;
							coordinate_jacobian[6]=0;
							coordinate_jacobian[7]=0;
							coordinate_jacobian[8]=1;
						}
					} break;
				} /* switch */
			} /* if (coordinate_field->value_type==FE_VALUE_VALUE) */
			else
			{
				display_message(ERROR_MESSAGE,"FE_node_get_position_cartesian.  "
					"Currently only does field->value_type=FE_VALUE_VALUE. Write the code!");
				return_field=(struct FE_field *)NULL;
			}
		} /* if (coordinate_node_field) */
		else
		{
			display_message(ERROR_MESSAGE,"FE_node_get_position_cartesian.  "
				"Could not find coordinate_node_field");
			return_field=(struct FE_field *)NULL;
		}
	}/* if (node& */
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_get_position_cartesian.  Invalid argument(s)");
		return_field=(struct FE_field *)NULL;
	}
	LEAVE;

	return (return_field);
} /* FE_node_get_position_cartesian */

int FE_node_set_position_cartesian(struct FE_node *node,
	struct FE_field *coordinate_field,
	FE_value node_x,FE_value node_y,FE_value node_z)
/*******************************************************************************
LAST MODIFIED : 12 April 1999

DESCRIPTION :
Sets the position of <node> in Cartesian coordinates: x[,y[,z]] using the
supplied coordinate_field (or the first one in the node if NULL). The given
Cartesian coordinates are converted into the coordinate system of the node
for the coordinate_field used.
==============================================================================*/
{
	struct Coordinate_system *coordinate_system;
	FE_value node_1,node_2,node_3;
	int number_of_coordinate_components,return_code,version;
	struct FE_node_field *coordinate_node_field;
	struct FE_node_field_component *coordinate_node_field_component;
	struct FE_node_field_info *node_field_information;	

	ENTER(FE_node_set_position_cartesian);
	if (node&&(node_field_information=node->fields))
	{
		if (coordinate_field)
		{
			coordinate_node_field=FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
				coordinate_field,node_field_information->node_field_list);
		}
		else
		{
			coordinate_node_field=FIRST_OBJECT_IN_LIST_THAT(FE_node_field)(
				FE_node_field_is_coordinate_field,(void *)NULL,
				node_field_information->node_field_list);
		}
		if (coordinate_node_field)
		{
			if ((coordinate_field=coordinate_node_field->field)&& 
				(coordinate_node_field->field->value_type==FE_VALUE_VALUE))
			{
				return_code=1;
				number_of_coordinate_components=
					coordinate_node_field->field->number_of_components;

				coordinate_system = get_FE_field_coordinate_system(
					coordinate_node_field->field);

				switch (coordinate_system->type)
				{
					case CYLINDRICAL_POLAR:
					{
						cartesian_to_cylindrical_polar(node_x,node_y,node_z,
							&node_1,&node_2,&node_3,(float *)NULL);
					} break;
					case PROLATE_SPHEROIDAL:
					{
						cartesian_to_prolate_spheroidal(node_x,node_y,node_z,
							coordinate_system->parameters.focus,
							&node_1,&node_2,&node_3,(float *)NULL);
					} break;
					case OBLATE_SPHEROIDAL:
					{

						/*???DB.  Haven't written geometry function yet */
						node_1=(float)node_x;
						node_2=(float)node_y;
						node_3=(float)node_z;
					} break;
					case SPHERICAL_POLAR:
					{

						/*???DB.  Haven't written geometry function yet */
						node_1=(float)node_x;
						node_2=(float)node_y;
						node_3=(float)node_z;
					} break;
					default:
					{

						node_1=(float)node_x;
						node_2=(float)node_y;
						node_3=(float)node_z;
					} break;
				}
				coordinate_node_field_component=coordinate_node_field->components;
				for (version=0;
						 version<coordinate_node_field_component->number_of_versions;version++)
				{
					set_FE_nodal_FE_value_value(node,coordinate_node_field->field,
						/*component_number*/0,version,FE_NODAL_VALUE,
						/*time*/0, node_1);
				}
				if (1<number_of_coordinate_components)
				{
					coordinate_node_field_component++;
					for (version=0;
							 version<coordinate_node_field_component->number_of_versions;version++)
					{
						set_FE_nodal_FE_value_value(node,coordinate_node_field->field,
						/*component_number*/1,version,
							FE_NODAL_VALUE, /*time*/0, node_2);
					}
					if (2<number_of_coordinate_components)
					{
						coordinate_node_field_component++;
						for (version=0;version<
									 coordinate_node_field_component->number_of_versions;version++)
						{
							set_FE_nodal_FE_value_value(node,coordinate_node_field->field,
								/*component_number*/2,version,
								FE_NODAL_VALUE, /*time*/0, node_3);
						}
					}
				}
			} /* if (coordinate_field->value_type==FE_VALUE_VALUE) */
			else
			{
				display_message(ERROR_MESSAGE,"FE_node_set_position_cartesian.  "
					"Currently only does field->value_type=FE_VALUE_VALUE. Write the code!");
				return_code=0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,"FE_node_set_position_cartesian.  "
				"Could not find coordinate_node_field");
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_set_position_cartesian.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_set_position_cartesian */

int FE_field_is_1_component_integer(struct FE_field *field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 18 May 2000

DESCRIPTION :
Conditional function returning true if <field> has exactly 1 component and a
value type of integer.
This type of field is used for storing eg. grid_point_number.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_1_component_integer);
	USE_PARAMETER(dummy_void);
	if (field)
	{
		return_code=(INT_VALUE==field->value_type)&&
			(1==field->number_of_components);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_1_component_integer.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_1_component_integer */

int FE_field_is_coordinate_field(struct FE_field *field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 30 August 2001

DESCRIPTION :
Conditional function returning true if the <field> is a coordinate field
(defined by having a CM_field_type of coordinate) has a Value_type of
FE_VALUE_VALUE and has from 1 to 3 components.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_coordinate_field);
	USE_PARAMETER(dummy_void);
	if (field)
	{
		return_code=
			(CM_COORDINATE_FIELD==field->cm_field_type)&&
			(FE_VALUE_VALUE==field->value_type)&&
			(1<=field->number_of_components)&&
			(3>=field->number_of_components);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_coordinate_field.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_coordinate_field */

int FE_field_is_anatomical_fibre_field(struct FE_field *field,void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 2 September 2001

DESCRIPTION :
Conditional function returning true if the <field> is a anatomical field
(defined by having a CM_field_type of anatomical), has a Value_type of
FE_VALUE_VALUE, has from 1 to 3 components, and has a FIBRE coordinate system.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_anatomical_fibre_field);
	USE_PARAMETER(dummy_void);
	if (field)
	{
		return_code=(CM_ANATOMICAL_FIELD==field->cm_field_type)&&
			(FE_VALUE_VALUE==field->value_type)&&
			(1<=field->number_of_components)&&
			(3>=field->number_of_components)&&
			(FIBRE==field->coordinate_system.type);		
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_anatomical_fibre_field.  Invalid argument");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_anatomical_fibre_field */

int FE_field_is_embedded(struct FE_field *field, void *dummy_void)
/*******************************************************************************
LAST MODIFIED : 5 June 2003

DESCRIPTION :
Returns true if the values returned by <field> are a location in an FE_region,
either an element_xi value, or eventually a node.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_embedded);
	USE_PARAMETER(dummy_void);
	if (field)
	{
		return_code = (ELEMENT_XI_VALUE == field->value_type);		
	}
	else
	{
		display_message(ERROR_MESSAGE, "FE_field_is_embedded.  Invalid argument");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_embedded */

int FE_field_is_defined_at_node(struct FE_field *field, struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 21 September 1999

DESCRIPTION :
Returns true if the <field> is defined for the <node>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_defined_at_node);
	return_code=0;
	if (field&&node&&(node->fields))
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(field,
			node->fields->node_field_list))
		{
			return_code=1;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_defined_at_node.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_defined_at_node */

int FE_node_field_is_not_defined(struct FE_node *node,void *field_void)
/*******************************************************************************
LAST MODIFIED : 15 September 2000

DESCRIPTION :
FE_node iterator version of FE_field_is_defined_at_node.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(FE_node_field_is_not_defined);
	if (node&&(field=(struct FE_field *)field_void))
	{
		return_code = !FE_field_is_defined_at_node(field,node);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_is_not_defined.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_is_not_defined */

static int FE_element_parent_has_field_defined(struct FE_element_parent *parent,
	void *field_void)
/*******************************************************************************
LAST MODIFIED : 3 September 1999

DESCRIPTION :
Calls FE_field_is_defined_in_element for the parent element.
==============================================================================*/
{
	int return_code;
	struct FE_field *field;

	ENTER(FE_element_parent_has_field_defined);
	if (parent&&(field=(struct FE_field *)field_void))
	{
		return_code=FE_field_is_defined_in_element(field,parent->parent);
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_parent_has_field_defined.  Unknown FE_field_type");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_has_field_defined */

int FE_field_is_defined_in_element(struct FE_field *field,
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Returns true if the <field> is defined for the <element>.
==============================================================================*/
{
	int return_code;

	ENTER(FE_field_is_defined_in_element);
	return_code = 0;
	if (element && element->fields && field)
	{
		if (FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(field,
			element->fields->element_field_list))
		{
			return_code = 1;
		}
		else
		{
			return_code = ((struct FE_element_parent *)NULL !=
				FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_has_field_defined, (void *)field,
					element->parent_list));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_field_is_defined_in_element.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_field_is_defined_in_element */

int FE_element_field_is_grid_based(struct FE_element *element,
	struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Returns true if <field> is grid-based in <element>. Only checks the first
component since we assume all subsequent components have the same basis and
numbers of grid cells in xi.
Returns 0 with no error if <field> is not defined over element or not element-
based in it.
==============================================================================*/
{
	int return_code;
	struct FE_element_field *element_field;

	ENTER(FE_element_field_is_grid_based);
	return_code=0;
	if (element && field && element->fields)
	{
		/* must have element->information for grid-based values_storage */
		if (element->information)
		{
			if ((element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				field, element->fields->element_field_list)))
			{
				return_code =
					FE_element_field_has_element_grid_map(element_field, (void *)NULL);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_is_grid_based.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_is_grid_based */

int get_FE_element_field_grid_map_number_in_xi(struct FE_element *element,
	struct FE_field *field,int *number_in_xi)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
If <field> is grid-based in <element>, returns in <number_in_xi> the numbers of
finite difference cells in each xi-direction of <element>. Note that this number
is one less than the number of grid points in each direction. <number_in_xi>
should be allocated with at least as much space as the number of dimensions in
<element>, but is assumed to have no more than MAXIMUM_ELEMENT_XI_DIMENSIONS so
that int number_in_xi[MAXIMUM_ELEMENT_XI_DIMENSIONS] can be passed to this
function.
==============================================================================*/
{
	int *component_number_in_xi, dimension, i, return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;

	ENTER(get_FE_element_field_grid_map_number_in_xi);
	return_code = 0;
	if (element && element->fields && number_in_xi && element->shape &&
		(dimension = element->shape->dimension) &&
		(MAXIMUM_ELEMENT_XI_DIMENSIONS >= element->shape->dimension))
	{
		if ((element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field, element->fields->element_field_list)))
		{
			/* only GENERAL_FE_FIELD has components and can be grid-based */
			if (GENERAL_FE_FIELD == element_field->field->fe_field_type)
			{
				/* get first field component */
				if (element_field->components &&
					(component = *(element_field->components)))
				{
					if (ELEMENT_GRID_MAP==component->type)
					{
						if (component_number_in_xi=
							component->map.element_grid_based.number_in_xi)
						{
							return_code=1;
							for (i=0;i<dimension;i++)
							{
								number_in_xi[i]=component_number_in_xi[i];
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"get_FE_element_field_grid_map_number_in_xi.  "
								"Missing component number_in_xi");
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"get_FE_element_field_grid_map_number_in_xi.  "
							"Field is not grid-based");
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_field_grid_map_number_in_xi.  "
						"Missing element field component");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"get_FE_element_field_grid_map_number_in_xi.  "
					"Field is not general, not grid-based");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_field_grid_map_number_in_xi.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_field_grid_map_number_in_xi.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_field_grid_map_number_in_xi */

int get_FE_element_field_number_of_grid_values(struct FE_element *element,
	struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
If <field> is grid-based in <element>, returns the total number of grid points
at which data is stored for <field>, equal to product of <number_in_xi>+1 in
all directions. Returns 0 without error for non grid-based fields.
==============================================================================*/
{
	int *component_number_in_xi,dimension,i,number_of_grid_values;
	struct FE_element_field *element_field;
	struct FE_element_field_component *component;

	ENTER(get_FE_element_field_number_of_grid_values);
	number_of_grid_values=0;
	if (element && element->fields &&
		element->shape && (dimension = element->shape->dimension))
	{
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field, element->fields->element_field_list)))
		{
			/* only GENERAL_FE_FIELD has components and can be grid-based */
			if (GENERAL_FE_FIELD==element_field->field->fe_field_type)
			{
				/* get first field component */
				if (element_field->components&&(component=*(element_field->components)))
				{
					if (ELEMENT_GRID_MAP==component->type)
					{
						if (component_number_in_xi=
							component->map.element_grid_based.number_in_xi)
						{
							number_of_grid_values=1;
							for (i=0;i<dimension;i++)
							{
								number_of_grid_values *= (component_number_in_xi[i] + 1);
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"get_FE_element_field_number_of_grid_values.  "
								"Missing component number_in_xi");
						}
					}
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"get_FE_element_field_number_of_grid_values.  "
						"Missing element field component");
				}
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"get_FE_element_field_number_of_grid_values.  "
				"Field not defined for element");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_field_number_of_grid_values.  Invalid argument(s)");
	}
	LEAVE;

	return (number_of_grid_values);
} /* get_FE_element_field_number_of_grid_values */

int get_FE_element_field_component(struct FE_element *element,
	struct FE_field *field, int component_number,
	struct FE_element_field_component **component_address)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Returns the element field component structure for <component_number> of <field>
at <element> if defined there; otherwise reports an error.
If fails, puts NULL in *<component_address> if supplied.
Note: returned component must not be modified or destroyed!
==============================================================================*/
{
	int return_code;
	struct FE_element_field *element_field;

	ENTER(get_FE_element_field_component);
	return_code = 0;
	if (element && element->fields && field && (0 <= component_number) &&
		(component_number < get_FE_field_number_of_components(field)) &&
		component_address)
	{
		if (element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field, element->fields->element_field_list))
		{
			if (element_field->components)
			{
				if (*component_address = element_field->components[component_number])
				{
					return_code = 1;
				}
				else
				{
					display_message(ERROR_MESSAGE, "get_FE_element_field_component.  "
						"Missing element field component");
				}
			}
			else
			{
				display_message(ERROR_MESSAGE, "get_FE_element_field_component.  "
					"Missing element field components array");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE, "get_FE_element_field_component.  "
				"Field %s not defined for element", get_FE_field_name(field));
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_field_component.  Invalid argument(s)");
	}
	if ((!return_code) && component_address)
	{
		*component_address = (struct FE_element_field_component *)NULL;
	}
	LEAVE;

	return (return_code);
} /* get_FE_element_field_component */

#define INSTANTIATE_GET_FE_ELEMENT_FIELD_COMPONENT_FUNCTION( macro_value_type, value_enum ) \
int get_FE_element_field_component_grid_ ## macro_value_type ## _values( \
	struct FE_element *element,struct FE_field *field,int component_number, \
	macro_value_type **values) \
/******************************************************************************* \
LAST MODIFIED : 22 April 2005 \
 \
DESCRIPTION : \
If <field> is grid-based in <element>, returns an allocated array of the grid \
values stored for <component_number>. To get number of values returned, call \
get_FE_element_field_number_of_grid_values; Grids change in xi0 fastest. \
It is up to the calling function to DEALLOCATE the returned values. \
==============================================================================*/ \
{ \
	macro_value_type *value; \
	int *component_number_in_xi,dimension,i,number_of_grid_values,return_code, \
		size; \
	struct FE_element_field *element_field; \
	struct FE_element_field_component *component; \
	Value_storage *values_storage; \
 \
	ENTER(get_FE_element_field_component_grid_ ## macro_value_type ## _values); \
	return_code=0; \
	if (element && element->fields && element->information &&  \
		element->shape&&(dimension=element->shape->dimension)&&field&& \
		(0<=component_number)&&(component_number<field->number_of_components)&& \
		(value_enum==field->value_type)&&values) \
	{ \
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)( \
			field,element->fields->element_field_list))) \
		{ \
			/* get the component */ \
			if (element_field->components&& \
				(component=element_field->components[component_number])) \
			{ \
				if ((ELEMENT_GRID_MAP==component->type)&& \
					(values_storage=element->information->values_storage)) \
				{ \
					if (component_number_in_xi= \
						component->map.element_grid_based.number_in_xi) \
					{ \
						values_storage += component->map.element_grid_based.value_index; \
						size = get_Value_storage_size(value_enum, \
							(struct FE_time_sequence *)NULL); \
						number_of_grid_values=1; \
						for (i=0;i<dimension;i++) \
						{ \
							number_of_grid_values *= (component_number_in_xi[i] + 1); \
						} \
						if (ALLOCATE(*values,macro_value_type,number_of_grid_values)) \
						{ \
							return_code=1; \
							value= *values; \
							for (i=number_of_grid_values;0<i;i--) \
							{ \
								*value = *((macro_value_type *)values_storage); \
								value++; \
								values_storage += size; \
							} \
						} \
						else \
						{ \
							display_message(ERROR_MESSAGE, \
								"get_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
								"Not enough memory"); \
						} \
					} \
					else \
					{ \
						display_message(ERROR_MESSAGE, \
							"get_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
							"Missing component number_in_xi"); \
					} \
				} \
				else \
				{ \
					display_message(ERROR_MESSAGE, \
						"get_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
						"Field is not grid-based in element"); \
				} \
			} \
			else \
			{ \
				display_message(ERROR_MESSAGE, \
					"get_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
					"Missing element field component"); \
			} \
		} \
		else \
		{ \
			display_message(ERROR_MESSAGE, \
				"get_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
				"Field not defined for element"); \
		} \
	} \
	else \
	{ \
		display_message(ERROR_MESSAGE, \
			"get_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
			"Invalid argument(s)"); \
	} \
	LEAVE; \
 \
	return (return_code); \
} /* get_FE_element_field_component_grid_ ## macro_value_type ## _values */

#define INSTANTIATE_SET_FE_ELEMENT_FIELD_COMPONENT_FUNCTION( macro_value_type, value_enum ) \
int set_FE_element_field_component_grid_ ## macro_value_type ## _values( \
	struct FE_element *element,struct FE_field *field,int component_number, \
	macro_value_type *values) \
/******************************************************************************* \
LAST MODIFIED : 21 April 2005 \
\
DESCRIPTION : \
If <field> is grid-based in <element>, copies <values> into the values storage \
for <component_number>. To get number of values to pass, call \
get_FE_element_field_number_of_grid_values; Grids change in xi0 fastest. \
==============================================================================*/ \
{ \
	macro_value_type *value; \
	int *component_number_in_xi,dimension,i,number_of_grid_values,return_code, \
		size; \
	struct FE_element_field *element_field; \
	struct FE_element_field_component *component; \
	Value_storage *values_storage; \
 \
	ENTER(set_FE_element_field_component_grid_ ## macro_value_type ## _values); \
	return_code=0; \
	if (element&&element->fields && element->information && \
		element->shape&&(dimension=element->shape->dimension)&&field&& \
		(0<=component_number)&&(component_number<field->number_of_components)&& \
		(value_enum==field->value_type)&&values) \
	{ \
		if ((element_field=FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)( \
			field,element->fields->element_field_list))) \
		{ \
			/* get the component */ \
			if (element_field->components&& \
				(component=element_field->components[component_number])) \
			{ \
				if ((ELEMENT_GRID_MAP==component->type)&& \
					(values_storage=element->information->values_storage)) \
				{ \
					if (component_number_in_xi= \
						component->map.element_grid_based.number_in_xi) \
					{ \
						return_code=1; \
						values_storage += component->map.element_grid_based.value_index; \
						size = get_Value_storage_size(value_enum, \
							(struct FE_time_sequence *)NULL); \
						number_of_grid_values=1; \
						for (i=0;i<dimension;i++) \
						{ \
							number_of_grid_values *= (component_number_in_xi[i] + 1); \
						} \
						value=values; \
						for (i=number_of_grid_values;0<i;i--) \
						{ \
							/*???RC following should be a macro */ \
							*((macro_value_type *)values_storage) = *value; \
							value++; \
							values_storage += size; \
						} \
						if (return_code) \
						{ \
							/* Check this node is being managed by the region it belongs to (All nodes \
								are created with respect to some region but they are not necessarily merged \
								into it yet. */ \
							if (element->fields && element->fields->fe_region && \
								FE_region_contains_FE_element(element->fields->fe_region, element)) \
							{	\
								/* If so, notify the change */ \
								FE_region_notify_FE_element_field_change(element->fields->fe_region, element, \
									field); \
							} \
						} \
					} \
					else \
					{ \
						display_message(ERROR_MESSAGE, \
							"set_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
							"Missing component number_in_xi"); \
					} \
				} \
				else \
				{ \
					display_message(ERROR_MESSAGE, \
						"set_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
						"Field is not grid-based in element"); \
				} \
			} \
			else \
			{ \
				display_message(ERROR_MESSAGE, \
					"set_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
					"Missing element field component"); \
			} \
		} \
		else \
		{ \
			display_message(ERROR_MESSAGE, \
				"set_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
				"Field not defined for element"); \
		} \
	} \
	else \
	{ \
		display_message(ERROR_MESSAGE, \
			"set_FE_element_field_component_grid_ ## macro_value_type ## _values.  " \
			"Invalid argument(s)"); \
	} \
	LEAVE; \
 \
	return (return_code); \
} /* set_FE_element_field_component_grid_ ## macro_value_type ## _values */

#define INSTANTIATE_FE_ELEMENT_FIELD_COMPONENT_FUNCTIONS( macro_value_type , value_enum ) \
INSTANTIATE_GET_FE_ELEMENT_FIELD_COMPONENT_FUNCTION(macro_value_type,value_enum) \
INSTANTIATE_SET_FE_ELEMENT_FIELD_COMPONENT_FUNCTION(macro_value_type,value_enum)

INSTANTIATE_FE_ELEMENT_FIELD_COMPONENT_FUNCTIONS( FE_value , FE_VALUE_VALUE )
INSTANTIATE_FE_ELEMENT_FIELD_COMPONENT_FUNCTIONS( int , INT_VALUE )

int FE_element_field_get_copy_components(struct FE_element *element,
	struct FE_field *fe_field,
	struct FE_element_field_component ***components_address)
/*******************************************************************************
LAST MODIFIED : 12 May 2003

DESCRIPTION :
Constructs copies of the FE_element_field_components of <fe_field> at <element>
and stores them at <components_address>.
Up to the calling function to clean up the returned components.
==============================================================================*/
{
	int i, number_of_components, return_code;
	struct FE_element_field *element_field;
	struct FE_element_field_component **components;

	ENTER(FE_element_field_get_copy_components);
	if (element && element->fields && fe_field && components_address &&
		(number_of_components = get_FE_field_number_of_components(fe_field)))
	{
		return_code = 1;
		if (element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			fe_field, element->fields->element_field_list))
		{
			if (ALLOCATE(components, struct FE_element_field_component *,
				number_of_components))
			{
				for (i = 0; i < number_of_components; i++)
				{
					components[i] = (struct FE_element_field_component *)NULL;
				}
				for (i = 0; (i < number_of_components) && return_code; i++)
				{
					if (!(components[i] = copy_create_FE_element_field_component(
						element_field->components[i])))
					{
						display_message(ERROR_MESSAGE,
							"FE_element_field_get_copy_components.  "
							"Could not copy_create component");
						return_code = 0;
					}
				}
				if (return_code)
				{
					*components_address = components;
				}
				else
				{
					for (i = 0; i < number_of_components; i++)
					{
						if (components[i])
						{
							DESTROY(FE_element_field_component)(&(components[i]));
						}
					}
					DEALLOCATE(components);
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_field_get_copy_components.  "
					"Out of memory for components");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_get_copy_components.  "
				"FE_field not defined at element");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_get_copy_components.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_get_copy_components */

int FE_element_field_get_component_FE_basis(struct FE_element *element,
	struct FE_field *field, int component_number, struct FE_basis **fe_basis)
/*******************************************************************************
LAST MODIFIED : 30 May 2003

DESCRIPTION :
If <field> is standard node based in <element>, returns the <fe_basis> used for
<component_number>.
==============================================================================*/
{
	int return_code;
	struct FE_element_field *element_field;

	ENTER(FE_element_field_get_component_FE_basis);
	return_code = 0;
	if (element && field && fe_basis && element->fields)
	{
		*fe_basis = (struct FE_basis *)NULL;
		if ((element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
			field, element->fields->element_field_list)))
		{
			return_code = FE_element_field_private_get_component_FE_basis(
				element_field, component_number, fe_basis);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_field_get_component_FE_basis.  "
				"Field not defined for element");
			return_code = 0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_field_get_component_FE_basis.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_field_get_component_FE_basis */

int FE_node_smooth_FE_field(struct FE_node *node, struct FE_field *fe_field,
	FE_value time, struct FE_field *element_count_fe_field)
/*******************************************************************************
LAST MODIFIED : 16 April 2003

DESCRIPTION :
Partner function to FE_element_smooth_FE_field.
Divides the nodal first derivatives of <fe_field> at <time> in <node> by the
corresponding integer from <element_count_fe_field>, then undefines
<element_count_fe_field>.
<node> is not a global object, as from FE_element_smooth_FE_field.
==============================================================================*/
{
	enum FE_nodal_value_type type;
	enum FE_nodal_value_type types[3] =
		{FE_NODAL_D_DS1, FE_NODAL_D_DS2, FE_NODAL_D_DS3};
	FE_value value;
	int count, i, j, number_of_components, return_code, version;

	ENTER(FE_node_smooth_FE_field);
	if (node && fe_field && element_count_fe_field &&
		(number_of_components = get_FE_field_number_of_components(fe_field)))
	{
		return_code = 1;
		version = 0;
		for (i = 0; (i < number_of_components) && return_code; i++)
		{
			for (j = 0; (j < 3) && return_code; j++)
			{
				type = types[j];
				if (FE_nodal_value_version_exists(node, fe_field, /*component_number*/i,
					version, type))
				{
					if (get_FE_nodal_FE_value_value(node, fe_field, /*component_number*/i,
						version, type, time, &value) &&
						get_FE_nodal_int_value(node, element_count_fe_field, /*component_number*/i,
						version, type, time, &count))
					{
						if (0 < count)
						{
							if (!set_FE_nodal_FE_value_value(node, fe_field, /*component_number*/i,
								version, type, time, value / (FE_value)count))
							{
								return_code = 0;
							}
						}
					}
					else
					{
						return_code = 0;
					}
				}
			}
		}
		if (return_code)
		{
			/* undefine the element_count_fe_field at <node> */
			return_code = undefine_FE_field_at_node(node, element_count_fe_field);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_smooth_FE_field.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_smooth_FE_field */

static int FE_node_field_component_accumulate_value(struct FE_node *node,
	struct FE_field *fe_field, struct FE_field *count_fe_field,
	int component_number, int version, enum FE_nodal_value_type type,
	FE_value time, FE_value delta)
/*******************************************************************************
LAST MODIFIED : 12 March 2003

DESCRIPTION :
Used by FE_element_smooth_FE_field.
Adds <delta> to the identified quantity in <fe_field> and increments the
integer counter for the corresponding quantity in <count_fe_field>.
==============================================================================*/
{
	FE_value value;
	int int_value, return_code;

	ENTER(FE_node_field_component_accumulate_value);
	if (node && fe_field && count_fe_field && (0 <= component_number) &&
		(component_number <= get_FE_field_number_of_components(fe_field)) &&
		(0 <= version))
	{
		return_code = 1;
		if (FE_nodal_value_version_exists(node, fe_field, component_number, version, type))
		{
			if (!(get_FE_nodal_FE_value_value(node, fe_field, component_number, version,
				type, time, &value) &&
				set_FE_nodal_FE_value_value(node, fe_field, component_number, version, type,
					time, value + delta) &&
				get_FE_nodal_int_value(node, count_fe_field, component_number, version, type,
					time, &int_value) &&
				set_FE_nodal_int_value(node, count_fe_field, component_number, version, type,
					time, int_value + 1)))
			{
				display_message(ERROR_MESSAGE,
					"FE_node_field_component_accumulate_value.  Failed");
				return_code = 0;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_node_field_component_accumulate_value.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_field_component_accumulate_value */

int FE_element_smooth_FE_field(struct FE_element *element,
	struct FE_field *fe_field, FE_value time,
	struct FE_field *element_count_fe_field,
	struct LIST(FE_node) *copy_node_list)
/*******************************************************************************
LAST MODIFIED : 16 April 2003

DESCRIPTION :
For each node contributing to <fe_field> in <element> either its copy is found
in <copy_node_list> or one is made and added to this list. The copy node will
have <fe_field> defined on it in the same way as the original, plus the integer
<element_count_fe_field> with the same number of components as <fe_field> for
accumulating the number of elements each first derivative of <fe_field> is
referenced by. The copy node starts with all derivatives set to zero.

After making calls to this function for all the intended elements, call
FE_node_smooth_FE_field for each node to divide the accumulated derivatives
by the number of elements they are over and to undefine the
<element_count_fe_field>.
It is up to the calling funcion to merge the copied information into global
elements and nodes.

Sets all scale factors used for <fe_field> to 1.

Notes:
- Only works for "line" shapes with Hermite basis functions.
- <element> shold not be global = not merged into an FE_region.
- <fe_field> should be of type FE_VALUE_VALUE.
- returns 1 without errors if fe_field is not defined on this element or the
  element has no field information, or the field cannot be smoothed.
- only handles 1 version at nodes.
==============================================================================*/
{
	FE_value component_value[8], delta, value, *values,
		xi[MAXIMUM_ELEMENT_XI_DIMENSIONS];
	int element_dimension, i, index, j, k, n, number_of_components,
		number_of_nodes, number_of_values, return_code, version;
	struct FE_element_field *element_field;
	struct FE_element_field_component *element_field_component;
	struct FE_element_field_values *fe_element_field_values;
	struct FE_node *copy_node[8], *node;
	struct FE_node_field_creator *fe_node_field_creator;
	struct LIST(FE_field) *fe_field_list;
	struct Standard_node_to_element_map *node_to_element_map;

	ENTER(FE_element_smooth_FE_field);
	if (element && fe_field && element_count_fe_field && copy_node_list &&
		(FE_VALUE_VALUE == get_FE_field_value_type(fe_field)) &&
		(INT_VALUE == get_FE_field_value_type(element_count_fe_field)) &&
		(number_of_components = get_FE_field_number_of_components(fe_field)) &&
		(get_FE_field_number_of_components(element_count_fe_field) ==
			number_of_components))
	{
		return_code = 1;
		version = 0;
		/* work out if element has this fe_field defined and if it is a "square"
			 shape */
		if (element->information && element->fields &&
			(element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				fe_field, element->fields->element_field_list)) &&
			element_field->components &&
			FE_element_shape_is_line(element->shape))
		{
			fe_field_list = (struct LIST(FE_field) *)NULL;
			element_dimension = get_FE_element_dimension(element);
			for (i = 0; (i < number_of_components) && return_code; i++)
			{
				element_field_component = (element_field->components)[i];
				/* work out if the node map is appropriate for smoothing */
				if ((STANDARD_NODE_TO_ELEMENT_MAP == element_field_component->type) &&
					element_field_component->map.standard_node_based.node_to_element_maps
					&& (0 < (number_of_nodes = element_field_component->
						map.standard_node_based.number_of_nodes)) && (
							((1 == element_dimension) && (2 == number_of_nodes)) ||
							((2 == element_dimension) && (4 == number_of_nodes)) ||
							((3 == element_dimension) && (8 == number_of_nodes))))
				{
					for (n = 0; (n < number_of_nodes) && return_code; n++)
					{
						/* get the node_to_element_map and hence the node */
						if ((node_to_element_map = element_field_component->map.
							standard_node_based.node_to_element_maps[n]) &&
							get_FE_element_node(element, node_to_element_map->node_index,
								&node) && node)
						{
							copy_node[n] =
								FIND_BY_IDENTIFIER_IN_LIST(FE_node,cm_node_identifier)(
									get_FE_node_identifier(node), copy_node_list);
							if (!(copy_node[n]))
							{
								fe_node_field_creator = (struct FE_node_field_creator *)NULL;
								if ((fe_field_list ||
									((fe_field_list = CREATE(LIST(FE_field))()) &&
										ADD_OBJECT_TO_LIST(FE_field)(fe_field, fe_field_list))) &&
									(copy_node[n] =
										FE_node_copy_with_FE_field_list(node, fe_field_list)) &&
									(fe_node_field_creator =
										create_FE_node_field_creator_from_node_field(node,
											fe_field)) &&
									define_FE_field_at_node(copy_node[n], element_count_fe_field,
										(struct FE_time_sequence *)NULL, fe_node_field_creator) &&
									ADD_OBJECT_TO_LIST(FE_node)(copy_node[n], copy_node_list))
								{
									/* assume that element_count_fe_field values are cleared to
										 zero by define_FE_field_at_node */
									/* first clear all values for fe_field in copy_node */
									if (get_FE_nodal_field_FE_value_values(fe_field, node,
										&number_of_values, &values))
									{
										for (k = 0; k < number_of_values; k++)
										{
											values[k] = 0.0;
										}
										if (!set_FE_nodal_field_FE_value_values(fe_field,
											copy_node[n], values, &number_of_values))
										{
											display_message(ERROR_MESSAGE,
												"FE_element_smooth_FE_field.  Could clear node values");
											return_code = 0;
										}
										DEALLOCATE(values);
										/* restore the nodal values */
										for (j = 0; j < number_of_components; j++)
										{
											if (!(get_FE_nodal_FE_value_value(node,
												fe_field, /*component_number*/j, version,
												FE_NODAL_VALUE, time, &value) &&
												set_FE_nodal_FE_value_value(copy_node[n],
													fe_field, /*component_number*/j, version,
													FE_NODAL_VALUE, time, value)))
											{
												display_message(ERROR_MESSAGE,
													"FE_element_smooth_FE_field.  "
													"Could not copy node value");
												return_code = 0;
											}
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"FE_element_smooth_FE_field.  Could get all node values");
										return_code = 0;
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"FE_element_smooth_FE_field.  Could not copy node");
									DESTROY(FE_node)(&(copy_node[n]));
									return_code = 0;
								}
								if (fe_node_field_creator)
								{
									DESTROY(FE_node_field_creator)(&fe_node_field_creator);
								}
							}
							/* set unit scale factors */
							if (return_code && node_to_element_map->scale_factor_indices)
							{
								for (k = 0; (k < node_to_element_map->number_of_nodal_values) &&
									return_code; k++)
								{
									if (0 <=
										(index = node_to_element_map->scale_factor_indices[k]))
									{
										if (!set_FE_element_scale_factor(element, index, 1.0))
										{
											display_message(ERROR_MESSAGE,
												"FE_element_smooth_FE_field.  "
												"Could set unit scale factor");
											return_code = 0;
										}
									}
								}
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"FE_element_smooth_FE_field.  Element is missing a node");
							return_code = 0;
						}
					}
					if (return_code)
					{
						/* get nodal values */
						if (element_field_component->modify)
						{
							/* need to calculate field values so that modify function can
								 make its changes */
							fe_element_field_values = CREATE(FE_element_field_values)();
							if (calculate_FE_element_field_values(element, fe_field, time,
								/*calculate_derivatives*/0, fe_element_field_values,
								/*top_level_element*/(struct FE_element *)NULL))
							{
								for (n = 0; (n < number_of_nodes) && return_code; n++)
								{
									xi[0] = (FE_value)(n & 1);
									xi[1] = (FE_value)((n & 2)/2);
									xi[2] = (FE_value)((n & 4)/4);
									if (!calculate_FE_element_field(/*component_number*/i,
										fe_element_field_values, xi, &(component_value[n]),
										/*jacobian*/(FE_value *)NULL))
									{
										display_message(ERROR_MESSAGE,
											"FE_element_smooth_FE_field.  "
											"Could not calculate element field");
										return_code = 0;
									}
								}
							}
							else
							{
								display_message(ERROR_MESSAGE, "FE_element_smooth_FE_field.  "
									"Could not get element field values");
								return_code = 0;
							}
							DESTROY(FE_element_field_values)(&fe_element_field_values);
						}
						else
						{
							for (n = 0; (n < number_of_nodes) && return_code; n++)
							{
								if (!get_FE_nodal_FE_value_value(copy_node[n],
										fe_field, /*component_number*/i, version, FE_NODAL_VALUE,
									time, &(component_value[n])))
								{
									display_message(ERROR_MESSAGE, "FE_element_smooth_FE_field.  "
										"Could not get node field component value");
									return_code = 0;
								}
							}
						}
					}
					if (return_code)
					{
						/* d/ds1 between nodes 0 and 1 */
						delta = component_value[1] - component_value[0];
						if (!(FE_node_field_component_accumulate_value(copy_node[0],
							fe_field, element_count_fe_field, /*component_number*/i,
							version, FE_NODAL_D_DS1, time, delta) &&
							FE_node_field_component_accumulate_value(copy_node[1],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS1, time, delta)))
						{
							return_code = 0;
						}
						if (1 < element_dimension)
						{
							/* d/ds1 between nodes 2 and 3 */
							delta = component_value[3] - component_value[2];
							if (!(FE_node_field_component_accumulate_value(copy_node[2],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS1, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[3],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS1, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds2 between nodes 0 and 2 */
							delta = component_value[2] - component_value[0];
							if (!(FE_node_field_component_accumulate_value(copy_node[0],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS2, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[2],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS2, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds2 between nodes 1 and 3 */
							delta = component_value[3] - component_value[1];
							if (!(FE_node_field_component_accumulate_value(copy_node[1],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS2, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[3],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS2, time, delta)))
							{
								return_code = 0;
							}
						}
						if (2 < element_dimension)
						{
							/* d/ds1 between nodes 4 and 5 */
							delta = component_value[5] - component_value[4];
							if (!(FE_node_field_component_accumulate_value(copy_node[4],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS1, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[5],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS1, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds1 between nodes 6 and 7 */
							delta = component_value[7] - component_value[6];
							if (!(FE_node_field_component_accumulate_value(copy_node[6],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS1, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[7],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS1, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds2 between nodes 4 and 6 */
							delta = component_value[6] - component_value[4];
							if (!(FE_node_field_component_accumulate_value(copy_node[4],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS2, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[6],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS2, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds2 between nodes 5 and 7 */
							delta = component_value[7] - component_value[5];
							if (!(FE_node_field_component_accumulate_value(copy_node[5],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS2, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[7],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS2, time, delta)))
							{
								return_code = 0;
							}

							/* d/ds3 between nodes 0 and 4 */
							delta = component_value[4] - component_value[0];
							if (!(FE_node_field_component_accumulate_value(copy_node[0],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS3, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[4],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS3, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds3 between nodes 1 and 5 */
							delta = component_value[5] - component_value[1];
							if (!(FE_node_field_component_accumulate_value(copy_node[1],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS3, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[5],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS3, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds3 between nodes 2 and 6 */
							delta = component_value[6] - component_value[2];
							if (!(FE_node_field_component_accumulate_value(copy_node[2],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS3, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[6],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS3, time, delta)))
							{
								return_code = 0;
							}
							/* d/ds3 between nodes 3 and 7 */
							delta = component_value[7] - component_value[3];
							if (!(FE_node_field_component_accumulate_value(copy_node[3],
								fe_field, element_count_fe_field, /*component_number*/i,
								version, FE_NODAL_D_DS3, time, delta) &&
								FE_node_field_component_accumulate_value(copy_node[7],
									fe_field, element_count_fe_field, /*component_number*/i,
									version, FE_NODAL_D_DS3, time, delta)))
							{
								return_code = 0;
							}
						}
					}
				}
			}
			/* clean up */
			if (fe_field_list)
			{
				DESTROY(LIST(FE_field))(&fe_field_list);
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_smooth_FE_field.  Invalid argument(s)");
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_smooth_FE_field */

struct FE_field_order_info *CREATE(FE_field_order_info)(void)
/*******************************************************************************
LAST MODIFIED : 4 September 2001

DESCRIPTION :
Creates an empty FE_field_order_info structure.
==============================================================================*/
{
	struct FE_field_order_info *field_order_info;

	ENTER(CREATE(FE_field_order_info));
	if (ALLOCATE(field_order_info,struct FE_field_order_info,1))
	{
		field_order_info->allocated_number_of_fields = 0;
		field_order_info->number_of_fields = 0;
		field_order_info->fields = (struct FE_field **)NULL;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"CREATE(FE_field_order_info).  Not enough memory");
	}
	LEAVE;

	return (field_order_info);
} /* CREATE(FE_field_order_info) */

int DESTROY(FE_field_order_info)(
	struct FE_field_order_info **field_order_info_address)
/*******************************************************************************
LAST MODIFIED : 4 September 2001

DESCRIPTION
Frees them memory used by field_order_info.
==============================================================================*/
{
	int return_code, i;
	struct FE_field_order_info *field_order_info;

	ENTER(DESTROY(FE_field_order_info));
	if ((field_order_info_address) &&
		(field_order_info = *field_order_info_address))
	{			
		if (field_order_info->fields)
		{		
			for (i = 0; i < field_order_info->number_of_fields; i++)
			{
				DEACCESS(FE_field)(&(field_order_info->fields[i]));
			}
			DEALLOCATE(field_order_info->fields);	
		}
		DEALLOCATE(*field_order_info_address);	
		return_code = 1;
	}
	else
	{
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_field_order_info) */

int add_FE_field_order_info_field(
	struct FE_field_order_info *field_order_info, struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 4 September 2001

DESCRIPTION :
Adds <field> to the end of the list of fields in <field_order_info>.
==============================================================================*/
{
#define FE_FIELD_ORDER_INFO_ALLOCATE_SIZE 10
	int return_code;
	struct FE_field **temp_fields;

	ENTER(add_FE_field_order_info_field);
	if (field_order_info && field)
	{
		return_code = 1;
		if (field_order_info->number_of_fields ==
			field_order_info->allocated_number_of_fields)
		{
			field_order_info->allocated_number_of_fields +=
				FE_FIELD_ORDER_INFO_ALLOCATE_SIZE;
			if (REALLOCATE(temp_fields, field_order_info->fields, struct FE_field *,
				field_order_info->allocated_number_of_fields))
			{
				field_order_info->fields = temp_fields;
			}
			else
			{
				field_order_info->allocated_number_of_fields -=
					FE_FIELD_ORDER_INFO_ALLOCATE_SIZE;
				display_message(ERROR_MESSAGE,
					"add_FE_field_order_info_field.  Not enough memory");		
				return_code = 0;
			}
		}
		if (return_code)
		{
			field_order_info->fields[field_order_info->number_of_fields] =
				ACCESS(FE_field)(field);
			field_order_info->number_of_fields++;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"add_FE_field_order_info_field.  Invalid argument");		
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* add_FE_field_order_info_field */

int clear_FE_field_order_info(struct FE_field_order_info *field_order_info)
/*******************************************************************************
LAST MODIFIED : 4 September 2001

DESCRIPTION : 
Clears the fields from <field_order_info>.
==============================================================================*/
{
	int i, return_code;

	ENTER(clear_FE_field_order_info_field);
	if (field_order_info)
	{		
		for (i = 0; i < field_order_info->number_of_fields; i++)
		{
			DEACCESS(FE_field)(&(field_order_info->fields[i]));
		}
		field_order_info->number_of_fields = 0;
		return_code = 1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"clear_FE_field_order_info_field.  Invalid argument");		
		return_code = 0;
	}
	LEAVE;

	return (return_code);
} /* clear_FE_field_order_field */

int get_FE_field_order_info_number_of_fields(
	struct FE_field_order_info *field_order_info)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Gets the <field_order_info> number_of_fields
==============================================================================*/
{
	int number_of_fields;

	ENTER(get_FE_field_order_info_number_of_fields);
	if (field_order_info)
	{
		number_of_fields=field_order_info->number_of_fields;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_order_info_number_of_fields.  Invalid argument");		
		number_of_fields=0;
	}
	LEAVE;

	return (number_of_fields);
} /* get_FE_field_order_info_number_of_fields */

struct FE_field *get_FE_field_order_info_field(
	struct FE_field_order_info *field_order_info,int field_number)
/*******************************************************************************
LAST MODIFIED : 4 September 2001

DESCRIPTION : 
Gets the <field_order_info> field at the specified field_number.
==============================================================================*/
{
	struct FE_field *field;

	ENTER(get_FE_field_order_info_field);
	if (field_order_info &&
		(field_number <= field_order_info->number_of_fields))
	{		
		field=field_order_info->fields[field_number];
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_field_order_info_field.  Invalid argument(s)");		
		field = (struct FE_field *)NULL;
	}
	LEAVE;

	return (field);
} /* get_FE_field_order_field */

int define_node_field_and_field_order_info(struct FE_node *node,
	struct FE_field *field, struct FE_node_field_creator *node_field_creator,
	struct FE_field_order_info *field_order_info)
/*******************************************************************************
LAST MODIFIED : 16 November 2001

DESCRIPTION :
Helper function for create_config_template_node() and
create_mapping_template_node() that, given the node, field and
field_order_info, defines the field at the node, and places it at the end of
the field_order_info list.
==============================================================================*/
{
	int return_code;

	ENTER(define_node_field_and_field_order_info);
	return_code = 0;
	if (node && field && field_order_info && node_field_creator)
	{
		return_code = 1;
		if (define_FE_field_at_node(node, field, (struct FE_time_sequence *)NULL,
			node_field_creator))
		{
			if (!add_FE_field_order_info_field(field_order_info, field))
			{
				display_message(ERROR_MESSAGE,
					"define_node_field_and_field_order_info.  "
					"Could not add field to list");
				return_code = 0;
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"define_node_field_and_field_order_info.  "
				"Could not define field at node");
			/*???RC This should not have been here: */
			/* DESTROY(FE_field)(&field); */
			return_code = 0;
		}	
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"define_node_field_and_field_order_info.  Invalid argument(s)");
		return_code = 0;
	}		 
	LEAVE;

	return (return_code);
} /* define_node_field_and_field_order_info */

struct FE_node_order_info *CREATE(FE_node_order_info)(
	int number_of_nodes)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Allocate space for an array of pointers to nodes of length number_of_nodes, 
set these to NULL, copy the number_of_nodes. 
==============================================================================*/
{
	int i;
	struct FE_node_order_info *node_order_info;

	ENTER(CREATE(FE_node_order_info));				
	if (ALLOCATE(node_order_info,struct FE_node_order_info,1))
	{
		if (number_of_nodes>0)
		{	
			if (ALLOCATE(node_order_info->nodes,struct FE_node *,
				number_of_nodes))
			{
				node_order_info->number_of_nodes = number_of_nodes; 
				for (i=0;i<number_of_nodes;i++)
				{				
					node_order_info->nodes[i]=(struct FE_node *)NULL;
				}	
				node_order_info->access_count=0;
			}
			else
			{
				display_message(ERROR_MESSAGE,
"CREATE(FE_node_order_info).  Could not allocate memory for node_field_info->nodes");
				DEALLOCATE(node_order_info->nodes);		
				DEALLOCATE(node_order_info);
			}
		}
		else
		{	
			node_order_info->number_of_nodes=0;
			node_order_info->nodes=(struct FE_node **)NULL;	
			node_order_info->access_count=0;
		}
		node_order_info->current_node_number=0;
	}
	else
	{
		display_message(ERROR_MESSAGE,
"CREATE(FE_node_order_info).  Could not allocate memory for node field info");	
		DEALLOCATE(node_order_info);	
	}
	LEAVE;

	return (node_order_info);
} /* CREATE(FE_node_order_info) */

int DESTROY(FE_node_order_info)(
	struct FE_node_order_info **node_order_info_address)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Frees them memory used by node_order_info.
==============================================================================*/
{
	int i,return_code;
	struct FE_node_order_info *node_order_info;
	struct FE_node *node;

	ENTER(DESTROY(FE_node_order_info));
	return_code=0;
	if ((node_order_info_address)&&
		(node_order_info= *node_order_info_address))
	{					
		/* free the components */		
		for (i=0;i<node_order_info->number_of_nodes;i++)
		{				
			node=node_order_info->nodes[i];
			DEACCESS(FE_node)(&node);
		}			
		DEALLOCATE(node_order_info->nodes);	
		DEALLOCATE(*node_order_info_address);	
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_node_order_info) */

DECLARE_OBJECT_FUNCTIONS(FE_node_order_info)

PROTOTYPE_COPY_OBJECT_FUNCTION(FE_node_order_info)
/*******************************************************************************
LAST MODIFIED : 11 August 1999

DESCRIPTION :
Makes an exacy copy of the FE_node_order_info
==============================================================================*/
{
	int return_code,i;
	
	ENTER(COPY(FE_node_order_info));
	return_code=0;
	/* check the arguments */
	if (source&&destination)
	{
		/* free any existing the destination things */
		if (destination->number_of_nodes)
		{
			for (i=0;i<destination->number_of_nodes;i++)
			{				
				DEACCESS(FE_node)(&(destination->nodes[i]));
			}		
			DEALLOCATE(destination->nodes);
			destination->number_of_nodes=0;
		}
		if (ALLOCATE(destination->nodes,struct FE_node*,source->number_of_nodes))
		{
			/* copy the new */
			destination->number_of_nodes=source->number_of_nodes;
			for (i=0;i<destination->number_of_nodes;i++)
			{				
				destination->nodes[i]=ACCESS(FE_node)(source->nodes[i]);
			}	
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"COPY(FE_node_order_info).  Out of memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"COPY(FE_node_order_info).  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* COPY(FE_node_order_info) */

int get_FE_node_order_info_number_of_nodes(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Gets the <node_order_info> number_of_nodes
==============================================================================*/
{
	int number_of_nodes;

	ENTER(get_FE_node_order_info_number_of_nodes);
	if (node_order_info)
	{
		number_of_nodes=node_order_info->number_of_nodes;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_number_of_nodes.  Invalid argument");		
		number_of_nodes=0;
	}
	LEAVE;

	return (number_of_nodes);
} /* get_FE_node_order_info_number_of_nodes */

struct FE_node *get_FE_node_order_info_node(
	struct FE_node_order_info *node_order_info,int node_number)
/*******************************************************************************
LAST MODIFIED : 13 July 1999

DESCRIPTION : 
Gets the <node_order_info> node at the specified node_number
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_node);
	if ((node_order_info)&&
		(node_number<=node_order_info->number_of_nodes))
	{		
		node=node_order_info->nodes[node_number];
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /* get_FE_node_order_info_node */

int set_FE_node_order_info_node(
	struct FE_node_order_info *node_order_info,int node_number,
	struct FE_node *node)
/*******************************************************************************
LAST MODIFIED : 16 August 1999

DESCRIPTION : 
Sets the <node_order_info> node at the specified node_number.
Also sets the current_node_number to <the node_number>
==============================================================================*/
{
	int return_code

	ENTER(set_FE_node_order_info_node);
	return_code=0;
	if ((node_order_info)&&
		(node_number<=node_order_info->number_of_nodes)&&(node))
	{	
		REACCESS(FE_node)(&(node_order_info->nodes[node_number]),node);
		node_order_info->current_node_number=node_number;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_node_order_info_node.  Invalid argument");		
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_group_order_node */

int get_FE_node_order_info_current_node_number(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
gets the <node_order_info> <current_node_number>
==============================================================================*/
{
	int current_node_number;

	ENTER(get_FE_node_order_info_current_node_number);	
	if (node_order_info&&(node_order_info->number_of_nodes>0))
	{			
		current_node_number=node_order_info->current_node_number;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_current_node_number.  Invalid argument");		
		current_node_number=-1;
	}
	LEAVE;

	return (current_node_number);
} /* get_FE_node_order_info_current_node_number */

int set_FE_node_order_info_current_node_number(
	struct FE_node_order_info *node_order_info,int current_node_number)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Sets the <node_order_info> <current_node_number>
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_node_order_info_current_node_number);
	return_code=0;
	if ((node_order_info)&&(current_node_number>-1)&&
		(current_node_number<=node_order_info->number_of_nodes))
	{			
		node_order_info->current_node_number=current_node_number;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_node_order_info_current_node_number.  Invalid argument");		
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_node_order_info_current_node_number */

struct FE_node *get_FE_node_order_info_current_node(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Gets the <node_order_info> node at the current_node_number
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_current_node);
	if (node_order_info)
	{		
		if (node_order_info->number_of_nodes)
		{
			node=node_order_info->nodes[node_order_info->current_node_number];
		}
		else
		{
			node=(struct FE_node *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_current_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /*get_FE_node_order_info_current_node  */

struct FE_node *get_FE_node_order_info_next_node(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Gets the <node_order_info> next node by incrementing the current_node_number,
and returning the new current node. If at the end of the array, return null.
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_next_node);
	if (node_order_info)
	{		
		if ((node_order_info->number_of_nodes)&&
			(node_order_info->current_node_number<(node_order_info->number_of_nodes-1)))
		{			
			node_order_info->current_node_number++;
			node=node_order_info->nodes[node_order_info->current_node_number];		
		}
		else
		{
			node=(struct FE_node *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_next_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /*get_FE_node_order_info_next_node  */

struct FE_node *get_FE_node_order_info_prev_node(
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 17 August 2000

DESCRIPTION : 
Gets the <node_order_info> next node by incrementing the current_node_number,
and returning the new current node. If at the start of the array, return null.
==============================================================================*/
{
	struct FE_node *node;

	ENTER(get_FE_node_order_info_prev_node);
	if (node_order_info)
	{		
		if ((node_order_info->number_of_nodes)&&
			(node_order_info->current_node_number>0))
		{			
			node_order_info->current_node_number--;
			node=node_order_info->nodes[node_order_info->current_node_number];		
		}
		else
		{
			node=(struct FE_node *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_node_order_info_prev_node.  Invalid argument");		
		node=(struct FE_node *)NULL;
	}
	LEAVE;

	return (node);
} /*get_FE_node_order_info_prev_node  */

int add_nodes_FE_node_order_info(int number_of_nodes_to_add,
	struct FE_node_order_info *node_order_info)
/*******************************************************************************
LAST MODIFIED : 6 July 1999

DESCRIPTION :
Reallocates space for more  nodes in a previously created
FE_node_order_info.  Use set_FE_node_order_info to set up the nodes.
==============================================================================*/
{
	int i,return_code,old_number_of_nodes;
	struct FE_node **nodes;

	ENTER(add_nodes_FE_node_order_info)
	return_code=0;
	if (node_order_info)
	{		
		old_number_of_nodes=node_order_info->number_of_nodes;
		node_order_info->number_of_nodes += number_of_nodes_to_add;				
		if (REALLOCATE(nodes,node_order_info->nodes,struct FE_node *,
			node_order_info->number_of_nodes))
		{
			node_order_info->nodes=nodes;
			/*set the new nodes to null*/
			for (i=old_number_of_nodes;i<node_order_info->number_of_nodes;i++)
			{
				node_order_info->nodes[i]=(struct FE_node *)NULL;
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_node_order_info_add_node.  Out of memory ");	
			return_code=0;
		}
	}	
	else
	{	
		display_message(ERROR_MESSAGE,
			"FE_node_order_info_add_node.  Invalid arguments");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_node_order_info_add_node */

int fill_FE_node_order_info(struct FE_node *node,void *dummy)
/*******************************************************************************
LAST MODIFIED : 6 July 1999

DESCRIPTION :
Allocate space for and add an FE_node to previously created 
FE_node_order_info (passed in dummy).
Called iteratively.
==============================================================================*/
{
	int return_code;
	struct FE_node **nodes;
	struct FE_node_order_info *node_order_info;

	ENTER(fill_FE_node_order_info)
	return_code=0;
	if (node&&dummy)
	{
		node_order_info=(struct FE_node_order_info *)dummy;
		node_order_info->number_of_nodes++;
		/* reallocate space for pointer to the node */
		if (REALLOCATE(nodes,node_order_info->nodes,struct FE_node *,
			node_order_info->number_of_nodes))
		{
			node_order_info->nodes=nodes;
			/* set the pointer to the node */
			node_order_info->nodes[node_order_info->number_of_nodes-1]=
				ACCESS(FE_node)(node);
			node_order_info->current_node_number=node_order_info->number_of_nodes-1;
			return_code=1;	
		}		
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"fill_FE_node_order_info. Invalid arguments");
		return_code=0;	
	}
	LEAVE;

	return (return_code);
} /* fill_FE_node_order_info */

struct FE_element_order_info *CREATE(FE_element_order_info)(
	int number_of_elements)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Allocate space for an array of pointers to elements of length number_of_elements, 
set these to NULL, copy the number_of_elements. 
==============================================================================*/
{
	int i;
	struct FE_element_order_info *element_order_info;

	ENTER(CREATE(FE_element_order_info));				
	if (ALLOCATE(element_order_info,struct FE_element_order_info,1))
	{
		if (number_of_elements>0)
		{	
			if (ALLOCATE(element_order_info->elements,struct FE_element *,
				number_of_elements))
			{
				element_order_info->number_of_elements = number_of_elements; 
				for (i=0;i<number_of_elements;i++)
				{				
					element_order_info->elements[i]=(struct FE_element *)NULL;
				}	
				element_order_info->access_count=0;
			}
			else
			{
				display_message(ERROR_MESSAGE,
"CREATE(FE_element_order_info).  Could not allocate memory for element_field_info->elements");
				DEALLOCATE(element_order_info->elements);		
				DEALLOCATE(element_order_info);
			}
		}
		else
		{	
			element_order_info->number_of_elements=0;
			element_order_info->elements=(struct FE_element **)NULL;	
			element_order_info->access_count=0;
		}
		element_order_info->current_element_number=0;
	}
	else
	{
		display_message(ERROR_MESSAGE,
"CREATE(FE_element_order_info).  Could not allocate memory for element field info");	
		DEALLOCATE(element_order_info);	
	}
	LEAVE;

	return (element_order_info);
} /* CREATE(FE_element_order_info) */

int DESTROY(FE_element_order_info)(
	struct FE_element_order_info **element_order_info_address)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Frees them memory used by element_order_info.
==============================================================================*/
{
	int i,return_code;
	struct FE_element_order_info *element_order_info;
	struct FE_element *element;

	ENTER(DESTROY(FE_element_order_info));
	return_code=0;
	if ((element_order_info_address)&&
		(element_order_info= *element_order_info_address))
	{					
		/* free the components */		
		for (i=0;i<element_order_info->number_of_elements;i++)
		{				
			element=element_order_info->elements[i];
			DEACCESS(FE_element)(&element);
		}			
		DEALLOCATE(element_order_info->elements);	
		DEALLOCATE(*element_order_info_address);	
		return_code=1;
	}
	else
	{
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* DESTROY(FE_element_order_info) */

DECLARE_OBJECT_FUNCTIONS(FE_element_order_info)

PROTOTYPE_COPY_OBJECT_FUNCTION(FE_element_order_info)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION :
Makes an exacy copy of the FE_element_order_info
==============================================================================*/
{
	int return_code,i;
	
	ENTER(COPY(FE_element_order_info));
	return_code=0;
	/* check the arguments */
	if (source&&destination)
	{
		/* free any existing the destination things */
		if (destination->number_of_elements)
		{
			for (i=0;i<destination->number_of_elements;i++)
			{				
				DEACCESS(FE_element)(&(destination->elements[i]));
			}		
			DEALLOCATE(destination->elements);
			destination->number_of_elements=0;
		}
		if (ALLOCATE(destination->elements,struct FE_element*,source->number_of_elements))
		{
			/* copy the new */
			destination->number_of_elements=source->number_of_elements;
			for (i=0;i<destination->number_of_elements;i++)
			{				
				destination->elements[i]=ACCESS(FE_element)(source->elements[i]);
			}	
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"COPY(FE_element_order_info).  Out of memory");
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"COPY(FE_element_order_info).  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* COPY(FE_element_order_info) */

int get_FE_element_order_info_number_of_elements(
	struct FE_element_order_info *element_order_info)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Gets the <element_order_info> number_of_elements
==============================================================================*/
{
	int number_of_elements;

	ENTER(get_FE_element_order_info_number_of_elements);
	if (element_order_info)
	{
		number_of_elements=element_order_info->number_of_elements;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_order_info_number_of_elements.  Invalid argument");		
		number_of_elements=0;
	}
	LEAVE;

	return (number_of_elements);
} /* get_FE_element_order_info_number_of_elements */

struct FE_element *get_FE_element_order_info_element(
	struct FE_element_order_info *element_order_info,int element_number)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Gets the <element_order_info> element at the specified element_number
==============================================================================*/
{
	struct FE_element *element;

	ENTER(get_FE_element_order_info_element);
	if ((element_order_info)&&
		(element_number<=element_order_info->number_of_elements))
	{		
		element=element_order_info->elements[element_number];
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_order_info_element.  Invalid argument");		
		element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (element);
} /* get_FE_element_order_info_element */

int set_FE_element_order_info_element(
	struct FE_element_order_info *element_order_info,int element_number,
	struct FE_element *element)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Sets the <element_order_info> element at the specified element_number.
Also sets the current_element_number to <the element_number>
==============================================================================*/
{
	int return_code

	ENTER(set_FE_element_order_info_element);
	return_code=0;
	if ((element_order_info)&&
		(element_number<=element_order_info->number_of_elements)&&(element))
	{	
		REACCESS(FE_element)(&(element_order_info->elements[element_number]),element);
		element_order_info->current_element_number=element_number;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_order_info_element.  Invalid argument");		
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_group_order_element */

int get_FE_element_order_info_current_element_number(
	struct FE_element_order_info *element_order_info)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
gets the <element_order_info> <current_element_number>
==============================================================================*/
{
	int current_element_number;

	ENTER(get_FE_element_order_info_current_element_number);	
	if (element_order_info&&(element_order_info->number_of_elements>0))
	{			
		current_element_number=element_order_info->current_element_number;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_order_info_current_element_number.  Invalid argument");		
		current_element_number=-1;
	}
	LEAVE;

	return (current_element_number);
} /* set_FE_element_order_info_current_element_number */

int set_FE_element_order_info_current_element_number(
	struct FE_element_order_info *element_order_info,int current_element_number)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Sets the <element_order_info> <current_element_number>
==============================================================================*/
{
	int return_code;

	ENTER(set_FE_element_order_info_current_element_number);
	return_code=0;
	if ((element_order_info)&&(current_element_number>-1)&&
		(current_element_number<=element_order_info->number_of_elements))
	{			
		element_order_info->current_element_number=current_element_number;
		return_code=1;
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"set_FE_element_order_info_current_element_number.  Invalid argument");		
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* set_FE_element_order_info_current_element_number */

struct FE_element *get_FE_element_order_info_current_element(
	struct FE_element_order_info *element_order_info)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Gets the <element_order_info> element at the current_element_number
==============================================================================*/
{
	struct FE_element *element;

	ENTER(get_FE_element_order_info_current_element);
	if (element_order_info)
	{		
		if (element_order_info->number_of_elements)
		{
			element=element_order_info->elements[element_order_info->current_element_number];
		}
		else
		{
			element=(struct FE_element *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_order_info_current_element.  Invalid argument");		
		element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (element);
} /*get_FE_element_order_info_current_element  */

struct FE_element *get_FE_element_order_info_next_element(
	struct FE_element_order_info *element_order_info)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Gets the <element_order_info> next element by incrementing the current_element_number,
and returning the new current element. If at the end of the array, return null.
==============================================================================*/
{
	struct FE_element *element;

	ENTER(get_FE_element_order_info_next_element);
	if (element_order_info)
	{		
		if ((element_order_info->number_of_elements)&&
			(element_order_info->current_element_number<(element_order_info->number_of_elements-1)))
		{			
			element_order_info->current_element_number++;
			element=element_order_info->elements[element_order_info->current_element_number];		
		}
		else
		{
			element=(struct FE_element *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_order_info_next_element.  Invalid argument");		
		element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (element);
} /*get_FE_element_order_info_next_element  */

struct FE_element *get_FE_element_order_info_prev_element(
	struct FE_element_order_info *element_order_info)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION : 
Gets the <element_order_info> next element by incrementing the current_element_number,
and returning the new current element. If at the start of the array, return null.
==============================================================================*/
{
	struct FE_element *element;

	ENTER(get_FE_element_order_info_prev_element);
	if (element_order_info)
	{		
		if ((element_order_info->number_of_elements)&&
			(element_order_info->current_element_number>0))
		{			
			element_order_info->current_element_number--;
			element=element_order_info->elements[element_order_info->current_element_number];		
		}
		else
		{
			element=(struct FE_element *)NULL;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"get_FE_element_order_info_prev_element.  Invalid argument");		
		element=(struct FE_element *)NULL;
	}
	LEAVE;

	return (element);
} /*get_FE_element_order_info_prev_element  */

int add_elements_FE_element_order_info(int number_of_elements_to_add,
	struct FE_element_order_info *element_order_info)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION :
Reallocates space for more  elements in a previously created
FE_element_order_info.  Use set_FE_element_order_info to set up the elements.
==============================================================================*/
{
	int i,return_code,old_number_of_elements;
	struct FE_element **elements;

	ENTER(add_elements_FE_element_order_info)
	return_code=0;
	if (element_order_info)
	{		
		old_number_of_elements=element_order_info->number_of_elements;
		element_order_info->number_of_elements += number_of_elements_to_add;				
		if (REALLOCATE(elements,element_order_info->elements,struct FE_element *,
			element_order_info->number_of_elements))
		{
			element_order_info->elements=elements;
			/*set the new elements to null*/
			for (i=old_number_of_elements;i<element_order_info->number_of_elements;
				i++)
			{
				element_order_info->elements[i]=(struct FE_element *)NULL;
			}
			return_code=1;
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_order_info_add_element.  Out of memory ");	
			return_code=0;
		}
	}	
	else
	{	
		display_message(ERROR_MESSAGE,
			"FE_element_order_info_add_element.  Invalid arguments");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_order_info_add_element */

int fill_FE_element_order_info(struct FE_element *element,void *dummy)
/*******************************************************************************
LAST MODIFIED : 10 January 2001

DESCRIPTION :
Allocate space for and add an FE_element to previously created 
FE_element_order_info (passed in dummy).
Called iteratively.
==============================================================================*/
{
	int return_code;
	struct FE_element **elements;
	struct FE_element_order_info *element_order_info;

	ENTER(fill_FE_element_order_info)
	return_code=0;
	if (element&&dummy)
	{
		element_order_info=(struct FE_element_order_info *)dummy;
		element_order_info->number_of_elements++;
		/* reallocate space for pointer to the element */
		if (REALLOCATE(elements,element_order_info->elements,struct FE_element *,
			element_order_info->number_of_elements))
		{
			element_order_info->elements=elements;
			/* set the pointer to the element */
			element_order_info->elements[element_order_info->number_of_elements-1]=
				ACCESS(FE_element)(element);
			element_order_info->current_element_number=element_order_info->number_of_elements-1;
			return_code=1;	
		}		
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"fill_FE_element_order_info. Invalid arguments");
		return_code=0;	
	}
	LEAVE;

	return (return_code);
} /* fill_FE_element_order_info */

int FE_element_get_scale_factor_for_nodal_value(
	struct FE_element *element, struct FE_node *node, struct FE_field *field,
	int component_number,	enum FE_nodal_value_type nodal_value_type,
	FE_value *scale_factor)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Given  <component_number>  and <nodal_value_type> of <field> at a 
<node> in an <element>, find the  corresponding <scale_factor>.
===============================================================================*/
{
	int i, nodal_value_index, nodal_value_number, number_of_nodes, 
		number_of_versions, return_code,	scale_factor_index;
	struct FE_element_field *element_field;
	struct FE_element_field_component *element_field_component;
	struct FE_node **nodes;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct Standard_node_to_element_map *node_to_element_map,
		**node_to_element_maps;

	ENTER(FE_element_get_scale_factor_for_nodal_value);
	return_code = 0;
	if (element && node && field && (0 <= component_number) &&
		(component_number < field->number_of_components) && scale_factor)
	{
		/* get the element field*/
		if (element->information && element->fields &&
			(element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				field, element->fields->element_field_list)) &&
			(element_field_component = element_field->components[component_number]))
		{
			/* ensure element has nodes*/
			if (nodes = element->information->nodes)
			{
				switch (element_field_component->type)
				{
					case STANDARD_NODE_TO_ELEMENT_MAP:
					{
						/* get the node_to_element map*/
						node_to_element_maps = element_field_component->
							map.standard_node_based.node_to_element_maps;
						node_to_element_map = (struct Standard_node_to_element_map *)NULL;
						number_of_nodes =
							element_field_component->map.standard_node_based.number_of_nodes;
						for (i = 0; (!node_to_element_map) && (i < number_of_nodes); i++)
						{
							if (node_to_element_maps[i] &&
								(node == nodes[node_to_element_maps[i]->node_index]))
							{
								node_to_element_map = node_to_element_maps[i];
							}
						}
						if (node_to_element_map &&
							node_to_element_map->nodal_value_indices &&
							node_to_element_map->scale_factor_indices)
						{
							/* ensure element field is defined in node */
							if (node->fields && (node_field =
								FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
									field, node->fields->node_field_list)) &&
								(node_field_component =
									&(node_field->components[component_number])))
							{
								/* ensure node field has nodal value types */
								if (node_field_component->nodal_value_types &&
									(number_of_versions=node_field_component->number_of_versions))
								{
									/* find the nodal value in the field*/
									nodal_value_number = -1;
									for (i = 0; (0 > nodal_value_number) &&
										(i < node_to_element_map->number_of_nodal_values); i++)
									{
										nodal_value_index =
											node_to_element_map->nodal_value_indices[i];
										if (nodal_value_type == node_field_component->
											nodal_value_types[nodal_value_index /	number_of_versions])
										{
											nodal_value_number = i;
										}
									}
									/* find the scale factor corresponding to the nodal value */
									if (0 <= nodal_value_number)
									{
										scale_factor_index = node_to_element_map->
											scale_factor_indices[nodal_value_number];
										if (-1 == scale_factor_index)
										{
											*scale_factor = 1.0;
											return_code = 1;
										}
										else if ((0 <= scale_factor_index) && (scale_factor_index <
											element->information->number_of_scale_factors))
										{
											*scale_factor =
												element->information->scale_factors[scale_factor_index];
											return_code = 1;
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"FE_element_get_scale_factor_for_nodal_value.  "
												"Scale factor index out of range");
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"FE_element_get_scale_factor_for_nodal_value.  "
											"Nodal value type not used for field");
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"FE_element_get_scale_factor_for_nodal_value.  "
										"Node field has no nodal value types");
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"FE_element_get_scale_factor_for_nodal_value.  "
									"Element field is corrupt as not defined in node it uses");
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"FE_element_get_scale_factor_for_nodal_value.  "
								"Node not used by field in element");
						}
					} break;
					default:
					{
						display_message(ERROR_MESSAGE,
							"FE_element_get_scale_factor_for_nodal_value.  "
							"Currently Only supports STANDARD_NODE_TO_ELEMENT_MAP"
							" Write the code");
					} break;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_get_scale_factor_for_nodal_value.  Element has no nodes");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_get_scale_factor_for_nodal_value.  "
				"Field is not defined in this element");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"FE_element_get_scale_factor_for_nodal_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_get_scale_factor_for_nodal_value */

int FE_element_set_scale_factor_for_nodal_value(
	struct FE_element *element, struct FE_node *node, struct FE_field *field,
	int component_number,	enum FE_nodal_value_type nodal_value_type,
	FE_value scale_factor)
/*******************************************************************************
LAST MODIFIED : 27 February 2003

DESCRIPTION :
Given  <component_number>  and <nodal_value_type> of <field> at a 
<node> in an <element>, set the  corresponding scale_factor to <scale_factor>.
===============================================================================*/
{
	int i, nodal_value_index, nodal_value_number, number_of_nodes, 
		number_of_versions, return_code,	scale_factor_index;
	struct FE_element_field *element_field;
	struct FE_element_field_component *element_field_component;
	struct FE_node **nodes;
	struct FE_node_field *node_field;
	struct FE_node_field_component *node_field_component;
	struct Standard_node_to_element_map *node_to_element_map,
		**node_to_element_maps;

	ENTER(FE_element_set_scale_factor_for_nodal_value);
	return_code = 0;
	if (element && node && field && (0 <= component_number) &&
		(component_number < field->number_of_components) && scale_factor)
	{
		/* get the element field */
		if (element->information && element->fields &&
			(element_field = FIND_BY_IDENTIFIER_IN_LIST(FE_element_field,field)(
				field, element->fields->element_field_list)) &&
			(element_field_component = element_field->components[component_number]))
		{
			/* ensure element has nodes*/
			if (nodes = element->information->nodes)
			{
				switch (element_field_component->type)
				{
					case STANDARD_NODE_TO_ELEMENT_MAP:
					{
						/* get the node_to_element map*/
						node_to_element_maps = element_field_component->
							map.standard_node_based.node_to_element_maps;
						node_to_element_map = (struct Standard_node_to_element_map *)NULL;
						number_of_nodes =
							element_field_component->map.standard_node_based.number_of_nodes;
						for (i = 0; (!node_to_element_map) && (i < number_of_nodes); i++)
						{
							if (node_to_element_maps[i] &&
								(node == nodes[node_to_element_maps[i]->node_index]))
							{
								node_to_element_map = node_to_element_maps[i];
							}
						}
						if (node_to_element_map &&
							node_to_element_map->nodal_value_indices &&
							node_to_element_map->scale_factor_indices)
						{
							/* ensure element field is defined in node */
							if (node->fields && (node_field =
								FIND_BY_IDENTIFIER_IN_LIST(FE_node_field,field)(
									field, node->fields->node_field_list)) &&
								(node_field_component =
									&(node_field->components[component_number])))
							{
								/* ensure node field has nodal value types */
								if (node_field_component->nodal_value_types &&
									(number_of_versions=node_field_component->number_of_versions))
								{
									/* find the nodal value in the field*/
									nodal_value_number = -1;
									for (i = 0; (0 > nodal_value_number) &&
										(i < node_to_element_map->number_of_nodal_values); i++)
									{
										nodal_value_index =
											node_to_element_map->nodal_value_indices[i];
										if (nodal_value_type == node_field_component->
											nodal_value_types[nodal_value_index /	number_of_versions])
										{
											nodal_value_number = i;
										}
									}
									/* find the scale factor corresponding to the nodal value */
									if (0 <= nodal_value_number)
									{
										scale_factor_index = node_to_element_map->
											scale_factor_indices[nodal_value_number];
										if (-1 == scale_factor_index)
										{
											display_message(WARNING_MESSAGE,
												"FE_element_set_scale_factor_for_nodal_value.  "
												"scale_factor_index = -1. can't set scale_factor ");
											return_code = 1;
											
										}
										else if ((0 <= scale_factor_index) && (scale_factor_index <
											element->information->number_of_scale_factors))
										{											
											element->information->scale_factors[scale_factor_index]=scale_factor;
											return_code = 1;
										}
										else
										{
											display_message(ERROR_MESSAGE,
												"FE_element_set_scale_factor_for_nodal_value.  "
												"Scale factor index out of range");
										}
									}
									else
									{
										display_message(ERROR_MESSAGE,
											"FE_element_set_scale_factor_for_nodal_value.  "
											"Nodal value type not used for field");
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,
										"FE_element_set_scale_factor_for_nodal_value.  "
										"Node field has no nodal value types");
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"FE_element_set_scale_factor_for_nodal_value.  "
									"Element field is corrupt as not defined in node it uses");
							}
						}
						else
						{
							display_message(ERROR_MESSAGE,
								"FE_element_set_scale_factor_for_nodal_value.  "
								"Node not used by field in element");
						}
					} break;
					default:
					{
						display_message(ERROR_MESSAGE,
							"FE_element_set_scale_factor_for_nodal_value.  "
							"Currently Only supports STANDARD_NODE_TO_ELEMENT_MAP"
							" Write the code");
					} break;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_set_scale_factor_for_nodal_value.  Element has no nodes");
			}
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"FE_element_set_scale_factor_for_nodal_value.  "
				"Field is not defined in this element");
		}
	}
	else
	{	
		display_message(ERROR_MESSAGE,
			"FE_element_set_scale_factor_for_nodal_value.  Invalid argument(s)");
	}
	LEAVE;

	return (return_code);
} /* FE_element_set_scale_factor_for_nodal_value */

struct FE_element_parent_not_equal_data
/*******************************************************************************
LAST MODIFIED : 19 March 2003

DESCRIPTION :
Data structure for the FE_element_parent_not_equal_to_element routine
==============================================================================*/
{
	struct FE_element *not_element;
	struct FE_region *fe_region;
}; /* struct FE_element_parent_not_equal_data */

static int FE_element_parent_not_equal_to_element(struct FE_element_parent *object,
	void *data_void)
/*******************************************************************************
LAST MODIFIED : 19 March 2003

DESCRIPTION :
An iterator function that returns true if the element referred to in the parent
<object> is not equal to the FE_element pointer referenced by <element_void>.
==============================================================================*/
{
	int return_code;
	struct FE_element_parent_not_equal_data *data;

	ENTER(parent_not_equal_to_element);
	if (object && (data = (struct FE_element_parent_not_equal_data *)data_void))
	{
		if (object->parent != data->not_element)
		{
			if (data->fe_region)
			{
				return_code = FE_region_contains_FE_element(data->fe_region,
					object->parent);
			}
			else
			{
				return_code=1;
			}
		}
		else
		{
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"parent_not_equal_to_element.  Invalid arguments");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_parent_not_equal_to_element */

int FE_element_xi_increment_within_element(struct FE_element *element,
	FE_value *xi,FE_value *increment,FE_value *fraction,int *face_number,
	FE_value *xi_face)
/*******************************************************************************
LAST MODIFIED : 20 January 2004

DESCRIPTION :
Adds the <increment> to <xi>.  If this moves <xi> outside of the element, then
the step is limited to take <xi> to the boundary, <face_number> is set to be
the limiting face, <fraction> is updated with the fraction of the <increment>
actually used, the <increment> is updated to contain the part not used,
the <xi_face> are calculated for that face and the <xi> are changed to be
on the boundary of the element.
==============================================================================*/
{
	int return_code;

	ENTER(FE_element_xi_increment_within_element);
	return_code=0;
	if (element&&element->shape&&xi&&face_number&&fraction&&xi_face)
	{
		return_code=FE_element_shape_xi_increment(element->shape,
			xi, increment, fraction, face_number, xi_face);
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_xi_increment_within_element.  "
			"Invalid argument(s).  %p %p %d %p %p",element,element->shape,
			face_number,fraction,xi_face);
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_xi_increment_within_element */

int FE_element_get_number_of_change_to_adjacent_element_permutations(
	struct FE_element *element, FE_value *xi, int face_number)
/*******************************************************************************
LAST MODIFIED : 8 June 2006

DESCRIPTION :
Returns the number of permutations known for the changing to the adjacent
element at face <face_number>.
==============================================================================*/
{
	int number_of_permutations;
	struct FE_element *face;

	ENTER(FE_element_get_number_of_change_to_adjacent_element_permutations);
	USE_PARAMETER(xi);
	if (element&&(0<get_FE_element_dimension(element))&&
		(0<=face_number)&&(face_number<element->shape->number_of_faces))
	{
		number_of_permutations = 1;
		if (face=(element->faces)[face_number])
		{
			number_of_permutations = 1;
			switch (face->shape->dimension)
			{
				case 1:
				{
					number_of_permutations = 2;
				} break;
				case 2:
				{
					if ((face->shape->type[0] == SIMPLEX_SHAPE)
						&& (face->shape->type[2] == SIMPLEX_SHAPE))
					{
						number_of_permutations = 6;
					}
				} break;
			}
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_get_number_of_change_to_adjacent_element_permutations.  "
			"Invalid argument(s).");
		number_of_permutations = 0;
	}
	LEAVE;

	return (number_of_permutations);
} /* FE_element_get_number_of_change_to_adjacent_element_permutations */

int FE_element_change_to_adjacent_element(struct FE_element **element_address,
	FE_value *xi, FE_value *increment, int *face_number, FE_value *xi_face,
	struct FE_region *fe_region, int permutation)
/*******************************************************************************
LAST MODIFIED : 8 June 2006

DESCRIPTION :
Steps into the adjacent element through face <face_number>, updating the 
<element_address> location.
If <xi> is not NULL then the <xi_face> coordinates are converted to an xi
location in the new element.
If <increment> is not NULL then it is converted into an equvalent increment
in the new element.
If <fe_region> is not NULL then the function will restrict itself to elements
in that region.
<permutation> is used to resolve the possible rotation and flipping of the 
local face xi coordinates between the two parents.
The shape mapping from parents are reused for all elements of the same shape
and do not take into account the relative orientation of the parents.
==============================================================================*/
{
	double dot_product;
	FE_value *face_to_element,*local_xi_face,*temp_increment;
	int dimension,i,j,new_face_number,return_code;
	struct FE_element *element,*face,*new_element;
	struct FE_element_parent *face_parent;
	struct FE_element_parent_not_equal_data data;
	FE_value *face_normal;

	ENTER(FE_element_change_to_adjacent_element);
	return_code=0;
	if ((element=*element_address)&&(0<(dimension=get_FE_element_dimension(element)))&&
		(0<=*face_number)&&(*face_number<element->shape->number_of_faces))
	{
		if (increment)
		{
			ALLOCATE(face_normal,FE_value,dimension);
			ALLOCATE(temp_increment,FE_value,dimension);
		}
		ALLOCATE(local_xi_face,FE_value,dimension-1);
		if ((!increment) || (face_normal && temp_increment))
		{
			face=(element->faces)[*face_number];
			if (face)
			{
				/* find the other parent */
				data.not_element = element;
				data.fe_region = fe_region;
				face_parent=FIRST_OBJECT_IN_LIST_THAT(FE_element_parent)(
					FE_element_parent_not_equal_to_element, (void *)&data,
					face->parent_list);
				if (face_parent)
				{
					new_element=face_parent->parent;
					new_face_number=face_parent->face_number;
					/* change xi and increment into element coordinates */
					if (new_element&&(new_element->shape)&&(dimension==
							get_FE_element_dimension(new_element))&&(0<=new_face_number)&&
						(new_face_number<new_element->shape->number_of_faces))
					{
						return_code = 1;
						if (xi)
						{
							if (permutation > 0)
							{
								/* Try rotating the face_xi coordinates */
								/* Only implementing the cases required so far and
									enumerated by FE_element_change_get_number_of_permutations */
								switch (face->shape->dimension)
								{
									case 1:
									{
										if (face->shape->type[0] == LINE_SHAPE)
										{
											local_xi_face[0] = 1.0 - xi_face[0];
										}
									} break;
									case 2:
									{
										if ((face->shape->type[0] == SIMPLEX_SHAPE)
											&& (face->shape->type[2] == SIMPLEX_SHAPE))
										{
											switch (permutation)
											{
												case 1:
												{
													local_xi_face[0] = xi_face[1];
													local_xi_face[1] = 1.0 - xi_face[0] - xi_face[1];
												} break;
												case 2:
												{
													local_xi_face[0] = 1.0 - xi_face[0] - xi_face[1];
													local_xi_face[1] = xi_face[0];
												} break;
												case 3:
												{
													local_xi_face[0] = xi_face[1];
													local_xi_face[1] = xi_face[0];
												} break;
												case 4:
												{
													local_xi_face[0] = xi_face[0];
													local_xi_face[1] = 1.0 - xi_face[0] - xi_face[1];
												} break;
												case 5:
												{
													local_xi_face[0] = 1.0 - xi_face[0] - xi_face[1];
													local_xi_face[1] = xi_face[1];
												} break;
											}
										}
									} break;
								}
							}
							else
							{
								for (j = 0 ; j < dimension - 1 ; j++)
								{
									local_xi_face[j] = xi_face[j];
								}
							}
							face_to_element=(new_element->shape->face_to_element)+
								(new_face_number*dimension*dimension);
							for (i=0;i<dimension;i++)
							{
								xi[i]= *face_to_element;
								face_to_element++;
								for (j=0;j<dimension-1;j++)
								{
									xi[i] += (*face_to_element)*local_xi_face[j];
									face_to_element++;
								}
							}
						}
						if (increment)
						{
							/* convert increment into face+normal coordinates */
							face_to_element=(element->shape->face_to_element)+
								(*face_number*dimension*dimension);
							if (return_code=face_calculate_xi_normal(element->shape,*face_number,
									face_normal))
							{
								for (i=0;i<dimension;i++)
								{
									temp_increment[i]=increment[i];
								}
								for (i=1;i<dimension;i++)
								{
									dot_product=(double)0;
									for (j=0;j<dimension;j++)
									{
										dot_product += (double)(temp_increment[j])*
											(double)(face_to_element[j*dimension+i]);
									}
									increment[i-1]=(FE_value)dot_product;
								}
								dot_product=(double)0;
								for (i=0;i<dimension;i++)
								{
									dot_product += (double)(temp_increment[i])*(double)(face_normal[i]);
								}
								increment[dimension-1]=(FE_value)dot_product;

								/* Convert this back to an increment in the new element */
								if (return_code=face_calculate_xi_normal(new_element->shape,new_face_number,
										face_normal))
								{
									for (i=0;i<dimension;i++)
									{
										temp_increment[i]=increment[i];
									}
									face_to_element=(new_element->shape->face_to_element)+
										(new_face_number*dimension*dimension);
									for (i=0;i<dimension;i++)
									{
										increment[i]=temp_increment[dimension-1]*face_normal[i];
										face_to_element++;
										for (j=0;j<dimension-1;j++)
										{
											increment[i] += (*face_to_element)*temp_increment[j];
											face_to_element++;
										}
									}
								}
								else
								{
									display_message(ERROR_MESSAGE,"FE_element_change_to_adjacent_element.  "
										"Unable to calculate face_normal for new element and face");
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,"FE_element_change_to_adjacent_element.  "
									"Unable to calculate face_normal for old element and face");
							}
						}
						if (return_code)
						{
							*element_address=new_element;
							*face_number=new_face_number;
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,"FE_element_change_to_adjacent_element.  "
							"Invalid new element or element shape");
					}
				}
				else
				{
					/* Valid attempt to change element but there is no adjacent element found */
					return_code = 1;
					*face_number = -1;
				}
			}
			else
			{
				display_message(ERROR_MESSAGE,"FE_element_change_to_adjacent_element.  "
					"Invalid face number %d or face_array", *face_number);
				return_code=0;
			}
			if (increment)
			{
				DEALLOCATE(temp_increment);
				DEALLOCATE(face_normal);
			}
			DEALLOCATE(local_xi_face);
		}
		else
		{
			display_message(ERROR_MESSAGE,"FE_element_change_to_adjacent_element.  "
				"Could not allocate <temp_increment> (%p), or <face_normal> (%p)",
				temp_increment, face_normal);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_change_to_adjacent_element.  "
			"Invalid argument(s).  %p %p %d %p %p %d %p",element_address,element,dimension,
			xi,increment,*face_number,xi_face);
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_change_to_adjacent_element */

int FE_element_xi_increment(struct FE_element **element_address,FE_value *xi,
	FE_value *increment)
/*******************************************************************************
LAST MODIFIED : 23 June 2004

DESCRIPTION :
Adds the <increment> to <xi>.  If this moves <xi> outside of the element, then
if an adjacent element is found then the element and xi location are changed 
to this element and the stepping continues using the remaining increment.  If
no adjacent element is found then the <xi> will be on the element boundary and
the <increment> will contain the fraction of the increment not used.
==============================================================================*/
{
	FE_value fraction,*local_increment,*local_xi,*xi_face;
	int dimension,face_number,i,return_code;
	struct FE_element *element;

	ENTER(FE_element_xi_increment);
	return_code=0;
	if (element_address&&(element= *element_address)&&
		(0<(dimension=get_FE_element_dimension(element)))&&xi&&increment)
	{
		if (ALLOCATE(xi_face,FE_value,dimension) &&
			ALLOCATE(local_xi,FE_value,dimension) &&
			ALLOCATE(local_increment,FE_value,dimension))
		{
			for (i = 0 ; i < dimension ; i++)
			{
				local_xi[i] = xi[i];
				local_increment[i] = increment[i];
			}
			fraction = 0.0;
			return_code = 1;
			/* Continue stepping until a step within an element is able to do
				all of the remaining increment or there is no adjacent element */
			while (return_code && (fraction != 1.0))
			{
				return_code = FE_element_xi_increment_within_element(element, local_xi,
					local_increment, &fraction, &face_number, xi_face);
				if (return_code && (fraction < 1.0))
				{
					return_code = FE_element_change_to_adjacent_element(&element,
						local_xi, local_increment, &face_number, xi_face,
						(struct FE_region *)NULL, /*permutation*/0);
					if (face_number == -1)
					{
						/* No adjacent face could be found, so stop */
						fraction = 1.0;
					}
				}
			}
			if (return_code)
			{
				*element_address=element;				
				for (i = 0 ; i < dimension ; i++)
				{
					xi[i] = local_xi[i];
					increment[i] = local_increment[i];
				}
			}
			DEALLOCATE(local_xi);
			DEALLOCATE(local_increment);
			DEALLOCATE(xi_face);
		}
		else
		{
			display_message(ERROR_MESSAGE, "FE_element_xi_increment.  "
				"Could not allocate <local_xi> (%p), <local_increment> (%p) or "
				"<xi_face) (%p).", local_xi, local_increment, xi_face);
			return_code=0;
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,"FE_element_xi_increment.  "
			"Invalid argument(s).  %p %p %d %p %p",element_address,element,dimension,
			xi,increment);
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_xi_increment */

struct FE_element *create_FE_element_with_line_shape(int identifier,
	struct FE_region *fe_region, int dimension)
/*******************************************************************************
LAST MODIFIED : 1 December 2004

DESCRIPTION :
Creates an element that has a line shape product of the specified <dimension>.
==============================================================================*/
{
	int i,j,return_code,*type,*type_entry;
	struct CM_element_information element_identifier;
	struct FE_element *element;
	struct FE_element_shape *element_shape;

	ENTER(create_FE_element_with_tensor_product_basis);
	return_code=1;
	element = (struct FE_element *)NULL;
	if (identifier && fe_region && (dimension > 0))
	{
		/* make shape */
		element_shape=(struct FE_element_shape *)NULL;
		/* make default n-D "square" element shape */
		if (ALLOCATE(type,int,(dimension*(dimension+1))/2))
		{
			/* retrieve a "square" element of the specified dimension */
			type_entry=type;
			for (i=dimension-1;i>=0;i--)
			{
				*type_entry=LINE_SHAPE;
				type_entry++;
				for (j=i;j>0;j--)
				{
					*type_entry=0;
					type_entry++;
				}
			}
			if (element_shape=CREATE(FE_element_shape)(dimension,type,
					fe_region))
			{
				ACCESS(FE_element_shape)(element_shape);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"create_FE_element_with_line_shape.  Error creating shape");
				return_code=0;
			}
			DEALLOCATE(type);
		}
		else
		{
			display_message(ERROR_MESSAGE,
				"create_FE_element_with_line_shape.  Not enough memory");
			return_code=0;
		}
		/* make element */
		if (return_code)
		{
			element_identifier.type=CM_ELEMENT;
			element_identifier.number=identifier;
			if (!(element = CREATE(FE_element)(
				&element_identifier, element_shape, fe_region, (struct FE_element *)NULL)))
			{
				display_message(ERROR_MESSAGE,
					"create_FE_element_with_line_shape.  "
					"Could not set element shape and field info");
				DESTROY(FE_element)(&(element));
				return_code=0;
			}
		}
		/* deaccess shape so at most used by template element */
		if (element_shape)
		{
			DEACCESS(FE_element_shape)(&element_shape);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"create_FE_element_with_line_shape.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (element);
} /* create_FE_element_with_line_shape */

int FE_element_define_tensor_product_basis(struct FE_element *element,
	int dimension, enum FE_basis_type basis_type, struct FE_field *field)
/*******************************************************************************
LAST MODIFIED : 1 December 2004

DESCRIPTION :
Defines a tensor product basis on <element> with the specified <dimension> 
and <basis_type>.  This does not support mixed basis types in the tensor product.
==============================================================================*/
{
	int *basis_type_array,i,j,k,number_of_components,number_of_nodes,
		number_of_nodes_per_xi,number_of_scale_factors,
		old_number_of_nodes,old_number_of_scale_factor_sets,return_code,
		*xi_basis_type;
	struct FE_basis *element_basis;
	struct FE_element_field_component *component,**components;
	struct Standard_node_to_element_map *standard_node_map;
	void *scale_factor_identifier;

	ENTER(FE_element_define_tensor_product_basis);
	return_code=1;
	if (element && (dimension > 0) && 
		(dimension == element->shape->dimension) && field)
	{
		/* make basis */
		element_basis=(struct FE_basis *)NULL;
		if (return_code)
		{
			/* make default N-linear basis */
			if (ALLOCATE(basis_type_array,int,
					 1+(dimension*(1+dimension))/2))
			{
				xi_basis_type=basis_type_array;
				*xi_basis_type=dimension;
				xi_basis_type++;
				for (i=dimension;0<i;i--)
				{
					for (j=i;0<j;j--)
					{
						if (i==j)
						{
							*xi_basis_type=basis_type;
						}
						else
						{
							*xi_basis_type=NO_RELATION;
						}
						xi_basis_type++;
					}
				}
				if (element_basis = make_FE_basis(basis_type_array,
						FE_region_get_basis_manager(FE_element_get_FE_region(element))))
				{
					ACCESS(FE_basis)(element_basis);
				}
				else
				{
					display_message(ERROR_MESSAGE,
						"FE_element_define_tensor_product_basis.  Error creating shape");
					return_code=0;
				}
				DEALLOCATE(basis_type_array);
			}
			else
			{
				display_message(ERROR_MESSAGE,
					"FE_element_define_tensor_product_basis.  Not enough memory");
				return_code=0;
			}
		}
		if (return_code)
		{
			switch (basis_type)
			{
				case QUADRATIC_LAGRANGE:
				{
					number_of_nodes_per_xi = 3;
				} break;
				case CUBIC_LAGRANGE:
				{
					number_of_nodes_per_xi = 4;
				} break;
				default:
				{
					number_of_nodes_per_xi = 2;
				} break;
			}
			number_of_nodes=1;
			for (i=0;i<dimension;i++)
			{
				number_of_nodes *= number_of_nodes_per_xi;
			}
			switch (basis_type)
			{
				case CUBIC_HERMITE:
				{
					number_of_scale_factors = number_of_nodes * 4;
				} break;
				default:
				{
					number_of_scale_factors = number_of_nodes;
				} break;
			}
			if (get_FE_element_number_of_nodes(element,&old_number_of_nodes) &&
				get_FE_element_number_of_scale_factor_sets(element,
					&old_number_of_scale_factor_sets))
			{
				number_of_nodes += old_number_of_nodes;
				if (old_number_of_scale_factor_sets)
				{
					/* Currently this cannot be increased so we must find it */
					i = 0;
					while ((i < old_number_of_scale_factor_sets) && 
						get_FE_element_scale_factor_set_identifier(element, i,
							&scale_factor_identifier) &&
						(element_basis != scale_factor_identifier))
					{
						i++;
					}
					if (i == old_number_of_scale_factor_sets)
					{
						display_message(ERROR_MESSAGE,
							"FE_element_define_tensor_product_basis.  "
							"Currently unable to add to an existing list of scale factors sets");
						return_code = 0;
					}
				}
				else
				{
					set_FE_element_number_of_scale_factor_sets(
						element, /*number_of_scale_factor_sets*/1,
						/*scale_factor_set_identifiers*/(void *)&element_basis,
						/*numbers_in_scale_factor_sets*/&number_of_scale_factors);
				}
				if (return_code)
				{
					if (set_FE_element_number_of_nodes(element,
							number_of_nodes))
					{
						number_of_components = get_FE_field_number_of_components(
							field);
						if (ALLOCATE(components,struct FE_element_field_component *,
								number_of_components))
						{
							for (i=0;i<number_of_components;i++)
							{
								components[i]=(struct FE_element_field_component *)NULL;
							}
							for (i=0;(i<number_of_components)&&return_code;i++)
							{
								if (component=CREATE(FE_element_field_component)(
										 STANDARD_NODE_TO_ELEMENT_MAP,number_of_nodes,
										 element_basis,(FE_element_field_component_modify)NULL))
								{
									for (j=0;j<number_of_nodes;j++)
									{
										switch (basis_type)
										{
											case CUBIC_HERMITE:
											{
												if (standard_node_map =
													CREATE(Standard_node_to_element_map)(
														/*node_index*/j, /*number_of_values*/4))
												{
													for (k = 0 ; return_code && (k < 4) ; k++)
													{
														if (!(Standard_node_to_element_map_set_nodal_value_index(
																	standard_node_map, k, k) &&
																Standard_node_to_element_map_set_scale_factor_index(
																	standard_node_map, k, j * 4 + k) &&
																/* set scale_factors to 1 */
																set_FE_element_scale_factor(element,
																	/*scale_factor_number*/j * 4 + k, 1.0)))
														{
															return_code = 0;
														}
													}
													if (return_code)
													{
														return_code = FE_element_field_component_set_standard_node_map(
															component, /*node_number*/j, standard_node_map);
													}
													else
													{
														DESTROY(Standard_node_to_element_map)(&standard_node_map);
													}
												}
												else
												{
													return_code=0;
												}
											} break;
											default:
											{
												if (standard_node_map =
													CREATE(Standard_node_to_element_map)(
														/*node_index*/j, /*number_of_values*/1))
												{
													if (!(Standard_node_to_element_map_set_nodal_value_index(
																standard_node_map, 0, 0) &&
															Standard_node_to_element_map_set_scale_factor_index(
																standard_node_map, 0, j) &&
															/* set scale_factors to 1 */
															set_FE_element_scale_factor(element,
																/*scale_factor_number*/j, 1.0) &&
															FE_element_field_component_set_standard_node_map(
																component, /*node_number*/j, standard_node_map)))
													{
														DESTROY(Standard_node_to_element_map)(
															&standard_node_map);
														return_code = 0;
													}
												}
												else
												{
													return_code=0;
												}
											} break;
										}
									}
								}
								else
								{
									return_code=0;
								}
								components[i]=component;
							}
							if (return_code)
							{
								if (!define_FE_field_at_element(
										 element,field,components))
								{
									display_message(ERROR_MESSAGE,
										"FE_element_define_tensor_product_basis.  "
										"Could not define coordinate field at template_element");
									return_code=0;
								}
							}
							else
							{
								display_message(ERROR_MESSAGE,
									"FE_element_define_tensor_product_basis.  "
									"Could not create components");
								return_code = 0;
							}
							for (i=0;i<number_of_components;i++)
							{
								DESTROY(FE_element_field_component)(&(components[i]));
							}
							DEALLOCATE(components);
						}
					}
					else
					{
						display_message(ERROR_MESSAGE,
							"FE_element_define_tensor_product_basis.  "
							"Could not allocate components");
						return_code=0;
					}
				}
			}
		}
		/* deaccess basis and shape so at most used by template element */
		if (element_basis)
		{
			DEACCESS(FE_basis)(&element_basis);
		}
	}
	else
	{
		display_message(ERROR_MESSAGE,
			"FE_element_define_tensor_product_basis.  Invalid argument(s)");
		return_code=0;
	}
	LEAVE;

	return (return_code);
} /* FE_element_define_tensor_product_basis */

