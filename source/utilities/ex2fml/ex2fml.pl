#! /usr/bin/perl -w

use strict;

my $group;
my $number_of_fields;
my @field_name;
my %field_number_components;
my %field_coordinate_system;
my %field_components_names;
my %field_components_derivatives;
my %field_components_versions;
my %field_components_type_names;
my %field_components_basis;
my %field_components_modification;
my %field_components_mapping;
my %field_components_nodes;
my %field_components_number_of_parameters;
my %field_components_node_indices;
my %field_components_scale_factor_indices;
my $i;
my $j;
my $k;
my $l;
my $values;
my $read_already;
my $node_field_values_name;
my $node_parameter_list_name;
my $element_field_values_name;
my $scale_factor_list_name;
my %scale_factor_list_lookup;
my $node_list_name;
my $element_parameter_list_name;
my $mapping_name;
my $value_type;
my $node_name;
my $dimension;
my $shape;
my $element_name;
my $face_name;
my $node_list_number;
my %scale_factor_list_numbers;
my $number_of_scale_factor_sets;
my %mapping;
my $name;
my $new_field;
my $node_index;
my $node_indices;
my $expected_number_of_nodal_values;
my $number_of_nodal_values;
my $scale_factor_indices;
my @list;
my @node_list_indices;
my @derivative_types;
my @scale_factor_list_indices;
my $derivative;
my $count;
my $derivative_line;
my $basis;
my $index;

my $line_name_offset = 100000;
my $face_name_offset = 200000;

my $in_group;
my $in_element_field;
my $node_field_defined;
my $element_field_declared;
my $element_field_defined;

my $end_match = "(Node:|Shape|Group|#Fields|Element)";

$in_group = 0;
$node_field_defined = 0;
$element_field_declared = 0;
$element_field_defined = 0;

$node_field_values_name = "NodeFieldValuerZ";
$node_parameter_list_name = "NodeParameterLissZ";
$element_field_values_name = "ElementFieldValuerZ";
$scale_factor_list_name = "ScaleFactorSesZ";
$node_list_name = "NodeSesZ";
$element_parameter_list_name = "ElementParameterLissZ";
$mapping_name = "MappinfZ";

my $time_var = localtime(time());
print <<FIELDML_HEADER;
<fieldml xmlns="http://www.physiome.org.nz/fieldml/0.1#"
         xmlns:fieldml="http://www.physiome.org.nz/fieldml/0.1#">
  <!Generated by ex2fml.pl on $time_var>
FIELDML_HEADER


$read_already = 0;
$_ = <>;
while (defined $_)
  {
	 if (m/Group name\s*:\s*(\w+)/)
	 {
		if ($in_group)
		{
		  if ($group ne $1)
		  {
			 print "</group>\n";
			 $in_group = 0;
		  }
		}
		$group = $1;
	 }

	 elsif (m"#Fields=(\d+)")
	 {
		$number_of_fields = $1;
		for ($i = 0 ; $i < $number_of_fields ; $i++)
		{
		  $_ = <>;
		  if (m"(\d+)\)\s+(\w+),\s+\w+,\s+([^,]+),[^#]*#Components=(\d)+")
		  {
			 if ($1 != $i+1)
			 {
				die ("Unable to read field header, field numbers don't match\n$_");
			 }
			 $name = $2;
			 $field_name[$i] = $2;
			 if (!defined $field_number_components{$name})
			 {
				$new_field = 1;
			 }
			 else
			 {
				$new_field = 0;
			 }
			 define_field_parameter(\$field_number_components{$name}, "number of components",
				 $4, $name, $_);
			 define_field_parameter(\$field_coordinate_system{$name}, "coordinate systems",
				 $3, $name, $_);
			 for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				$_ = <>;
				if (m"([^\.\s]+)\.\s+Value index=\s*\d+,\s+#Derivatives=\s*(\d+)\s*\(?([\w/,]*)\)?(?:,\s*#Versions\s*(\d+))?")
				{
				  define_field_parameter(\$field_components_names{$name}[$j],
					 "component names", $1, $name, $_);
				  $field_components_derivatives{$name}[$j] = $2;
				  $field_components_type_names{$name}[$j] = "value,$3";
				  $field_components_versions{$name}[$j] = $4;
				}
				elsif (m"([^\.\s]+)\.\s+([^,]+),\s+([^,]+),\s+([^\.]+)\.")
				{
				  $element_field_declared = 1;
				  define_field_parameter(\$field_components_names{$name}[$j],
					 "component names", $1, $name, $_);
				  $field_components_basis{$name}[$j] = $2;
				  define_field_parameter(\$field_components_modification{$name}[$j],
					 "component modifications", $3, $name, $_);
				  define_field_parameter(\$field_components_mapping{$name}[$j],
					 "component mappings", $4, $name, $_);
				  $_ = <>;
				  if (m"#Nodes=\s*(\d+)")
				  {
					 $field_components_nodes{$name}[$j] = $1;
					 $node_indices = "";
					 $scale_factor_indices = "";
					 for ($k = 0 ; $k < $field_components_nodes{$name}[$j] ; $k++)
					 {
						$_ = <>;
						if (m"(\d+)\.\s+#Values=\s*(\d+)")
						{
						  $node_index = $1;
						}
						else
 						{
						  die ("Unable to parse field header, could not read node index\n$_");
						}
						$_ = <>;
						chomp;
						if (m"Value indices:\s+(\d+(\s+\d+)*)")
						{
						  $count = scalar (@list = split(/\s+/, $1));
						  for ($l = 0 ; $l < $count ; $l++)
						  {
							 $node_indices .= "$node_index ";
						  }
						}
						else
						{
						  die ("Unable to parse field header, could not read value indices\n$_");
						}
						$_ = <>;
						chomp;
						if (m"Scale factor indices:\s+(\d+(\s+\d+)*)")
						{
						  $scale_factor_indices .= "$1 ";
						}
						else
						{
						  die ("Unable to parse field header, could not scale factor indices\n$_");
						}
					 }
					 if ((scalar (@list = split(/\s+/, $node_indices))) !=
						  (scalar (@list = split(/\s+/, $scale_factor_indices))))
					 {
						die ("Unable to parse field header for $name $field_components_names{$name}[$j], number of node_indices does not match number of scale_factor_indices\nnode indices: $node_indices\nscale_factor_indices $scale_factor_indices");
					 }
					 $field_components_number_of_parameters{$name}[$j] = scalar @list;
					 $field_components_node_indices{$name}[$j] = $node_indices;
					 $field_components_scale_factor_indices{$name}[$j] = $scale_factor_indices;
				  }
				  else
				  {
					 die ("Unable to read field header, number node line didn't parse\n$_");
				  }
				}
				else
				{
				  die ("Unable to read field header, component line didn't parse\n$_");
				}
			 }
		  }
		  else
		  {
			 die ("Unable to read field header, field line didn't parse\n$_");
		  }

		  if ($new_field)
		  {
			 $name = $field_name[$i];
			 print <<FIELD_HEADER_1;
	<field name="$field_name[$i]"
		    value_type="real"
		    coordinate_system="$field_coordinate_system{$name}">
FIELD_HEADER_1

			 for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				print <<FIELD_HEADER_2
		<component name="$field_components_names{$name}[$j]"/>
FIELD_HEADER_2
			 }
			 print <<FIELD_HEADER_3;
	</field>

FIELD_HEADER_3
		  }
		}

		$node_field_defined = 0;
		$element_field_defined = 0;

	 }

#Nodes
	 elsif (m/Node:\s*(\d+)/)
	 {
		$node_name = $1;
		$_ = <>;		
		$values = "";
		while ((defined $_) && (! /$end_match/))
		{
		  $values .= $_;
		  $_ = <>;
		}
		$read_already = 1;

		if (! $in_group)
		{
		  print <<GROUP_HEADER;
	<group name="$group">

GROUP_HEADER
        $in_group = 1;
		}

#Write the node field if the field is new or different
		if (! $node_field_defined)
		{
		  $node_field_values_name++;
		  $node_parameter_list_name++;
		  $expected_number_of_nodal_values = 0;
		  print <<NODE_VALUES_HEADER;
		<node_field_values name="$node_field_values_name"
NODE_VALUES_HEADER
        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
			 print <<NODE_VALUES_FIELD_1;
			<parameter_list name="$node_parameter_list_name">
			   <node_field ref="$field_name[$i]">
NODE_VALUES_FIELD_1

          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				print <<NODE_VALUES_FIELD_2;
				   <node_field_component ref="$field_components_names{$name}[$j]">
NODE_VALUES_FIELD_2

            if (defined $field_components_type_names{$name}[$j])
				{
				  for $value_type (split(',', $field_components_type_names{$name}[$j]))
				  {
					 print <<NODE_VALUES_FIELD_3;
				      <parameter name="$value_type"/>
NODE_VALUES_FIELD_3
                $expected_number_of_nodal_values++;
				  }
				}
				elsif ($field_components_derivatives{$name}[$j] > 0)
				{
				  for ($k = 0 ; $k < $field_components_derivatives{$name}[$j] ; $k++)
				  {
					 print <<NODE_VALUES_FIELD_4;
				      <parameter name="value_type_$k"/>
NODE_VALUES_FIELD_4
                $expected_number_of_nodal_values++;
				  }
				}
				print <<NODE_VALUES_FIELD_5;
			      </node_field_component>
NODE_VALUES_FIELD_5
			 }
		  print <<NODE_VALUES_FIELD_6;
		      </node_field>
		   </parameter_list>
NODE_VALUES_FIELD_6
		  }
		  print <<NODE_VALUES_END;
		</node_field_values>

NODE_VALUES_END
         $node_field_defined = 1;
		}
		
		#Strip leading and trailing whitespace
		$values =~ s/^\s+//;
		$values =~ s/\s+$//;
		#Split into the number of values.
		$number_of_nodal_values = scalar (@list = split(/\s+/, $values));
		if ($expected_number_of_nodal_values != $number_of_nodal_values)
		{
		  for $i (@list)
		  {
			 print (STDERR " Item:$i\n");
		  }
		  die ("Number of values ($number_of_nodal_values) in node $node_name does not match the expected number ($expected_number_of_nodal_values) from the header");
		}

#Write the actual node		
		print <<NODE_1;
		<node name="$node_name">
		  <node_field_values ref="$node_field_values_name">
			 <parameter_list name="$node_parameter_list_name">
$values			 </parameter_list>
		  </node_field_values>
		</node>

NODE_1
	 }

#Elements
	 elsif (m/Shape.\s+Dimension=(\d+)(,\s([;\w\(\)\*]*))?/)
	 {
		$dimension = $1;
		if (defined $3)
		{
		  $shape = $3;
		}
		else
		{
		  if ($dimension == 1)
		  {
			 $shape = "line";
		  }
		  elsif ($dimension == 2)
		  {
			 $shape = "line*line";
		  }
		  elsif ($dimension == 3)
		  {
			 $shape = "line*line*line";
		  }
		}
	 }

	 elsif (m"#Nodes=\s*(\d+)")
	 {
		$node_list_number = $1;
		$node_list_name++;
      %mapping = ();
	 }

	 elsif (m"#Scale factor sets=\s*(\d+)")
	 {
		$scale_factor_list_name++;
		if (defined $1)
		{
		  $number_of_scale_factor_sets = $1;
		}
		else
		{
		  die ("Could not parse number of scale factors\n$_");
		}
		for ($i = 0 ; $i < $number_of_scale_factor_sets ; $i++)
		{
		  $_ = <>;
		  if (m"([\w\*\.\(\)\;]+),\s*#Scale factors=\s*(\d+)")
			 {
				$scale_factor_list_lookup{$1} = $scale_factor_list_name;
				$scale_factor_list_numbers{$1} = $2;
			 }
		  else
			 {
				die ("Could not parse number of scale factors\n$_");
			 }
		}
		%mapping = ();
	 }

	 elsif (m/Element:\s+(\d+)\s+(\d+)\s+(\d+)/)
	 {
		if ($element_field_declared && ! $element_field_defined)
		{
#Pre define any new mapping schemes we haven't seen before
        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				$basis = $field_components_basis{$name}[$j];
				if (! $mapping{$field_components_basis{$name}[$j]})
				{
				  $element_parameter_list_name++;
				  $mapping_name++;
				  $mapping{$field_components_basis{$name}[$j]} = $mapping_name;
              @node_list_indices = split(/\s+/, $field_components_node_indices{$name}[$j]);
				  @derivative_types = split(/[,\s]+/, $field_components_type_names{$name}[$j]);
              @scale_factor_list_indices = split(/\s+/, $field_components_scale_factor_indices{$name}[$j]);
				  if (! defined $scale_factor_list_lookup{$basis})
				  {
					 die ("No scale factor set found for basis $basis\n$_");
				  }
 				  print <<ELEMENT_PARAMETER_LIST_1;
		<parameter_list name="$element_parameter_list_name">
ELEMENT_PARAMETER_LIST_1

              for ($k = 0 ; $k < $field_components_number_of_parameters{$name}[$j] ; $k++)
              {
                if (($k > 0) && ($node_list_indices[$k] eq $node_list_indices[$k-1]))
                {
						 $derivative++;
					 }
					 else
					 {
						 $derivative = 1;
					 }
					 if (defined $derivative_types[$derivative-1])
					 {
						$derivative_line = "indices=\"$derivative_types[$derivative-1]\"";
					 }
					 else
					 {
						$derivative_line = "indices=\"$derivative\"";
					 }
#Cannot name the parameter list here as this should be valid for any
#nodal list that has the correct field, component, index name
				    print <<ELEMENT_PARAMETER_LIST_2;
        <nodal_parameter $derivative_line\>
            <node><parameter parameter_list="$node_list_name"
                             indices="$node_list_indices[$k]"/></node>
        </nodal_parameter>
ELEMENT_PARAMETER_LIST_2
              }
				 print <<ELEMENT_PARAMETER_LIST_3;
		</parameter_list>

ELEMENT_PARAMETER_LIST_3

 				  print <<MAPPING_1;
		<mapping name="$mapping_name"
					      basis="$basis"
					      modification="$field_components_modification{$name}[$j]">
        <coefficients>
MAPPING_1
              for ($k = 0 ; $k < $field_components_number_of_parameters{$name}[$j] ; $k++)
              {
					 $index = $k+1;
				    print <<MAPPING_2;
           <coefficient>
              <parameter parameter_list="$element_parameter_list_name"
                         indices="$index"/>
              <parameter parameter_list="$scale_factor_list_name"
                         indices="$scale_factor_list_indices[$k]"/>
           </coefficient>
MAPPING_2
              }
				 print <<MAPPING_3;
        </coefficients>
		</mapping>

MAPPING_3
             }
			  }
		  }

#Now use these in the node fields
		  $element_field_values_name++;
		  print <<ELEMENT_FIELD_1;
		<element_field_values name="$element_field_values_name">
ELEMENT_FIELD_1

        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
		  print <<ELEMENT_FIELD_2;
		  <element_field ref="$field_name[$i]">
ELEMENT_FIELD_2
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				print <<ELEMENT_FIELD_3;
				<element_field_component ref="$field_components_names{$name}[$j]">
				  <mapping ref="$mapping{$field_components_basis{$name}[$j]}"/>
				</element_field_component>
ELEMENT_FIELD_3
			 }
		  print <<ELEMENT_FIELD_5;
		  </element_field>
ELEMENT_FIELD_5
		  }
		  print <<ELEMENT_FIELD_6;
		</element_field_values>

ELEMENT_FIELD_6

		  $element_field_defined = 1;
		}

		if ($dimension == 1)
		{
		  $element_name = $3 + $line_name_offset;
		}
		elsif ($dimension == 2)
		{
		  $element_name = $2 + $face_name_offset;
		}
		elsif ($dimension == 3)
		{
		  $element_name = $1;
		}
		else
		{
		  die ("Unable to read element, dimension is $dimension");
		}
	
 		print <<ELEMENT_HEADER;
		<element	name="$element_name"
               shape="$shape">
ELEMENT_HEADER

      $in_element_field = 0;
		$_ = <>;
		while ((defined $_) && (! m/$end_match/))
		{
		  if (m/Faces:/)
		  {
			 print <<ELEMENT_FACES_1;
		  <faces>
ELEMENT_FACES_1
			 $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				if (m/(\d+)\s+(\d+)\s+(\d+)/)
				{
				  if ($dimension == 3)
				  {
					 $face_name = $2 + $face_name_offset;
				  }
				  elsif ($dimension == 2)
				  {
					 $face_name = $3 + $line_name_offset;
				  }
				  else
				  {
					 die ("Unable to read faces, dimension is $dimension");
				  }
				  print " $face_name";
				}
				else
				{
				  die ("Unable to read face, line didn't parse\n$_");
				}
				$_ = <>;
			 }

			 print <<ELEMENT_FACES_3;

		  </faces>
ELEMENT_FACES_3
		  }
 		  elsif (m/Nodes:/)
		  {
			 if (!$in_element_field)
			 {
			 print <<ELEMENT_NODES_1;
		  <element_field_values ref="$element_field_values_name">
ELEMENT_NODES_1
            $in_element_field = 1;
			 }
			 print <<ELEMENT_NODES_2;
			 <parameter_list ref="$node_list_name">
ELEMENT_NODES_2
          $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				print $_;
				$_ = <>;
			 }

			 print <<ELEMENT_NODES_3;
			 </parameter_list>
ELEMENT_NODES_3
		  }
 		  elsif (m/Scale factors:/)
		  {
			 if (!$in_element_field)
			 {
			 print <<ELEMENT_SCALE_1;
		  <element_field_values ref="element_field_values_name">
ELEMENT_SCALE_1
            $in_element_field = 1;
          }
			 print <<ELEMENT_SCALE_2;
			 <parameter_list ref="$scale_factor_list_name">
ELEMENT_SCALE_2

          $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				print $_;
				$_ = <>;
			 }

			 print <<ELEMENT_SCALE_3;
			 </parameter_list>
ELEMENT_SCALE_3
		  }
		  else
		  {
			 $_ = <>;
		  }
		}

		if ($in_element_field)
		{
			 print <<ELEMENT_FIELD_6;
		  </element_field_values>
ELEMENT_FIELD_6
		}

 		print <<ELEMENT_END;
		</element>

ELEMENT_END
		$read_already = 1;
	 }

	 if ($read_already)
		{
		  $read_already = 0;
		}
	 else
		{
		  $_ = <>;
		}
  }

if ($in_group)
  {
	 print <<END_GROUP;
	</group>
END_GROUP
  }

print "</fieldml>\n";


sub define_field_parameter
{
  my $parameter_ref = shift;
  my $parameter_name = shift;
  my $new_value = shift;
  my $name = shift;
  my $line = shift;

  if (defined $$parameter_ref)
  {
	 if ($$parameter_ref ne $new_value)
	 {
		die ("Redefinition of field $name is inconsistent, $parameter_name don't match\n$line");
	 }
  }
  else
  {
	 $$parameter_ref = $new_value;
  }
}
